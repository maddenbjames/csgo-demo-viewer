{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = exports.CMsgNotificationOfSuspiciousActivity = exports.CMsgGCHUpdateSession = exports.CMsgGCMsgSetOptions = exports.CMsgGCMsgMasterSetClientMsgRouting_Response = exports.CMsgGCMsgMasterSetWebAPIRouting_Response = exports.CMsgGCMsgMasterSetClientMsgRouting = exports.CMsgGCMsgMasterSetWebAPIRouting = exports.CMsgGCRoutingInfo = exports.CMsgGCGetPartnerAccountLink_Response = exports.CMsgGCGetPartnerAccountLink = exports.CMsgGCHAccountVacStatusChange = exports.CGCSystemMsg_GetPurchaseTrust_Response = exports.CGCSystemMsg_GetPurchaseTrust_Request = exports.CMsgGCMsgWebAPIJobRequestForwardResponse = exports.CMsgGCMsgMasterSetDirectory_Response = exports.CMsgGCMsgMasterSetDirectory = exports.CMsgGCCheckFriendship_Response = exports.CMsgGCCheckFriendship = exports.CMsgGCGetPersonaNames_Response = exports.CMsgGCGetPersonaNames = exports.CGCSystemMsg_GetAccountDetails_Response = exports.CGCSystemMsg_GetAccountDetails = exports.CMsgAMGrantGuestPasses2Response = exports.CMsgAMGrantGuestPasses2 = exports.CMsgGCGetEmailTemplateResponse = exports.CMsgGCGetEmailTemplate = exports.CMsgAMSendEmailResponse = exports.CMsgAMSendEmail = exports.CGCMsgGetSystemStatsResponse = exports.CGCMsgGetSystemStats = exports.CGCMsgSystemStatsSchema = exports.CGCMsgGetIPLocationResponse = exports.CIPLocationInfo = exports.CGCMsgGetIPLocation = exports.CMsgAMAddFreeLicenseResponse = exports.CMsgAMAddFreeLicense = exports.CGCMsgSQLStatsResponse = exports.CGCMsgSQLStats = exports.CGCMsgMemCachedStatsResponse = exports.CGCMsgMemCachedStats = exports.CGCMsgMemCachedDelete = exports.CGCMsgMemCachedSet = exports.CGCMsgMemCachedGetResponse = exports.CGCMsgMemCachedGet = exports.CMsgGCGetCommandListResponse = exports.CMsgGCGetCommandList = exports.CMsgAMGetUserGameStatsResponse = exports.CMsgAMGetUserGameStats = exports.CMsgAMGetLicensesResponse = exports.CMsgPackageLicense = exports.CMsgAMGetLicenses = exports.CMsgNotifyWatchdog = exports.CMsgAMFindAccountsResponse = exports.CMsgAMFindAccounts = exports.CMsgHttpResponse = exports.CMsgWebAPIRequest = exports.CMsgHttpRequest = exports.CMsgWebAPIKey = exports.CMsgProtoBufHeader = exports.CMsgGCCStrike15_v2_Client2GCStreamUnlock = exports.CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin = exports.CMsgGCCStrike15_v2_AcknowledgePenalty = exports.CMsgGC_GlobalGame_Play = exports.CMsgGC_GlobalGame_Unsubscribe = exports.CMsgGC_GlobalGame_Subscribe = exports.CSOPersonaDataPublic = exports.CSOQuestProgress = exports.CSOEconCoupon = exports.CMsgGCCStrike15_v2_GC2ClientTournamentInfo = exports.CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure = exports.CMsgGCCStrike15_v2_Server2GCClientValidate = exports.CMsgGCCStrike15_v2_ClientSubmitSurveyVote = exports.CMsgGCCStrike15_v2_GiftsLeaderboardResponse = exports.CMsgGCCStrike15_v2_GiftsLeaderboardRequest = exports.CMsgGCCStrike15_v2_ServerVarValueNotificationInfo = exports.CMsgGCCStrike15_v2_ClientVarValueNotificationInfo = exports.CMsgCStrike15Welcome = exports.CMsgGCToGCReloadVersions = exports.CAttribute_String = exports.CMsgGCCStrike15_v2_Fantasy = exports.CMsgGCCStrike15_v2_Predictions = exports.CMsgGCCStrike15_v2_MatchList = exports.CDataGCCStrike15_v2_TournamentInfo = exports.CDataGCCStrike15_v2_TournamentSection = exports.CDataGCCStrike15_v2_TournamentGroup = exports.CDataGCCStrike15_v2_TournamentGroupTeam = exports.CDataGCCStrike15_v2_MatchInfo = exports.CMsgGCCStrike15_v2_MatchListRequestFullGameInfo = exports.CMsgGCCStrike15_v2_MatchListRequestTournamentGames = exports.CMsgGCCStrike15_v2_MatchListRequestRecentUserGames = exports.CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser = exports.CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames = exports.CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification = exports.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse = exports.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest = exports.CMsgItemAcknowledged = exports.CMsgGCCStrike15_v2_MatchEndRewardDropsNotification = exports.CEconItemPreviewDataBlock = exports.CMsgGCCStrike15_v2_MatchEndRunRewardDrops = exports.CMsgGCCStrike15_v2_Client2GCTextMsg = exports.CMsgGCCStrike15_v2_GC2ClientTextMsg = exports.CClientHeaderOverwatchEvidence = exports.CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus = exports.CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment = exports.CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate = exports.CMsgGCCStrike15_v2_PlayersProfile = exports.CMsgGCCStrike15_v2_ClientRequestPlayersProfile = exports.CMsgGCCStrike15_v2_WatchInfoUsers = exports.CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded = exports.CMsgGCCstrike15_v2_ClientRequestNewMission = exports.CMsgGCCStrike15_v2_ClientRequestJoinServerData = exports.CMsgGCCStrike15_v2_ClientRequestJoinFriendData = exports.WatchableMatchInfo = exports.CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends = exports.CMsgGCCStrike15_v2_ClientReportResponse = exports.CMsgGCCStrike15_v2_ClientReportServer = exports.CMsgGCCStrike15_v2_ClientCommendPlayer = exports.CMsgGCCStrike15_v2_ClientReportPlayer = exports.CMsgGCCStrike15_v2_ServerNotificationForUserPenalty = exports.CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate = exports.CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate = exports.CMsgGCCStrike15_v2_MatchmakingServer2GCKick = exports.CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon = exports.CMsgGCCStrike15_v2_AccountPrivacySettings = exports.CMsgGCCStrike15_v2_MatchmakingGC2ClientHello = exports.CMsgGCCStrike15_v2_MatchmakingClient2GCHello = exports.CMsgGCCStrike15_v2_MatchmakingServerMatchEnd = exports.CMsgGCCStrike15_v2_MatchmakingServerRoundStats = exports.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve = exports.CMsgGCCStrike15_v2_MatchmakingServerReservationResponse = exports.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve = exports.CPreMatchInfoData = exports.CDataGCCStrike15_v2_TournamentMatchDraft = exports.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate = exports.CMsgGCCStrike15_v2_MatchmakingClient2ServerPing = exports.CMsgGCCStrike15_v2_MatchmakingStop = exports.CMsgGCCStrike15_v2_MatchmakingStart = exports.CMsgGCCStrike15_v2_GC2ServerReservationUpdate = exports.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm = exports.CMsgGCCStrike15_v2_MatchmakingGCOperationalStats = exports.CMsgGC_ServerQuestUpdateData = exports.PlayerQuestData = exports.MatchEndItemUpdates = exports.XpProgressData = exports.IpAddressMask = exports.ServerHltvInfo = exports.TournamentMatchSetup = exports.AccountActivity = exports.PlayerMedalsInfo = exports.PlayerCommendationInfo = exports.PlayerRankingInfo = exports.OperationalStatisticsPacket = exports.OperationalStatisticElement = exports.OperationalStatisticDescription = exports.GlobalStatistics = exports.TournamentEvent = exports.TournamentTeam = exports.TournamentPlayer = exports.DetailedSearchStatistic = exports.GameServerPing = exports.CCLCMsg_HltvReplay = exports.CSVCMsg_HltvReplay = exports.CSVCMsg_EncryptedData = exports.CSVCMsg_CmdKeyValues = exports.CSVCMsg_EntityMsg = exports.CSVCMsg_Sounds = exports.CSVCMsg_PacketEntities = exports.CSVCMsg_TempEntities = exports.CSVCMsg_GameEventList = exports.CSVCMsg_GameEvent = exports.CSVCMsg_PaintmapData = exports.CSVCMsg_UserMessage = exports.CSVCMsg_Menu = exports.CSVCMsg_GetCvarValue = exports.CSVCMsg_SplitScreen = exports.CSVCMsg_BSPDecal = exports.CSVCMsg_Prefetch = exports.CSVCMsg_CrosshairAngle = exports.CSVCMsg_FixAngle = exports.CSVCMsg_VoiceData = exports.CSVCMsg_VoiceInit = exports.CSVCMsg_UpdateStringTable = exports.CSVCMsg_CreateStringTable = exports.CSVCMsg_SetView = exports.CSVCMsg_SetPause = exports.CSVCMsg_Print = exports.CSVCMsg_SendTable = exports.CSVCMsg_ClassInfo = exports.CSVCMsg_ServerInfo = exports.CCLCMsg_CmdKeyValues = exports.CCLCMsg_SplitPlayerConnect = exports.CCLCMsg_LoadingProgress = exports.CCLCMsg_FileCRCCheck = exports.CCLCMsg_RespondCvarValue = exports.CCLCMsg_ListenEvents = exports.CCLCMsg_BaselineAck = exports.CCLCMsg_VoiceData = exports.CCLCMsg_Move = exports.CCLCMsg_ClientInfo = exports.CNETMsg_PlayerAvatarData = exports.CNETMsg_SplitScreenUser = exports.CNETMsg_File = exports.CNETMsg_Disconnect = exports.CNETMsg_NOP = exports.CNETMsg_SetConVar = exports.CMsg_CVars = exports.CNETMsg_SignonState = exports.CNETMsg_StringCmd = exports.CNETMsg_Tick = exports.CMsgRGBA = exports.CMsgQAngle = exports.CMsgVector2D = exports.CMsgVector = exports.google = exports.CCSUsrMsg_ServerRankRevealAll = exports.CCSUsrMsg_ClientInfo = exports.CCSUsrMsg_WarmupHasEnded = exports.CCSUsrMsg_DisconnectToLobby = exports.CCSUsrMsg_StopSpectatorMode = exports.CCSUsrMsg_RequestState = exports.CCSUsrMsg_GameTitle = exports.CCSUsrMsg_ResetHud = exports.CCSUsrMsg_RoundBackupFilenames = exports.CCSUsrMsg_GlowPropTurnOff = exports.CCSUsrMsg_ItemDrop = exports.CCSUsrMsg_MatchStatsUpdate = exports.CCSUsrMsg_MarkAchievement = exports.CCSUsrMsg_AmmoDenied = exports.CCSUsrMsg_BarTime = exports.CCSUsrMsg_ShowMenu = exports.CCSUsrMsg_ItemPickup = exports.CCSUsrMsg_XpUpdate = exports.CCSUsrMsg_ServerRankUpdate = exports.CCSUsrMsg_SendLastKillerDamageToClient = exports.CCSUsrMsg_VoteSetup = exports.CCSUsrMsg_VoteFailed = exports.CCSUsrMsg_VotePass = exports.CCSUsrMsg_VoteStart = exports.CCSUsrMsg_CallVoteFailed = exports.CCSUsrMsg_XRankUpd = exports.CCSUsrMsg_XRankGet = exports.CCSUsrMsg_QuestProgress = exports.CCSUsrMsg_DisplayInventory = exports.CCSUsrMsg_PlayerStatsUpdate = exports.CCSUsrMsg_MatchEndConditions = exports.CCSUsrMsg_AchievementEvent = exports.CCSUsrMsg_CurrentTimescale = exports.CCSUsrMsg_DesiredTimescale = exports.CCSUsrMsg_KillCam = exports.CCSUsrMsg_ReportHit = exports.CCSUsrMsg_AdjustMoney = exports.CCSUsrMsg_ReloadEffect = exports.CCSUsrMsg_SendPlayerItemFound = exports.CCSUsrMsg_SendPlayerItemDrops = exports.CCSUsrMsg_ProcessSpottedEntityUpdate = exports.CCSUsrMsg_KeyHintText = exports.CCSUsrMsg_HintText = exports.CCSUsrMsg_RadioText = exports.CCSUsrMsg_Damage = exports.CCSUsrMsg_VoiceMask = exports.CCSUsrMsg_RawAudio = exports.CCSUsrMsg_SendAudio = exports.CCSUsrMsg_CloseCaptionDirect = exports.CCSUsrMsg_CloseCaption = exports.CCSUsrMsg_Rumble = exports.CCSUsrMsg_Fade = exports.CCSUsrMsg_Shake = exports.CCSUsrMsg_HudMsg = exports.CCSUsrMsg_TextMsg = exports.CCSUsrMsg_SayText2 = exports.CCSUsrMsg_SayText = exports.CCSUsrMsg_HudText = exports.CCSUsrMsg_Train = exports.CCSUsrMsg_Geiger = exports.CCSUsrMsg_VGUIMenu = exports.ECstrike15UserMessages = void 0;\n/* tslint:disable */\n\nconst $protobuf = require(\"protobufjs/minimal\"); // Common aliases\n\n\nconst $Reader = $protobuf.Reader,\n      $util = $protobuf.util; // Exported root namespace\n\nconst $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\nexports.default = $root;\n/**\n * ECstrike15UserMessages enum.\n * @exports ECstrike15UserMessages\n * @enum {string}\n * @property {number} CS_UM_VGUIMenu=1 CS_UM_VGUIMenu value\n * @property {number} CS_UM_Geiger=2 CS_UM_Geiger value\n * @property {number} CS_UM_Train=3 CS_UM_Train value\n * @property {number} CS_UM_HudText=4 CS_UM_HudText value\n * @property {number} CS_UM_SayText=5 CS_UM_SayText value\n * @property {number} CS_UM_SayText2=6 CS_UM_SayText2 value\n * @property {number} CS_UM_TextMsg=7 CS_UM_TextMsg value\n * @property {number} CS_UM_HudMsg=8 CS_UM_HudMsg value\n * @property {number} CS_UM_ResetHud=9 CS_UM_ResetHud value\n * @property {number} CS_UM_GameTitle=10 CS_UM_GameTitle value\n * @property {number} CS_UM_Shake=12 CS_UM_Shake value\n * @property {number} CS_UM_Fade=13 CS_UM_Fade value\n * @property {number} CS_UM_Rumble=14 CS_UM_Rumble value\n * @property {number} CS_UM_CloseCaption=15 CS_UM_CloseCaption value\n * @property {number} CS_UM_CloseCaptionDirect=16 CS_UM_CloseCaptionDirect value\n * @property {number} CS_UM_SendAudio=17 CS_UM_SendAudio value\n * @property {number} CS_UM_RawAudio=18 CS_UM_RawAudio value\n * @property {number} CS_UM_VoiceMask=19 CS_UM_VoiceMask value\n * @property {number} CS_UM_RequestState=20 CS_UM_RequestState value\n * @property {number} CS_UM_Damage=21 CS_UM_Damage value\n * @property {number} CS_UM_RadioText=22 CS_UM_RadioText value\n * @property {number} CS_UM_HintText=23 CS_UM_HintText value\n * @property {number} CS_UM_KeyHintText=24 CS_UM_KeyHintText value\n * @property {number} CS_UM_ProcessSpottedEntityUpdate=25 CS_UM_ProcessSpottedEntityUpdate value\n * @property {number} CS_UM_ReloadEffect=26 CS_UM_ReloadEffect value\n * @property {number} CS_UM_AdjustMoney=27 CS_UM_AdjustMoney value\n * @property {number} CS_UM_UpdateTeamMoney=28 CS_UM_UpdateTeamMoney value\n * @property {number} CS_UM_StopSpectatorMode=29 CS_UM_StopSpectatorMode value\n * @property {number} CS_UM_KillCam=30 CS_UM_KillCam value\n * @property {number} CS_UM_DesiredTimescale=31 CS_UM_DesiredTimescale value\n * @property {number} CS_UM_CurrentTimescale=32 CS_UM_CurrentTimescale value\n * @property {number} CS_UM_AchievementEvent=33 CS_UM_AchievementEvent value\n * @property {number} CS_UM_MatchEndConditions=34 CS_UM_MatchEndConditions value\n * @property {number} CS_UM_DisconnectToLobby=35 CS_UM_DisconnectToLobby value\n * @property {number} CS_UM_PlayerStatsUpdate=36 CS_UM_PlayerStatsUpdate value\n * @property {number} CS_UM_DisplayInventory=37 CS_UM_DisplayInventory value\n * @property {number} CS_UM_WarmupHasEnded=38 CS_UM_WarmupHasEnded value\n * @property {number} CS_UM_ClientInfo=39 CS_UM_ClientInfo value\n * @property {number} CS_UM_XRankGet=40 CS_UM_XRankGet value\n * @property {number} CS_UM_XRankUpd=41 CS_UM_XRankUpd value\n * @property {number} CS_UM_CallVoteFailed=45 CS_UM_CallVoteFailed value\n * @property {number} CS_UM_VoteStart=46 CS_UM_VoteStart value\n * @property {number} CS_UM_VotePass=47 CS_UM_VotePass value\n * @property {number} CS_UM_VoteFailed=48 CS_UM_VoteFailed value\n * @property {number} CS_UM_VoteSetup=49 CS_UM_VoteSetup value\n * @property {number} CS_UM_ServerRankRevealAll=50 CS_UM_ServerRankRevealAll value\n * @property {number} CS_UM_SendLastKillerDamageToClient=51 CS_UM_SendLastKillerDamageToClient value\n * @property {number} CS_UM_ServerRankUpdate=52 CS_UM_ServerRankUpdate value\n * @property {number} CS_UM_ItemPickup=53 CS_UM_ItemPickup value\n * @property {number} CS_UM_ShowMenu=54 CS_UM_ShowMenu value\n * @property {number} CS_UM_BarTime=55 CS_UM_BarTime value\n * @property {number} CS_UM_AmmoDenied=56 CS_UM_AmmoDenied value\n * @property {number} CS_UM_MarkAchievement=57 CS_UM_MarkAchievement value\n * @property {number} CS_UM_MatchStatsUpdate=58 CS_UM_MatchStatsUpdate value\n * @property {number} CS_UM_ItemDrop=59 CS_UM_ItemDrop value\n * @property {number} CS_UM_GlowPropTurnOff=60 CS_UM_GlowPropTurnOff value\n * @property {number} CS_UM_SendPlayerItemDrops=61 CS_UM_SendPlayerItemDrops value\n * @property {number} CS_UM_RoundBackupFilenames=62 CS_UM_RoundBackupFilenames value\n * @property {number} CS_UM_SendPlayerItemFound=63 CS_UM_SendPlayerItemFound value\n * @property {number} CS_UM_ReportHit=64 CS_UM_ReportHit value\n * @property {number} CS_UM_XpUpdate=65 CS_UM_XpUpdate value\n * @property {number} CS_UM_QuestProgress=66 CS_UM_QuestProgress value\n */\n\nexports.ECstrike15UserMessages = $root.ECstrike15UserMessages = function () {\n  const valuesById = {},\n        values = Object.create(valuesById);\n  values[valuesById[1] = \"CS_UM_VGUIMenu\"] = 1;\n  values[valuesById[2] = \"CS_UM_Geiger\"] = 2;\n  values[valuesById[3] = \"CS_UM_Train\"] = 3;\n  values[valuesById[4] = \"CS_UM_HudText\"] = 4;\n  values[valuesById[5] = \"CS_UM_SayText\"] = 5;\n  values[valuesById[6] = \"CS_UM_SayText2\"] = 6;\n  values[valuesById[7] = \"CS_UM_TextMsg\"] = 7;\n  values[valuesById[8] = \"CS_UM_HudMsg\"] = 8;\n  values[valuesById[9] = \"CS_UM_ResetHud\"] = 9;\n  values[valuesById[10] = \"CS_UM_GameTitle\"] = 10;\n  values[valuesById[12] = \"CS_UM_Shake\"] = 12;\n  values[valuesById[13] = \"CS_UM_Fade\"] = 13;\n  values[valuesById[14] = \"CS_UM_Rumble\"] = 14;\n  values[valuesById[15] = \"CS_UM_CloseCaption\"] = 15;\n  values[valuesById[16] = \"CS_UM_CloseCaptionDirect\"] = 16;\n  values[valuesById[17] = \"CS_UM_SendAudio\"] = 17;\n  values[valuesById[18] = \"CS_UM_RawAudio\"] = 18;\n  values[valuesById[19] = \"CS_UM_VoiceMask\"] = 19;\n  values[valuesById[20] = \"CS_UM_RequestState\"] = 20;\n  values[valuesById[21] = \"CS_UM_Damage\"] = 21;\n  values[valuesById[22] = \"CS_UM_RadioText\"] = 22;\n  values[valuesById[23] = \"CS_UM_HintText\"] = 23;\n  values[valuesById[24] = \"CS_UM_KeyHintText\"] = 24;\n  values[valuesById[25] = \"CS_UM_ProcessSpottedEntityUpdate\"] = 25;\n  values[valuesById[26] = \"CS_UM_ReloadEffect\"] = 26;\n  values[valuesById[27] = \"CS_UM_AdjustMoney\"] = 27;\n  values[valuesById[28] = \"CS_UM_UpdateTeamMoney\"] = 28;\n  values[valuesById[29] = \"CS_UM_StopSpectatorMode\"] = 29;\n  values[valuesById[30] = \"CS_UM_KillCam\"] = 30;\n  values[valuesById[31] = \"CS_UM_DesiredTimescale\"] = 31;\n  values[valuesById[32] = \"CS_UM_CurrentTimescale\"] = 32;\n  values[valuesById[33] = \"CS_UM_AchievementEvent\"] = 33;\n  values[valuesById[34] = \"CS_UM_MatchEndConditions\"] = 34;\n  values[valuesById[35] = \"CS_UM_DisconnectToLobby\"] = 35;\n  values[valuesById[36] = \"CS_UM_PlayerStatsUpdate\"] = 36;\n  values[valuesById[37] = \"CS_UM_DisplayInventory\"] = 37;\n  values[valuesById[38] = \"CS_UM_WarmupHasEnded\"] = 38;\n  values[valuesById[39] = \"CS_UM_ClientInfo\"] = 39;\n  values[valuesById[40] = \"CS_UM_XRankGet\"] = 40;\n  values[valuesById[41] = \"CS_UM_XRankUpd\"] = 41;\n  values[valuesById[45] = \"CS_UM_CallVoteFailed\"] = 45;\n  values[valuesById[46] = \"CS_UM_VoteStart\"] = 46;\n  values[valuesById[47] = \"CS_UM_VotePass\"] = 47;\n  values[valuesById[48] = \"CS_UM_VoteFailed\"] = 48;\n  values[valuesById[49] = \"CS_UM_VoteSetup\"] = 49;\n  values[valuesById[50] = \"CS_UM_ServerRankRevealAll\"] = 50;\n  values[valuesById[51] = \"CS_UM_SendLastKillerDamageToClient\"] = 51;\n  values[valuesById[52] = \"CS_UM_ServerRankUpdate\"] = 52;\n  values[valuesById[53] = \"CS_UM_ItemPickup\"] = 53;\n  values[valuesById[54] = \"CS_UM_ShowMenu\"] = 54;\n  values[valuesById[55] = \"CS_UM_BarTime\"] = 55;\n  values[valuesById[56] = \"CS_UM_AmmoDenied\"] = 56;\n  values[valuesById[57] = \"CS_UM_MarkAchievement\"] = 57;\n  values[valuesById[58] = \"CS_UM_MatchStatsUpdate\"] = 58;\n  values[valuesById[59] = \"CS_UM_ItemDrop\"] = 59;\n  values[valuesById[60] = \"CS_UM_GlowPropTurnOff\"] = 60;\n  values[valuesById[61] = \"CS_UM_SendPlayerItemDrops\"] = 61;\n  values[valuesById[62] = \"CS_UM_RoundBackupFilenames\"] = 62;\n  values[valuesById[63] = \"CS_UM_SendPlayerItemFound\"] = 63;\n  values[valuesById[64] = \"CS_UM_ReportHit\"] = 64;\n  values[valuesById[65] = \"CS_UM_XpUpdate\"] = 65;\n  values[valuesById[66] = \"CS_UM_QuestProgress\"] = 66;\n  return values;\n}();\n\nexports.CCSUsrMsg_VGUIMenu = $root.CCSUsrMsg_VGUIMenu = (() => {\n  /**\n   * Properties of a CCSUsrMsg_VGUIMenu.\n   * @exports ICCSUsrMsg_VGUIMenu\n   * @interface ICCSUsrMsg_VGUIMenu\n   * @property {string|null} [name] CCSUsrMsg_VGUIMenu name\n   * @property {boolean|null} [show] CCSUsrMsg_VGUIMenu show\n   * @property {Array.<CCSUsrMsg_VGUIMenu.ISubkey>|null} [subkeys] CCSUsrMsg_VGUIMenu subkeys\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_VGUIMenu.\n   * @exports CCSUsrMsg_VGUIMenu\n   * @classdesc Represents a CCSUsrMsg_VGUIMenu.\n   * @implements ICCSUsrMsg_VGUIMenu\n   * @constructor\n   * @param {ICCSUsrMsg_VGUIMenu=} [properties] Properties to set\n   */\n  function CCSUsrMsg_VGUIMenu(properties) {\n    this.subkeys = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_VGUIMenu name.\n   * @member {string} name\n   * @memberof CCSUsrMsg_VGUIMenu\n   * @instance\n   */\n\n\n  CCSUsrMsg_VGUIMenu.prototype.name = \"\";\n  /**\n   * CCSUsrMsg_VGUIMenu show.\n   * @member {boolean} show\n   * @memberof CCSUsrMsg_VGUIMenu\n   * @instance\n   */\n\n  CCSUsrMsg_VGUIMenu.prototype.show = false;\n  /**\n   * CCSUsrMsg_VGUIMenu subkeys.\n   * @member {Array.<CCSUsrMsg_VGUIMenu.ISubkey>} subkeys\n   * @memberof CCSUsrMsg_VGUIMenu\n   * @instance\n   */\n\n  CCSUsrMsg_VGUIMenu.prototype.subkeys = $util.emptyArray;\n  /**\n   * Decodes a CCSUsrMsg_VGUIMenu message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_VGUIMenu\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_VGUIMenu} CCSUsrMsg_VGUIMenu\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_VGUIMenu.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_VGUIMenu();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.name = reader.string();\n          break;\n\n        case 2:\n          message.show = reader.bool();\n          break;\n\n        case 3:\n          if (!(message.subkeys && message.subkeys.length)) message.subkeys = [];\n          message.subkeys.push($root.CCSUsrMsg_VGUIMenu.Subkey.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CCSUsrMsg_VGUIMenu.Subkey = function () {\n    /**\n     * Properties of a Subkey.\n     * @memberof CCSUsrMsg_VGUIMenu\n     * @interface ISubkey\n     * @property {string|null} [name] Subkey name\n     * @property {string|null} [str] Subkey str\n     */\n\n    /**\n     * Constructs a new Subkey.\n     * @memberof CCSUsrMsg_VGUIMenu\n     * @classdesc Represents a Subkey.\n     * @implements ISubkey\n     * @constructor\n     * @param {CCSUsrMsg_VGUIMenu.ISubkey=} [properties] Properties to set\n     */\n    function Subkey(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Subkey name.\n     * @member {string} name\n     * @memberof CCSUsrMsg_VGUIMenu.Subkey\n     * @instance\n     */\n\n\n    Subkey.prototype.name = \"\";\n    /**\n     * Subkey str.\n     * @member {string} str\n     * @memberof CCSUsrMsg_VGUIMenu.Subkey\n     * @instance\n     */\n\n    Subkey.prototype.str = \"\";\n    /**\n     * Decodes a Subkey message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_VGUIMenu.Subkey\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_VGUIMenu.Subkey} Subkey\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    Subkey.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CCSUsrMsg_VGUIMenu.Subkey();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.name = reader.string();\n            break;\n\n          case 2:\n            message.str = reader.string();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return Subkey;\n  }();\n\n  return CCSUsrMsg_VGUIMenu;\n})();\n\nexports.CCSUsrMsg_Geiger = $root.CCSUsrMsg_Geiger = (() => {\n  /**\n   * Properties of a CCSUsrMsg_Geiger.\n   * @exports ICCSUsrMsg_Geiger\n   * @interface ICCSUsrMsg_Geiger\n   * @property {number|null} [range] CCSUsrMsg_Geiger range\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_Geiger.\n   * @exports CCSUsrMsg_Geiger\n   * @classdesc Represents a CCSUsrMsg_Geiger.\n   * @implements ICCSUsrMsg_Geiger\n   * @constructor\n   * @param {ICCSUsrMsg_Geiger=} [properties] Properties to set\n   */\n  function CCSUsrMsg_Geiger(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_Geiger range.\n   * @member {number} range\n   * @memberof CCSUsrMsg_Geiger\n   * @instance\n   */\n\n\n  CCSUsrMsg_Geiger.prototype.range = 0;\n  /**\n   * Decodes a CCSUsrMsg_Geiger message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_Geiger\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_Geiger} CCSUsrMsg_Geiger\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_Geiger.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_Geiger();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.range = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_Geiger;\n})();\n\nexports.CCSUsrMsg_Train = $root.CCSUsrMsg_Train = (() => {\n  /**\n   * Properties of a CCSUsrMsg_Train.\n   * @exports ICCSUsrMsg_Train\n   * @interface ICCSUsrMsg_Train\n   * @property {number|null} [train] CCSUsrMsg_Train train\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_Train.\n   * @exports CCSUsrMsg_Train\n   * @classdesc Represents a CCSUsrMsg_Train.\n   * @implements ICCSUsrMsg_Train\n   * @constructor\n   * @param {ICCSUsrMsg_Train=} [properties] Properties to set\n   */\n  function CCSUsrMsg_Train(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_Train train.\n   * @member {number} train\n   * @memberof CCSUsrMsg_Train\n   * @instance\n   */\n\n\n  CCSUsrMsg_Train.prototype.train = 0;\n  /**\n   * Decodes a CCSUsrMsg_Train message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_Train\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_Train} CCSUsrMsg_Train\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_Train.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_Train();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.train = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_Train;\n})();\n\nexports.CCSUsrMsg_HudText = $root.CCSUsrMsg_HudText = (() => {\n  /**\n   * Properties of a CCSUsrMsg_HudText.\n   * @exports ICCSUsrMsg_HudText\n   * @interface ICCSUsrMsg_HudText\n   * @property {string|null} [text] CCSUsrMsg_HudText text\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_HudText.\n   * @exports CCSUsrMsg_HudText\n   * @classdesc Represents a CCSUsrMsg_HudText.\n   * @implements ICCSUsrMsg_HudText\n   * @constructor\n   * @param {ICCSUsrMsg_HudText=} [properties] Properties to set\n   */\n  function CCSUsrMsg_HudText(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_HudText text.\n   * @member {string} text\n   * @memberof CCSUsrMsg_HudText\n   * @instance\n   */\n\n\n  CCSUsrMsg_HudText.prototype.text = \"\";\n  /**\n   * Decodes a CCSUsrMsg_HudText message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_HudText\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_HudText} CCSUsrMsg_HudText\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_HudText.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_HudText();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.text = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_HudText;\n})();\n\nexports.CCSUsrMsg_SayText = $root.CCSUsrMsg_SayText = (() => {\n  /**\n   * Properties of a CCSUsrMsg_SayText.\n   * @exports ICCSUsrMsg_SayText\n   * @interface ICCSUsrMsg_SayText\n   * @property {number|null} [entIdx] CCSUsrMsg_SayText entIdx\n   * @property {string|null} [text] CCSUsrMsg_SayText text\n   * @property {boolean|null} [chat] CCSUsrMsg_SayText chat\n   * @property {boolean|null} [textallchat] CCSUsrMsg_SayText textallchat\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_SayText.\n   * @exports CCSUsrMsg_SayText\n   * @classdesc Represents a CCSUsrMsg_SayText.\n   * @implements ICCSUsrMsg_SayText\n   * @constructor\n   * @param {ICCSUsrMsg_SayText=} [properties] Properties to set\n   */\n  function CCSUsrMsg_SayText(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_SayText entIdx.\n   * @member {number} entIdx\n   * @memberof CCSUsrMsg_SayText\n   * @instance\n   */\n\n\n  CCSUsrMsg_SayText.prototype.entIdx = 0;\n  /**\n   * CCSUsrMsg_SayText text.\n   * @member {string} text\n   * @memberof CCSUsrMsg_SayText\n   * @instance\n   */\n\n  CCSUsrMsg_SayText.prototype.text = \"\";\n  /**\n   * CCSUsrMsg_SayText chat.\n   * @member {boolean} chat\n   * @memberof CCSUsrMsg_SayText\n   * @instance\n   */\n\n  CCSUsrMsg_SayText.prototype.chat = false;\n  /**\n   * CCSUsrMsg_SayText textallchat.\n   * @member {boolean} textallchat\n   * @memberof CCSUsrMsg_SayText\n   * @instance\n   */\n\n  CCSUsrMsg_SayText.prototype.textallchat = false;\n  /**\n   * Decodes a CCSUsrMsg_SayText message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_SayText\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_SayText} CCSUsrMsg_SayText\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_SayText.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_SayText();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.entIdx = reader.int32();\n          break;\n\n        case 2:\n          message.text = reader.string();\n          break;\n\n        case 3:\n          message.chat = reader.bool();\n          break;\n\n        case 4:\n          message.textallchat = reader.bool();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_SayText;\n})();\n\nexports.CCSUsrMsg_SayText2 = $root.CCSUsrMsg_SayText2 = (() => {\n  /**\n   * Properties of a CCSUsrMsg_SayText2.\n   * @exports ICCSUsrMsg_SayText2\n   * @interface ICCSUsrMsg_SayText2\n   * @property {number|null} [entIdx] CCSUsrMsg_SayText2 entIdx\n   * @property {boolean|null} [chat] CCSUsrMsg_SayText2 chat\n   * @property {string|null} [msgName] CCSUsrMsg_SayText2 msgName\n   * @property {Array.<string>|null} [params] CCSUsrMsg_SayText2 params\n   * @property {boolean|null} [textallchat] CCSUsrMsg_SayText2 textallchat\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_SayText2.\n   * @exports CCSUsrMsg_SayText2\n   * @classdesc Represents a CCSUsrMsg_SayText2.\n   * @implements ICCSUsrMsg_SayText2\n   * @constructor\n   * @param {ICCSUsrMsg_SayText2=} [properties] Properties to set\n   */\n  function CCSUsrMsg_SayText2(properties) {\n    this.params = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_SayText2 entIdx.\n   * @member {number} entIdx\n   * @memberof CCSUsrMsg_SayText2\n   * @instance\n   */\n\n\n  CCSUsrMsg_SayText2.prototype.entIdx = 0;\n  /**\n   * CCSUsrMsg_SayText2 chat.\n   * @member {boolean} chat\n   * @memberof CCSUsrMsg_SayText2\n   * @instance\n   */\n\n  CCSUsrMsg_SayText2.prototype.chat = false;\n  /**\n   * CCSUsrMsg_SayText2 msgName.\n   * @member {string} msgName\n   * @memberof CCSUsrMsg_SayText2\n   * @instance\n   */\n\n  CCSUsrMsg_SayText2.prototype.msgName = \"\";\n  /**\n   * CCSUsrMsg_SayText2 params.\n   * @member {Array.<string>} params\n   * @memberof CCSUsrMsg_SayText2\n   * @instance\n   */\n\n  CCSUsrMsg_SayText2.prototype.params = $util.emptyArray;\n  /**\n   * CCSUsrMsg_SayText2 textallchat.\n   * @member {boolean} textallchat\n   * @memberof CCSUsrMsg_SayText2\n   * @instance\n   */\n\n  CCSUsrMsg_SayText2.prototype.textallchat = false;\n  /**\n   * Decodes a CCSUsrMsg_SayText2 message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_SayText2\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_SayText2} CCSUsrMsg_SayText2\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_SayText2.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_SayText2();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.entIdx = reader.int32();\n          break;\n\n        case 2:\n          message.chat = reader.bool();\n          break;\n\n        case 3:\n          message.msgName = reader.string();\n          break;\n\n        case 4:\n          if (!(message.params && message.params.length)) message.params = [];\n          message.params.push(reader.string());\n          break;\n\n        case 5:\n          message.textallchat = reader.bool();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_SayText2;\n})();\n\nexports.CCSUsrMsg_TextMsg = $root.CCSUsrMsg_TextMsg = (() => {\n  /**\n   * Properties of a CCSUsrMsg_TextMsg.\n   * @exports ICCSUsrMsg_TextMsg\n   * @interface ICCSUsrMsg_TextMsg\n   * @property {number|null} [msgDst] CCSUsrMsg_TextMsg msgDst\n   * @property {Array.<string>|null} [params] CCSUsrMsg_TextMsg params\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_TextMsg.\n   * @exports CCSUsrMsg_TextMsg\n   * @classdesc Represents a CCSUsrMsg_TextMsg.\n   * @implements ICCSUsrMsg_TextMsg\n   * @constructor\n   * @param {ICCSUsrMsg_TextMsg=} [properties] Properties to set\n   */\n  function CCSUsrMsg_TextMsg(properties) {\n    this.params = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_TextMsg msgDst.\n   * @member {number} msgDst\n   * @memberof CCSUsrMsg_TextMsg\n   * @instance\n   */\n\n\n  CCSUsrMsg_TextMsg.prototype.msgDst = 0;\n  /**\n   * CCSUsrMsg_TextMsg params.\n   * @member {Array.<string>} params\n   * @memberof CCSUsrMsg_TextMsg\n   * @instance\n   */\n\n  CCSUsrMsg_TextMsg.prototype.params = $util.emptyArray;\n  /**\n   * Decodes a CCSUsrMsg_TextMsg message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_TextMsg\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_TextMsg} CCSUsrMsg_TextMsg\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_TextMsg.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_TextMsg();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.msgDst = reader.int32();\n          break;\n\n        case 3:\n          if (!(message.params && message.params.length)) message.params = [];\n          message.params.push(reader.string());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_TextMsg;\n})();\n\nexports.CCSUsrMsg_HudMsg = $root.CCSUsrMsg_HudMsg = (() => {\n  /**\n   * Properties of a CCSUsrMsg_HudMsg.\n   * @exports ICCSUsrMsg_HudMsg\n   * @interface ICCSUsrMsg_HudMsg\n   * @property {number|null} [channel] CCSUsrMsg_HudMsg channel\n   * @property {ICMsgVector2D|null} [pos] CCSUsrMsg_HudMsg pos\n   * @property {ICMsgRGBA|null} [clr1] CCSUsrMsg_HudMsg clr1\n   * @property {ICMsgRGBA|null} [clr2] CCSUsrMsg_HudMsg clr2\n   * @property {number|null} [effect] CCSUsrMsg_HudMsg effect\n   * @property {number|null} [fadeInTime] CCSUsrMsg_HudMsg fadeInTime\n   * @property {number|null} [fadeOutTime] CCSUsrMsg_HudMsg fadeOutTime\n   * @property {number|null} [holdTime] CCSUsrMsg_HudMsg holdTime\n   * @property {number|null} [fxTime] CCSUsrMsg_HudMsg fxTime\n   * @property {string|null} [text] CCSUsrMsg_HudMsg text\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_HudMsg.\n   * @exports CCSUsrMsg_HudMsg\n   * @classdesc Represents a CCSUsrMsg_HudMsg.\n   * @implements ICCSUsrMsg_HudMsg\n   * @constructor\n   * @param {ICCSUsrMsg_HudMsg=} [properties] Properties to set\n   */\n  function CCSUsrMsg_HudMsg(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_HudMsg channel.\n   * @member {number} channel\n   * @memberof CCSUsrMsg_HudMsg\n   * @instance\n   */\n\n\n  CCSUsrMsg_HudMsg.prototype.channel = 0;\n  /**\n   * CCSUsrMsg_HudMsg pos.\n   * @member {ICMsgVector2D|null|undefined} pos\n   * @memberof CCSUsrMsg_HudMsg\n   * @instance\n   */\n\n  CCSUsrMsg_HudMsg.prototype.pos = null;\n  /**\n   * CCSUsrMsg_HudMsg clr1.\n   * @member {ICMsgRGBA|null|undefined} clr1\n   * @memberof CCSUsrMsg_HudMsg\n   * @instance\n   */\n\n  CCSUsrMsg_HudMsg.prototype.clr1 = null;\n  /**\n   * CCSUsrMsg_HudMsg clr2.\n   * @member {ICMsgRGBA|null|undefined} clr2\n   * @memberof CCSUsrMsg_HudMsg\n   * @instance\n   */\n\n  CCSUsrMsg_HudMsg.prototype.clr2 = null;\n  /**\n   * CCSUsrMsg_HudMsg effect.\n   * @member {number} effect\n   * @memberof CCSUsrMsg_HudMsg\n   * @instance\n   */\n\n  CCSUsrMsg_HudMsg.prototype.effect = 0;\n  /**\n   * CCSUsrMsg_HudMsg fadeInTime.\n   * @member {number} fadeInTime\n   * @memberof CCSUsrMsg_HudMsg\n   * @instance\n   */\n\n  CCSUsrMsg_HudMsg.prototype.fadeInTime = 0;\n  /**\n   * CCSUsrMsg_HudMsg fadeOutTime.\n   * @member {number} fadeOutTime\n   * @memberof CCSUsrMsg_HudMsg\n   * @instance\n   */\n\n  CCSUsrMsg_HudMsg.prototype.fadeOutTime = 0;\n  /**\n   * CCSUsrMsg_HudMsg holdTime.\n   * @member {number} holdTime\n   * @memberof CCSUsrMsg_HudMsg\n   * @instance\n   */\n\n  CCSUsrMsg_HudMsg.prototype.holdTime = 0;\n  /**\n   * CCSUsrMsg_HudMsg fxTime.\n   * @member {number} fxTime\n   * @memberof CCSUsrMsg_HudMsg\n   * @instance\n   */\n\n  CCSUsrMsg_HudMsg.prototype.fxTime = 0;\n  /**\n   * CCSUsrMsg_HudMsg text.\n   * @member {string} text\n   * @memberof CCSUsrMsg_HudMsg\n   * @instance\n   */\n\n  CCSUsrMsg_HudMsg.prototype.text = \"\";\n  /**\n   * Decodes a CCSUsrMsg_HudMsg message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_HudMsg\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_HudMsg} CCSUsrMsg_HudMsg\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_HudMsg.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_HudMsg();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.channel = reader.int32();\n          break;\n\n        case 2:\n          message.pos = $root.CMsgVector2D.decode(reader, reader.uint32());\n          break;\n\n        case 3:\n          message.clr1 = $root.CMsgRGBA.decode(reader, reader.uint32());\n          break;\n\n        case 4:\n          message.clr2 = $root.CMsgRGBA.decode(reader, reader.uint32());\n          break;\n\n        case 5:\n          message.effect = reader.int32();\n          break;\n\n        case 6:\n          message.fadeInTime = reader.float();\n          break;\n\n        case 7:\n          message.fadeOutTime = reader.float();\n          break;\n\n        case 9:\n          message.holdTime = reader.float();\n          break;\n\n        case 10:\n          message.fxTime = reader.float();\n          break;\n\n        case 11:\n          message.text = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_HudMsg;\n})();\n\nexports.CCSUsrMsg_Shake = $root.CCSUsrMsg_Shake = (() => {\n  /**\n   * Properties of a CCSUsrMsg_Shake.\n   * @exports ICCSUsrMsg_Shake\n   * @interface ICCSUsrMsg_Shake\n   * @property {number|null} [command] CCSUsrMsg_Shake command\n   * @property {number|null} [localAmplitude] CCSUsrMsg_Shake localAmplitude\n   * @property {number|null} [frequency] CCSUsrMsg_Shake frequency\n   * @property {number|null} [duration] CCSUsrMsg_Shake duration\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_Shake.\n   * @exports CCSUsrMsg_Shake\n   * @classdesc Represents a CCSUsrMsg_Shake.\n   * @implements ICCSUsrMsg_Shake\n   * @constructor\n   * @param {ICCSUsrMsg_Shake=} [properties] Properties to set\n   */\n  function CCSUsrMsg_Shake(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_Shake command.\n   * @member {number} command\n   * @memberof CCSUsrMsg_Shake\n   * @instance\n   */\n\n\n  CCSUsrMsg_Shake.prototype.command = 0;\n  /**\n   * CCSUsrMsg_Shake localAmplitude.\n   * @member {number} localAmplitude\n   * @memberof CCSUsrMsg_Shake\n   * @instance\n   */\n\n  CCSUsrMsg_Shake.prototype.localAmplitude = 0;\n  /**\n   * CCSUsrMsg_Shake frequency.\n   * @member {number} frequency\n   * @memberof CCSUsrMsg_Shake\n   * @instance\n   */\n\n  CCSUsrMsg_Shake.prototype.frequency = 0;\n  /**\n   * CCSUsrMsg_Shake duration.\n   * @member {number} duration\n   * @memberof CCSUsrMsg_Shake\n   * @instance\n   */\n\n  CCSUsrMsg_Shake.prototype.duration = 0;\n  /**\n   * Decodes a CCSUsrMsg_Shake message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_Shake\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_Shake} CCSUsrMsg_Shake\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_Shake.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_Shake();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.command = reader.int32();\n          break;\n\n        case 2:\n          message.localAmplitude = reader.float();\n          break;\n\n        case 3:\n          message.frequency = reader.float();\n          break;\n\n        case 4:\n          message.duration = reader.float();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_Shake;\n})();\n\nexports.CCSUsrMsg_Fade = $root.CCSUsrMsg_Fade = (() => {\n  /**\n   * Properties of a CCSUsrMsg_Fade.\n   * @exports ICCSUsrMsg_Fade\n   * @interface ICCSUsrMsg_Fade\n   * @property {number|null} [duration] CCSUsrMsg_Fade duration\n   * @property {number|null} [holdTime] CCSUsrMsg_Fade holdTime\n   * @property {number|null} [flags] CCSUsrMsg_Fade flags\n   * @property {ICMsgRGBA|null} [clr] CCSUsrMsg_Fade clr\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_Fade.\n   * @exports CCSUsrMsg_Fade\n   * @classdesc Represents a CCSUsrMsg_Fade.\n   * @implements ICCSUsrMsg_Fade\n   * @constructor\n   * @param {ICCSUsrMsg_Fade=} [properties] Properties to set\n   */\n  function CCSUsrMsg_Fade(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_Fade duration.\n   * @member {number} duration\n   * @memberof CCSUsrMsg_Fade\n   * @instance\n   */\n\n\n  CCSUsrMsg_Fade.prototype.duration = 0;\n  /**\n   * CCSUsrMsg_Fade holdTime.\n   * @member {number} holdTime\n   * @memberof CCSUsrMsg_Fade\n   * @instance\n   */\n\n  CCSUsrMsg_Fade.prototype.holdTime = 0;\n  /**\n   * CCSUsrMsg_Fade flags.\n   * @member {number} flags\n   * @memberof CCSUsrMsg_Fade\n   * @instance\n   */\n\n  CCSUsrMsg_Fade.prototype.flags = 0;\n  /**\n   * CCSUsrMsg_Fade clr.\n   * @member {ICMsgRGBA|null|undefined} clr\n   * @memberof CCSUsrMsg_Fade\n   * @instance\n   */\n\n  CCSUsrMsg_Fade.prototype.clr = null;\n  /**\n   * Decodes a CCSUsrMsg_Fade message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_Fade\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_Fade} CCSUsrMsg_Fade\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_Fade.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_Fade();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.duration = reader.int32();\n          break;\n\n        case 2:\n          message.holdTime = reader.int32();\n          break;\n\n        case 3:\n          message.flags = reader.int32();\n          break;\n\n        case 4:\n          message.clr = $root.CMsgRGBA.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_Fade;\n})();\n\nexports.CCSUsrMsg_Rumble = $root.CCSUsrMsg_Rumble = (() => {\n  /**\n   * Properties of a CCSUsrMsg_Rumble.\n   * @exports ICCSUsrMsg_Rumble\n   * @interface ICCSUsrMsg_Rumble\n   * @property {number|null} [index] CCSUsrMsg_Rumble index\n   * @property {number|null} [data] CCSUsrMsg_Rumble data\n   * @property {number|null} [flags] CCSUsrMsg_Rumble flags\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_Rumble.\n   * @exports CCSUsrMsg_Rumble\n   * @classdesc Represents a CCSUsrMsg_Rumble.\n   * @implements ICCSUsrMsg_Rumble\n   * @constructor\n   * @param {ICCSUsrMsg_Rumble=} [properties] Properties to set\n   */\n  function CCSUsrMsg_Rumble(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_Rumble index.\n   * @member {number} index\n   * @memberof CCSUsrMsg_Rumble\n   * @instance\n   */\n\n\n  CCSUsrMsg_Rumble.prototype.index = 0;\n  /**\n   * CCSUsrMsg_Rumble data.\n   * @member {number} data\n   * @memberof CCSUsrMsg_Rumble\n   * @instance\n   */\n\n  CCSUsrMsg_Rumble.prototype.data = 0;\n  /**\n   * CCSUsrMsg_Rumble flags.\n   * @member {number} flags\n   * @memberof CCSUsrMsg_Rumble\n   * @instance\n   */\n\n  CCSUsrMsg_Rumble.prototype.flags = 0;\n  /**\n   * Decodes a CCSUsrMsg_Rumble message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_Rumble\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_Rumble} CCSUsrMsg_Rumble\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_Rumble.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_Rumble();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.index = reader.int32();\n          break;\n\n        case 2:\n          message.data = reader.int32();\n          break;\n\n        case 3:\n          message.flags = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_Rumble;\n})();\n\nexports.CCSUsrMsg_CloseCaption = $root.CCSUsrMsg_CloseCaption = (() => {\n  /**\n   * Properties of a CCSUsrMsg_CloseCaption.\n   * @exports ICCSUsrMsg_CloseCaption\n   * @interface ICCSUsrMsg_CloseCaption\n   * @property {number|null} [hash] CCSUsrMsg_CloseCaption hash\n   * @property {number|null} [duration] CCSUsrMsg_CloseCaption duration\n   * @property {boolean|null} [fromPlayer] CCSUsrMsg_CloseCaption fromPlayer\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_CloseCaption.\n   * @exports CCSUsrMsg_CloseCaption\n   * @classdesc Represents a CCSUsrMsg_CloseCaption.\n   * @implements ICCSUsrMsg_CloseCaption\n   * @constructor\n   * @param {ICCSUsrMsg_CloseCaption=} [properties] Properties to set\n   */\n  function CCSUsrMsg_CloseCaption(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_CloseCaption hash.\n   * @member {number} hash\n   * @memberof CCSUsrMsg_CloseCaption\n   * @instance\n   */\n\n\n  CCSUsrMsg_CloseCaption.prototype.hash = 0;\n  /**\n   * CCSUsrMsg_CloseCaption duration.\n   * @member {number} duration\n   * @memberof CCSUsrMsg_CloseCaption\n   * @instance\n   */\n\n  CCSUsrMsg_CloseCaption.prototype.duration = 0;\n  /**\n   * CCSUsrMsg_CloseCaption fromPlayer.\n   * @member {boolean} fromPlayer\n   * @memberof CCSUsrMsg_CloseCaption\n   * @instance\n   */\n\n  CCSUsrMsg_CloseCaption.prototype.fromPlayer = false;\n  /**\n   * Decodes a CCSUsrMsg_CloseCaption message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_CloseCaption\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_CloseCaption} CCSUsrMsg_CloseCaption\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_CloseCaption.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_CloseCaption();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.hash = reader.uint32();\n          break;\n\n        case 2:\n          message.duration = reader.int32();\n          break;\n\n        case 3:\n          message.fromPlayer = reader.bool();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_CloseCaption;\n})();\n\nexports.CCSUsrMsg_CloseCaptionDirect = $root.CCSUsrMsg_CloseCaptionDirect = (() => {\n  /**\n   * Properties of a CCSUsrMsg_CloseCaptionDirect.\n   * @exports ICCSUsrMsg_CloseCaptionDirect\n   * @interface ICCSUsrMsg_CloseCaptionDirect\n   * @property {number|null} [hash] CCSUsrMsg_CloseCaptionDirect hash\n   * @property {number|null} [duration] CCSUsrMsg_CloseCaptionDirect duration\n   * @property {boolean|null} [fromPlayer] CCSUsrMsg_CloseCaptionDirect fromPlayer\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_CloseCaptionDirect.\n   * @exports CCSUsrMsg_CloseCaptionDirect\n   * @classdesc Represents a CCSUsrMsg_CloseCaptionDirect.\n   * @implements ICCSUsrMsg_CloseCaptionDirect\n   * @constructor\n   * @param {ICCSUsrMsg_CloseCaptionDirect=} [properties] Properties to set\n   */\n  function CCSUsrMsg_CloseCaptionDirect(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_CloseCaptionDirect hash.\n   * @member {number} hash\n   * @memberof CCSUsrMsg_CloseCaptionDirect\n   * @instance\n   */\n\n\n  CCSUsrMsg_CloseCaptionDirect.prototype.hash = 0;\n  /**\n   * CCSUsrMsg_CloseCaptionDirect duration.\n   * @member {number} duration\n   * @memberof CCSUsrMsg_CloseCaptionDirect\n   * @instance\n   */\n\n  CCSUsrMsg_CloseCaptionDirect.prototype.duration = 0;\n  /**\n   * CCSUsrMsg_CloseCaptionDirect fromPlayer.\n   * @member {boolean} fromPlayer\n   * @memberof CCSUsrMsg_CloseCaptionDirect\n   * @instance\n   */\n\n  CCSUsrMsg_CloseCaptionDirect.prototype.fromPlayer = false;\n  /**\n   * Decodes a CCSUsrMsg_CloseCaptionDirect message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_CloseCaptionDirect\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_CloseCaptionDirect} CCSUsrMsg_CloseCaptionDirect\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_CloseCaptionDirect.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_CloseCaptionDirect();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.hash = reader.uint32();\n          break;\n\n        case 2:\n          message.duration = reader.int32();\n          break;\n\n        case 3:\n          message.fromPlayer = reader.bool();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_CloseCaptionDirect;\n})();\n\nexports.CCSUsrMsg_SendAudio = $root.CCSUsrMsg_SendAudio = (() => {\n  /**\n   * Properties of a CCSUsrMsg_SendAudio.\n   * @exports ICCSUsrMsg_SendAudio\n   * @interface ICCSUsrMsg_SendAudio\n   * @property {string|null} [radioSound] CCSUsrMsg_SendAudio radioSound\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_SendAudio.\n   * @exports CCSUsrMsg_SendAudio\n   * @classdesc Represents a CCSUsrMsg_SendAudio.\n   * @implements ICCSUsrMsg_SendAudio\n   * @constructor\n   * @param {ICCSUsrMsg_SendAudio=} [properties] Properties to set\n   */\n  function CCSUsrMsg_SendAudio(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_SendAudio radioSound.\n   * @member {string} radioSound\n   * @memberof CCSUsrMsg_SendAudio\n   * @instance\n   */\n\n\n  CCSUsrMsg_SendAudio.prototype.radioSound = \"\";\n  /**\n   * Decodes a CCSUsrMsg_SendAudio message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_SendAudio\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_SendAudio} CCSUsrMsg_SendAudio\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_SendAudio.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_SendAudio();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.radioSound = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_SendAudio;\n})();\n\nexports.CCSUsrMsg_RawAudio = $root.CCSUsrMsg_RawAudio = (() => {\n  /**\n   * Properties of a CCSUsrMsg_RawAudio.\n   * @exports ICCSUsrMsg_RawAudio\n   * @interface ICCSUsrMsg_RawAudio\n   * @property {number|null} [pitch] CCSUsrMsg_RawAudio pitch\n   * @property {number|null} [entidx] CCSUsrMsg_RawAudio entidx\n   * @property {number|null} [duration] CCSUsrMsg_RawAudio duration\n   * @property {string|null} [voiceFilename] CCSUsrMsg_RawAudio voiceFilename\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_RawAudio.\n   * @exports CCSUsrMsg_RawAudio\n   * @classdesc Represents a CCSUsrMsg_RawAudio.\n   * @implements ICCSUsrMsg_RawAudio\n   * @constructor\n   * @param {ICCSUsrMsg_RawAudio=} [properties] Properties to set\n   */\n  function CCSUsrMsg_RawAudio(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_RawAudio pitch.\n   * @member {number} pitch\n   * @memberof CCSUsrMsg_RawAudio\n   * @instance\n   */\n\n\n  CCSUsrMsg_RawAudio.prototype.pitch = 0;\n  /**\n   * CCSUsrMsg_RawAudio entidx.\n   * @member {number} entidx\n   * @memberof CCSUsrMsg_RawAudio\n   * @instance\n   */\n\n  CCSUsrMsg_RawAudio.prototype.entidx = 0;\n  /**\n   * CCSUsrMsg_RawAudio duration.\n   * @member {number} duration\n   * @memberof CCSUsrMsg_RawAudio\n   * @instance\n   */\n\n  CCSUsrMsg_RawAudio.prototype.duration = 0;\n  /**\n   * CCSUsrMsg_RawAudio voiceFilename.\n   * @member {string} voiceFilename\n   * @memberof CCSUsrMsg_RawAudio\n   * @instance\n   */\n\n  CCSUsrMsg_RawAudio.prototype.voiceFilename = \"\";\n  /**\n   * Decodes a CCSUsrMsg_RawAudio message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_RawAudio\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_RawAudio} CCSUsrMsg_RawAudio\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_RawAudio.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_RawAudio();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.pitch = reader.int32();\n          break;\n\n        case 2:\n          message.entidx = reader.int32();\n          break;\n\n        case 3:\n          message.duration = reader.float();\n          break;\n\n        case 4:\n          message.voiceFilename = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_RawAudio;\n})();\n\nexports.CCSUsrMsg_VoiceMask = $root.CCSUsrMsg_VoiceMask = (() => {\n  /**\n   * Properties of a CCSUsrMsg_VoiceMask.\n   * @exports ICCSUsrMsg_VoiceMask\n   * @interface ICCSUsrMsg_VoiceMask\n   * @property {Array.<CCSUsrMsg_VoiceMask.IPlayerMask>|null} [playerMasks] CCSUsrMsg_VoiceMask playerMasks\n   * @property {boolean|null} [playerModEnable] CCSUsrMsg_VoiceMask playerModEnable\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_VoiceMask.\n   * @exports CCSUsrMsg_VoiceMask\n   * @classdesc Represents a CCSUsrMsg_VoiceMask.\n   * @implements ICCSUsrMsg_VoiceMask\n   * @constructor\n   * @param {ICCSUsrMsg_VoiceMask=} [properties] Properties to set\n   */\n  function CCSUsrMsg_VoiceMask(properties) {\n    this.playerMasks = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_VoiceMask playerMasks.\n   * @member {Array.<CCSUsrMsg_VoiceMask.IPlayerMask>} playerMasks\n   * @memberof CCSUsrMsg_VoiceMask\n   * @instance\n   */\n\n\n  CCSUsrMsg_VoiceMask.prototype.playerMasks = $util.emptyArray;\n  /**\n   * CCSUsrMsg_VoiceMask playerModEnable.\n   * @member {boolean} playerModEnable\n   * @memberof CCSUsrMsg_VoiceMask\n   * @instance\n   */\n\n  CCSUsrMsg_VoiceMask.prototype.playerModEnable = false;\n  /**\n   * Decodes a CCSUsrMsg_VoiceMask message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_VoiceMask\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_VoiceMask} CCSUsrMsg_VoiceMask\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_VoiceMask.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_VoiceMask();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.playerMasks && message.playerMasks.length)) message.playerMasks = [];\n          message.playerMasks.push($root.CCSUsrMsg_VoiceMask.PlayerMask.decode(reader, reader.uint32()));\n          break;\n\n        case 2:\n          message.playerModEnable = reader.bool();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CCSUsrMsg_VoiceMask.PlayerMask = function () {\n    /**\n     * Properties of a PlayerMask.\n     * @memberof CCSUsrMsg_VoiceMask\n     * @interface IPlayerMask\n     * @property {number|null} [gameRulesMask] PlayerMask gameRulesMask\n     * @property {number|null} [banMasks] PlayerMask banMasks\n     */\n\n    /**\n     * Constructs a new PlayerMask.\n     * @memberof CCSUsrMsg_VoiceMask\n     * @classdesc Represents a PlayerMask.\n     * @implements IPlayerMask\n     * @constructor\n     * @param {CCSUsrMsg_VoiceMask.IPlayerMask=} [properties] Properties to set\n     */\n    function PlayerMask(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * PlayerMask gameRulesMask.\n     * @member {number} gameRulesMask\n     * @memberof CCSUsrMsg_VoiceMask.PlayerMask\n     * @instance\n     */\n\n\n    PlayerMask.prototype.gameRulesMask = 0;\n    /**\n     * PlayerMask banMasks.\n     * @member {number} banMasks\n     * @memberof CCSUsrMsg_VoiceMask.PlayerMask\n     * @instance\n     */\n\n    PlayerMask.prototype.banMasks = 0;\n    /**\n     * Decodes a PlayerMask message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_VoiceMask.PlayerMask\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_VoiceMask.PlayerMask} PlayerMask\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    PlayerMask.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CCSUsrMsg_VoiceMask.PlayerMask();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.gameRulesMask = reader.int32();\n            break;\n\n          case 2:\n            message.banMasks = reader.int32();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return PlayerMask;\n  }();\n\n  return CCSUsrMsg_VoiceMask;\n})();\n\nexports.CCSUsrMsg_Damage = $root.CCSUsrMsg_Damage = (() => {\n  /**\n   * Properties of a CCSUsrMsg_Damage.\n   * @exports ICCSUsrMsg_Damage\n   * @interface ICCSUsrMsg_Damage\n   * @property {number|null} [amount] CCSUsrMsg_Damage amount\n   * @property {ICMsgVector|null} [inflictorWorldPos] CCSUsrMsg_Damage inflictorWorldPos\n   * @property {number|null} [victimEntindex] CCSUsrMsg_Damage victimEntindex\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_Damage.\n   * @exports CCSUsrMsg_Damage\n   * @classdesc Represents a CCSUsrMsg_Damage.\n   * @implements ICCSUsrMsg_Damage\n   * @constructor\n   * @param {ICCSUsrMsg_Damage=} [properties] Properties to set\n   */\n  function CCSUsrMsg_Damage(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_Damage amount.\n   * @member {number} amount\n   * @memberof CCSUsrMsg_Damage\n   * @instance\n   */\n\n\n  CCSUsrMsg_Damage.prototype.amount = 0;\n  /**\n   * CCSUsrMsg_Damage inflictorWorldPos.\n   * @member {ICMsgVector|null|undefined} inflictorWorldPos\n   * @memberof CCSUsrMsg_Damage\n   * @instance\n   */\n\n  CCSUsrMsg_Damage.prototype.inflictorWorldPos = null;\n  /**\n   * CCSUsrMsg_Damage victimEntindex.\n   * @member {number} victimEntindex\n   * @memberof CCSUsrMsg_Damage\n   * @instance\n   */\n\n  CCSUsrMsg_Damage.prototype.victimEntindex = 0;\n  /**\n   * Decodes a CCSUsrMsg_Damage message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_Damage\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_Damage} CCSUsrMsg_Damage\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_Damage.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_Damage();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.amount = reader.int32();\n          break;\n\n        case 2:\n          message.inflictorWorldPos = $root.CMsgVector.decode(reader, reader.uint32());\n          break;\n\n        case 3:\n          message.victimEntindex = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_Damage;\n})();\n\nexports.CCSUsrMsg_RadioText = $root.CCSUsrMsg_RadioText = (() => {\n  /**\n   * Properties of a CCSUsrMsg_RadioText.\n   * @exports ICCSUsrMsg_RadioText\n   * @interface ICCSUsrMsg_RadioText\n   * @property {number|null} [msgDst] CCSUsrMsg_RadioText msgDst\n   * @property {number|null} [client] CCSUsrMsg_RadioText client\n   * @property {string|null} [msgName] CCSUsrMsg_RadioText msgName\n   * @property {Array.<string>|null} [params] CCSUsrMsg_RadioText params\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_RadioText.\n   * @exports CCSUsrMsg_RadioText\n   * @classdesc Represents a CCSUsrMsg_RadioText.\n   * @implements ICCSUsrMsg_RadioText\n   * @constructor\n   * @param {ICCSUsrMsg_RadioText=} [properties] Properties to set\n   */\n  function CCSUsrMsg_RadioText(properties) {\n    this.params = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_RadioText msgDst.\n   * @member {number} msgDst\n   * @memberof CCSUsrMsg_RadioText\n   * @instance\n   */\n\n\n  CCSUsrMsg_RadioText.prototype.msgDst = 0;\n  /**\n   * CCSUsrMsg_RadioText client.\n   * @member {number} client\n   * @memberof CCSUsrMsg_RadioText\n   * @instance\n   */\n\n  CCSUsrMsg_RadioText.prototype.client = 0;\n  /**\n   * CCSUsrMsg_RadioText msgName.\n   * @member {string} msgName\n   * @memberof CCSUsrMsg_RadioText\n   * @instance\n   */\n\n  CCSUsrMsg_RadioText.prototype.msgName = \"\";\n  /**\n   * CCSUsrMsg_RadioText params.\n   * @member {Array.<string>} params\n   * @memberof CCSUsrMsg_RadioText\n   * @instance\n   */\n\n  CCSUsrMsg_RadioText.prototype.params = $util.emptyArray;\n  /**\n   * Decodes a CCSUsrMsg_RadioText message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_RadioText\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_RadioText} CCSUsrMsg_RadioText\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_RadioText.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_RadioText();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.msgDst = reader.int32();\n          break;\n\n        case 2:\n          message.client = reader.int32();\n          break;\n\n        case 3:\n          message.msgName = reader.string();\n          break;\n\n        case 4:\n          if (!(message.params && message.params.length)) message.params = [];\n          message.params.push(reader.string());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_RadioText;\n})();\n\nexports.CCSUsrMsg_HintText = $root.CCSUsrMsg_HintText = (() => {\n  /**\n   * Properties of a CCSUsrMsg_HintText.\n   * @exports ICCSUsrMsg_HintText\n   * @interface ICCSUsrMsg_HintText\n   * @property {string|null} [text] CCSUsrMsg_HintText text\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_HintText.\n   * @exports CCSUsrMsg_HintText\n   * @classdesc Represents a CCSUsrMsg_HintText.\n   * @implements ICCSUsrMsg_HintText\n   * @constructor\n   * @param {ICCSUsrMsg_HintText=} [properties] Properties to set\n   */\n  function CCSUsrMsg_HintText(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_HintText text.\n   * @member {string} text\n   * @memberof CCSUsrMsg_HintText\n   * @instance\n   */\n\n\n  CCSUsrMsg_HintText.prototype.text = \"\";\n  /**\n   * Decodes a CCSUsrMsg_HintText message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_HintText\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_HintText} CCSUsrMsg_HintText\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_HintText.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_HintText();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.text = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_HintText;\n})();\n\nexports.CCSUsrMsg_KeyHintText = $root.CCSUsrMsg_KeyHintText = (() => {\n  /**\n   * Properties of a CCSUsrMsg_KeyHintText.\n   * @exports ICCSUsrMsg_KeyHintText\n   * @interface ICCSUsrMsg_KeyHintText\n   * @property {Array.<string>|null} [hints] CCSUsrMsg_KeyHintText hints\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_KeyHintText.\n   * @exports CCSUsrMsg_KeyHintText\n   * @classdesc Represents a CCSUsrMsg_KeyHintText.\n   * @implements ICCSUsrMsg_KeyHintText\n   * @constructor\n   * @param {ICCSUsrMsg_KeyHintText=} [properties] Properties to set\n   */\n  function CCSUsrMsg_KeyHintText(properties) {\n    this.hints = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_KeyHintText hints.\n   * @member {Array.<string>} hints\n   * @memberof CCSUsrMsg_KeyHintText\n   * @instance\n   */\n\n\n  CCSUsrMsg_KeyHintText.prototype.hints = $util.emptyArray;\n  /**\n   * Decodes a CCSUsrMsg_KeyHintText message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_KeyHintText\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_KeyHintText} CCSUsrMsg_KeyHintText\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_KeyHintText.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_KeyHintText();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.hints && message.hints.length)) message.hints = [];\n          message.hints.push(reader.string());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_KeyHintText;\n})();\n\nexports.CCSUsrMsg_ProcessSpottedEntityUpdate = $root.CCSUsrMsg_ProcessSpottedEntityUpdate = (() => {\n  /**\n   * Properties of a CCSUsrMsg_ProcessSpottedEntityUpdate.\n   * @exports ICCSUsrMsg_ProcessSpottedEntityUpdate\n   * @interface ICCSUsrMsg_ProcessSpottedEntityUpdate\n   * @property {boolean|null} [newUpdate] CCSUsrMsg_ProcessSpottedEntityUpdate newUpdate\n   * @property {Array.<CCSUsrMsg_ProcessSpottedEntityUpdate.ISpottedEntityUpdate>|null} [entityUpdates] CCSUsrMsg_ProcessSpottedEntityUpdate entityUpdates\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_ProcessSpottedEntityUpdate.\n   * @exports CCSUsrMsg_ProcessSpottedEntityUpdate\n   * @classdesc Represents a CCSUsrMsg_ProcessSpottedEntityUpdate.\n   * @implements ICCSUsrMsg_ProcessSpottedEntityUpdate\n   * @constructor\n   * @param {ICCSUsrMsg_ProcessSpottedEntityUpdate=} [properties] Properties to set\n   */\n  function CCSUsrMsg_ProcessSpottedEntityUpdate(properties) {\n    this.entityUpdates = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_ProcessSpottedEntityUpdate newUpdate.\n   * @member {boolean} newUpdate\n   * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate\n   * @instance\n   */\n\n\n  CCSUsrMsg_ProcessSpottedEntityUpdate.prototype.newUpdate = false;\n  /**\n   * CCSUsrMsg_ProcessSpottedEntityUpdate entityUpdates.\n   * @member {Array.<CCSUsrMsg_ProcessSpottedEntityUpdate.ISpottedEntityUpdate>} entityUpdates\n   * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate\n   * @instance\n   */\n\n  CCSUsrMsg_ProcessSpottedEntityUpdate.prototype.entityUpdates = $util.emptyArray;\n  /**\n   * Decodes a CCSUsrMsg_ProcessSpottedEntityUpdate message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_ProcessSpottedEntityUpdate} CCSUsrMsg_ProcessSpottedEntityUpdate\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_ProcessSpottedEntityUpdate.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_ProcessSpottedEntityUpdate();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.newUpdate = reader.bool();\n          break;\n\n        case 2:\n          if (!(message.entityUpdates && message.entityUpdates.length)) message.entityUpdates = [];\n          message.entityUpdates.push($root.CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate = function () {\n    /**\n     * Properties of a SpottedEntityUpdate.\n     * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate\n     * @interface ISpottedEntityUpdate\n     * @property {number|null} [entityIdx] SpottedEntityUpdate entityIdx\n     * @property {number|null} [classId] SpottedEntityUpdate classId\n     * @property {number|null} [originX] SpottedEntityUpdate originX\n     * @property {number|null} [originY] SpottedEntityUpdate originY\n     * @property {number|null} [originZ] SpottedEntityUpdate originZ\n     * @property {number|null} [angleY] SpottedEntityUpdate angleY\n     * @property {boolean|null} [defuser] SpottedEntityUpdate defuser\n     * @property {boolean|null} [playerHasDefuser] SpottedEntityUpdate playerHasDefuser\n     * @property {boolean|null} [playerHasC4] SpottedEntityUpdate playerHasC4\n     */\n\n    /**\n     * Constructs a new SpottedEntityUpdate.\n     * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate\n     * @classdesc Represents a SpottedEntityUpdate.\n     * @implements ISpottedEntityUpdate\n     * @constructor\n     * @param {CCSUsrMsg_ProcessSpottedEntityUpdate.ISpottedEntityUpdate=} [properties] Properties to set\n     */\n    function SpottedEntityUpdate(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * SpottedEntityUpdate entityIdx.\n     * @member {number} entityIdx\n     * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate\n     * @instance\n     */\n\n\n    SpottedEntityUpdate.prototype.entityIdx = 0;\n    /**\n     * SpottedEntityUpdate classId.\n     * @member {number} classId\n     * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate\n     * @instance\n     */\n\n    SpottedEntityUpdate.prototype.classId = 0;\n    /**\n     * SpottedEntityUpdate originX.\n     * @member {number} originX\n     * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate\n     * @instance\n     */\n\n    SpottedEntityUpdate.prototype.originX = 0;\n    /**\n     * SpottedEntityUpdate originY.\n     * @member {number} originY\n     * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate\n     * @instance\n     */\n\n    SpottedEntityUpdate.prototype.originY = 0;\n    /**\n     * SpottedEntityUpdate originZ.\n     * @member {number} originZ\n     * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate\n     * @instance\n     */\n\n    SpottedEntityUpdate.prototype.originZ = 0;\n    /**\n     * SpottedEntityUpdate angleY.\n     * @member {number} angleY\n     * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate\n     * @instance\n     */\n\n    SpottedEntityUpdate.prototype.angleY = 0;\n    /**\n     * SpottedEntityUpdate defuser.\n     * @member {boolean} defuser\n     * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate\n     * @instance\n     */\n\n    SpottedEntityUpdate.prototype.defuser = false;\n    /**\n     * SpottedEntityUpdate playerHasDefuser.\n     * @member {boolean} playerHasDefuser\n     * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate\n     * @instance\n     */\n\n    SpottedEntityUpdate.prototype.playerHasDefuser = false;\n    /**\n     * SpottedEntityUpdate playerHasC4.\n     * @member {boolean} playerHasC4\n     * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate\n     * @instance\n     */\n\n    SpottedEntityUpdate.prototype.playerHasC4 = false;\n    /**\n     * Decodes a SpottedEntityUpdate message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate} SpottedEntityUpdate\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    SpottedEntityUpdate.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.entityIdx = reader.int32();\n            break;\n\n          case 2:\n            message.classId = reader.int32();\n            break;\n\n          case 3:\n            message.originX = reader.int32();\n            break;\n\n          case 4:\n            message.originY = reader.int32();\n            break;\n\n          case 5:\n            message.originZ = reader.int32();\n            break;\n\n          case 6:\n            message.angleY = reader.int32();\n            break;\n\n          case 7:\n            message.defuser = reader.bool();\n            break;\n\n          case 8:\n            message.playerHasDefuser = reader.bool();\n            break;\n\n          case 9:\n            message.playerHasC4 = reader.bool();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return SpottedEntityUpdate;\n  }();\n\n  return CCSUsrMsg_ProcessSpottedEntityUpdate;\n})();\n\nexports.CCSUsrMsg_SendPlayerItemDrops = $root.CCSUsrMsg_SendPlayerItemDrops = (() => {\n  /**\n   * Properties of a CCSUsrMsg_SendPlayerItemDrops.\n   * @exports ICCSUsrMsg_SendPlayerItemDrops\n   * @interface ICCSUsrMsg_SendPlayerItemDrops\n   * @property {Array.<ICEconItemPreviewDataBlock>|null} [entityUpdates] CCSUsrMsg_SendPlayerItemDrops entityUpdates\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_SendPlayerItemDrops.\n   * @exports CCSUsrMsg_SendPlayerItemDrops\n   * @classdesc Represents a CCSUsrMsg_SendPlayerItemDrops.\n   * @implements ICCSUsrMsg_SendPlayerItemDrops\n   * @constructor\n   * @param {ICCSUsrMsg_SendPlayerItemDrops=} [properties] Properties to set\n   */\n  function CCSUsrMsg_SendPlayerItemDrops(properties) {\n    this.entityUpdates = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_SendPlayerItemDrops entityUpdates.\n   * @member {Array.<ICEconItemPreviewDataBlock>} entityUpdates\n   * @memberof CCSUsrMsg_SendPlayerItemDrops\n   * @instance\n   */\n\n\n  CCSUsrMsg_SendPlayerItemDrops.prototype.entityUpdates = $util.emptyArray;\n  /**\n   * Decodes a CCSUsrMsg_SendPlayerItemDrops message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_SendPlayerItemDrops\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_SendPlayerItemDrops} CCSUsrMsg_SendPlayerItemDrops\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_SendPlayerItemDrops.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_SendPlayerItemDrops();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.entityUpdates && message.entityUpdates.length)) message.entityUpdates = [];\n          message.entityUpdates.push($root.CEconItemPreviewDataBlock.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_SendPlayerItemDrops;\n})();\n\nexports.CCSUsrMsg_SendPlayerItemFound = $root.CCSUsrMsg_SendPlayerItemFound = (() => {\n  /**\n   * Properties of a CCSUsrMsg_SendPlayerItemFound.\n   * @exports ICCSUsrMsg_SendPlayerItemFound\n   * @interface ICCSUsrMsg_SendPlayerItemFound\n   * @property {ICEconItemPreviewDataBlock|null} [iteminfo] CCSUsrMsg_SendPlayerItemFound iteminfo\n   * @property {number|null} [entindex] CCSUsrMsg_SendPlayerItemFound entindex\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_SendPlayerItemFound.\n   * @exports CCSUsrMsg_SendPlayerItemFound\n   * @classdesc Represents a CCSUsrMsg_SendPlayerItemFound.\n   * @implements ICCSUsrMsg_SendPlayerItemFound\n   * @constructor\n   * @param {ICCSUsrMsg_SendPlayerItemFound=} [properties] Properties to set\n   */\n  function CCSUsrMsg_SendPlayerItemFound(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_SendPlayerItemFound iteminfo.\n   * @member {ICEconItemPreviewDataBlock|null|undefined} iteminfo\n   * @memberof CCSUsrMsg_SendPlayerItemFound\n   * @instance\n   */\n\n\n  CCSUsrMsg_SendPlayerItemFound.prototype.iteminfo = null;\n  /**\n   * CCSUsrMsg_SendPlayerItemFound entindex.\n   * @member {number} entindex\n   * @memberof CCSUsrMsg_SendPlayerItemFound\n   * @instance\n   */\n\n  CCSUsrMsg_SendPlayerItemFound.prototype.entindex = 0;\n  /**\n   * Decodes a CCSUsrMsg_SendPlayerItemFound message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_SendPlayerItemFound\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_SendPlayerItemFound} CCSUsrMsg_SendPlayerItemFound\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_SendPlayerItemFound.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_SendPlayerItemFound();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.iteminfo = $root.CEconItemPreviewDataBlock.decode(reader, reader.uint32());\n          break;\n\n        case 2:\n          message.entindex = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_SendPlayerItemFound;\n})();\n\nexports.CCSUsrMsg_ReloadEffect = $root.CCSUsrMsg_ReloadEffect = (() => {\n  /**\n   * Properties of a CCSUsrMsg_ReloadEffect.\n   * @exports ICCSUsrMsg_ReloadEffect\n   * @interface ICCSUsrMsg_ReloadEffect\n   * @property {number|null} [entidx] CCSUsrMsg_ReloadEffect entidx\n   * @property {number|null} [actanim] CCSUsrMsg_ReloadEffect actanim\n   * @property {number|null} [originX] CCSUsrMsg_ReloadEffect originX\n   * @property {number|null} [originY] CCSUsrMsg_ReloadEffect originY\n   * @property {number|null} [originZ] CCSUsrMsg_ReloadEffect originZ\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_ReloadEffect.\n   * @exports CCSUsrMsg_ReloadEffect\n   * @classdesc Represents a CCSUsrMsg_ReloadEffect.\n   * @implements ICCSUsrMsg_ReloadEffect\n   * @constructor\n   * @param {ICCSUsrMsg_ReloadEffect=} [properties] Properties to set\n   */\n  function CCSUsrMsg_ReloadEffect(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_ReloadEffect entidx.\n   * @member {number} entidx\n   * @memberof CCSUsrMsg_ReloadEffect\n   * @instance\n   */\n\n\n  CCSUsrMsg_ReloadEffect.prototype.entidx = 0;\n  /**\n   * CCSUsrMsg_ReloadEffect actanim.\n   * @member {number} actanim\n   * @memberof CCSUsrMsg_ReloadEffect\n   * @instance\n   */\n\n  CCSUsrMsg_ReloadEffect.prototype.actanim = 0;\n  /**\n   * CCSUsrMsg_ReloadEffect originX.\n   * @member {number} originX\n   * @memberof CCSUsrMsg_ReloadEffect\n   * @instance\n   */\n\n  CCSUsrMsg_ReloadEffect.prototype.originX = 0;\n  /**\n   * CCSUsrMsg_ReloadEffect originY.\n   * @member {number} originY\n   * @memberof CCSUsrMsg_ReloadEffect\n   * @instance\n   */\n\n  CCSUsrMsg_ReloadEffect.prototype.originY = 0;\n  /**\n   * CCSUsrMsg_ReloadEffect originZ.\n   * @member {number} originZ\n   * @memberof CCSUsrMsg_ReloadEffect\n   * @instance\n   */\n\n  CCSUsrMsg_ReloadEffect.prototype.originZ = 0;\n  /**\n   * Decodes a CCSUsrMsg_ReloadEffect message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_ReloadEffect\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_ReloadEffect} CCSUsrMsg_ReloadEffect\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_ReloadEffect.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_ReloadEffect();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.entidx = reader.int32();\n          break;\n\n        case 2:\n          message.actanim = reader.int32();\n          break;\n\n        case 3:\n          message.originX = reader.float();\n          break;\n\n        case 4:\n          message.originY = reader.float();\n          break;\n\n        case 5:\n          message.originZ = reader.float();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_ReloadEffect;\n})();\n\nexports.CCSUsrMsg_AdjustMoney = $root.CCSUsrMsg_AdjustMoney = (() => {\n  /**\n   * Properties of a CCSUsrMsg_AdjustMoney.\n   * @exports ICCSUsrMsg_AdjustMoney\n   * @interface ICCSUsrMsg_AdjustMoney\n   * @property {number|null} [amount] CCSUsrMsg_AdjustMoney amount\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_AdjustMoney.\n   * @exports CCSUsrMsg_AdjustMoney\n   * @classdesc Represents a CCSUsrMsg_AdjustMoney.\n   * @implements ICCSUsrMsg_AdjustMoney\n   * @constructor\n   * @param {ICCSUsrMsg_AdjustMoney=} [properties] Properties to set\n   */\n  function CCSUsrMsg_AdjustMoney(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_AdjustMoney amount.\n   * @member {number} amount\n   * @memberof CCSUsrMsg_AdjustMoney\n   * @instance\n   */\n\n\n  CCSUsrMsg_AdjustMoney.prototype.amount = 0;\n  /**\n   * Decodes a CCSUsrMsg_AdjustMoney message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_AdjustMoney\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_AdjustMoney} CCSUsrMsg_AdjustMoney\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_AdjustMoney.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_AdjustMoney();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.amount = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_AdjustMoney;\n})();\n\nexports.CCSUsrMsg_ReportHit = $root.CCSUsrMsg_ReportHit = (() => {\n  /**\n   * Properties of a CCSUsrMsg_ReportHit.\n   * @exports ICCSUsrMsg_ReportHit\n   * @interface ICCSUsrMsg_ReportHit\n   * @property {number|null} [posX] CCSUsrMsg_ReportHit posX\n   * @property {number|null} [posY] CCSUsrMsg_ReportHit posY\n   * @property {number|null} [timestamp] CCSUsrMsg_ReportHit timestamp\n   * @property {number|null} [posZ] CCSUsrMsg_ReportHit posZ\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_ReportHit.\n   * @exports CCSUsrMsg_ReportHit\n   * @classdesc Represents a CCSUsrMsg_ReportHit.\n   * @implements ICCSUsrMsg_ReportHit\n   * @constructor\n   * @param {ICCSUsrMsg_ReportHit=} [properties] Properties to set\n   */\n  function CCSUsrMsg_ReportHit(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_ReportHit posX.\n   * @member {number} posX\n   * @memberof CCSUsrMsg_ReportHit\n   * @instance\n   */\n\n\n  CCSUsrMsg_ReportHit.prototype.posX = 0;\n  /**\n   * CCSUsrMsg_ReportHit posY.\n   * @member {number} posY\n   * @memberof CCSUsrMsg_ReportHit\n   * @instance\n   */\n\n  CCSUsrMsg_ReportHit.prototype.posY = 0;\n  /**\n   * CCSUsrMsg_ReportHit timestamp.\n   * @member {number} timestamp\n   * @memberof CCSUsrMsg_ReportHit\n   * @instance\n   */\n\n  CCSUsrMsg_ReportHit.prototype.timestamp = 0;\n  /**\n   * CCSUsrMsg_ReportHit posZ.\n   * @member {number} posZ\n   * @memberof CCSUsrMsg_ReportHit\n   * @instance\n   */\n\n  CCSUsrMsg_ReportHit.prototype.posZ = 0;\n  /**\n   * Decodes a CCSUsrMsg_ReportHit message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_ReportHit\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_ReportHit} CCSUsrMsg_ReportHit\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_ReportHit.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_ReportHit();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.posX = reader.float();\n          break;\n\n        case 2:\n          message.posY = reader.float();\n          break;\n\n        case 4:\n          message.timestamp = reader.float();\n          break;\n\n        case 3:\n          message.posZ = reader.float();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_ReportHit;\n})();\n\nexports.CCSUsrMsg_KillCam = $root.CCSUsrMsg_KillCam = (() => {\n  /**\n   * Properties of a CCSUsrMsg_KillCam.\n   * @exports ICCSUsrMsg_KillCam\n   * @interface ICCSUsrMsg_KillCam\n   * @property {number|null} [obsMode] CCSUsrMsg_KillCam obsMode\n   * @property {number|null} [firstTarget] CCSUsrMsg_KillCam firstTarget\n   * @property {number|null} [secondTarget] CCSUsrMsg_KillCam secondTarget\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_KillCam.\n   * @exports CCSUsrMsg_KillCam\n   * @classdesc Represents a CCSUsrMsg_KillCam.\n   * @implements ICCSUsrMsg_KillCam\n   * @constructor\n   * @param {ICCSUsrMsg_KillCam=} [properties] Properties to set\n   */\n  function CCSUsrMsg_KillCam(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_KillCam obsMode.\n   * @member {number} obsMode\n   * @memberof CCSUsrMsg_KillCam\n   * @instance\n   */\n\n\n  CCSUsrMsg_KillCam.prototype.obsMode = 0;\n  /**\n   * CCSUsrMsg_KillCam firstTarget.\n   * @member {number} firstTarget\n   * @memberof CCSUsrMsg_KillCam\n   * @instance\n   */\n\n  CCSUsrMsg_KillCam.prototype.firstTarget = 0;\n  /**\n   * CCSUsrMsg_KillCam secondTarget.\n   * @member {number} secondTarget\n   * @memberof CCSUsrMsg_KillCam\n   * @instance\n   */\n\n  CCSUsrMsg_KillCam.prototype.secondTarget = 0;\n  /**\n   * Decodes a CCSUsrMsg_KillCam message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_KillCam\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_KillCam} CCSUsrMsg_KillCam\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_KillCam.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_KillCam();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.obsMode = reader.int32();\n          break;\n\n        case 2:\n          message.firstTarget = reader.int32();\n          break;\n\n        case 3:\n          message.secondTarget = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_KillCam;\n})();\n\nexports.CCSUsrMsg_DesiredTimescale = $root.CCSUsrMsg_DesiredTimescale = (() => {\n  /**\n   * Properties of a CCSUsrMsg_DesiredTimescale.\n   * @exports ICCSUsrMsg_DesiredTimescale\n   * @interface ICCSUsrMsg_DesiredTimescale\n   * @property {number|null} [desiredTimescale] CCSUsrMsg_DesiredTimescale desiredTimescale\n   * @property {number|null} [durationRealtimeSec] CCSUsrMsg_DesiredTimescale durationRealtimeSec\n   * @property {number|null} [interpolatorType] CCSUsrMsg_DesiredTimescale interpolatorType\n   * @property {number|null} [startBlendTime] CCSUsrMsg_DesiredTimescale startBlendTime\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_DesiredTimescale.\n   * @exports CCSUsrMsg_DesiredTimescale\n   * @classdesc Represents a CCSUsrMsg_DesiredTimescale.\n   * @implements ICCSUsrMsg_DesiredTimescale\n   * @constructor\n   * @param {ICCSUsrMsg_DesiredTimescale=} [properties] Properties to set\n   */\n  function CCSUsrMsg_DesiredTimescale(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_DesiredTimescale desiredTimescale.\n   * @member {number} desiredTimescale\n   * @memberof CCSUsrMsg_DesiredTimescale\n   * @instance\n   */\n\n\n  CCSUsrMsg_DesiredTimescale.prototype.desiredTimescale = 0;\n  /**\n   * CCSUsrMsg_DesiredTimescale durationRealtimeSec.\n   * @member {number} durationRealtimeSec\n   * @memberof CCSUsrMsg_DesiredTimescale\n   * @instance\n   */\n\n  CCSUsrMsg_DesiredTimescale.prototype.durationRealtimeSec = 0;\n  /**\n   * CCSUsrMsg_DesiredTimescale interpolatorType.\n   * @member {number} interpolatorType\n   * @memberof CCSUsrMsg_DesiredTimescale\n   * @instance\n   */\n\n  CCSUsrMsg_DesiredTimescale.prototype.interpolatorType = 0;\n  /**\n   * CCSUsrMsg_DesiredTimescale startBlendTime.\n   * @member {number} startBlendTime\n   * @memberof CCSUsrMsg_DesiredTimescale\n   * @instance\n   */\n\n  CCSUsrMsg_DesiredTimescale.prototype.startBlendTime = 0;\n  /**\n   * Decodes a CCSUsrMsg_DesiredTimescale message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_DesiredTimescale\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_DesiredTimescale} CCSUsrMsg_DesiredTimescale\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_DesiredTimescale.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_DesiredTimescale();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.desiredTimescale = reader.float();\n          break;\n\n        case 2:\n          message.durationRealtimeSec = reader.float();\n          break;\n\n        case 3:\n          message.interpolatorType = reader.int32();\n          break;\n\n        case 4:\n          message.startBlendTime = reader.float();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_DesiredTimescale;\n})();\n\nexports.CCSUsrMsg_CurrentTimescale = $root.CCSUsrMsg_CurrentTimescale = (() => {\n  /**\n   * Properties of a CCSUsrMsg_CurrentTimescale.\n   * @exports ICCSUsrMsg_CurrentTimescale\n   * @interface ICCSUsrMsg_CurrentTimescale\n   * @property {number|null} [curTimescale] CCSUsrMsg_CurrentTimescale curTimescale\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_CurrentTimescale.\n   * @exports CCSUsrMsg_CurrentTimescale\n   * @classdesc Represents a CCSUsrMsg_CurrentTimescale.\n   * @implements ICCSUsrMsg_CurrentTimescale\n   * @constructor\n   * @param {ICCSUsrMsg_CurrentTimescale=} [properties] Properties to set\n   */\n  function CCSUsrMsg_CurrentTimescale(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_CurrentTimescale curTimescale.\n   * @member {number} curTimescale\n   * @memberof CCSUsrMsg_CurrentTimescale\n   * @instance\n   */\n\n\n  CCSUsrMsg_CurrentTimescale.prototype.curTimescale = 0;\n  /**\n   * Decodes a CCSUsrMsg_CurrentTimescale message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_CurrentTimescale\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_CurrentTimescale} CCSUsrMsg_CurrentTimescale\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_CurrentTimescale.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_CurrentTimescale();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.curTimescale = reader.float();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_CurrentTimescale;\n})();\n\nexports.CCSUsrMsg_AchievementEvent = $root.CCSUsrMsg_AchievementEvent = (() => {\n  /**\n   * Properties of a CCSUsrMsg_AchievementEvent.\n   * @exports ICCSUsrMsg_AchievementEvent\n   * @interface ICCSUsrMsg_AchievementEvent\n   * @property {number|null} [achievement] CCSUsrMsg_AchievementEvent achievement\n   * @property {number|null} [count] CCSUsrMsg_AchievementEvent count\n   * @property {number|null} [userId] CCSUsrMsg_AchievementEvent userId\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_AchievementEvent.\n   * @exports CCSUsrMsg_AchievementEvent\n   * @classdesc Represents a CCSUsrMsg_AchievementEvent.\n   * @implements ICCSUsrMsg_AchievementEvent\n   * @constructor\n   * @param {ICCSUsrMsg_AchievementEvent=} [properties] Properties to set\n   */\n  function CCSUsrMsg_AchievementEvent(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_AchievementEvent achievement.\n   * @member {number} achievement\n   * @memberof CCSUsrMsg_AchievementEvent\n   * @instance\n   */\n\n\n  CCSUsrMsg_AchievementEvent.prototype.achievement = 0;\n  /**\n   * CCSUsrMsg_AchievementEvent count.\n   * @member {number} count\n   * @memberof CCSUsrMsg_AchievementEvent\n   * @instance\n   */\n\n  CCSUsrMsg_AchievementEvent.prototype.count = 0;\n  /**\n   * CCSUsrMsg_AchievementEvent userId.\n   * @member {number} userId\n   * @memberof CCSUsrMsg_AchievementEvent\n   * @instance\n   */\n\n  CCSUsrMsg_AchievementEvent.prototype.userId = 0;\n  /**\n   * Decodes a CCSUsrMsg_AchievementEvent message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_AchievementEvent\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_AchievementEvent} CCSUsrMsg_AchievementEvent\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_AchievementEvent.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_AchievementEvent();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.achievement = reader.int32();\n          break;\n\n        case 2:\n          message.count = reader.int32();\n          break;\n\n        case 3:\n          message.userId = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_AchievementEvent;\n})();\n\nexports.CCSUsrMsg_MatchEndConditions = $root.CCSUsrMsg_MatchEndConditions = (() => {\n  /**\n   * Properties of a CCSUsrMsg_MatchEndConditions.\n   * @exports ICCSUsrMsg_MatchEndConditions\n   * @interface ICCSUsrMsg_MatchEndConditions\n   * @property {number|null} [fraglimit] CCSUsrMsg_MatchEndConditions fraglimit\n   * @property {number|null} [mpMaxrounds] CCSUsrMsg_MatchEndConditions mpMaxrounds\n   * @property {number|null} [mpWinlimit] CCSUsrMsg_MatchEndConditions mpWinlimit\n   * @property {number|null} [mpTimelimit] CCSUsrMsg_MatchEndConditions mpTimelimit\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_MatchEndConditions.\n   * @exports CCSUsrMsg_MatchEndConditions\n   * @classdesc Represents a CCSUsrMsg_MatchEndConditions.\n   * @implements ICCSUsrMsg_MatchEndConditions\n   * @constructor\n   * @param {ICCSUsrMsg_MatchEndConditions=} [properties] Properties to set\n   */\n  function CCSUsrMsg_MatchEndConditions(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_MatchEndConditions fraglimit.\n   * @member {number} fraglimit\n   * @memberof CCSUsrMsg_MatchEndConditions\n   * @instance\n   */\n\n\n  CCSUsrMsg_MatchEndConditions.prototype.fraglimit = 0;\n  /**\n   * CCSUsrMsg_MatchEndConditions mpMaxrounds.\n   * @member {number} mpMaxrounds\n   * @memberof CCSUsrMsg_MatchEndConditions\n   * @instance\n   */\n\n  CCSUsrMsg_MatchEndConditions.prototype.mpMaxrounds = 0;\n  /**\n   * CCSUsrMsg_MatchEndConditions mpWinlimit.\n   * @member {number} mpWinlimit\n   * @memberof CCSUsrMsg_MatchEndConditions\n   * @instance\n   */\n\n  CCSUsrMsg_MatchEndConditions.prototype.mpWinlimit = 0;\n  /**\n   * CCSUsrMsg_MatchEndConditions mpTimelimit.\n   * @member {number} mpTimelimit\n   * @memberof CCSUsrMsg_MatchEndConditions\n   * @instance\n   */\n\n  CCSUsrMsg_MatchEndConditions.prototype.mpTimelimit = 0;\n  /**\n   * Decodes a CCSUsrMsg_MatchEndConditions message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_MatchEndConditions\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_MatchEndConditions} CCSUsrMsg_MatchEndConditions\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_MatchEndConditions.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_MatchEndConditions();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.fraglimit = reader.int32();\n          break;\n\n        case 2:\n          message.mpMaxrounds = reader.int32();\n          break;\n\n        case 3:\n          message.mpWinlimit = reader.int32();\n          break;\n\n        case 4:\n          message.mpTimelimit = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_MatchEndConditions;\n})();\n\nexports.CCSUsrMsg_PlayerStatsUpdate = $root.CCSUsrMsg_PlayerStatsUpdate = (() => {\n  /**\n   * Properties of a CCSUsrMsg_PlayerStatsUpdate.\n   * @exports ICCSUsrMsg_PlayerStatsUpdate\n   * @interface ICCSUsrMsg_PlayerStatsUpdate\n   * @property {number|null} [version] CCSUsrMsg_PlayerStatsUpdate version\n   * @property {Array.<CCSUsrMsg_PlayerStatsUpdate.IStat>|null} [stats] CCSUsrMsg_PlayerStatsUpdate stats\n   * @property {number|null} [userId] CCSUsrMsg_PlayerStatsUpdate userId\n   * @property {number|null} [crc] CCSUsrMsg_PlayerStatsUpdate crc\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_PlayerStatsUpdate.\n   * @exports CCSUsrMsg_PlayerStatsUpdate\n   * @classdesc Represents a CCSUsrMsg_PlayerStatsUpdate.\n   * @implements ICCSUsrMsg_PlayerStatsUpdate\n   * @constructor\n   * @param {ICCSUsrMsg_PlayerStatsUpdate=} [properties] Properties to set\n   */\n  function CCSUsrMsg_PlayerStatsUpdate(properties) {\n    this.stats = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_PlayerStatsUpdate version.\n   * @member {number} version\n   * @memberof CCSUsrMsg_PlayerStatsUpdate\n   * @instance\n   */\n\n\n  CCSUsrMsg_PlayerStatsUpdate.prototype.version = 0;\n  /**\n   * CCSUsrMsg_PlayerStatsUpdate stats.\n   * @member {Array.<CCSUsrMsg_PlayerStatsUpdate.IStat>} stats\n   * @memberof CCSUsrMsg_PlayerStatsUpdate\n   * @instance\n   */\n\n  CCSUsrMsg_PlayerStatsUpdate.prototype.stats = $util.emptyArray;\n  /**\n   * CCSUsrMsg_PlayerStatsUpdate userId.\n   * @member {number} userId\n   * @memberof CCSUsrMsg_PlayerStatsUpdate\n   * @instance\n   */\n\n  CCSUsrMsg_PlayerStatsUpdate.prototype.userId = 0;\n  /**\n   * CCSUsrMsg_PlayerStatsUpdate crc.\n   * @member {number} crc\n   * @memberof CCSUsrMsg_PlayerStatsUpdate\n   * @instance\n   */\n\n  CCSUsrMsg_PlayerStatsUpdate.prototype.crc = 0;\n  /**\n   * Decodes a CCSUsrMsg_PlayerStatsUpdate message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_PlayerStatsUpdate\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_PlayerStatsUpdate} CCSUsrMsg_PlayerStatsUpdate\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_PlayerStatsUpdate.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_PlayerStatsUpdate();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.version = reader.int32();\n          break;\n\n        case 4:\n          if (!(message.stats && message.stats.length)) message.stats = [];\n          message.stats.push($root.CCSUsrMsg_PlayerStatsUpdate.Stat.decode(reader, reader.uint32()));\n          break;\n\n        case 5:\n          message.userId = reader.int32();\n          break;\n\n        case 6:\n          message.crc = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CCSUsrMsg_PlayerStatsUpdate.Stat = function () {\n    /**\n     * Properties of a Stat.\n     * @memberof CCSUsrMsg_PlayerStatsUpdate\n     * @interface IStat\n     * @property {number|null} [idx] Stat idx\n     * @property {number|null} [delta] Stat delta\n     */\n\n    /**\n     * Constructs a new Stat.\n     * @memberof CCSUsrMsg_PlayerStatsUpdate\n     * @classdesc Represents a Stat.\n     * @implements IStat\n     * @constructor\n     * @param {CCSUsrMsg_PlayerStatsUpdate.IStat=} [properties] Properties to set\n     */\n    function Stat(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Stat idx.\n     * @member {number} idx\n     * @memberof CCSUsrMsg_PlayerStatsUpdate.Stat\n     * @instance\n     */\n\n\n    Stat.prototype.idx = 0;\n    /**\n     * Stat delta.\n     * @member {number} delta\n     * @memberof CCSUsrMsg_PlayerStatsUpdate.Stat\n     * @instance\n     */\n\n    Stat.prototype.delta = 0;\n    /**\n     * Decodes a Stat message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_PlayerStatsUpdate.Stat\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_PlayerStatsUpdate.Stat} Stat\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    Stat.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CCSUsrMsg_PlayerStatsUpdate.Stat();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.idx = reader.int32();\n            break;\n\n          case 2:\n            message.delta = reader.int32();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return Stat;\n  }();\n\n  return CCSUsrMsg_PlayerStatsUpdate;\n})();\n\nexports.CCSUsrMsg_DisplayInventory = $root.CCSUsrMsg_DisplayInventory = (() => {\n  /**\n   * Properties of a CCSUsrMsg_DisplayInventory.\n   * @exports ICCSUsrMsg_DisplayInventory\n   * @interface ICCSUsrMsg_DisplayInventory\n   * @property {boolean|null} [display] CCSUsrMsg_DisplayInventory display\n   * @property {number|null} [userId] CCSUsrMsg_DisplayInventory userId\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_DisplayInventory.\n   * @exports CCSUsrMsg_DisplayInventory\n   * @classdesc Represents a CCSUsrMsg_DisplayInventory.\n   * @implements ICCSUsrMsg_DisplayInventory\n   * @constructor\n   * @param {ICCSUsrMsg_DisplayInventory=} [properties] Properties to set\n   */\n  function CCSUsrMsg_DisplayInventory(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_DisplayInventory display.\n   * @member {boolean} display\n   * @memberof CCSUsrMsg_DisplayInventory\n   * @instance\n   */\n\n\n  CCSUsrMsg_DisplayInventory.prototype.display = false;\n  /**\n   * CCSUsrMsg_DisplayInventory userId.\n   * @member {number} userId\n   * @memberof CCSUsrMsg_DisplayInventory\n   * @instance\n   */\n\n  CCSUsrMsg_DisplayInventory.prototype.userId = 0;\n  /**\n   * Decodes a CCSUsrMsg_DisplayInventory message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_DisplayInventory\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_DisplayInventory} CCSUsrMsg_DisplayInventory\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_DisplayInventory.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_DisplayInventory();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.display = reader.bool();\n          break;\n\n        case 2:\n          message.userId = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_DisplayInventory;\n})();\n\nexports.CCSUsrMsg_QuestProgress = $root.CCSUsrMsg_QuestProgress = (() => {\n  /**\n   * Properties of a CCSUsrMsg_QuestProgress.\n   * @exports ICCSUsrMsg_QuestProgress\n   * @interface ICCSUsrMsg_QuestProgress\n   * @property {number|null} [questId] CCSUsrMsg_QuestProgress questId\n   * @property {number|null} [normalPoints] CCSUsrMsg_QuestProgress normalPoints\n   * @property {number|null} [bonusPoints] CCSUsrMsg_QuestProgress bonusPoints\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_QuestProgress.\n   * @exports CCSUsrMsg_QuestProgress\n   * @classdesc Represents a CCSUsrMsg_QuestProgress.\n   * @implements ICCSUsrMsg_QuestProgress\n   * @constructor\n   * @param {ICCSUsrMsg_QuestProgress=} [properties] Properties to set\n   */\n  function CCSUsrMsg_QuestProgress(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_QuestProgress questId.\n   * @member {number} questId\n   * @memberof CCSUsrMsg_QuestProgress\n   * @instance\n   */\n\n\n  CCSUsrMsg_QuestProgress.prototype.questId = 0;\n  /**\n   * CCSUsrMsg_QuestProgress normalPoints.\n   * @member {number} normalPoints\n   * @memberof CCSUsrMsg_QuestProgress\n   * @instance\n   */\n\n  CCSUsrMsg_QuestProgress.prototype.normalPoints = 0;\n  /**\n   * CCSUsrMsg_QuestProgress bonusPoints.\n   * @member {number} bonusPoints\n   * @memberof CCSUsrMsg_QuestProgress\n   * @instance\n   */\n\n  CCSUsrMsg_QuestProgress.prototype.bonusPoints = 0;\n  /**\n   * Decodes a CCSUsrMsg_QuestProgress message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_QuestProgress\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_QuestProgress} CCSUsrMsg_QuestProgress\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_QuestProgress.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_QuestProgress();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.questId = reader.uint32();\n          break;\n\n        case 2:\n          message.normalPoints = reader.uint32();\n          break;\n\n        case 3:\n          message.bonusPoints = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_QuestProgress;\n})();\n\nexports.CCSUsrMsg_XRankGet = $root.CCSUsrMsg_XRankGet = (() => {\n  /**\n   * Properties of a CCSUsrMsg_XRankGet.\n   * @exports ICCSUsrMsg_XRankGet\n   * @interface ICCSUsrMsg_XRankGet\n   * @property {number|null} [modeIdx] CCSUsrMsg_XRankGet modeIdx\n   * @property {number|null} [controller] CCSUsrMsg_XRankGet controller\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_XRankGet.\n   * @exports CCSUsrMsg_XRankGet\n   * @classdesc Represents a CCSUsrMsg_XRankGet.\n   * @implements ICCSUsrMsg_XRankGet\n   * @constructor\n   * @param {ICCSUsrMsg_XRankGet=} [properties] Properties to set\n   */\n  function CCSUsrMsg_XRankGet(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_XRankGet modeIdx.\n   * @member {number} modeIdx\n   * @memberof CCSUsrMsg_XRankGet\n   * @instance\n   */\n\n\n  CCSUsrMsg_XRankGet.prototype.modeIdx = 0;\n  /**\n   * CCSUsrMsg_XRankGet controller.\n   * @member {number} controller\n   * @memberof CCSUsrMsg_XRankGet\n   * @instance\n   */\n\n  CCSUsrMsg_XRankGet.prototype.controller = 0;\n  /**\n   * Decodes a CCSUsrMsg_XRankGet message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_XRankGet\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_XRankGet} CCSUsrMsg_XRankGet\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_XRankGet.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_XRankGet();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.modeIdx = reader.int32();\n          break;\n\n        case 2:\n          message.controller = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_XRankGet;\n})();\n\nexports.CCSUsrMsg_XRankUpd = $root.CCSUsrMsg_XRankUpd = (() => {\n  /**\n   * Properties of a CCSUsrMsg_XRankUpd.\n   * @exports ICCSUsrMsg_XRankUpd\n   * @interface ICCSUsrMsg_XRankUpd\n   * @property {number|null} [modeIdx] CCSUsrMsg_XRankUpd modeIdx\n   * @property {number|null} [controller] CCSUsrMsg_XRankUpd controller\n   * @property {number|null} [ranking] CCSUsrMsg_XRankUpd ranking\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_XRankUpd.\n   * @exports CCSUsrMsg_XRankUpd\n   * @classdesc Represents a CCSUsrMsg_XRankUpd.\n   * @implements ICCSUsrMsg_XRankUpd\n   * @constructor\n   * @param {ICCSUsrMsg_XRankUpd=} [properties] Properties to set\n   */\n  function CCSUsrMsg_XRankUpd(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_XRankUpd modeIdx.\n   * @member {number} modeIdx\n   * @memberof CCSUsrMsg_XRankUpd\n   * @instance\n   */\n\n\n  CCSUsrMsg_XRankUpd.prototype.modeIdx = 0;\n  /**\n   * CCSUsrMsg_XRankUpd controller.\n   * @member {number} controller\n   * @memberof CCSUsrMsg_XRankUpd\n   * @instance\n   */\n\n  CCSUsrMsg_XRankUpd.prototype.controller = 0;\n  /**\n   * CCSUsrMsg_XRankUpd ranking.\n   * @member {number} ranking\n   * @memberof CCSUsrMsg_XRankUpd\n   * @instance\n   */\n\n  CCSUsrMsg_XRankUpd.prototype.ranking = 0;\n  /**\n   * Decodes a CCSUsrMsg_XRankUpd message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_XRankUpd\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_XRankUpd} CCSUsrMsg_XRankUpd\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_XRankUpd.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_XRankUpd();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.modeIdx = reader.int32();\n          break;\n\n        case 2:\n          message.controller = reader.int32();\n          break;\n\n        case 3:\n          message.ranking = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_XRankUpd;\n})();\n\nexports.CCSUsrMsg_CallVoteFailed = $root.CCSUsrMsg_CallVoteFailed = (() => {\n  /**\n   * Properties of a CCSUsrMsg_CallVoteFailed.\n   * @exports ICCSUsrMsg_CallVoteFailed\n   * @interface ICCSUsrMsg_CallVoteFailed\n   * @property {number|null} [reason] CCSUsrMsg_CallVoteFailed reason\n   * @property {number|null} [time] CCSUsrMsg_CallVoteFailed time\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_CallVoteFailed.\n   * @exports CCSUsrMsg_CallVoteFailed\n   * @classdesc Represents a CCSUsrMsg_CallVoteFailed.\n   * @implements ICCSUsrMsg_CallVoteFailed\n   * @constructor\n   * @param {ICCSUsrMsg_CallVoteFailed=} [properties] Properties to set\n   */\n  function CCSUsrMsg_CallVoteFailed(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_CallVoteFailed reason.\n   * @member {number} reason\n   * @memberof CCSUsrMsg_CallVoteFailed\n   * @instance\n   */\n\n\n  CCSUsrMsg_CallVoteFailed.prototype.reason = 0;\n  /**\n   * CCSUsrMsg_CallVoteFailed time.\n   * @member {number} time\n   * @memberof CCSUsrMsg_CallVoteFailed\n   * @instance\n   */\n\n  CCSUsrMsg_CallVoteFailed.prototype.time = 0;\n  /**\n   * Decodes a CCSUsrMsg_CallVoteFailed message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_CallVoteFailed\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_CallVoteFailed} CCSUsrMsg_CallVoteFailed\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_CallVoteFailed.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_CallVoteFailed();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.reason = reader.int32();\n          break;\n\n        case 2:\n          message.time = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_CallVoteFailed;\n})();\n\nexports.CCSUsrMsg_VoteStart = $root.CCSUsrMsg_VoteStart = (() => {\n  /**\n   * Properties of a CCSUsrMsg_VoteStart.\n   * @exports ICCSUsrMsg_VoteStart\n   * @interface ICCSUsrMsg_VoteStart\n   * @property {number|null} [team] CCSUsrMsg_VoteStart team\n   * @property {number|null} [entIdx] CCSUsrMsg_VoteStart entIdx\n   * @property {number|null} [voteType] CCSUsrMsg_VoteStart voteType\n   * @property {string|null} [dispStr] CCSUsrMsg_VoteStart dispStr\n   * @property {string|null} [detailsStr] CCSUsrMsg_VoteStart detailsStr\n   * @property {string|null} [otherTeamStr] CCSUsrMsg_VoteStart otherTeamStr\n   * @property {boolean|null} [isYesNoVote] CCSUsrMsg_VoteStart isYesNoVote\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_VoteStart.\n   * @exports CCSUsrMsg_VoteStart\n   * @classdesc Represents a CCSUsrMsg_VoteStart.\n   * @implements ICCSUsrMsg_VoteStart\n   * @constructor\n   * @param {ICCSUsrMsg_VoteStart=} [properties] Properties to set\n   */\n  function CCSUsrMsg_VoteStart(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_VoteStart team.\n   * @member {number} team\n   * @memberof CCSUsrMsg_VoteStart\n   * @instance\n   */\n\n\n  CCSUsrMsg_VoteStart.prototype.team = 0;\n  /**\n   * CCSUsrMsg_VoteStart entIdx.\n   * @member {number} entIdx\n   * @memberof CCSUsrMsg_VoteStart\n   * @instance\n   */\n\n  CCSUsrMsg_VoteStart.prototype.entIdx = 0;\n  /**\n   * CCSUsrMsg_VoteStart voteType.\n   * @member {number} voteType\n   * @memberof CCSUsrMsg_VoteStart\n   * @instance\n   */\n\n  CCSUsrMsg_VoteStart.prototype.voteType = 0;\n  /**\n   * CCSUsrMsg_VoteStart dispStr.\n   * @member {string} dispStr\n   * @memberof CCSUsrMsg_VoteStart\n   * @instance\n   */\n\n  CCSUsrMsg_VoteStart.prototype.dispStr = \"\";\n  /**\n   * CCSUsrMsg_VoteStart detailsStr.\n   * @member {string} detailsStr\n   * @memberof CCSUsrMsg_VoteStart\n   * @instance\n   */\n\n  CCSUsrMsg_VoteStart.prototype.detailsStr = \"\";\n  /**\n   * CCSUsrMsg_VoteStart otherTeamStr.\n   * @member {string} otherTeamStr\n   * @memberof CCSUsrMsg_VoteStart\n   * @instance\n   */\n\n  CCSUsrMsg_VoteStart.prototype.otherTeamStr = \"\";\n  /**\n   * CCSUsrMsg_VoteStart isYesNoVote.\n   * @member {boolean} isYesNoVote\n   * @memberof CCSUsrMsg_VoteStart\n   * @instance\n   */\n\n  CCSUsrMsg_VoteStart.prototype.isYesNoVote = false;\n  /**\n   * Decodes a CCSUsrMsg_VoteStart message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_VoteStart\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_VoteStart} CCSUsrMsg_VoteStart\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_VoteStart.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_VoteStart();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.team = reader.int32();\n          break;\n\n        case 2:\n          message.entIdx = reader.int32();\n          break;\n\n        case 3:\n          message.voteType = reader.int32();\n          break;\n\n        case 4:\n          message.dispStr = reader.string();\n          break;\n\n        case 5:\n          message.detailsStr = reader.string();\n          break;\n\n        case 6:\n          message.otherTeamStr = reader.string();\n          break;\n\n        case 7:\n          message.isYesNoVote = reader.bool();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_VoteStart;\n})();\n\nexports.CCSUsrMsg_VotePass = $root.CCSUsrMsg_VotePass = (() => {\n  /**\n   * Properties of a CCSUsrMsg_VotePass.\n   * @exports ICCSUsrMsg_VotePass\n   * @interface ICCSUsrMsg_VotePass\n   * @property {number|null} [team] CCSUsrMsg_VotePass team\n   * @property {number|null} [voteType] CCSUsrMsg_VotePass voteType\n   * @property {string|null} [dispStr] CCSUsrMsg_VotePass dispStr\n   * @property {string|null} [detailsStr] CCSUsrMsg_VotePass detailsStr\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_VotePass.\n   * @exports CCSUsrMsg_VotePass\n   * @classdesc Represents a CCSUsrMsg_VotePass.\n   * @implements ICCSUsrMsg_VotePass\n   * @constructor\n   * @param {ICCSUsrMsg_VotePass=} [properties] Properties to set\n   */\n  function CCSUsrMsg_VotePass(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_VotePass team.\n   * @member {number} team\n   * @memberof CCSUsrMsg_VotePass\n   * @instance\n   */\n\n\n  CCSUsrMsg_VotePass.prototype.team = 0;\n  /**\n   * CCSUsrMsg_VotePass voteType.\n   * @member {number} voteType\n   * @memberof CCSUsrMsg_VotePass\n   * @instance\n   */\n\n  CCSUsrMsg_VotePass.prototype.voteType = 0;\n  /**\n   * CCSUsrMsg_VotePass dispStr.\n   * @member {string} dispStr\n   * @memberof CCSUsrMsg_VotePass\n   * @instance\n   */\n\n  CCSUsrMsg_VotePass.prototype.dispStr = \"\";\n  /**\n   * CCSUsrMsg_VotePass detailsStr.\n   * @member {string} detailsStr\n   * @memberof CCSUsrMsg_VotePass\n   * @instance\n   */\n\n  CCSUsrMsg_VotePass.prototype.detailsStr = \"\";\n  /**\n   * Decodes a CCSUsrMsg_VotePass message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_VotePass\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_VotePass} CCSUsrMsg_VotePass\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_VotePass.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_VotePass();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.team = reader.int32();\n          break;\n\n        case 2:\n          message.voteType = reader.int32();\n          break;\n\n        case 3:\n          message.dispStr = reader.string();\n          break;\n\n        case 4:\n          message.detailsStr = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_VotePass;\n})();\n\nexports.CCSUsrMsg_VoteFailed = $root.CCSUsrMsg_VoteFailed = (() => {\n  /**\n   * Properties of a CCSUsrMsg_VoteFailed.\n   * @exports ICCSUsrMsg_VoteFailed\n   * @interface ICCSUsrMsg_VoteFailed\n   * @property {number|null} [team] CCSUsrMsg_VoteFailed team\n   * @property {number|null} [reason] CCSUsrMsg_VoteFailed reason\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_VoteFailed.\n   * @exports CCSUsrMsg_VoteFailed\n   * @classdesc Represents a CCSUsrMsg_VoteFailed.\n   * @implements ICCSUsrMsg_VoteFailed\n   * @constructor\n   * @param {ICCSUsrMsg_VoteFailed=} [properties] Properties to set\n   */\n  function CCSUsrMsg_VoteFailed(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_VoteFailed team.\n   * @member {number} team\n   * @memberof CCSUsrMsg_VoteFailed\n   * @instance\n   */\n\n\n  CCSUsrMsg_VoteFailed.prototype.team = 0;\n  /**\n   * CCSUsrMsg_VoteFailed reason.\n   * @member {number} reason\n   * @memberof CCSUsrMsg_VoteFailed\n   * @instance\n   */\n\n  CCSUsrMsg_VoteFailed.prototype.reason = 0;\n  /**\n   * Decodes a CCSUsrMsg_VoteFailed message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_VoteFailed\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_VoteFailed} CCSUsrMsg_VoteFailed\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_VoteFailed.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_VoteFailed();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.team = reader.int32();\n          break;\n\n        case 2:\n          message.reason = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_VoteFailed;\n})();\n\nexports.CCSUsrMsg_VoteSetup = $root.CCSUsrMsg_VoteSetup = (() => {\n  /**\n   * Properties of a CCSUsrMsg_VoteSetup.\n   * @exports ICCSUsrMsg_VoteSetup\n   * @interface ICCSUsrMsg_VoteSetup\n   * @property {Array.<string>|null} [potentialIssues] CCSUsrMsg_VoteSetup potentialIssues\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_VoteSetup.\n   * @exports CCSUsrMsg_VoteSetup\n   * @classdesc Represents a CCSUsrMsg_VoteSetup.\n   * @implements ICCSUsrMsg_VoteSetup\n   * @constructor\n   * @param {ICCSUsrMsg_VoteSetup=} [properties] Properties to set\n   */\n  function CCSUsrMsg_VoteSetup(properties) {\n    this.potentialIssues = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_VoteSetup potentialIssues.\n   * @member {Array.<string>} potentialIssues\n   * @memberof CCSUsrMsg_VoteSetup\n   * @instance\n   */\n\n\n  CCSUsrMsg_VoteSetup.prototype.potentialIssues = $util.emptyArray;\n  /**\n   * Decodes a CCSUsrMsg_VoteSetup message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_VoteSetup\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_VoteSetup} CCSUsrMsg_VoteSetup\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_VoteSetup.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_VoteSetup();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.potentialIssues && message.potentialIssues.length)) message.potentialIssues = [];\n          message.potentialIssues.push(reader.string());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_VoteSetup;\n})();\n\nexports.CCSUsrMsg_SendLastKillerDamageToClient = $root.CCSUsrMsg_SendLastKillerDamageToClient = (() => {\n  /**\n   * Properties of a CCSUsrMsg_SendLastKillerDamageToClient.\n   * @exports ICCSUsrMsg_SendLastKillerDamageToClient\n   * @interface ICCSUsrMsg_SendLastKillerDamageToClient\n   * @property {number|null} [numHitsGiven] CCSUsrMsg_SendLastKillerDamageToClient numHitsGiven\n   * @property {number|null} [damageGiven] CCSUsrMsg_SendLastKillerDamageToClient damageGiven\n   * @property {number|null} [numHitsTaken] CCSUsrMsg_SendLastKillerDamageToClient numHitsTaken\n   * @property {number|null} [damageTaken] CCSUsrMsg_SendLastKillerDamageToClient damageTaken\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_SendLastKillerDamageToClient.\n   * @exports CCSUsrMsg_SendLastKillerDamageToClient\n   * @classdesc Represents a CCSUsrMsg_SendLastKillerDamageToClient.\n   * @implements ICCSUsrMsg_SendLastKillerDamageToClient\n   * @constructor\n   * @param {ICCSUsrMsg_SendLastKillerDamageToClient=} [properties] Properties to set\n   */\n  function CCSUsrMsg_SendLastKillerDamageToClient(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_SendLastKillerDamageToClient numHitsGiven.\n   * @member {number} numHitsGiven\n   * @memberof CCSUsrMsg_SendLastKillerDamageToClient\n   * @instance\n   */\n\n\n  CCSUsrMsg_SendLastKillerDamageToClient.prototype.numHitsGiven = 0;\n  /**\n   * CCSUsrMsg_SendLastKillerDamageToClient damageGiven.\n   * @member {number} damageGiven\n   * @memberof CCSUsrMsg_SendLastKillerDamageToClient\n   * @instance\n   */\n\n  CCSUsrMsg_SendLastKillerDamageToClient.prototype.damageGiven = 0;\n  /**\n   * CCSUsrMsg_SendLastKillerDamageToClient numHitsTaken.\n   * @member {number} numHitsTaken\n   * @memberof CCSUsrMsg_SendLastKillerDamageToClient\n   * @instance\n   */\n\n  CCSUsrMsg_SendLastKillerDamageToClient.prototype.numHitsTaken = 0;\n  /**\n   * CCSUsrMsg_SendLastKillerDamageToClient damageTaken.\n   * @member {number} damageTaken\n   * @memberof CCSUsrMsg_SendLastKillerDamageToClient\n   * @instance\n   */\n\n  CCSUsrMsg_SendLastKillerDamageToClient.prototype.damageTaken = 0;\n  /**\n   * Decodes a CCSUsrMsg_SendLastKillerDamageToClient message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_SendLastKillerDamageToClient\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_SendLastKillerDamageToClient} CCSUsrMsg_SendLastKillerDamageToClient\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_SendLastKillerDamageToClient.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_SendLastKillerDamageToClient();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.numHitsGiven = reader.int32();\n          break;\n\n        case 2:\n          message.damageGiven = reader.int32();\n          break;\n\n        case 3:\n          message.numHitsTaken = reader.int32();\n          break;\n\n        case 4:\n          message.damageTaken = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_SendLastKillerDamageToClient;\n})();\n\nexports.CCSUsrMsg_ServerRankUpdate = $root.CCSUsrMsg_ServerRankUpdate = (() => {\n  /**\n   * Properties of a CCSUsrMsg_ServerRankUpdate.\n   * @exports ICCSUsrMsg_ServerRankUpdate\n   * @interface ICCSUsrMsg_ServerRankUpdate\n   * @property {Array.<CCSUsrMsg_ServerRankUpdate.IRankUpdate>|null} [rankUpdate] CCSUsrMsg_ServerRankUpdate rankUpdate\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_ServerRankUpdate.\n   * @exports CCSUsrMsg_ServerRankUpdate\n   * @classdesc Represents a CCSUsrMsg_ServerRankUpdate.\n   * @implements ICCSUsrMsg_ServerRankUpdate\n   * @constructor\n   * @param {ICCSUsrMsg_ServerRankUpdate=} [properties] Properties to set\n   */\n  function CCSUsrMsg_ServerRankUpdate(properties) {\n    this.rankUpdate = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_ServerRankUpdate rankUpdate.\n   * @member {Array.<CCSUsrMsg_ServerRankUpdate.IRankUpdate>} rankUpdate\n   * @memberof CCSUsrMsg_ServerRankUpdate\n   * @instance\n   */\n\n\n  CCSUsrMsg_ServerRankUpdate.prototype.rankUpdate = $util.emptyArray;\n  /**\n   * Decodes a CCSUsrMsg_ServerRankUpdate message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_ServerRankUpdate\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_ServerRankUpdate} CCSUsrMsg_ServerRankUpdate\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_ServerRankUpdate.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_ServerRankUpdate();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.rankUpdate && message.rankUpdate.length)) message.rankUpdate = [];\n          message.rankUpdate.push($root.CCSUsrMsg_ServerRankUpdate.RankUpdate.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CCSUsrMsg_ServerRankUpdate.RankUpdate = function () {\n    /**\n     * Properties of a RankUpdate.\n     * @memberof CCSUsrMsg_ServerRankUpdate\n     * @interface IRankUpdate\n     * @property {number|null} [accountId] RankUpdate accountId\n     * @property {number|null} [rankOld] RankUpdate rankOld\n     * @property {number|null} [rankNew] RankUpdate rankNew\n     * @property {number|null} [numWins] RankUpdate numWins\n     * @property {number|null} [rankChange] RankUpdate rankChange\n     */\n\n    /**\n     * Constructs a new RankUpdate.\n     * @memberof CCSUsrMsg_ServerRankUpdate\n     * @classdesc Represents a RankUpdate.\n     * @implements IRankUpdate\n     * @constructor\n     * @param {CCSUsrMsg_ServerRankUpdate.IRankUpdate=} [properties] Properties to set\n     */\n    function RankUpdate(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * RankUpdate accountId.\n     * @member {number} accountId\n     * @memberof CCSUsrMsg_ServerRankUpdate.RankUpdate\n     * @instance\n     */\n\n\n    RankUpdate.prototype.accountId = 0;\n    /**\n     * RankUpdate rankOld.\n     * @member {number} rankOld\n     * @memberof CCSUsrMsg_ServerRankUpdate.RankUpdate\n     * @instance\n     */\n\n    RankUpdate.prototype.rankOld = 0;\n    /**\n     * RankUpdate rankNew.\n     * @member {number} rankNew\n     * @memberof CCSUsrMsg_ServerRankUpdate.RankUpdate\n     * @instance\n     */\n\n    RankUpdate.prototype.rankNew = 0;\n    /**\n     * RankUpdate numWins.\n     * @member {number} numWins\n     * @memberof CCSUsrMsg_ServerRankUpdate.RankUpdate\n     * @instance\n     */\n\n    RankUpdate.prototype.numWins = 0;\n    /**\n     * RankUpdate rankChange.\n     * @member {number} rankChange\n     * @memberof CCSUsrMsg_ServerRankUpdate.RankUpdate\n     * @instance\n     */\n\n    RankUpdate.prototype.rankChange = 0;\n    /**\n     * Decodes a RankUpdate message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_ServerRankUpdate.RankUpdate\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_ServerRankUpdate.RankUpdate} RankUpdate\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    RankUpdate.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CCSUsrMsg_ServerRankUpdate.RankUpdate();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.accountId = reader.int32();\n            break;\n\n          case 2:\n            message.rankOld = reader.int32();\n            break;\n\n          case 3:\n            message.rankNew = reader.int32();\n            break;\n\n          case 4:\n            message.numWins = reader.int32();\n            break;\n\n          case 5:\n            message.rankChange = reader.float();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return RankUpdate;\n  }();\n\n  return CCSUsrMsg_ServerRankUpdate;\n})();\n\nexports.CCSUsrMsg_XpUpdate = $root.CCSUsrMsg_XpUpdate = (() => {\n  /**\n   * Properties of a CCSUsrMsg_XpUpdate.\n   * @exports ICCSUsrMsg_XpUpdate\n   * @interface ICCSUsrMsg_XpUpdate\n   * @property {ICMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded|null} [data] CCSUsrMsg_XpUpdate data\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_XpUpdate.\n   * @exports CCSUsrMsg_XpUpdate\n   * @classdesc Represents a CCSUsrMsg_XpUpdate.\n   * @implements ICCSUsrMsg_XpUpdate\n   * @constructor\n   * @param {ICCSUsrMsg_XpUpdate=} [properties] Properties to set\n   */\n  function CCSUsrMsg_XpUpdate(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_XpUpdate data.\n   * @member {ICMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded|null|undefined} data\n   * @memberof CCSUsrMsg_XpUpdate\n   * @instance\n   */\n\n\n  CCSUsrMsg_XpUpdate.prototype.data = null;\n  /**\n   * Decodes a CCSUsrMsg_XpUpdate message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_XpUpdate\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_XpUpdate} CCSUsrMsg_XpUpdate\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_XpUpdate.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_XpUpdate();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.data = $root.CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_XpUpdate;\n})();\n\nexports.CCSUsrMsg_ItemPickup = $root.CCSUsrMsg_ItemPickup = (() => {\n  /**\n   * Properties of a CCSUsrMsg_ItemPickup.\n   * @exports ICCSUsrMsg_ItemPickup\n   * @interface ICCSUsrMsg_ItemPickup\n   * @property {string|null} [item] CCSUsrMsg_ItemPickup item\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_ItemPickup.\n   * @exports CCSUsrMsg_ItemPickup\n   * @classdesc Represents a CCSUsrMsg_ItemPickup.\n   * @implements ICCSUsrMsg_ItemPickup\n   * @constructor\n   * @param {ICCSUsrMsg_ItemPickup=} [properties] Properties to set\n   */\n  function CCSUsrMsg_ItemPickup(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_ItemPickup item.\n   * @member {string} item\n   * @memberof CCSUsrMsg_ItemPickup\n   * @instance\n   */\n\n\n  CCSUsrMsg_ItemPickup.prototype.item = \"\";\n  /**\n   * Decodes a CCSUsrMsg_ItemPickup message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_ItemPickup\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_ItemPickup} CCSUsrMsg_ItemPickup\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_ItemPickup.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_ItemPickup();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.item = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_ItemPickup;\n})();\n\nexports.CCSUsrMsg_ShowMenu = $root.CCSUsrMsg_ShowMenu = (() => {\n  /**\n   * Properties of a CCSUsrMsg_ShowMenu.\n   * @exports ICCSUsrMsg_ShowMenu\n   * @interface ICCSUsrMsg_ShowMenu\n   * @property {number|null} [bitsValidSlots] CCSUsrMsg_ShowMenu bitsValidSlots\n   * @property {number|null} [displayTime] CCSUsrMsg_ShowMenu displayTime\n   * @property {string|null} [menuString] CCSUsrMsg_ShowMenu menuString\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_ShowMenu.\n   * @exports CCSUsrMsg_ShowMenu\n   * @classdesc Represents a CCSUsrMsg_ShowMenu.\n   * @implements ICCSUsrMsg_ShowMenu\n   * @constructor\n   * @param {ICCSUsrMsg_ShowMenu=} [properties] Properties to set\n   */\n  function CCSUsrMsg_ShowMenu(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_ShowMenu bitsValidSlots.\n   * @member {number} bitsValidSlots\n   * @memberof CCSUsrMsg_ShowMenu\n   * @instance\n   */\n\n\n  CCSUsrMsg_ShowMenu.prototype.bitsValidSlots = 0;\n  /**\n   * CCSUsrMsg_ShowMenu displayTime.\n   * @member {number} displayTime\n   * @memberof CCSUsrMsg_ShowMenu\n   * @instance\n   */\n\n  CCSUsrMsg_ShowMenu.prototype.displayTime = 0;\n  /**\n   * CCSUsrMsg_ShowMenu menuString.\n   * @member {string} menuString\n   * @memberof CCSUsrMsg_ShowMenu\n   * @instance\n   */\n\n  CCSUsrMsg_ShowMenu.prototype.menuString = \"\";\n  /**\n   * Decodes a CCSUsrMsg_ShowMenu message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_ShowMenu\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_ShowMenu} CCSUsrMsg_ShowMenu\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_ShowMenu.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_ShowMenu();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.bitsValidSlots = reader.int32();\n          break;\n\n        case 2:\n          message.displayTime = reader.int32();\n          break;\n\n        case 3:\n          message.menuString = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_ShowMenu;\n})();\n\nexports.CCSUsrMsg_BarTime = $root.CCSUsrMsg_BarTime = (() => {\n  /**\n   * Properties of a CCSUsrMsg_BarTime.\n   * @exports ICCSUsrMsg_BarTime\n   * @interface ICCSUsrMsg_BarTime\n   * @property {string|null} [time] CCSUsrMsg_BarTime time\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_BarTime.\n   * @exports CCSUsrMsg_BarTime\n   * @classdesc Represents a CCSUsrMsg_BarTime.\n   * @implements ICCSUsrMsg_BarTime\n   * @constructor\n   * @param {ICCSUsrMsg_BarTime=} [properties] Properties to set\n   */\n  function CCSUsrMsg_BarTime(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_BarTime time.\n   * @member {string} time\n   * @memberof CCSUsrMsg_BarTime\n   * @instance\n   */\n\n\n  CCSUsrMsg_BarTime.prototype.time = \"\";\n  /**\n   * Decodes a CCSUsrMsg_BarTime message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_BarTime\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_BarTime} CCSUsrMsg_BarTime\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_BarTime.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_BarTime();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.time = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_BarTime;\n})();\n\nexports.CCSUsrMsg_AmmoDenied = $root.CCSUsrMsg_AmmoDenied = (() => {\n  /**\n   * Properties of a CCSUsrMsg_AmmoDenied.\n   * @exports ICCSUsrMsg_AmmoDenied\n   * @interface ICCSUsrMsg_AmmoDenied\n   * @property {number|null} [ammoIdx] CCSUsrMsg_AmmoDenied ammoIdx\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_AmmoDenied.\n   * @exports CCSUsrMsg_AmmoDenied\n   * @classdesc Represents a CCSUsrMsg_AmmoDenied.\n   * @implements ICCSUsrMsg_AmmoDenied\n   * @constructor\n   * @param {ICCSUsrMsg_AmmoDenied=} [properties] Properties to set\n   */\n  function CCSUsrMsg_AmmoDenied(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_AmmoDenied ammoIdx.\n   * @member {number} ammoIdx\n   * @memberof CCSUsrMsg_AmmoDenied\n   * @instance\n   */\n\n\n  CCSUsrMsg_AmmoDenied.prototype.ammoIdx = 0;\n  /**\n   * Decodes a CCSUsrMsg_AmmoDenied message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_AmmoDenied\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_AmmoDenied} CCSUsrMsg_AmmoDenied\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_AmmoDenied.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_AmmoDenied();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.ammoIdx = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_AmmoDenied;\n})();\n\nexports.CCSUsrMsg_MarkAchievement = $root.CCSUsrMsg_MarkAchievement = (() => {\n  /**\n   * Properties of a CCSUsrMsg_MarkAchievement.\n   * @exports ICCSUsrMsg_MarkAchievement\n   * @interface ICCSUsrMsg_MarkAchievement\n   * @property {string|null} [achievement] CCSUsrMsg_MarkAchievement achievement\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_MarkAchievement.\n   * @exports CCSUsrMsg_MarkAchievement\n   * @classdesc Represents a CCSUsrMsg_MarkAchievement.\n   * @implements ICCSUsrMsg_MarkAchievement\n   * @constructor\n   * @param {ICCSUsrMsg_MarkAchievement=} [properties] Properties to set\n   */\n  function CCSUsrMsg_MarkAchievement(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_MarkAchievement achievement.\n   * @member {string} achievement\n   * @memberof CCSUsrMsg_MarkAchievement\n   * @instance\n   */\n\n\n  CCSUsrMsg_MarkAchievement.prototype.achievement = \"\";\n  /**\n   * Decodes a CCSUsrMsg_MarkAchievement message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_MarkAchievement\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_MarkAchievement} CCSUsrMsg_MarkAchievement\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_MarkAchievement.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_MarkAchievement();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.achievement = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_MarkAchievement;\n})();\n\nexports.CCSUsrMsg_MatchStatsUpdate = $root.CCSUsrMsg_MatchStatsUpdate = (() => {\n  /**\n   * Properties of a CCSUsrMsg_MatchStatsUpdate.\n   * @exports ICCSUsrMsg_MatchStatsUpdate\n   * @interface ICCSUsrMsg_MatchStatsUpdate\n   * @property {string|null} [update] CCSUsrMsg_MatchStatsUpdate update\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_MatchStatsUpdate.\n   * @exports CCSUsrMsg_MatchStatsUpdate\n   * @classdesc Represents a CCSUsrMsg_MatchStatsUpdate.\n   * @implements ICCSUsrMsg_MatchStatsUpdate\n   * @constructor\n   * @param {ICCSUsrMsg_MatchStatsUpdate=} [properties] Properties to set\n   */\n  function CCSUsrMsg_MatchStatsUpdate(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_MatchStatsUpdate update.\n   * @member {string} update\n   * @memberof CCSUsrMsg_MatchStatsUpdate\n   * @instance\n   */\n\n\n  CCSUsrMsg_MatchStatsUpdate.prototype.update = \"\";\n  /**\n   * Decodes a CCSUsrMsg_MatchStatsUpdate message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_MatchStatsUpdate\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_MatchStatsUpdate} CCSUsrMsg_MatchStatsUpdate\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_MatchStatsUpdate.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_MatchStatsUpdate();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.update = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_MatchStatsUpdate;\n})();\n\nexports.CCSUsrMsg_ItemDrop = $root.CCSUsrMsg_ItemDrop = (() => {\n  /**\n   * Properties of a CCSUsrMsg_ItemDrop.\n   * @exports ICCSUsrMsg_ItemDrop\n   * @interface ICCSUsrMsg_ItemDrop\n   * @property {number|Long|null} [itemid] CCSUsrMsg_ItemDrop itemid\n   * @property {boolean|null} [death] CCSUsrMsg_ItemDrop death\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_ItemDrop.\n   * @exports CCSUsrMsg_ItemDrop\n   * @classdesc Represents a CCSUsrMsg_ItemDrop.\n   * @implements ICCSUsrMsg_ItemDrop\n   * @constructor\n   * @param {ICCSUsrMsg_ItemDrop=} [properties] Properties to set\n   */\n  function CCSUsrMsg_ItemDrop(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_ItemDrop itemid.\n   * @member {number|Long} itemid\n   * @memberof CCSUsrMsg_ItemDrop\n   * @instance\n   */\n\n\n  CCSUsrMsg_ItemDrop.prototype.itemid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n  /**\n   * CCSUsrMsg_ItemDrop death.\n   * @member {boolean} death\n   * @memberof CCSUsrMsg_ItemDrop\n   * @instance\n   */\n\n  CCSUsrMsg_ItemDrop.prototype.death = false;\n  /**\n   * Decodes a CCSUsrMsg_ItemDrop message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_ItemDrop\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_ItemDrop} CCSUsrMsg_ItemDrop\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_ItemDrop.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_ItemDrop();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.itemid = reader.int64();\n          break;\n\n        case 2:\n          message.death = reader.bool();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_ItemDrop;\n})();\n\nexports.CCSUsrMsg_GlowPropTurnOff = $root.CCSUsrMsg_GlowPropTurnOff = (() => {\n  /**\n   * Properties of a CCSUsrMsg_GlowPropTurnOff.\n   * @exports ICCSUsrMsg_GlowPropTurnOff\n   * @interface ICCSUsrMsg_GlowPropTurnOff\n   * @property {number|null} [entidx] CCSUsrMsg_GlowPropTurnOff entidx\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_GlowPropTurnOff.\n   * @exports CCSUsrMsg_GlowPropTurnOff\n   * @classdesc Represents a CCSUsrMsg_GlowPropTurnOff.\n   * @implements ICCSUsrMsg_GlowPropTurnOff\n   * @constructor\n   * @param {ICCSUsrMsg_GlowPropTurnOff=} [properties] Properties to set\n   */\n  function CCSUsrMsg_GlowPropTurnOff(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_GlowPropTurnOff entidx.\n   * @member {number} entidx\n   * @memberof CCSUsrMsg_GlowPropTurnOff\n   * @instance\n   */\n\n\n  CCSUsrMsg_GlowPropTurnOff.prototype.entidx = 0;\n  /**\n   * Decodes a CCSUsrMsg_GlowPropTurnOff message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_GlowPropTurnOff\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_GlowPropTurnOff} CCSUsrMsg_GlowPropTurnOff\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_GlowPropTurnOff.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_GlowPropTurnOff();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.entidx = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_GlowPropTurnOff;\n})();\n\nexports.CCSUsrMsg_RoundBackupFilenames = $root.CCSUsrMsg_RoundBackupFilenames = (() => {\n  /**\n   * Properties of a CCSUsrMsg_RoundBackupFilenames.\n   * @exports ICCSUsrMsg_RoundBackupFilenames\n   * @interface ICCSUsrMsg_RoundBackupFilenames\n   * @property {number|null} [count] CCSUsrMsg_RoundBackupFilenames count\n   * @property {number|null} [index] CCSUsrMsg_RoundBackupFilenames index\n   * @property {string|null} [filename] CCSUsrMsg_RoundBackupFilenames filename\n   * @property {string|null} [nicename] CCSUsrMsg_RoundBackupFilenames nicename\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_RoundBackupFilenames.\n   * @exports CCSUsrMsg_RoundBackupFilenames\n   * @classdesc Represents a CCSUsrMsg_RoundBackupFilenames.\n   * @implements ICCSUsrMsg_RoundBackupFilenames\n   * @constructor\n   * @param {ICCSUsrMsg_RoundBackupFilenames=} [properties] Properties to set\n   */\n  function CCSUsrMsg_RoundBackupFilenames(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_RoundBackupFilenames count.\n   * @member {number} count\n   * @memberof CCSUsrMsg_RoundBackupFilenames\n   * @instance\n   */\n\n\n  CCSUsrMsg_RoundBackupFilenames.prototype.count = 0;\n  /**\n   * CCSUsrMsg_RoundBackupFilenames index.\n   * @member {number} index\n   * @memberof CCSUsrMsg_RoundBackupFilenames\n   * @instance\n   */\n\n  CCSUsrMsg_RoundBackupFilenames.prototype.index = 0;\n  /**\n   * CCSUsrMsg_RoundBackupFilenames filename.\n   * @member {string} filename\n   * @memberof CCSUsrMsg_RoundBackupFilenames\n   * @instance\n   */\n\n  CCSUsrMsg_RoundBackupFilenames.prototype.filename = \"\";\n  /**\n   * CCSUsrMsg_RoundBackupFilenames nicename.\n   * @member {string} nicename\n   * @memberof CCSUsrMsg_RoundBackupFilenames\n   * @instance\n   */\n\n  CCSUsrMsg_RoundBackupFilenames.prototype.nicename = \"\";\n  /**\n   * Decodes a CCSUsrMsg_RoundBackupFilenames message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_RoundBackupFilenames\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_RoundBackupFilenames} CCSUsrMsg_RoundBackupFilenames\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_RoundBackupFilenames.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_RoundBackupFilenames();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.count = reader.int32();\n          break;\n\n        case 2:\n          message.index = reader.int32();\n          break;\n\n        case 3:\n          message.filename = reader.string();\n          break;\n\n        case 4:\n          message.nicename = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_RoundBackupFilenames;\n})();\n\nexports.CCSUsrMsg_ResetHud = $root.CCSUsrMsg_ResetHud = (() => {\n  /**\n   * Properties of a CCSUsrMsg_ResetHud.\n   * @exports ICCSUsrMsg_ResetHud\n   * @interface ICCSUsrMsg_ResetHud\n   * @property {boolean|null} [reset] CCSUsrMsg_ResetHud reset\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_ResetHud.\n   * @exports CCSUsrMsg_ResetHud\n   * @classdesc Represents a CCSUsrMsg_ResetHud.\n   * @implements ICCSUsrMsg_ResetHud\n   * @constructor\n   * @param {ICCSUsrMsg_ResetHud=} [properties] Properties to set\n   */\n  function CCSUsrMsg_ResetHud(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_ResetHud reset.\n   * @member {boolean} reset\n   * @memberof CCSUsrMsg_ResetHud\n   * @instance\n   */\n\n\n  CCSUsrMsg_ResetHud.prototype.reset = false;\n  /**\n   * Decodes a CCSUsrMsg_ResetHud message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_ResetHud\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_ResetHud} CCSUsrMsg_ResetHud\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_ResetHud.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_ResetHud();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.reset = reader.bool();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_ResetHud;\n})();\n\nexports.CCSUsrMsg_GameTitle = $root.CCSUsrMsg_GameTitle = (() => {\n  /**\n   * Properties of a CCSUsrMsg_GameTitle.\n   * @exports ICCSUsrMsg_GameTitle\n   * @interface ICCSUsrMsg_GameTitle\n   * @property {number|null} [dummy] CCSUsrMsg_GameTitle dummy\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_GameTitle.\n   * @exports CCSUsrMsg_GameTitle\n   * @classdesc Represents a CCSUsrMsg_GameTitle.\n   * @implements ICCSUsrMsg_GameTitle\n   * @constructor\n   * @param {ICCSUsrMsg_GameTitle=} [properties] Properties to set\n   */\n  function CCSUsrMsg_GameTitle(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_GameTitle dummy.\n   * @member {number} dummy\n   * @memberof CCSUsrMsg_GameTitle\n   * @instance\n   */\n\n\n  CCSUsrMsg_GameTitle.prototype.dummy = 0;\n  /**\n   * Decodes a CCSUsrMsg_GameTitle message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_GameTitle\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_GameTitle} CCSUsrMsg_GameTitle\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_GameTitle.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_GameTitle();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.dummy = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_GameTitle;\n})();\n\nexports.CCSUsrMsg_RequestState = $root.CCSUsrMsg_RequestState = (() => {\n  /**\n   * Properties of a CCSUsrMsg_RequestState.\n   * @exports ICCSUsrMsg_RequestState\n   * @interface ICCSUsrMsg_RequestState\n   * @property {number|null} [dummy] CCSUsrMsg_RequestState dummy\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_RequestState.\n   * @exports CCSUsrMsg_RequestState\n   * @classdesc Represents a CCSUsrMsg_RequestState.\n   * @implements ICCSUsrMsg_RequestState\n   * @constructor\n   * @param {ICCSUsrMsg_RequestState=} [properties] Properties to set\n   */\n  function CCSUsrMsg_RequestState(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_RequestState dummy.\n   * @member {number} dummy\n   * @memberof CCSUsrMsg_RequestState\n   * @instance\n   */\n\n\n  CCSUsrMsg_RequestState.prototype.dummy = 0;\n  /**\n   * Decodes a CCSUsrMsg_RequestState message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_RequestState\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_RequestState} CCSUsrMsg_RequestState\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_RequestState.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_RequestState();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.dummy = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_RequestState;\n})();\n\nexports.CCSUsrMsg_StopSpectatorMode = $root.CCSUsrMsg_StopSpectatorMode = (() => {\n  /**\n   * Properties of a CCSUsrMsg_StopSpectatorMode.\n   * @exports ICCSUsrMsg_StopSpectatorMode\n   * @interface ICCSUsrMsg_StopSpectatorMode\n   * @property {number|null} [dummy] CCSUsrMsg_StopSpectatorMode dummy\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_StopSpectatorMode.\n   * @exports CCSUsrMsg_StopSpectatorMode\n   * @classdesc Represents a CCSUsrMsg_StopSpectatorMode.\n   * @implements ICCSUsrMsg_StopSpectatorMode\n   * @constructor\n   * @param {ICCSUsrMsg_StopSpectatorMode=} [properties] Properties to set\n   */\n  function CCSUsrMsg_StopSpectatorMode(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_StopSpectatorMode dummy.\n   * @member {number} dummy\n   * @memberof CCSUsrMsg_StopSpectatorMode\n   * @instance\n   */\n\n\n  CCSUsrMsg_StopSpectatorMode.prototype.dummy = 0;\n  /**\n   * Decodes a CCSUsrMsg_StopSpectatorMode message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_StopSpectatorMode\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_StopSpectatorMode} CCSUsrMsg_StopSpectatorMode\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_StopSpectatorMode.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_StopSpectatorMode();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.dummy = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_StopSpectatorMode;\n})();\n\nexports.CCSUsrMsg_DisconnectToLobby = $root.CCSUsrMsg_DisconnectToLobby = (() => {\n  /**\n   * Properties of a CCSUsrMsg_DisconnectToLobby.\n   * @exports ICCSUsrMsg_DisconnectToLobby\n   * @interface ICCSUsrMsg_DisconnectToLobby\n   * @property {number|null} [dummy] CCSUsrMsg_DisconnectToLobby dummy\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_DisconnectToLobby.\n   * @exports CCSUsrMsg_DisconnectToLobby\n   * @classdesc Represents a CCSUsrMsg_DisconnectToLobby.\n   * @implements ICCSUsrMsg_DisconnectToLobby\n   * @constructor\n   * @param {ICCSUsrMsg_DisconnectToLobby=} [properties] Properties to set\n   */\n  function CCSUsrMsg_DisconnectToLobby(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_DisconnectToLobby dummy.\n   * @member {number} dummy\n   * @memberof CCSUsrMsg_DisconnectToLobby\n   * @instance\n   */\n\n\n  CCSUsrMsg_DisconnectToLobby.prototype.dummy = 0;\n  /**\n   * Decodes a CCSUsrMsg_DisconnectToLobby message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_DisconnectToLobby\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_DisconnectToLobby} CCSUsrMsg_DisconnectToLobby\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_DisconnectToLobby.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_DisconnectToLobby();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.dummy = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_DisconnectToLobby;\n})();\n\nexports.CCSUsrMsg_WarmupHasEnded = $root.CCSUsrMsg_WarmupHasEnded = (() => {\n  /**\n   * Properties of a CCSUsrMsg_WarmupHasEnded.\n   * @exports ICCSUsrMsg_WarmupHasEnded\n   * @interface ICCSUsrMsg_WarmupHasEnded\n   * @property {number|null} [dummy] CCSUsrMsg_WarmupHasEnded dummy\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_WarmupHasEnded.\n   * @exports CCSUsrMsg_WarmupHasEnded\n   * @classdesc Represents a CCSUsrMsg_WarmupHasEnded.\n   * @implements ICCSUsrMsg_WarmupHasEnded\n   * @constructor\n   * @param {ICCSUsrMsg_WarmupHasEnded=} [properties] Properties to set\n   */\n  function CCSUsrMsg_WarmupHasEnded(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_WarmupHasEnded dummy.\n   * @member {number} dummy\n   * @memberof CCSUsrMsg_WarmupHasEnded\n   * @instance\n   */\n\n\n  CCSUsrMsg_WarmupHasEnded.prototype.dummy = 0;\n  /**\n   * Decodes a CCSUsrMsg_WarmupHasEnded message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_WarmupHasEnded\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_WarmupHasEnded} CCSUsrMsg_WarmupHasEnded\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_WarmupHasEnded.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_WarmupHasEnded();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.dummy = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_WarmupHasEnded;\n})();\n\nexports.CCSUsrMsg_ClientInfo = $root.CCSUsrMsg_ClientInfo = (() => {\n  /**\n   * Properties of a CCSUsrMsg_ClientInfo.\n   * @exports ICCSUsrMsg_ClientInfo\n   * @interface ICCSUsrMsg_ClientInfo\n   * @property {number|null} [dummy] CCSUsrMsg_ClientInfo dummy\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_ClientInfo.\n   * @exports CCSUsrMsg_ClientInfo\n   * @classdesc Represents a CCSUsrMsg_ClientInfo.\n   * @implements ICCSUsrMsg_ClientInfo\n   * @constructor\n   * @param {ICCSUsrMsg_ClientInfo=} [properties] Properties to set\n   */\n  function CCSUsrMsg_ClientInfo(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_ClientInfo dummy.\n   * @member {number} dummy\n   * @memberof CCSUsrMsg_ClientInfo\n   * @instance\n   */\n\n\n  CCSUsrMsg_ClientInfo.prototype.dummy = 0;\n  /**\n   * Decodes a CCSUsrMsg_ClientInfo message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_ClientInfo\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_ClientInfo} CCSUsrMsg_ClientInfo\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_ClientInfo.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_ClientInfo();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.dummy = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_ClientInfo;\n})();\n\nexports.CCSUsrMsg_ServerRankRevealAll = $root.CCSUsrMsg_ServerRankRevealAll = (() => {\n  /**\n   * Properties of a CCSUsrMsg_ServerRankRevealAll.\n   * @exports ICCSUsrMsg_ServerRankRevealAll\n   * @interface ICCSUsrMsg_ServerRankRevealAll\n   * @property {number|null} [secondsTillShutdown] CCSUsrMsg_ServerRankRevealAll secondsTillShutdown\n   */\n\n  /**\n   * Constructs a new CCSUsrMsg_ServerRankRevealAll.\n   * @exports CCSUsrMsg_ServerRankRevealAll\n   * @classdesc Represents a CCSUsrMsg_ServerRankRevealAll.\n   * @implements ICCSUsrMsg_ServerRankRevealAll\n   * @constructor\n   * @param {ICCSUsrMsg_ServerRankRevealAll=} [properties] Properties to set\n   */\n  function CCSUsrMsg_ServerRankRevealAll(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCSUsrMsg_ServerRankRevealAll secondsTillShutdown.\n   * @member {number} secondsTillShutdown\n   * @memberof CCSUsrMsg_ServerRankRevealAll\n   * @instance\n   */\n\n\n  CCSUsrMsg_ServerRankRevealAll.prototype.secondsTillShutdown = 0;\n  /**\n   * Decodes a CCSUsrMsg_ServerRankRevealAll message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCSUsrMsg_ServerRankRevealAll\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCSUsrMsg_ServerRankRevealAll} CCSUsrMsg_ServerRankRevealAll\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCSUsrMsg_ServerRankRevealAll.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCSUsrMsg_ServerRankRevealAll();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.secondsTillShutdown = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCSUsrMsg_ServerRankRevealAll;\n})();\n\nexports.google = $root.google = (() => {\n  /**\n   * Namespace google.\n   * @exports google\n   * @namespace\n   */\n  const google = {};\n\n  google.protobuf = function () {\n    /**\n     * Namespace protobuf.\n     * @memberof google\n     * @namespace\n     */\n    const protobuf = {};\n\n    protobuf.FileDescriptorSet = function () {\n      /**\n       * Properties of a FileDescriptorSet.\n       * @memberof google.protobuf\n       * @interface IFileDescriptorSet\n       * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file\n       */\n\n      /**\n       * Constructs a new FileDescriptorSet.\n       * @memberof google.protobuf\n       * @classdesc Represents a FileDescriptorSet.\n       * @implements IFileDescriptorSet\n       * @constructor\n       * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set\n       */\n      function FileDescriptorSet(properties) {\n        this.file = [];\n        if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * FileDescriptorSet file.\n       * @member {Array.<google.protobuf.IFileDescriptorProto>} file\n       * @memberof google.protobuf.FileDescriptorSet\n       * @instance\n       */\n\n\n      FileDescriptorSet.prototype.file = $util.emptyArray;\n      /**\n       * Decodes a FileDescriptorSet message from the specified reader or buffer.\n       * @function decode\n       * @memberof google.protobuf.FileDescriptorSet\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n      FileDescriptorSet.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.google.protobuf.FileDescriptorSet();\n\n        while (reader.pos < end) {\n          let tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              if (!(message.file && message.file.length)) message.file = [];\n              message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n\n      return FileDescriptorSet;\n    }();\n\n    protobuf.FileDescriptorProto = function () {\n      /**\n       * Properties of a FileDescriptorProto.\n       * @memberof google.protobuf\n       * @interface IFileDescriptorProto\n       * @property {string|null} [name] FileDescriptorProto name\n       * @property {string|null} [\"package\"] FileDescriptorProto package\n       * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency\n       * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency\n       * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency\n       * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType\n       * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType\n       * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service\n       * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension\n       * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options\n       * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo\n       * @property {string|null} [syntax] FileDescriptorProto syntax\n       */\n\n      /**\n       * Constructs a new FileDescriptorProto.\n       * @memberof google.protobuf\n       * @classdesc Represents a FileDescriptorProto.\n       * @implements IFileDescriptorProto\n       * @constructor\n       * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set\n       */\n      function FileDescriptorProto(properties) {\n        this.dependency = [];\n        this.publicDependency = [];\n        this.weakDependency = [];\n        this.messageType = [];\n        this.enumType = [];\n        this.service = [];\n        this.extension = [];\n        if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * FileDescriptorProto name.\n       * @member {string} name\n       * @memberof google.protobuf.FileDescriptorProto\n       * @instance\n       */\n\n\n      FileDescriptorProto.prototype.name = \"\";\n      /**\n       * FileDescriptorProto package.\n       * @member {string} package\n       * @memberof google.protobuf.FileDescriptorProto\n       * @instance\n       */\n\n      FileDescriptorProto.prototype[\"package\"] = \"\";\n      /**\n       * FileDescriptorProto dependency.\n       * @member {Array.<string>} dependency\n       * @memberof google.protobuf.FileDescriptorProto\n       * @instance\n       */\n\n      FileDescriptorProto.prototype.dependency = $util.emptyArray;\n      /**\n       * FileDescriptorProto publicDependency.\n       * @member {Array.<number>} publicDependency\n       * @memberof google.protobuf.FileDescriptorProto\n       * @instance\n       */\n\n      FileDescriptorProto.prototype.publicDependency = $util.emptyArray;\n      /**\n       * FileDescriptorProto weakDependency.\n       * @member {Array.<number>} weakDependency\n       * @memberof google.protobuf.FileDescriptorProto\n       * @instance\n       */\n\n      FileDescriptorProto.prototype.weakDependency = $util.emptyArray;\n      /**\n       * FileDescriptorProto messageType.\n       * @member {Array.<google.protobuf.IDescriptorProto>} messageType\n       * @memberof google.protobuf.FileDescriptorProto\n       * @instance\n       */\n\n      FileDescriptorProto.prototype.messageType = $util.emptyArray;\n      /**\n       * FileDescriptorProto enumType.\n       * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType\n       * @memberof google.protobuf.FileDescriptorProto\n       * @instance\n       */\n\n      FileDescriptorProto.prototype.enumType = $util.emptyArray;\n      /**\n       * FileDescriptorProto service.\n       * @member {Array.<google.protobuf.IServiceDescriptorProto>} service\n       * @memberof google.protobuf.FileDescriptorProto\n       * @instance\n       */\n\n      FileDescriptorProto.prototype.service = $util.emptyArray;\n      /**\n       * FileDescriptorProto extension.\n       * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension\n       * @memberof google.protobuf.FileDescriptorProto\n       * @instance\n       */\n\n      FileDescriptorProto.prototype.extension = $util.emptyArray;\n      /**\n       * FileDescriptorProto options.\n       * @member {google.protobuf.IFileOptions|null|undefined} options\n       * @memberof google.protobuf.FileDescriptorProto\n       * @instance\n       */\n\n      FileDescriptorProto.prototype.options = null;\n      /**\n       * FileDescriptorProto sourceCodeInfo.\n       * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo\n       * @memberof google.protobuf.FileDescriptorProto\n       * @instance\n       */\n\n      FileDescriptorProto.prototype.sourceCodeInfo = null;\n      /**\n       * FileDescriptorProto syntax.\n       * @member {string} syntax\n       * @memberof google.protobuf.FileDescriptorProto\n       * @instance\n       */\n\n      FileDescriptorProto.prototype.syntax = \"\";\n      /**\n       * Decodes a FileDescriptorProto message from the specified reader or buffer.\n       * @function decode\n       * @memberof google.protobuf.FileDescriptorProto\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n      FileDescriptorProto.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.google.protobuf.FileDescriptorProto();\n\n        while (reader.pos < end) {\n          let tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.name = reader.string();\n              break;\n\n            case 2:\n              message[\"package\"] = reader.string();\n              break;\n\n            case 3:\n              if (!(message.dependency && message.dependency.length)) message.dependency = [];\n              message.dependency.push(reader.string());\n              break;\n\n            case 10:\n              if (!(message.publicDependency && message.publicDependency.length)) message.publicDependency = [];\n\n              if ((tag & 7) === 2) {\n                let end2 = reader.uint32() + reader.pos;\n\n                while (reader.pos < end2) message.publicDependency.push(reader.int32());\n              } else message.publicDependency.push(reader.int32());\n\n              break;\n\n            case 11:\n              if (!(message.weakDependency && message.weakDependency.length)) message.weakDependency = [];\n\n              if ((tag & 7) === 2) {\n                let end2 = reader.uint32() + reader.pos;\n\n                while (reader.pos < end2) message.weakDependency.push(reader.int32());\n              } else message.weakDependency.push(reader.int32());\n\n              break;\n\n            case 4:\n              if (!(message.messageType && message.messageType.length)) message.messageType = [];\n              message.messageType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));\n              break;\n\n            case 5:\n              if (!(message.enumType && message.enumType.length)) message.enumType = [];\n              message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));\n              break;\n\n            case 6:\n              if (!(message.service && message.service.length)) message.service = [];\n              message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));\n              break;\n\n            case 7:\n              if (!(message.extension && message.extension.length)) message.extension = [];\n              message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));\n              break;\n\n            case 8:\n              message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());\n              break;\n\n            case 9:\n              message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());\n              break;\n\n            case 12:\n              message.syntax = reader.string();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n\n      return FileDescriptorProto;\n    }();\n\n    protobuf.DescriptorProto = function () {\n      /**\n       * Properties of a DescriptorProto.\n       * @memberof google.protobuf\n       * @interface IDescriptorProto\n       * @property {string|null} [name] DescriptorProto name\n       * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field\n       * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension\n       * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType\n       * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType\n       * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange\n       * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl\n       * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options\n       * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange\n       * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName\n       */\n\n      /**\n       * Constructs a new DescriptorProto.\n       * @memberof google.protobuf\n       * @classdesc Represents a DescriptorProto.\n       * @implements IDescriptorProto\n       * @constructor\n       * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set\n       */\n      function DescriptorProto(properties) {\n        this.field = [];\n        this.extension = [];\n        this.nestedType = [];\n        this.enumType = [];\n        this.extensionRange = [];\n        this.oneofDecl = [];\n        this.reservedRange = [];\n        this.reservedName = [];\n        if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * DescriptorProto name.\n       * @member {string} name\n       * @memberof google.protobuf.DescriptorProto\n       * @instance\n       */\n\n\n      DescriptorProto.prototype.name = \"\";\n      /**\n       * DescriptorProto field.\n       * @member {Array.<google.protobuf.IFieldDescriptorProto>} field\n       * @memberof google.protobuf.DescriptorProto\n       * @instance\n       */\n\n      DescriptorProto.prototype.field = $util.emptyArray;\n      /**\n       * DescriptorProto extension.\n       * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension\n       * @memberof google.protobuf.DescriptorProto\n       * @instance\n       */\n\n      DescriptorProto.prototype.extension = $util.emptyArray;\n      /**\n       * DescriptorProto nestedType.\n       * @member {Array.<google.protobuf.IDescriptorProto>} nestedType\n       * @memberof google.protobuf.DescriptorProto\n       * @instance\n       */\n\n      DescriptorProto.prototype.nestedType = $util.emptyArray;\n      /**\n       * DescriptorProto enumType.\n       * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType\n       * @memberof google.protobuf.DescriptorProto\n       * @instance\n       */\n\n      DescriptorProto.prototype.enumType = $util.emptyArray;\n      /**\n       * DescriptorProto extensionRange.\n       * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange\n       * @memberof google.protobuf.DescriptorProto\n       * @instance\n       */\n\n      DescriptorProto.prototype.extensionRange = $util.emptyArray;\n      /**\n       * DescriptorProto oneofDecl.\n       * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl\n       * @memberof google.protobuf.DescriptorProto\n       * @instance\n       */\n\n      DescriptorProto.prototype.oneofDecl = $util.emptyArray;\n      /**\n       * DescriptorProto options.\n       * @member {google.protobuf.IMessageOptions|null|undefined} options\n       * @memberof google.protobuf.DescriptorProto\n       * @instance\n       */\n\n      DescriptorProto.prototype.options = null;\n      /**\n       * DescriptorProto reservedRange.\n       * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange\n       * @memberof google.protobuf.DescriptorProto\n       * @instance\n       */\n\n      DescriptorProto.prototype.reservedRange = $util.emptyArray;\n      /**\n       * DescriptorProto reservedName.\n       * @member {Array.<string>} reservedName\n       * @memberof google.protobuf.DescriptorProto\n       * @instance\n       */\n\n      DescriptorProto.prototype.reservedName = $util.emptyArray;\n      /**\n       * Decodes a DescriptorProto message from the specified reader or buffer.\n       * @function decode\n       * @memberof google.protobuf.DescriptorProto\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {google.protobuf.DescriptorProto} DescriptorProto\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n      DescriptorProto.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.google.protobuf.DescriptorProto();\n\n        while (reader.pos < end) {\n          let tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.name = reader.string();\n              break;\n\n            case 2:\n              if (!(message.field && message.field.length)) message.field = [];\n              message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));\n              break;\n\n            case 6:\n              if (!(message.extension && message.extension.length)) message.extension = [];\n              message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));\n              break;\n\n            case 3:\n              if (!(message.nestedType && message.nestedType.length)) message.nestedType = [];\n              message.nestedType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));\n              break;\n\n            case 4:\n              if (!(message.enumType && message.enumType.length)) message.enumType = [];\n              message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));\n              break;\n\n            case 5:\n              if (!(message.extensionRange && message.extensionRange.length)) message.extensionRange = [];\n              message.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));\n              break;\n\n            case 8:\n              if (!(message.oneofDecl && message.oneofDecl.length)) message.oneofDecl = [];\n              message.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));\n              break;\n\n            case 7:\n              message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());\n              break;\n\n            case 9:\n              if (!(message.reservedRange && message.reservedRange.length)) message.reservedRange = [];\n              message.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));\n              break;\n\n            case 10:\n              if (!(message.reservedName && message.reservedName.length)) message.reservedName = [];\n              message.reservedName.push(reader.string());\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n\n      DescriptorProto.ExtensionRange = function () {\n        /**\n         * Properties of an ExtensionRange.\n         * @memberof google.protobuf.DescriptorProto\n         * @interface IExtensionRange\n         * @property {number|null} [start] ExtensionRange start\n         * @property {number|null} [end] ExtensionRange end\n         */\n\n        /**\n         * Constructs a new ExtensionRange.\n         * @memberof google.protobuf.DescriptorProto\n         * @classdesc Represents an ExtensionRange.\n         * @implements IExtensionRange\n         * @constructor\n         * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set\n         */\n        function ExtensionRange(properties) {\n          if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * ExtensionRange start.\n         * @member {number} start\n         * @memberof google.protobuf.DescriptorProto.ExtensionRange\n         * @instance\n         */\n\n\n        ExtensionRange.prototype.start = 0;\n        /**\n         * ExtensionRange end.\n         * @member {number} end\n         * @memberof google.protobuf.DescriptorProto.ExtensionRange\n         * @instance\n         */\n\n        ExtensionRange.prototype.end = 0;\n        /**\n         * Decodes an ExtensionRange message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.DescriptorProto.ExtensionRange\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n        ExtensionRange.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          let end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.DescriptorProto.ExtensionRange();\n\n          while (reader.pos < end) {\n            let tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.start = reader.int32();\n                break;\n\n              case 2:\n                message.end = reader.int32();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n\n        return ExtensionRange;\n      }();\n\n      DescriptorProto.ReservedRange = function () {\n        /**\n         * Properties of a ReservedRange.\n         * @memberof google.protobuf.DescriptorProto\n         * @interface IReservedRange\n         * @property {number|null} [start] ReservedRange start\n         * @property {number|null} [end] ReservedRange end\n         */\n\n        /**\n         * Constructs a new ReservedRange.\n         * @memberof google.protobuf.DescriptorProto\n         * @classdesc Represents a ReservedRange.\n         * @implements IReservedRange\n         * @constructor\n         * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set\n         */\n        function ReservedRange(properties) {\n          if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * ReservedRange start.\n         * @member {number} start\n         * @memberof google.protobuf.DescriptorProto.ReservedRange\n         * @instance\n         */\n\n\n        ReservedRange.prototype.start = 0;\n        /**\n         * ReservedRange end.\n         * @member {number} end\n         * @memberof google.protobuf.DescriptorProto.ReservedRange\n         * @instance\n         */\n\n        ReservedRange.prototype.end = 0;\n        /**\n         * Decodes a ReservedRange message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.DescriptorProto.ReservedRange\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n        ReservedRange.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          let end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.DescriptorProto.ReservedRange();\n\n          while (reader.pos < end) {\n            let tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.start = reader.int32();\n                break;\n\n              case 2:\n                message.end = reader.int32();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n\n        return ReservedRange;\n      }();\n\n      return DescriptorProto;\n    }();\n\n    protobuf.FieldDescriptorProto = function () {\n      /**\n       * Properties of a FieldDescriptorProto.\n       * @memberof google.protobuf\n       * @interface IFieldDescriptorProto\n       * @property {string|null} [name] FieldDescriptorProto name\n       * @property {number|null} [number] FieldDescriptorProto number\n       * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label\n       * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type\n       * @property {string|null} [typeName] FieldDescriptorProto typeName\n       * @property {string|null} [extendee] FieldDescriptorProto extendee\n       * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue\n       * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex\n       * @property {string|null} [jsonName] FieldDescriptorProto jsonName\n       * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options\n       */\n\n      /**\n       * Constructs a new FieldDescriptorProto.\n       * @memberof google.protobuf\n       * @classdesc Represents a FieldDescriptorProto.\n       * @implements IFieldDescriptorProto\n       * @constructor\n       * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set\n       */\n      function FieldDescriptorProto(properties) {\n        if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * FieldDescriptorProto name.\n       * @member {string} name\n       * @memberof google.protobuf.FieldDescriptorProto\n       * @instance\n       */\n\n\n      FieldDescriptorProto.prototype.name = \"\";\n      /**\n       * FieldDescriptorProto number.\n       * @member {number} number\n       * @memberof google.protobuf.FieldDescriptorProto\n       * @instance\n       */\n\n      FieldDescriptorProto.prototype.number = 0;\n      /**\n       * FieldDescriptorProto label.\n       * @member {google.protobuf.FieldDescriptorProto.Label} label\n       * @memberof google.protobuf.FieldDescriptorProto\n       * @instance\n       */\n\n      FieldDescriptorProto.prototype.label = 1;\n      /**\n       * FieldDescriptorProto type.\n       * @member {google.protobuf.FieldDescriptorProto.Type} type\n       * @memberof google.protobuf.FieldDescriptorProto\n       * @instance\n       */\n\n      FieldDescriptorProto.prototype.type = 1;\n      /**\n       * FieldDescriptorProto typeName.\n       * @member {string} typeName\n       * @memberof google.protobuf.FieldDescriptorProto\n       * @instance\n       */\n\n      FieldDescriptorProto.prototype.typeName = \"\";\n      /**\n       * FieldDescriptorProto extendee.\n       * @member {string} extendee\n       * @memberof google.protobuf.FieldDescriptorProto\n       * @instance\n       */\n\n      FieldDescriptorProto.prototype.extendee = \"\";\n      /**\n       * FieldDescriptorProto defaultValue.\n       * @member {string} defaultValue\n       * @memberof google.protobuf.FieldDescriptorProto\n       * @instance\n       */\n\n      FieldDescriptorProto.prototype.defaultValue = \"\";\n      /**\n       * FieldDescriptorProto oneofIndex.\n       * @member {number} oneofIndex\n       * @memberof google.protobuf.FieldDescriptorProto\n       * @instance\n       */\n\n      FieldDescriptorProto.prototype.oneofIndex = 0;\n      /**\n       * FieldDescriptorProto jsonName.\n       * @member {string} jsonName\n       * @memberof google.protobuf.FieldDescriptorProto\n       * @instance\n       */\n\n      FieldDescriptorProto.prototype.jsonName = \"\";\n      /**\n       * FieldDescriptorProto options.\n       * @member {google.protobuf.IFieldOptions|null|undefined} options\n       * @memberof google.protobuf.FieldDescriptorProto\n       * @instance\n       */\n\n      FieldDescriptorProto.prototype.options = null;\n      /**\n       * Decodes a FieldDescriptorProto message from the specified reader or buffer.\n       * @function decode\n       * @memberof google.protobuf.FieldDescriptorProto\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n      FieldDescriptorProto.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.google.protobuf.FieldDescriptorProto();\n\n        while (reader.pos < end) {\n          let tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.name = reader.string();\n              break;\n\n            case 3:\n              message.number = reader.int32();\n              break;\n\n            case 4:\n              message.label = reader.int32();\n              break;\n\n            case 5:\n              message.type = reader.int32();\n              break;\n\n            case 6:\n              message.typeName = reader.string();\n              break;\n\n            case 2:\n              message.extendee = reader.string();\n              break;\n\n            case 7:\n              message.defaultValue = reader.string();\n              break;\n\n            case 9:\n              message.oneofIndex = reader.int32();\n              break;\n\n            case 10:\n              message.jsonName = reader.string();\n              break;\n\n            case 8:\n              message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n      /**\n       * Type enum.\n       * @name google.protobuf.FieldDescriptorProto.Type\n       * @enum {string}\n       * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value\n       * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value\n       * @property {number} TYPE_INT64=3 TYPE_INT64 value\n       * @property {number} TYPE_UINT64=4 TYPE_UINT64 value\n       * @property {number} TYPE_INT32=5 TYPE_INT32 value\n       * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value\n       * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value\n       * @property {number} TYPE_BOOL=8 TYPE_BOOL value\n       * @property {number} TYPE_STRING=9 TYPE_STRING value\n       * @property {number} TYPE_GROUP=10 TYPE_GROUP value\n       * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value\n       * @property {number} TYPE_BYTES=12 TYPE_BYTES value\n       * @property {number} TYPE_UINT32=13 TYPE_UINT32 value\n       * @property {number} TYPE_ENUM=14 TYPE_ENUM value\n       * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value\n       * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value\n       * @property {number} TYPE_SINT32=17 TYPE_SINT32 value\n       * @property {number} TYPE_SINT64=18 TYPE_SINT64 value\n       */\n\n\n      FieldDescriptorProto.Type = function () {\n        const valuesById = {},\n              values = Object.create(valuesById);\n        values[valuesById[1] = \"TYPE_DOUBLE\"] = 1;\n        values[valuesById[2] = \"TYPE_FLOAT\"] = 2;\n        values[valuesById[3] = \"TYPE_INT64\"] = 3;\n        values[valuesById[4] = \"TYPE_UINT64\"] = 4;\n        values[valuesById[5] = \"TYPE_INT32\"] = 5;\n        values[valuesById[6] = \"TYPE_FIXED64\"] = 6;\n        values[valuesById[7] = \"TYPE_FIXED32\"] = 7;\n        values[valuesById[8] = \"TYPE_BOOL\"] = 8;\n        values[valuesById[9] = \"TYPE_STRING\"] = 9;\n        values[valuesById[10] = \"TYPE_GROUP\"] = 10;\n        values[valuesById[11] = \"TYPE_MESSAGE\"] = 11;\n        values[valuesById[12] = \"TYPE_BYTES\"] = 12;\n        values[valuesById[13] = \"TYPE_UINT32\"] = 13;\n        values[valuesById[14] = \"TYPE_ENUM\"] = 14;\n        values[valuesById[15] = \"TYPE_SFIXED32\"] = 15;\n        values[valuesById[16] = \"TYPE_SFIXED64\"] = 16;\n        values[valuesById[17] = \"TYPE_SINT32\"] = 17;\n        values[valuesById[18] = \"TYPE_SINT64\"] = 18;\n        return values;\n      }();\n      /**\n       * Label enum.\n       * @name google.protobuf.FieldDescriptorProto.Label\n       * @enum {string}\n       * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value\n       * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value\n       * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value\n       */\n\n\n      FieldDescriptorProto.Label = function () {\n        const valuesById = {},\n              values = Object.create(valuesById);\n        values[valuesById[1] = \"LABEL_OPTIONAL\"] = 1;\n        values[valuesById[2] = \"LABEL_REQUIRED\"] = 2;\n        values[valuesById[3] = \"LABEL_REPEATED\"] = 3;\n        return values;\n      }();\n\n      return FieldDescriptorProto;\n    }();\n\n    protobuf.OneofDescriptorProto = function () {\n      /**\n       * Properties of an OneofDescriptorProto.\n       * @memberof google.protobuf\n       * @interface IOneofDescriptorProto\n       * @property {string|null} [name] OneofDescriptorProto name\n       * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options\n       */\n\n      /**\n       * Constructs a new OneofDescriptorProto.\n       * @memberof google.protobuf\n       * @classdesc Represents an OneofDescriptorProto.\n       * @implements IOneofDescriptorProto\n       * @constructor\n       * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set\n       */\n      function OneofDescriptorProto(properties) {\n        if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * OneofDescriptorProto name.\n       * @member {string} name\n       * @memberof google.protobuf.OneofDescriptorProto\n       * @instance\n       */\n\n\n      OneofDescriptorProto.prototype.name = \"\";\n      /**\n       * OneofDescriptorProto options.\n       * @member {google.protobuf.IOneofOptions|null|undefined} options\n       * @memberof google.protobuf.OneofDescriptorProto\n       * @instance\n       */\n\n      OneofDescriptorProto.prototype.options = null;\n      /**\n       * Decodes an OneofDescriptorProto message from the specified reader or buffer.\n       * @function decode\n       * @memberof google.protobuf.OneofDescriptorProto\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n      OneofDescriptorProto.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.google.protobuf.OneofDescriptorProto();\n\n        while (reader.pos < end) {\n          let tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.name = reader.string();\n              break;\n\n            case 2:\n              message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n\n      return OneofDescriptorProto;\n    }();\n\n    protobuf.EnumDescriptorProto = function () {\n      /**\n       * Properties of an EnumDescriptorProto.\n       * @memberof google.protobuf\n       * @interface IEnumDescriptorProto\n       * @property {string|null} [name] EnumDescriptorProto name\n       * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value\n       * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options\n       */\n\n      /**\n       * Constructs a new EnumDescriptorProto.\n       * @memberof google.protobuf\n       * @classdesc Represents an EnumDescriptorProto.\n       * @implements IEnumDescriptorProto\n       * @constructor\n       * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set\n       */\n      function EnumDescriptorProto(properties) {\n        this.value = [];\n        if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * EnumDescriptorProto name.\n       * @member {string} name\n       * @memberof google.protobuf.EnumDescriptorProto\n       * @instance\n       */\n\n\n      EnumDescriptorProto.prototype.name = \"\";\n      /**\n       * EnumDescriptorProto value.\n       * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value\n       * @memberof google.protobuf.EnumDescriptorProto\n       * @instance\n       */\n\n      EnumDescriptorProto.prototype.value = $util.emptyArray;\n      /**\n       * EnumDescriptorProto options.\n       * @member {google.protobuf.IEnumOptions|null|undefined} options\n       * @memberof google.protobuf.EnumDescriptorProto\n       * @instance\n       */\n\n      EnumDescriptorProto.prototype.options = null;\n      /**\n       * Decodes an EnumDescriptorProto message from the specified reader or buffer.\n       * @function decode\n       * @memberof google.protobuf.EnumDescriptorProto\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n      EnumDescriptorProto.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.google.protobuf.EnumDescriptorProto();\n\n        while (reader.pos < end) {\n          let tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.name = reader.string();\n              break;\n\n            case 2:\n              if (!(message.value && message.value.length)) message.value = [];\n              message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));\n              break;\n\n            case 3:\n              message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n\n      return EnumDescriptorProto;\n    }();\n\n    protobuf.EnumValueDescriptorProto = function () {\n      /**\n       * Properties of an EnumValueDescriptorProto.\n       * @memberof google.protobuf\n       * @interface IEnumValueDescriptorProto\n       * @property {string|null} [name] EnumValueDescriptorProto name\n       * @property {number|null} [number] EnumValueDescriptorProto number\n       * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options\n       */\n\n      /**\n       * Constructs a new EnumValueDescriptorProto.\n       * @memberof google.protobuf\n       * @classdesc Represents an EnumValueDescriptorProto.\n       * @implements IEnumValueDescriptorProto\n       * @constructor\n       * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set\n       */\n      function EnumValueDescriptorProto(properties) {\n        if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * EnumValueDescriptorProto name.\n       * @member {string} name\n       * @memberof google.protobuf.EnumValueDescriptorProto\n       * @instance\n       */\n\n\n      EnumValueDescriptorProto.prototype.name = \"\";\n      /**\n       * EnumValueDescriptorProto number.\n       * @member {number} number\n       * @memberof google.protobuf.EnumValueDescriptorProto\n       * @instance\n       */\n\n      EnumValueDescriptorProto.prototype.number = 0;\n      /**\n       * EnumValueDescriptorProto options.\n       * @member {google.protobuf.IEnumValueOptions|null|undefined} options\n       * @memberof google.protobuf.EnumValueDescriptorProto\n       * @instance\n       */\n\n      EnumValueDescriptorProto.prototype.options = null;\n      /**\n       * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.\n       * @function decode\n       * @memberof google.protobuf.EnumValueDescriptorProto\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n      EnumValueDescriptorProto.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.google.protobuf.EnumValueDescriptorProto();\n\n        while (reader.pos < end) {\n          let tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.name = reader.string();\n              break;\n\n            case 2:\n              message.number = reader.int32();\n              break;\n\n            case 3:\n              message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n\n      return EnumValueDescriptorProto;\n    }();\n\n    protobuf.ServiceDescriptorProto = function () {\n      /**\n       * Properties of a ServiceDescriptorProto.\n       * @memberof google.protobuf\n       * @interface IServiceDescriptorProto\n       * @property {string|null} [name] ServiceDescriptorProto name\n       * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method\n       * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options\n       */\n\n      /**\n       * Constructs a new ServiceDescriptorProto.\n       * @memberof google.protobuf\n       * @classdesc Represents a ServiceDescriptorProto.\n       * @implements IServiceDescriptorProto\n       * @constructor\n       * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set\n       */\n      function ServiceDescriptorProto(properties) {\n        this.method = [];\n        if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * ServiceDescriptorProto name.\n       * @member {string} name\n       * @memberof google.protobuf.ServiceDescriptorProto\n       * @instance\n       */\n\n\n      ServiceDescriptorProto.prototype.name = \"\";\n      /**\n       * ServiceDescriptorProto method.\n       * @member {Array.<google.protobuf.IMethodDescriptorProto>} method\n       * @memberof google.protobuf.ServiceDescriptorProto\n       * @instance\n       */\n\n      ServiceDescriptorProto.prototype.method = $util.emptyArray;\n      /**\n       * ServiceDescriptorProto options.\n       * @member {google.protobuf.IServiceOptions|null|undefined} options\n       * @memberof google.protobuf.ServiceDescriptorProto\n       * @instance\n       */\n\n      ServiceDescriptorProto.prototype.options = null;\n      /**\n       * Decodes a ServiceDescriptorProto message from the specified reader or buffer.\n       * @function decode\n       * @memberof google.protobuf.ServiceDescriptorProto\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n      ServiceDescriptorProto.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.google.protobuf.ServiceDescriptorProto();\n\n        while (reader.pos < end) {\n          let tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.name = reader.string();\n              break;\n\n            case 2:\n              if (!(message.method && message.method.length)) message.method = [];\n              message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));\n              break;\n\n            case 3:\n              message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n\n      return ServiceDescriptorProto;\n    }();\n\n    protobuf.MethodDescriptorProto = function () {\n      /**\n       * Properties of a MethodDescriptorProto.\n       * @memberof google.protobuf\n       * @interface IMethodDescriptorProto\n       * @property {string|null} [name] MethodDescriptorProto name\n       * @property {string|null} [inputType] MethodDescriptorProto inputType\n       * @property {string|null} [outputType] MethodDescriptorProto outputType\n       * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options\n       * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming\n       * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming\n       */\n\n      /**\n       * Constructs a new MethodDescriptorProto.\n       * @memberof google.protobuf\n       * @classdesc Represents a MethodDescriptorProto.\n       * @implements IMethodDescriptorProto\n       * @constructor\n       * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set\n       */\n      function MethodDescriptorProto(properties) {\n        if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * MethodDescriptorProto name.\n       * @member {string} name\n       * @memberof google.protobuf.MethodDescriptorProto\n       * @instance\n       */\n\n\n      MethodDescriptorProto.prototype.name = \"\";\n      /**\n       * MethodDescriptorProto inputType.\n       * @member {string} inputType\n       * @memberof google.protobuf.MethodDescriptorProto\n       * @instance\n       */\n\n      MethodDescriptorProto.prototype.inputType = \"\";\n      /**\n       * MethodDescriptorProto outputType.\n       * @member {string} outputType\n       * @memberof google.protobuf.MethodDescriptorProto\n       * @instance\n       */\n\n      MethodDescriptorProto.prototype.outputType = \"\";\n      /**\n       * MethodDescriptorProto options.\n       * @member {google.protobuf.IMethodOptions|null|undefined} options\n       * @memberof google.protobuf.MethodDescriptorProto\n       * @instance\n       */\n\n      MethodDescriptorProto.prototype.options = null;\n      /**\n       * MethodDescriptorProto clientStreaming.\n       * @member {boolean} clientStreaming\n       * @memberof google.protobuf.MethodDescriptorProto\n       * @instance\n       */\n\n      MethodDescriptorProto.prototype.clientStreaming = false;\n      /**\n       * MethodDescriptorProto serverStreaming.\n       * @member {boolean} serverStreaming\n       * @memberof google.protobuf.MethodDescriptorProto\n       * @instance\n       */\n\n      MethodDescriptorProto.prototype.serverStreaming = false;\n      /**\n       * Decodes a MethodDescriptorProto message from the specified reader or buffer.\n       * @function decode\n       * @memberof google.protobuf.MethodDescriptorProto\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n      MethodDescriptorProto.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.google.protobuf.MethodDescriptorProto();\n\n        while (reader.pos < end) {\n          let tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.name = reader.string();\n              break;\n\n            case 2:\n              message.inputType = reader.string();\n              break;\n\n            case 3:\n              message.outputType = reader.string();\n              break;\n\n            case 4:\n              message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());\n              break;\n\n            case 5:\n              message.clientStreaming = reader.bool();\n              break;\n\n            case 6:\n              message.serverStreaming = reader.bool();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n\n      return MethodDescriptorProto;\n    }();\n\n    protobuf.FileOptions = function () {\n      /**\n       * Properties of a FileOptions.\n       * @memberof google.protobuf\n       * @interface IFileOptions\n       * @property {string|null} [javaPackage] FileOptions javaPackage\n       * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname\n       * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles\n       * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash\n       * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8\n       * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor\n       * @property {string|null} [goPackage] FileOptions goPackage\n       * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices\n       * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices\n       * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices\n       * @property {boolean|null} [deprecated] FileOptions deprecated\n       * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas\n       * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix\n       * @property {string|null} [csharpNamespace] FileOptions csharpNamespace\n       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption\n       */\n\n      /**\n       * Constructs a new FileOptions.\n       * @memberof google.protobuf\n       * @classdesc Represents a FileOptions.\n       * @implements IFileOptions\n       * @constructor\n       * @param {google.protobuf.IFileOptions=} [properties] Properties to set\n       */\n      function FileOptions(properties) {\n        this.uninterpretedOption = [];\n        if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * FileOptions javaPackage.\n       * @member {string} javaPackage\n       * @memberof google.protobuf.FileOptions\n       * @instance\n       */\n\n\n      FileOptions.prototype.javaPackage = \"\";\n      /**\n       * FileOptions javaOuterClassname.\n       * @member {string} javaOuterClassname\n       * @memberof google.protobuf.FileOptions\n       * @instance\n       */\n\n      FileOptions.prototype.javaOuterClassname = \"\";\n      /**\n       * FileOptions javaMultipleFiles.\n       * @member {boolean} javaMultipleFiles\n       * @memberof google.protobuf.FileOptions\n       * @instance\n       */\n\n      FileOptions.prototype.javaMultipleFiles = false;\n      /**\n       * FileOptions javaGenerateEqualsAndHash.\n       * @member {boolean} javaGenerateEqualsAndHash\n       * @memberof google.protobuf.FileOptions\n       * @instance\n       */\n\n      FileOptions.prototype.javaGenerateEqualsAndHash = false;\n      /**\n       * FileOptions javaStringCheckUtf8.\n       * @member {boolean} javaStringCheckUtf8\n       * @memberof google.protobuf.FileOptions\n       * @instance\n       */\n\n      FileOptions.prototype.javaStringCheckUtf8 = false;\n      /**\n       * FileOptions optimizeFor.\n       * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor\n       * @memberof google.protobuf.FileOptions\n       * @instance\n       */\n\n      FileOptions.prototype.optimizeFor = 1;\n      /**\n       * FileOptions goPackage.\n       * @member {string} goPackage\n       * @memberof google.protobuf.FileOptions\n       * @instance\n       */\n\n      FileOptions.prototype.goPackage = \"\";\n      /**\n       * FileOptions ccGenericServices.\n       * @member {boolean} ccGenericServices\n       * @memberof google.protobuf.FileOptions\n       * @instance\n       */\n\n      FileOptions.prototype.ccGenericServices = false;\n      /**\n       * FileOptions javaGenericServices.\n       * @member {boolean} javaGenericServices\n       * @memberof google.protobuf.FileOptions\n       * @instance\n       */\n\n      FileOptions.prototype.javaGenericServices = false;\n      /**\n       * FileOptions pyGenericServices.\n       * @member {boolean} pyGenericServices\n       * @memberof google.protobuf.FileOptions\n       * @instance\n       */\n\n      FileOptions.prototype.pyGenericServices = false;\n      /**\n       * FileOptions deprecated.\n       * @member {boolean} deprecated\n       * @memberof google.protobuf.FileOptions\n       * @instance\n       */\n\n      FileOptions.prototype.deprecated = false;\n      /**\n       * FileOptions ccEnableArenas.\n       * @member {boolean} ccEnableArenas\n       * @memberof google.protobuf.FileOptions\n       * @instance\n       */\n\n      FileOptions.prototype.ccEnableArenas = false;\n      /**\n       * FileOptions objcClassPrefix.\n       * @member {string} objcClassPrefix\n       * @memberof google.protobuf.FileOptions\n       * @instance\n       */\n\n      FileOptions.prototype.objcClassPrefix = \"\";\n      /**\n       * FileOptions csharpNamespace.\n       * @member {string} csharpNamespace\n       * @memberof google.protobuf.FileOptions\n       * @instance\n       */\n\n      FileOptions.prototype.csharpNamespace = \"\";\n      /**\n       * FileOptions uninterpretedOption.\n       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n       * @memberof google.protobuf.FileOptions\n       * @instance\n       */\n\n      FileOptions.prototype.uninterpretedOption = $util.emptyArray;\n      /**\n       * Decodes a FileOptions message from the specified reader or buffer.\n       * @function decode\n       * @memberof google.protobuf.FileOptions\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {google.protobuf.FileOptions} FileOptions\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n      FileOptions.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.google.protobuf.FileOptions();\n\n        while (reader.pos < end) {\n          let tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.javaPackage = reader.string();\n              break;\n\n            case 8:\n              message.javaOuterClassname = reader.string();\n              break;\n\n            case 10:\n              message.javaMultipleFiles = reader.bool();\n              break;\n\n            case 20:\n              message.javaGenerateEqualsAndHash = reader.bool();\n              break;\n\n            case 27:\n              message.javaStringCheckUtf8 = reader.bool();\n              break;\n\n            case 9:\n              message.optimizeFor = reader.int32();\n              break;\n\n            case 11:\n              message.goPackage = reader.string();\n              break;\n\n            case 16:\n              message.ccGenericServices = reader.bool();\n              break;\n\n            case 17:\n              message.javaGenericServices = reader.bool();\n              break;\n\n            case 18:\n              message.pyGenericServices = reader.bool();\n              break;\n\n            case 23:\n              message.deprecated = reader.bool();\n              break;\n\n            case 31:\n              message.ccEnableArenas = reader.bool();\n              break;\n\n            case 36:\n              message.objcClassPrefix = reader.string();\n              break;\n\n            case 37:\n              message.csharpNamespace = reader.string();\n              break;\n\n            case 999:\n              if (!(message.uninterpretedOption && message.uninterpretedOption.length)) message.uninterpretedOption = [];\n              message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n      /**\n       * OptimizeMode enum.\n       * @name google.protobuf.FileOptions.OptimizeMode\n       * @enum {string}\n       * @property {number} SPEED=1 SPEED value\n       * @property {number} CODE_SIZE=2 CODE_SIZE value\n       * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value\n       */\n\n\n      FileOptions.OptimizeMode = function () {\n        const valuesById = {},\n              values = Object.create(valuesById);\n        values[valuesById[1] = \"SPEED\"] = 1;\n        values[valuesById[2] = \"CODE_SIZE\"] = 2;\n        values[valuesById[3] = \"LITE_RUNTIME\"] = 3;\n        return values;\n      }();\n\n      return FileOptions;\n    }();\n\n    protobuf.MessageOptions = function () {\n      /**\n       * Properties of a MessageOptions.\n       * @memberof google.protobuf\n       * @interface IMessageOptions\n       * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat\n       * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor\n       * @property {boolean|null} [deprecated] MessageOptions deprecated\n       * @property {boolean|null} [mapEntry] MessageOptions mapEntry\n       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption\n       * @property {number|null} [\".msgpoolSoftLimit\"] MessageOptions .msgpoolSoftLimit\n       * @property {number|null} [\".msgpoolHardLimit\"] MessageOptions .msgpoolHardLimit\n       */\n\n      /**\n       * Constructs a new MessageOptions.\n       * @memberof google.protobuf\n       * @classdesc Represents a MessageOptions.\n       * @implements IMessageOptions\n       * @constructor\n       * @param {google.protobuf.IMessageOptions=} [properties] Properties to set\n       */\n      function MessageOptions(properties) {\n        this.uninterpretedOption = [];\n        if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * MessageOptions messageSetWireFormat.\n       * @member {boolean} messageSetWireFormat\n       * @memberof google.protobuf.MessageOptions\n       * @instance\n       */\n\n\n      MessageOptions.prototype.messageSetWireFormat = false;\n      /**\n       * MessageOptions noStandardDescriptorAccessor.\n       * @member {boolean} noStandardDescriptorAccessor\n       * @memberof google.protobuf.MessageOptions\n       * @instance\n       */\n\n      MessageOptions.prototype.noStandardDescriptorAccessor = false;\n      /**\n       * MessageOptions deprecated.\n       * @member {boolean} deprecated\n       * @memberof google.protobuf.MessageOptions\n       * @instance\n       */\n\n      MessageOptions.prototype.deprecated = false;\n      /**\n       * MessageOptions mapEntry.\n       * @member {boolean} mapEntry\n       * @memberof google.protobuf.MessageOptions\n       * @instance\n       */\n\n      MessageOptions.prototype.mapEntry = false;\n      /**\n       * MessageOptions uninterpretedOption.\n       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n       * @memberof google.protobuf.MessageOptions\n       * @instance\n       */\n\n      MessageOptions.prototype.uninterpretedOption = $util.emptyArray;\n      /**\n       * MessageOptions .msgpoolSoftLimit.\n       * @member {number} .msgpoolSoftLimit\n       * @memberof google.protobuf.MessageOptions\n       * @instance\n       */\n\n      MessageOptions.prototype[\".msgpoolSoftLimit\"] = 32;\n      /**\n       * MessageOptions .msgpoolHardLimit.\n       * @member {number} .msgpoolHardLimit\n       * @memberof google.protobuf.MessageOptions\n       * @instance\n       */\n\n      MessageOptions.prototype[\".msgpoolHardLimit\"] = 384;\n      /**\n       * Decodes a MessageOptions message from the specified reader or buffer.\n       * @function decode\n       * @memberof google.protobuf.MessageOptions\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {google.protobuf.MessageOptions} MessageOptions\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n      MessageOptions.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.google.protobuf.MessageOptions();\n\n        while (reader.pos < end) {\n          let tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.messageSetWireFormat = reader.bool();\n              break;\n\n            case 2:\n              message.noStandardDescriptorAccessor = reader.bool();\n              break;\n\n            case 3:\n              message.deprecated = reader.bool();\n              break;\n\n            case 7:\n              message.mapEntry = reader.bool();\n              break;\n\n            case 999:\n              if (!(message.uninterpretedOption && message.uninterpretedOption.length)) message.uninterpretedOption = [];\n              message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n              break;\n\n            case 60000:\n              message[\".msgpoolSoftLimit\"] = reader.int32();\n              break;\n\n            case 60001:\n              message[\".msgpoolHardLimit\"] = reader.int32();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n\n      return MessageOptions;\n    }();\n\n    protobuf.FieldOptions = function () {\n      /**\n       * Properties of a FieldOptions.\n       * @memberof google.protobuf\n       * @interface IFieldOptions\n       * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype\n       * @property {boolean|null} [packed] FieldOptions packed\n       * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype\n       * @property {boolean|null} [lazy] FieldOptions lazy\n       * @property {boolean|null} [deprecated] FieldOptions deprecated\n       * @property {boolean|null} [weak] FieldOptions weak\n       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption\n       * @property {boolean|null} [\".keyField\"] FieldOptions .keyField\n       */\n\n      /**\n       * Constructs a new FieldOptions.\n       * @memberof google.protobuf\n       * @classdesc Represents a FieldOptions.\n       * @implements IFieldOptions\n       * @constructor\n       * @param {google.protobuf.IFieldOptions=} [properties] Properties to set\n       */\n      function FieldOptions(properties) {\n        this.uninterpretedOption = [];\n        if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * FieldOptions ctype.\n       * @member {google.protobuf.FieldOptions.CType} ctype\n       * @memberof google.protobuf.FieldOptions\n       * @instance\n       */\n\n\n      FieldOptions.prototype.ctype = 0;\n      /**\n       * FieldOptions packed.\n       * @member {boolean} packed\n       * @memberof google.protobuf.FieldOptions\n       * @instance\n       */\n\n      FieldOptions.prototype.packed = false;\n      /**\n       * FieldOptions jstype.\n       * @member {google.protobuf.FieldOptions.JSType} jstype\n       * @memberof google.protobuf.FieldOptions\n       * @instance\n       */\n\n      FieldOptions.prototype.jstype = 0;\n      /**\n       * FieldOptions lazy.\n       * @member {boolean} lazy\n       * @memberof google.protobuf.FieldOptions\n       * @instance\n       */\n\n      FieldOptions.prototype.lazy = false;\n      /**\n       * FieldOptions deprecated.\n       * @member {boolean} deprecated\n       * @memberof google.protobuf.FieldOptions\n       * @instance\n       */\n\n      FieldOptions.prototype.deprecated = false;\n      /**\n       * FieldOptions weak.\n       * @member {boolean} weak\n       * @memberof google.protobuf.FieldOptions\n       * @instance\n       */\n\n      FieldOptions.prototype.weak = false;\n      /**\n       * FieldOptions uninterpretedOption.\n       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n       * @memberof google.protobuf.FieldOptions\n       * @instance\n       */\n\n      FieldOptions.prototype.uninterpretedOption = $util.emptyArray;\n      /**\n       * FieldOptions .keyField.\n       * @member {boolean} .keyField\n       * @memberof google.protobuf.FieldOptions\n       * @instance\n       */\n\n      FieldOptions.prototype[\".keyField\"] = false;\n      /**\n       * Decodes a FieldOptions message from the specified reader or buffer.\n       * @function decode\n       * @memberof google.protobuf.FieldOptions\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {google.protobuf.FieldOptions} FieldOptions\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n      FieldOptions.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.google.protobuf.FieldOptions();\n\n        while (reader.pos < end) {\n          let tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.ctype = reader.int32();\n              break;\n\n            case 2:\n              message.packed = reader.bool();\n              break;\n\n            case 6:\n              message.jstype = reader.int32();\n              break;\n\n            case 5:\n              message.lazy = reader.bool();\n              break;\n\n            case 3:\n              message.deprecated = reader.bool();\n              break;\n\n            case 10:\n              message.weak = reader.bool();\n              break;\n\n            case 999:\n              if (!(message.uninterpretedOption && message.uninterpretedOption.length)) message.uninterpretedOption = [];\n              message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n              break;\n\n            case 60000:\n              message[\".keyField\"] = reader.bool();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n      /**\n       * CType enum.\n       * @name google.protobuf.FieldOptions.CType\n       * @enum {string}\n       * @property {number} STRING=0 STRING value\n       * @property {number} CORD=1 CORD value\n       * @property {number} STRING_PIECE=2 STRING_PIECE value\n       */\n\n\n      FieldOptions.CType = function () {\n        const valuesById = {},\n              values = Object.create(valuesById);\n        values[valuesById[0] = \"STRING\"] = 0;\n        values[valuesById[1] = \"CORD\"] = 1;\n        values[valuesById[2] = \"STRING_PIECE\"] = 2;\n        return values;\n      }();\n      /**\n       * JSType enum.\n       * @name google.protobuf.FieldOptions.JSType\n       * @enum {string}\n       * @property {number} JS_NORMAL=0 JS_NORMAL value\n       * @property {number} JS_STRING=1 JS_STRING value\n       * @property {number} JS_NUMBER=2 JS_NUMBER value\n       */\n\n\n      FieldOptions.JSType = function () {\n        const valuesById = {},\n              values = Object.create(valuesById);\n        values[valuesById[0] = \"JS_NORMAL\"] = 0;\n        values[valuesById[1] = \"JS_STRING\"] = 1;\n        values[valuesById[2] = \"JS_NUMBER\"] = 2;\n        return values;\n      }();\n\n      return FieldOptions;\n    }();\n\n    protobuf.OneofOptions = function () {\n      /**\n       * Properties of an OneofOptions.\n       * @memberof google.protobuf\n       * @interface IOneofOptions\n       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption\n       */\n\n      /**\n       * Constructs a new OneofOptions.\n       * @memberof google.protobuf\n       * @classdesc Represents an OneofOptions.\n       * @implements IOneofOptions\n       * @constructor\n       * @param {google.protobuf.IOneofOptions=} [properties] Properties to set\n       */\n      function OneofOptions(properties) {\n        this.uninterpretedOption = [];\n        if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * OneofOptions uninterpretedOption.\n       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n       * @memberof google.protobuf.OneofOptions\n       * @instance\n       */\n\n\n      OneofOptions.prototype.uninterpretedOption = $util.emptyArray;\n      /**\n       * Decodes an OneofOptions message from the specified reader or buffer.\n       * @function decode\n       * @memberof google.protobuf.OneofOptions\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {google.protobuf.OneofOptions} OneofOptions\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n      OneofOptions.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.google.protobuf.OneofOptions();\n\n        while (reader.pos < end) {\n          let tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 999:\n              if (!(message.uninterpretedOption && message.uninterpretedOption.length)) message.uninterpretedOption = [];\n              message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n\n      return OneofOptions;\n    }();\n\n    protobuf.EnumOptions = function () {\n      /**\n       * Properties of an EnumOptions.\n       * @memberof google.protobuf\n       * @interface IEnumOptions\n       * @property {boolean|null} [allowAlias] EnumOptions allowAlias\n       * @property {boolean|null} [deprecated] EnumOptions deprecated\n       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption\n       */\n\n      /**\n       * Constructs a new EnumOptions.\n       * @memberof google.protobuf\n       * @classdesc Represents an EnumOptions.\n       * @implements IEnumOptions\n       * @constructor\n       * @param {google.protobuf.IEnumOptions=} [properties] Properties to set\n       */\n      function EnumOptions(properties) {\n        this.uninterpretedOption = [];\n        if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * EnumOptions allowAlias.\n       * @member {boolean} allowAlias\n       * @memberof google.protobuf.EnumOptions\n       * @instance\n       */\n\n\n      EnumOptions.prototype.allowAlias = false;\n      /**\n       * EnumOptions deprecated.\n       * @member {boolean} deprecated\n       * @memberof google.protobuf.EnumOptions\n       * @instance\n       */\n\n      EnumOptions.prototype.deprecated = false;\n      /**\n       * EnumOptions uninterpretedOption.\n       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n       * @memberof google.protobuf.EnumOptions\n       * @instance\n       */\n\n      EnumOptions.prototype.uninterpretedOption = $util.emptyArray;\n      /**\n       * Decodes an EnumOptions message from the specified reader or buffer.\n       * @function decode\n       * @memberof google.protobuf.EnumOptions\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {google.protobuf.EnumOptions} EnumOptions\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n      EnumOptions.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.google.protobuf.EnumOptions();\n\n        while (reader.pos < end) {\n          let tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 2:\n              message.allowAlias = reader.bool();\n              break;\n\n            case 3:\n              message.deprecated = reader.bool();\n              break;\n\n            case 999:\n              if (!(message.uninterpretedOption && message.uninterpretedOption.length)) message.uninterpretedOption = [];\n              message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n\n      return EnumOptions;\n    }();\n\n    protobuf.EnumValueOptions = function () {\n      /**\n       * Properties of an EnumValueOptions.\n       * @memberof google.protobuf\n       * @interface IEnumValueOptions\n       * @property {boolean|null} [deprecated] EnumValueOptions deprecated\n       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption\n       */\n\n      /**\n       * Constructs a new EnumValueOptions.\n       * @memberof google.protobuf\n       * @classdesc Represents an EnumValueOptions.\n       * @implements IEnumValueOptions\n       * @constructor\n       * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set\n       */\n      function EnumValueOptions(properties) {\n        this.uninterpretedOption = [];\n        if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * EnumValueOptions deprecated.\n       * @member {boolean} deprecated\n       * @memberof google.protobuf.EnumValueOptions\n       * @instance\n       */\n\n\n      EnumValueOptions.prototype.deprecated = false;\n      /**\n       * EnumValueOptions uninterpretedOption.\n       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n       * @memberof google.protobuf.EnumValueOptions\n       * @instance\n       */\n\n      EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;\n      /**\n       * Decodes an EnumValueOptions message from the specified reader or buffer.\n       * @function decode\n       * @memberof google.protobuf.EnumValueOptions\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {google.protobuf.EnumValueOptions} EnumValueOptions\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n      EnumValueOptions.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.google.protobuf.EnumValueOptions();\n\n        while (reader.pos < end) {\n          let tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              message.deprecated = reader.bool();\n              break;\n\n            case 999:\n              if (!(message.uninterpretedOption && message.uninterpretedOption.length)) message.uninterpretedOption = [];\n              message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n\n      return EnumValueOptions;\n    }();\n\n    protobuf.ServiceOptions = function () {\n      /**\n       * Properties of a ServiceOptions.\n       * @memberof google.protobuf\n       * @interface IServiceOptions\n       * @property {boolean|null} [deprecated] ServiceOptions deprecated\n       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption\n       */\n\n      /**\n       * Constructs a new ServiceOptions.\n       * @memberof google.protobuf\n       * @classdesc Represents a ServiceOptions.\n       * @implements IServiceOptions\n       * @constructor\n       * @param {google.protobuf.IServiceOptions=} [properties] Properties to set\n       */\n      function ServiceOptions(properties) {\n        this.uninterpretedOption = [];\n        if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * ServiceOptions deprecated.\n       * @member {boolean} deprecated\n       * @memberof google.protobuf.ServiceOptions\n       * @instance\n       */\n\n\n      ServiceOptions.prototype.deprecated = false;\n      /**\n       * ServiceOptions uninterpretedOption.\n       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n       * @memberof google.protobuf.ServiceOptions\n       * @instance\n       */\n\n      ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;\n      /**\n       * Decodes a ServiceOptions message from the specified reader or buffer.\n       * @function decode\n       * @memberof google.protobuf.ServiceOptions\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {google.protobuf.ServiceOptions} ServiceOptions\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n      ServiceOptions.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.google.protobuf.ServiceOptions();\n\n        while (reader.pos < end) {\n          let tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 33:\n              message.deprecated = reader.bool();\n              break;\n\n            case 999:\n              if (!(message.uninterpretedOption && message.uninterpretedOption.length)) message.uninterpretedOption = [];\n              message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n\n      return ServiceOptions;\n    }();\n\n    protobuf.MethodOptions = function () {\n      /**\n       * Properties of a MethodOptions.\n       * @memberof google.protobuf\n       * @interface IMethodOptions\n       * @property {boolean|null} [deprecated] MethodOptions deprecated\n       * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption\n       */\n\n      /**\n       * Constructs a new MethodOptions.\n       * @memberof google.protobuf\n       * @classdesc Represents a MethodOptions.\n       * @implements IMethodOptions\n       * @constructor\n       * @param {google.protobuf.IMethodOptions=} [properties] Properties to set\n       */\n      function MethodOptions(properties) {\n        this.uninterpretedOption = [];\n        if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * MethodOptions deprecated.\n       * @member {boolean} deprecated\n       * @memberof google.protobuf.MethodOptions\n       * @instance\n       */\n\n\n      MethodOptions.prototype.deprecated = false;\n      /**\n       * MethodOptions uninterpretedOption.\n       * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n       * @memberof google.protobuf.MethodOptions\n       * @instance\n       */\n\n      MethodOptions.prototype.uninterpretedOption = $util.emptyArray;\n      /**\n       * Decodes a MethodOptions message from the specified reader or buffer.\n       * @function decode\n       * @memberof google.protobuf.MethodOptions\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {google.protobuf.MethodOptions} MethodOptions\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n      MethodOptions.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.google.protobuf.MethodOptions();\n\n        while (reader.pos < end) {\n          let tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 33:\n              message.deprecated = reader.bool();\n              break;\n\n            case 999:\n              if (!(message.uninterpretedOption && message.uninterpretedOption.length)) message.uninterpretedOption = [];\n              message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n\n      return MethodOptions;\n    }();\n\n    protobuf.UninterpretedOption = function () {\n      /**\n       * Properties of an UninterpretedOption.\n       * @memberof google.protobuf\n       * @interface IUninterpretedOption\n       * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name\n       * @property {string|null} [identifierValue] UninterpretedOption identifierValue\n       * @property {number|Long|null} [positiveIntValue] UninterpretedOption positiveIntValue\n       * @property {number|Long|null} [negativeIntValue] UninterpretedOption negativeIntValue\n       * @property {number|null} [doubleValue] UninterpretedOption doubleValue\n       * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue\n       * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue\n       */\n\n      /**\n       * Constructs a new UninterpretedOption.\n       * @memberof google.protobuf\n       * @classdesc Represents an UninterpretedOption.\n       * @implements IUninterpretedOption\n       * @constructor\n       * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set\n       */\n      function UninterpretedOption(properties) {\n        this.name = [];\n        if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * UninterpretedOption name.\n       * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name\n       * @memberof google.protobuf.UninterpretedOption\n       * @instance\n       */\n\n\n      UninterpretedOption.prototype.name = $util.emptyArray;\n      /**\n       * UninterpretedOption identifierValue.\n       * @member {string} identifierValue\n       * @memberof google.protobuf.UninterpretedOption\n       * @instance\n       */\n\n      UninterpretedOption.prototype.identifierValue = \"\";\n      /**\n       * UninterpretedOption positiveIntValue.\n       * @member {number|Long} positiveIntValue\n       * @memberof google.protobuf.UninterpretedOption\n       * @instance\n       */\n\n      UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n      /**\n       * UninterpretedOption negativeIntValue.\n       * @member {number|Long} negativeIntValue\n       * @memberof google.protobuf.UninterpretedOption\n       * @instance\n       */\n\n      UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n      /**\n       * UninterpretedOption doubleValue.\n       * @member {number} doubleValue\n       * @memberof google.protobuf.UninterpretedOption\n       * @instance\n       */\n\n      UninterpretedOption.prototype.doubleValue = 0;\n      /**\n       * UninterpretedOption stringValue.\n       * @member {Uint8Array} stringValue\n       * @memberof google.protobuf.UninterpretedOption\n       * @instance\n       */\n\n      UninterpretedOption.prototype.stringValue = $util.newBuffer([]);\n      /**\n       * UninterpretedOption aggregateValue.\n       * @member {string} aggregateValue\n       * @memberof google.protobuf.UninterpretedOption\n       * @instance\n       */\n\n      UninterpretedOption.prototype.aggregateValue = \"\";\n      /**\n       * Decodes an UninterpretedOption message from the specified reader or buffer.\n       * @function decode\n       * @memberof google.protobuf.UninterpretedOption\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {google.protobuf.UninterpretedOption} UninterpretedOption\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n      UninterpretedOption.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.google.protobuf.UninterpretedOption();\n\n        while (reader.pos < end) {\n          let tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 2:\n              if (!(message.name && message.name.length)) message.name = [];\n              message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));\n              break;\n\n            case 3:\n              message.identifierValue = reader.string();\n              break;\n\n            case 4:\n              message.positiveIntValue = reader.uint64();\n              break;\n\n            case 5:\n              message.negativeIntValue = reader.int64();\n              break;\n\n            case 6:\n              message.doubleValue = reader.double();\n              break;\n\n            case 7:\n              message.stringValue = reader.bytes();\n              break;\n\n            case 8:\n              message.aggregateValue = reader.string();\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n\n      UninterpretedOption.NamePart = function () {\n        /**\n         * Properties of a NamePart.\n         * @memberof google.protobuf.UninterpretedOption\n         * @interface INamePart\n         * @property {string} namePart NamePart namePart\n         * @property {boolean} isExtension NamePart isExtension\n         */\n\n        /**\n         * Constructs a new NamePart.\n         * @memberof google.protobuf.UninterpretedOption\n         * @classdesc Represents a NamePart.\n         * @implements INamePart\n         * @constructor\n         * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set\n         */\n        function NamePart(properties) {\n          if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * NamePart namePart.\n         * @member {string} namePart\n         * @memberof google.protobuf.UninterpretedOption.NamePart\n         * @instance\n         */\n\n\n        NamePart.prototype.namePart = \"\";\n        /**\n         * NamePart isExtension.\n         * @member {boolean} isExtension\n         * @memberof google.protobuf.UninterpretedOption.NamePart\n         * @instance\n         */\n\n        NamePart.prototype.isExtension = false;\n        /**\n         * Decodes a NamePart message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.UninterpretedOption.NamePart\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n        NamePart.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          let end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.UninterpretedOption.NamePart();\n\n          while (reader.pos < end) {\n            let tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                message.namePart = reader.string();\n                break;\n\n              case 2:\n                message.isExtension = reader.bool();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          if (!message.hasOwnProperty(\"namePart\")) throw $util.ProtocolError(\"missing required 'namePart'\", {\n            instance: message\n          });\n          if (!message.hasOwnProperty(\"isExtension\")) throw $util.ProtocolError(\"missing required 'isExtension'\", {\n            instance: message\n          });\n          return message;\n        };\n\n        return NamePart;\n      }();\n\n      return UninterpretedOption;\n    }();\n\n    protobuf.SourceCodeInfo = function () {\n      /**\n       * Properties of a SourceCodeInfo.\n       * @memberof google.protobuf\n       * @interface ISourceCodeInfo\n       * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location\n       */\n\n      /**\n       * Constructs a new SourceCodeInfo.\n       * @memberof google.protobuf\n       * @classdesc Represents a SourceCodeInfo.\n       * @implements ISourceCodeInfo\n       * @constructor\n       * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set\n       */\n      function SourceCodeInfo(properties) {\n        this.location = [];\n        if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * SourceCodeInfo location.\n       * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location\n       * @memberof google.protobuf.SourceCodeInfo\n       * @instance\n       */\n\n\n      SourceCodeInfo.prototype.location = $util.emptyArray;\n      /**\n       * Decodes a SourceCodeInfo message from the specified reader or buffer.\n       * @function decode\n       * @memberof google.protobuf.SourceCodeInfo\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n      SourceCodeInfo.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.google.protobuf.SourceCodeInfo();\n\n        while (reader.pos < end) {\n          let tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              if (!(message.location && message.location.length)) message.location = [];\n              message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n\n      SourceCodeInfo.Location = function () {\n        /**\n         * Properties of a Location.\n         * @memberof google.protobuf.SourceCodeInfo\n         * @interface ILocation\n         * @property {Array.<number>|null} [path] Location path\n         * @property {Array.<number>|null} [span] Location span\n         * @property {string|null} [leadingComments] Location leadingComments\n         * @property {string|null} [trailingComments] Location trailingComments\n         * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments\n         */\n\n        /**\n         * Constructs a new Location.\n         * @memberof google.protobuf.SourceCodeInfo\n         * @classdesc Represents a Location.\n         * @implements ILocation\n         * @constructor\n         * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set\n         */\n        function Location(properties) {\n          this.path = [];\n          this.span = [];\n          this.leadingDetachedComments = [];\n          if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * Location path.\n         * @member {Array.<number>} path\n         * @memberof google.protobuf.SourceCodeInfo.Location\n         * @instance\n         */\n\n\n        Location.prototype.path = $util.emptyArray;\n        /**\n         * Location span.\n         * @member {Array.<number>} span\n         * @memberof google.protobuf.SourceCodeInfo.Location\n         * @instance\n         */\n\n        Location.prototype.span = $util.emptyArray;\n        /**\n         * Location leadingComments.\n         * @member {string} leadingComments\n         * @memberof google.protobuf.SourceCodeInfo.Location\n         * @instance\n         */\n\n        Location.prototype.leadingComments = \"\";\n        /**\n         * Location trailingComments.\n         * @member {string} trailingComments\n         * @memberof google.protobuf.SourceCodeInfo.Location\n         * @instance\n         */\n\n        Location.prototype.trailingComments = \"\";\n        /**\n         * Location leadingDetachedComments.\n         * @member {Array.<string>} leadingDetachedComments\n         * @memberof google.protobuf.SourceCodeInfo.Location\n         * @instance\n         */\n\n        Location.prototype.leadingDetachedComments = $util.emptyArray;\n        /**\n         * Decodes a Location message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.SourceCodeInfo.Location\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.SourceCodeInfo.Location} Location\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n        Location.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          let end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.SourceCodeInfo.Location();\n\n          while (reader.pos < end) {\n            let tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                if (!(message.path && message.path.length)) message.path = [];\n\n                if ((tag & 7) === 2) {\n                  let end2 = reader.uint32() + reader.pos;\n\n                  while (reader.pos < end2) message.path.push(reader.int32());\n                } else message.path.push(reader.int32());\n\n                break;\n\n              case 2:\n                if (!(message.span && message.span.length)) message.span = [];\n\n                if ((tag & 7) === 2) {\n                  let end2 = reader.uint32() + reader.pos;\n\n                  while (reader.pos < end2) message.span.push(reader.int32());\n                } else message.span.push(reader.int32());\n\n                break;\n\n              case 3:\n                message.leadingComments = reader.string();\n                break;\n\n              case 4:\n                message.trailingComments = reader.string();\n                break;\n\n              case 6:\n                if (!(message.leadingDetachedComments && message.leadingDetachedComments.length)) message.leadingDetachedComments = [];\n                message.leadingDetachedComments.push(reader.string());\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n\n        return Location;\n      }();\n\n      return SourceCodeInfo;\n    }();\n\n    protobuf.GeneratedCodeInfo = function () {\n      /**\n       * Properties of a GeneratedCodeInfo.\n       * @memberof google.protobuf\n       * @interface IGeneratedCodeInfo\n       * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation\n       */\n\n      /**\n       * Constructs a new GeneratedCodeInfo.\n       * @memberof google.protobuf\n       * @classdesc Represents a GeneratedCodeInfo.\n       * @implements IGeneratedCodeInfo\n       * @constructor\n       * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set\n       */\n      function GeneratedCodeInfo(properties) {\n        this.annotation = [];\n        if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n      }\n      /**\n       * GeneratedCodeInfo annotation.\n       * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation\n       * @memberof google.protobuf.GeneratedCodeInfo\n       * @instance\n       */\n\n\n      GeneratedCodeInfo.prototype.annotation = $util.emptyArray;\n      /**\n       * Decodes a GeneratedCodeInfo message from the specified reader or buffer.\n       * @function decode\n       * @memberof google.protobuf.GeneratedCodeInfo\n       * @static\n       * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n       * @param {number} [length] Message length if known beforehand\n       * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo\n       * @throws {Error} If the payload is not a reader or valid buffer\n       * @throws {$protobuf.util.ProtocolError} If required fields are missing\n       */\n\n      GeneratedCodeInfo.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length,\n            message = new $root.google.protobuf.GeneratedCodeInfo();\n\n        while (reader.pos < end) {\n          let tag = reader.uint32();\n\n          switch (tag >>> 3) {\n            case 1:\n              if (!(message.annotation && message.annotation.length)) message.annotation = [];\n              message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));\n              break;\n\n            default:\n              reader.skipType(tag & 7);\n              break;\n          }\n        }\n\n        return message;\n      };\n\n      GeneratedCodeInfo.Annotation = function () {\n        /**\n         * Properties of an Annotation.\n         * @memberof google.protobuf.GeneratedCodeInfo\n         * @interface IAnnotation\n         * @property {Array.<number>|null} [path] Annotation path\n         * @property {string|null} [sourceFile] Annotation sourceFile\n         * @property {number|null} [begin] Annotation begin\n         * @property {number|null} [end] Annotation end\n         */\n\n        /**\n         * Constructs a new Annotation.\n         * @memberof google.protobuf.GeneratedCodeInfo\n         * @classdesc Represents an Annotation.\n         * @implements IAnnotation\n         * @constructor\n         * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set\n         */\n        function Annotation(properties) {\n          this.path = [];\n          if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * Annotation path.\n         * @member {Array.<number>} path\n         * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n         * @instance\n         */\n\n\n        Annotation.prototype.path = $util.emptyArray;\n        /**\n         * Annotation sourceFile.\n         * @member {string} sourceFile\n         * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n         * @instance\n         */\n\n        Annotation.prototype.sourceFile = \"\";\n        /**\n         * Annotation begin.\n         * @member {number} begin\n         * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n         * @instance\n         */\n\n        Annotation.prototype.begin = 0;\n        /**\n         * Annotation end.\n         * @member {number} end\n         * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n         * @instance\n         */\n\n        Annotation.prototype.end = 0;\n        /**\n         * Decodes an Annotation message from the specified reader or buffer.\n         * @function decode\n         * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n\n        Annotation.decode = function decode(reader, length) {\n          if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n          let end = length === undefined ? reader.len : reader.pos + length,\n              message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();\n\n          while (reader.pos < end) {\n            let tag = reader.uint32();\n\n            switch (tag >>> 3) {\n              case 1:\n                if (!(message.path && message.path.length)) message.path = [];\n\n                if ((tag & 7) === 2) {\n                  let end2 = reader.uint32() + reader.pos;\n\n                  while (reader.pos < end2) message.path.push(reader.int32());\n                } else message.path.push(reader.int32());\n\n                break;\n\n              case 2:\n                message.sourceFile = reader.string();\n                break;\n\n              case 3:\n                message.begin = reader.int32();\n                break;\n\n              case 4:\n                message.end = reader.int32();\n                break;\n\n              default:\n                reader.skipType(tag & 7);\n                break;\n            }\n          }\n\n          return message;\n        };\n\n        return Annotation;\n      }();\n\n      return GeneratedCodeInfo;\n    }();\n\n    return protobuf;\n  }();\n\n  return google;\n})();\n/**\n * NET_Messages enum.\n * @exports NET_Messages\n * @enum {string}\n * @property {number} net_NOP=0 net_NOP value\n * @property {number} net_Disconnect=1 net_Disconnect value\n * @property {number} net_File=2 net_File value\n * @property {number} net_SplitScreenUser=3 net_SplitScreenUser value\n * @property {number} net_Tick=4 net_Tick value\n * @property {number} net_StringCmd=5 net_StringCmd value\n * @property {number} net_SetConVar=6 net_SetConVar value\n * @property {number} net_SignonState=7 net_SignonState value\n * @property {number} net_PlayerAvatarData=100 net_PlayerAvatarData value\n */\n\n\n$root.NET_Messages = function () {\n  const valuesById = {},\n        values = Object.create(valuesById);\n  values[valuesById[0] = \"net_NOP\"] = 0;\n  values[valuesById[1] = \"net_Disconnect\"] = 1;\n  values[valuesById[2] = \"net_File\"] = 2;\n  values[valuesById[3] = \"net_SplitScreenUser\"] = 3;\n  values[valuesById[4] = \"net_Tick\"] = 4;\n  values[valuesById[5] = \"net_StringCmd\"] = 5;\n  values[valuesById[6] = \"net_SetConVar\"] = 6;\n  values[valuesById[7] = \"net_SignonState\"] = 7;\n  values[valuesById[100] = \"net_PlayerAvatarData\"] = 100;\n  return values;\n}();\n/**\n * CLC_Messages enum.\n * @exports CLC_Messages\n * @enum {string}\n * @property {number} clc_ClientInfo=8 clc_ClientInfo value\n * @property {number} clc_Move=9 clc_Move value\n * @property {number} clc_VoiceData=10 clc_VoiceData value\n * @property {number} clc_BaselineAck=11 clc_BaselineAck value\n * @property {number} clc_ListenEvents=12 clc_ListenEvents value\n * @property {number} clc_RespondCvarValue=13 clc_RespondCvarValue value\n * @property {number} clc_FileCRCCheck=14 clc_FileCRCCheck value\n * @property {number} clc_LoadingProgress=15 clc_LoadingProgress value\n * @property {number} clc_SplitPlayerConnect=16 clc_SplitPlayerConnect value\n * @property {number} clc_ClientMessage=17 clc_ClientMessage value\n * @property {number} clc_CmdKeyValues=18 clc_CmdKeyValues value\n * @property {number} clc_HltvReplay=20 clc_HltvReplay value\n */\n\n\n$root.CLC_Messages = function () {\n  const valuesById = {},\n        values = Object.create(valuesById);\n  values[valuesById[8] = \"clc_ClientInfo\"] = 8;\n  values[valuesById[9] = \"clc_Move\"] = 9;\n  values[valuesById[10] = \"clc_VoiceData\"] = 10;\n  values[valuesById[11] = \"clc_BaselineAck\"] = 11;\n  values[valuesById[12] = \"clc_ListenEvents\"] = 12;\n  values[valuesById[13] = \"clc_RespondCvarValue\"] = 13;\n  values[valuesById[14] = \"clc_FileCRCCheck\"] = 14;\n  values[valuesById[15] = \"clc_LoadingProgress\"] = 15;\n  values[valuesById[16] = \"clc_SplitPlayerConnect\"] = 16;\n  values[valuesById[17] = \"clc_ClientMessage\"] = 17;\n  values[valuesById[18] = \"clc_CmdKeyValues\"] = 18;\n  values[valuesById[20] = \"clc_HltvReplay\"] = 20;\n  return values;\n}();\n/**\n * VoiceDataFormat_t enum.\n * @exports VoiceDataFormat_t\n * @enum {string}\n * @property {number} VOICEDATA_FORMAT_STEAM=0 VOICEDATA_FORMAT_STEAM value\n * @property {number} VOICEDATA_FORMAT_ENGINE=1 VOICEDATA_FORMAT_ENGINE value\n */\n\n\n$root.VoiceDataFormat_t = function () {\n  const valuesById = {},\n        values = Object.create(valuesById);\n  values[valuesById[0] = \"VOICEDATA_FORMAT_STEAM\"] = 0;\n  values[valuesById[1] = \"VOICEDATA_FORMAT_ENGINE\"] = 1;\n  return values;\n}();\n/**\n * ESplitScreenMessageType enum.\n * @exports ESplitScreenMessageType\n * @enum {string}\n * @property {number} MSG_SPLITSCREEN_ADDUSER=0 MSG_SPLITSCREEN_ADDUSER value\n * @property {number} MSG_SPLITSCREEN_REMOVEUSER=1 MSG_SPLITSCREEN_REMOVEUSER value\n * @property {number} MSG_SPLITSCREEN_TYPE_BITS=1 MSG_SPLITSCREEN_TYPE_BITS value\n */\n\n\n$root.ESplitScreenMessageType = function () {\n  const valuesById = {},\n        values = Object.create(valuesById);\n  values[valuesById[0] = \"MSG_SPLITSCREEN_ADDUSER\"] = 0;\n  values[valuesById[1] = \"MSG_SPLITSCREEN_REMOVEUSER\"] = 1;\n  values[\"MSG_SPLITSCREEN_TYPE_BITS\"] = 1;\n  return values;\n}();\n/**\n * SVC_Messages enum.\n * @exports SVC_Messages\n * @enum {string}\n * @property {number} svc_ServerInfo=8 svc_ServerInfo value\n * @property {number} svc_SendTable=9 svc_SendTable value\n * @property {number} svc_ClassInfo=10 svc_ClassInfo value\n * @property {number} svc_SetPause=11 svc_SetPause value\n * @property {number} svc_CreateStringTable=12 svc_CreateStringTable value\n * @property {number} svc_UpdateStringTable=13 svc_UpdateStringTable value\n * @property {number} svc_VoiceInit=14 svc_VoiceInit value\n * @property {number} svc_VoiceData=15 svc_VoiceData value\n * @property {number} svc_Print=16 svc_Print value\n * @property {number} svc_Sounds=17 svc_Sounds value\n * @property {number} svc_SetView=18 svc_SetView value\n * @property {number} svc_FixAngle=19 svc_FixAngle value\n * @property {number} svc_CrosshairAngle=20 svc_CrosshairAngle value\n * @property {number} svc_BSPDecal=21 svc_BSPDecal value\n * @property {number} svc_SplitScreen=22 svc_SplitScreen value\n * @property {number} svc_UserMessage=23 svc_UserMessage value\n * @property {number} svc_EntityMessage=24 svc_EntityMessage value\n * @property {number} svc_GameEvent=25 svc_GameEvent value\n * @property {number} svc_PacketEntities=26 svc_PacketEntities value\n * @property {number} svc_TempEntities=27 svc_TempEntities value\n * @property {number} svc_Prefetch=28 svc_Prefetch value\n * @property {number} svc_Menu=29 svc_Menu value\n * @property {number} svc_GameEventList=30 svc_GameEventList value\n * @property {number} svc_GetCvarValue=31 svc_GetCvarValue value\n * @property {number} svc_PaintmapData=33 svc_PaintmapData value\n * @property {number} svc_CmdKeyValues=34 svc_CmdKeyValues value\n * @property {number} svc_EncryptedData=35 svc_EncryptedData value\n * @property {number} svc_HltvReplay=36 svc_HltvReplay value\n */\n\n\n$root.SVC_Messages = function () {\n  const valuesById = {},\n        values = Object.create(valuesById);\n  values[valuesById[8] = \"svc_ServerInfo\"] = 8;\n  values[valuesById[9] = \"svc_SendTable\"] = 9;\n  values[valuesById[10] = \"svc_ClassInfo\"] = 10;\n  values[valuesById[11] = \"svc_SetPause\"] = 11;\n  values[valuesById[12] = \"svc_CreateStringTable\"] = 12;\n  values[valuesById[13] = \"svc_UpdateStringTable\"] = 13;\n  values[valuesById[14] = \"svc_VoiceInit\"] = 14;\n  values[valuesById[15] = \"svc_VoiceData\"] = 15;\n  values[valuesById[16] = \"svc_Print\"] = 16;\n  values[valuesById[17] = \"svc_Sounds\"] = 17;\n  values[valuesById[18] = \"svc_SetView\"] = 18;\n  values[valuesById[19] = \"svc_FixAngle\"] = 19;\n  values[valuesById[20] = \"svc_CrosshairAngle\"] = 20;\n  values[valuesById[21] = \"svc_BSPDecal\"] = 21;\n  values[valuesById[22] = \"svc_SplitScreen\"] = 22;\n  values[valuesById[23] = \"svc_UserMessage\"] = 23;\n  values[valuesById[24] = \"svc_EntityMessage\"] = 24;\n  values[valuesById[25] = \"svc_GameEvent\"] = 25;\n  values[valuesById[26] = \"svc_PacketEntities\"] = 26;\n  values[valuesById[27] = \"svc_TempEntities\"] = 27;\n  values[valuesById[28] = \"svc_Prefetch\"] = 28;\n  values[valuesById[29] = \"svc_Menu\"] = 29;\n  values[valuesById[30] = \"svc_GameEventList\"] = 30;\n  values[valuesById[31] = \"svc_GetCvarValue\"] = 31;\n  values[valuesById[33] = \"svc_PaintmapData\"] = 33;\n  values[valuesById[34] = \"svc_CmdKeyValues\"] = 34;\n  values[valuesById[35] = \"svc_EncryptedData\"] = 35;\n  values[valuesById[36] = \"svc_HltvReplay\"] = 36;\n  return values;\n}();\n/**\n * ReplayEventType_t enum.\n * @exports ReplayEventType_t\n * @enum {string}\n * @property {number} REPLAY_EVENT_CANCEL=0 REPLAY_EVENT_CANCEL value\n * @property {number} REPLAY_EVENT_DEATH=1 REPLAY_EVENT_DEATH value\n * @property {number} REPLAY_EVENT_GENERIC=2 REPLAY_EVENT_GENERIC value\n */\n\n\n$root.ReplayEventType_t = function () {\n  const valuesById = {},\n        values = Object.create(valuesById);\n  values[valuesById[0] = \"REPLAY_EVENT_CANCEL\"] = 0;\n  values[valuesById[1] = \"REPLAY_EVENT_DEATH\"] = 1;\n  values[valuesById[2] = \"REPLAY_EVENT_GENERIC\"] = 2;\n  return values;\n}();\n\nexports.CMsgVector = $root.CMsgVector = (() => {\n  /**\n   * Properties of a CMsgVector.\n   * @exports ICMsgVector\n   * @interface ICMsgVector\n   * @property {number|null} [x] CMsgVector x\n   * @property {number|null} [y] CMsgVector y\n   * @property {number|null} [z] CMsgVector z\n   */\n\n  /**\n   * Constructs a new CMsgVector.\n   * @exports CMsgVector\n   * @classdesc Represents a CMsgVector.\n   * @implements ICMsgVector\n   * @constructor\n   * @param {ICMsgVector=} [properties] Properties to set\n   */\n  function CMsgVector(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgVector x.\n   * @member {number} x\n   * @memberof CMsgVector\n   * @instance\n   */\n\n\n  CMsgVector.prototype.x = 0;\n  /**\n   * CMsgVector y.\n   * @member {number} y\n   * @memberof CMsgVector\n   * @instance\n   */\n\n  CMsgVector.prototype.y = 0;\n  /**\n   * CMsgVector z.\n   * @member {number} z\n   * @memberof CMsgVector\n   * @instance\n   */\n\n  CMsgVector.prototype.z = 0;\n  /**\n   * Decodes a CMsgVector message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgVector\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgVector} CMsgVector\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgVector.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgVector();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.x = reader.float();\n          break;\n\n        case 2:\n          message.y = reader.float();\n          break;\n\n        case 3:\n          message.z = reader.float();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgVector;\n})();\n\nexports.CMsgVector2D = $root.CMsgVector2D = (() => {\n  /**\n   * Properties of a CMsgVector2D.\n   * @exports ICMsgVector2D\n   * @interface ICMsgVector2D\n   * @property {number|null} [x] CMsgVector2D x\n   * @property {number|null} [y] CMsgVector2D y\n   */\n\n  /**\n   * Constructs a new CMsgVector2D.\n   * @exports CMsgVector2D\n   * @classdesc Represents a CMsgVector2D.\n   * @implements ICMsgVector2D\n   * @constructor\n   * @param {ICMsgVector2D=} [properties] Properties to set\n   */\n  function CMsgVector2D(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgVector2D x.\n   * @member {number} x\n   * @memberof CMsgVector2D\n   * @instance\n   */\n\n\n  CMsgVector2D.prototype.x = 0;\n  /**\n   * CMsgVector2D y.\n   * @member {number} y\n   * @memberof CMsgVector2D\n   * @instance\n   */\n\n  CMsgVector2D.prototype.y = 0;\n  /**\n   * Decodes a CMsgVector2D message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgVector2D\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgVector2D} CMsgVector2D\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgVector2D.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgVector2D();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.x = reader.float();\n          break;\n\n        case 2:\n          message.y = reader.float();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgVector2D;\n})();\n\nexports.CMsgQAngle = $root.CMsgQAngle = (() => {\n  /**\n   * Properties of a CMsgQAngle.\n   * @exports ICMsgQAngle\n   * @interface ICMsgQAngle\n   * @property {number|null} [x] CMsgQAngle x\n   * @property {number|null} [y] CMsgQAngle y\n   * @property {number|null} [z] CMsgQAngle z\n   */\n\n  /**\n   * Constructs a new CMsgQAngle.\n   * @exports CMsgQAngle\n   * @classdesc Represents a CMsgQAngle.\n   * @implements ICMsgQAngle\n   * @constructor\n   * @param {ICMsgQAngle=} [properties] Properties to set\n   */\n  function CMsgQAngle(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgQAngle x.\n   * @member {number} x\n   * @memberof CMsgQAngle\n   * @instance\n   */\n\n\n  CMsgQAngle.prototype.x = 0;\n  /**\n   * CMsgQAngle y.\n   * @member {number} y\n   * @memberof CMsgQAngle\n   * @instance\n   */\n\n  CMsgQAngle.prototype.y = 0;\n  /**\n   * CMsgQAngle z.\n   * @member {number} z\n   * @memberof CMsgQAngle\n   * @instance\n   */\n\n  CMsgQAngle.prototype.z = 0;\n  /**\n   * Decodes a CMsgQAngle message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgQAngle\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgQAngle} CMsgQAngle\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgQAngle.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgQAngle();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.x = reader.float();\n          break;\n\n        case 2:\n          message.y = reader.float();\n          break;\n\n        case 3:\n          message.z = reader.float();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgQAngle;\n})();\n\nexports.CMsgRGBA = $root.CMsgRGBA = (() => {\n  /**\n   * Properties of a CMsgRGBA.\n   * @exports ICMsgRGBA\n   * @interface ICMsgRGBA\n   * @property {number|null} [r] CMsgRGBA r\n   * @property {number|null} [g] CMsgRGBA g\n   * @property {number|null} [b] CMsgRGBA b\n   * @property {number|null} [a] CMsgRGBA a\n   */\n\n  /**\n   * Constructs a new CMsgRGBA.\n   * @exports CMsgRGBA\n   * @classdesc Represents a CMsgRGBA.\n   * @implements ICMsgRGBA\n   * @constructor\n   * @param {ICMsgRGBA=} [properties] Properties to set\n   */\n  function CMsgRGBA(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgRGBA r.\n   * @member {number} r\n   * @memberof CMsgRGBA\n   * @instance\n   */\n\n\n  CMsgRGBA.prototype.r = 0;\n  /**\n   * CMsgRGBA g.\n   * @member {number} g\n   * @memberof CMsgRGBA\n   * @instance\n   */\n\n  CMsgRGBA.prototype.g = 0;\n  /**\n   * CMsgRGBA b.\n   * @member {number} b\n   * @memberof CMsgRGBA\n   * @instance\n   */\n\n  CMsgRGBA.prototype.b = 0;\n  /**\n   * CMsgRGBA a.\n   * @member {number} a\n   * @memberof CMsgRGBA\n   * @instance\n   */\n\n  CMsgRGBA.prototype.a = 0;\n  /**\n   * Decodes a CMsgRGBA message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgRGBA\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgRGBA} CMsgRGBA\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgRGBA.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgRGBA();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.r = reader.int32();\n          break;\n\n        case 2:\n          message.g = reader.int32();\n          break;\n\n        case 3:\n          message.b = reader.int32();\n          break;\n\n        case 4:\n          message.a = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgRGBA;\n})();\n\nexports.CNETMsg_Tick = $root.CNETMsg_Tick = (() => {\n  /**\n   * Properties of a CNETMsg_Tick.\n   * @exports ICNETMsg_Tick\n   * @interface ICNETMsg_Tick\n   * @property {number|null} [tick] CNETMsg_Tick tick\n   * @property {number|null} [hostComputationtime] CNETMsg_Tick hostComputationtime\n   * @property {number|null} [hostComputationtimeStdDeviation] CNETMsg_Tick hostComputationtimeStdDeviation\n   * @property {number|null} [hostFramestarttimeStdDeviation] CNETMsg_Tick hostFramestarttimeStdDeviation\n   * @property {number|null} [hltvReplayFlags] CNETMsg_Tick hltvReplayFlags\n   */\n\n  /**\n   * Constructs a new CNETMsg_Tick.\n   * @exports CNETMsg_Tick\n   * @classdesc Represents a CNETMsg_Tick.\n   * @implements ICNETMsg_Tick\n   * @constructor\n   * @param {ICNETMsg_Tick=} [properties] Properties to set\n   */\n  function CNETMsg_Tick(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CNETMsg_Tick tick.\n   * @member {number} tick\n   * @memberof CNETMsg_Tick\n   * @instance\n   */\n\n\n  CNETMsg_Tick.prototype.tick = 0;\n  /**\n   * CNETMsg_Tick hostComputationtime.\n   * @member {number} hostComputationtime\n   * @memberof CNETMsg_Tick\n   * @instance\n   */\n\n  CNETMsg_Tick.prototype.hostComputationtime = 0;\n  /**\n   * CNETMsg_Tick hostComputationtimeStdDeviation.\n   * @member {number} hostComputationtimeStdDeviation\n   * @memberof CNETMsg_Tick\n   * @instance\n   */\n\n  CNETMsg_Tick.prototype.hostComputationtimeStdDeviation = 0;\n  /**\n   * CNETMsg_Tick hostFramestarttimeStdDeviation.\n   * @member {number} hostFramestarttimeStdDeviation\n   * @memberof CNETMsg_Tick\n   * @instance\n   */\n\n  CNETMsg_Tick.prototype.hostFramestarttimeStdDeviation = 0;\n  /**\n   * CNETMsg_Tick hltvReplayFlags.\n   * @member {number} hltvReplayFlags\n   * @memberof CNETMsg_Tick\n   * @instance\n   */\n\n  CNETMsg_Tick.prototype.hltvReplayFlags = 0;\n  /**\n   * Decodes a CNETMsg_Tick message from the specified reader or buffer.\n   * @function decode\n   * @memberof CNETMsg_Tick\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CNETMsg_Tick} CNETMsg_Tick\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CNETMsg_Tick.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CNETMsg_Tick();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.tick = reader.uint32();\n          break;\n\n        case 4:\n          message.hostComputationtime = reader.uint32();\n          break;\n\n        case 5:\n          message.hostComputationtimeStdDeviation = reader.uint32();\n          break;\n\n        case 6:\n          message.hostFramestarttimeStdDeviation = reader.uint32();\n          break;\n\n        case 7:\n          message.hltvReplayFlags = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CNETMsg_Tick;\n})();\n\nexports.CNETMsg_StringCmd = $root.CNETMsg_StringCmd = (() => {\n  /**\n   * Properties of a CNETMsg_StringCmd.\n   * @exports ICNETMsg_StringCmd\n   * @interface ICNETMsg_StringCmd\n   * @property {string|null} [command] CNETMsg_StringCmd command\n   */\n\n  /**\n   * Constructs a new CNETMsg_StringCmd.\n   * @exports CNETMsg_StringCmd\n   * @classdesc Represents a CNETMsg_StringCmd.\n   * @implements ICNETMsg_StringCmd\n   * @constructor\n   * @param {ICNETMsg_StringCmd=} [properties] Properties to set\n   */\n  function CNETMsg_StringCmd(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CNETMsg_StringCmd command.\n   * @member {string} command\n   * @memberof CNETMsg_StringCmd\n   * @instance\n   */\n\n\n  CNETMsg_StringCmd.prototype.command = \"\";\n  /**\n   * Decodes a CNETMsg_StringCmd message from the specified reader or buffer.\n   * @function decode\n   * @memberof CNETMsg_StringCmd\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CNETMsg_StringCmd.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CNETMsg_StringCmd();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.command = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CNETMsg_StringCmd;\n})();\n\nexports.CNETMsg_SignonState = $root.CNETMsg_SignonState = (() => {\n  /**\n   * Properties of a CNETMsg_SignonState.\n   * @exports ICNETMsg_SignonState\n   * @interface ICNETMsg_SignonState\n   * @property {number|null} [signonState] CNETMsg_SignonState signonState\n   * @property {number|null} [spawnCount] CNETMsg_SignonState spawnCount\n   * @property {number|null} [numServerPlayers] CNETMsg_SignonState numServerPlayers\n   * @property {Array.<string>|null} [playersNetworkids] CNETMsg_SignonState playersNetworkids\n   * @property {string|null} [mapName] CNETMsg_SignonState mapName\n   */\n\n  /**\n   * Constructs a new CNETMsg_SignonState.\n   * @exports CNETMsg_SignonState\n   * @classdesc Represents a CNETMsg_SignonState.\n   * @implements ICNETMsg_SignonState\n   * @constructor\n   * @param {ICNETMsg_SignonState=} [properties] Properties to set\n   */\n  function CNETMsg_SignonState(properties) {\n    this.playersNetworkids = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CNETMsg_SignonState signonState.\n   * @member {number} signonState\n   * @memberof CNETMsg_SignonState\n   * @instance\n   */\n\n\n  CNETMsg_SignonState.prototype.signonState = 0;\n  /**\n   * CNETMsg_SignonState spawnCount.\n   * @member {number} spawnCount\n   * @memberof CNETMsg_SignonState\n   * @instance\n   */\n\n  CNETMsg_SignonState.prototype.spawnCount = 0;\n  /**\n   * CNETMsg_SignonState numServerPlayers.\n   * @member {number} numServerPlayers\n   * @memberof CNETMsg_SignonState\n   * @instance\n   */\n\n  CNETMsg_SignonState.prototype.numServerPlayers = 0;\n  /**\n   * CNETMsg_SignonState playersNetworkids.\n   * @member {Array.<string>} playersNetworkids\n   * @memberof CNETMsg_SignonState\n   * @instance\n   */\n\n  CNETMsg_SignonState.prototype.playersNetworkids = $util.emptyArray;\n  /**\n   * CNETMsg_SignonState mapName.\n   * @member {string} mapName\n   * @memberof CNETMsg_SignonState\n   * @instance\n   */\n\n  CNETMsg_SignonState.prototype.mapName = \"\";\n  /**\n   * Decodes a CNETMsg_SignonState message from the specified reader or buffer.\n   * @function decode\n   * @memberof CNETMsg_SignonState\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CNETMsg_SignonState} CNETMsg_SignonState\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CNETMsg_SignonState.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CNETMsg_SignonState();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.signonState = reader.uint32();\n          break;\n\n        case 2:\n          message.spawnCount = reader.uint32();\n          break;\n\n        case 3:\n          message.numServerPlayers = reader.uint32();\n          break;\n\n        case 4:\n          if (!(message.playersNetworkids && message.playersNetworkids.length)) message.playersNetworkids = [];\n          message.playersNetworkids.push(reader.string());\n          break;\n\n        case 5:\n          message.mapName = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CNETMsg_SignonState;\n})();\n\nexports.CMsg_CVars = $root.CMsg_CVars = (() => {\n  /**\n   * Properties of a CMsg_CVars.\n   * @exports ICMsg_CVars\n   * @interface ICMsg_CVars\n   * @property {Array.<CMsg_CVars.ICVar>|null} [cvars] CMsg_CVars cvars\n   */\n\n  /**\n   * Constructs a new CMsg_CVars.\n   * @exports CMsg_CVars\n   * @classdesc Represents a CMsg_CVars.\n   * @implements ICMsg_CVars\n   * @constructor\n   * @param {ICMsg_CVars=} [properties] Properties to set\n   */\n  function CMsg_CVars(properties) {\n    this.cvars = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsg_CVars cvars.\n   * @member {Array.<CMsg_CVars.ICVar>} cvars\n   * @memberof CMsg_CVars\n   * @instance\n   */\n\n\n  CMsg_CVars.prototype.cvars = $util.emptyArray;\n  /**\n   * Decodes a CMsg_CVars message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsg_CVars\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsg_CVars} CMsg_CVars\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsg_CVars.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsg_CVars();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.cvars && message.cvars.length)) message.cvars = [];\n          message.cvars.push($root.CMsg_CVars.CVar.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CMsg_CVars.CVar = function () {\n    /**\n     * Properties of a CVar.\n     * @memberof CMsg_CVars\n     * @interface ICVar\n     * @property {string|null} [name] CVar name\n     * @property {string|null} [value] CVar value\n     * @property {number|null} [dictionaryName] CVar dictionaryName\n     */\n\n    /**\n     * Constructs a new CVar.\n     * @memberof CMsg_CVars\n     * @classdesc Represents a CVar.\n     * @implements ICVar\n     * @constructor\n     * @param {CMsg_CVars.ICVar=} [properties] Properties to set\n     */\n    function CVar(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CVar name.\n     * @member {string} name\n     * @memberof CMsg_CVars.CVar\n     * @instance\n     */\n\n\n    CVar.prototype.name = \"\";\n    /**\n     * CVar value.\n     * @member {string} value\n     * @memberof CMsg_CVars.CVar\n     * @instance\n     */\n\n    CVar.prototype.value = \"\";\n    /**\n     * CVar dictionaryName.\n     * @member {number} dictionaryName\n     * @memberof CMsg_CVars.CVar\n     * @instance\n     */\n\n    CVar.prototype.dictionaryName = 0;\n    /**\n     * Decodes a CVar message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsg_CVars.CVar\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsg_CVars.CVar} CVar\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    CVar.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CMsg_CVars.CVar();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.name = reader.string();\n            break;\n\n          case 2:\n            message.value = reader.string();\n            break;\n\n          case 3:\n            message.dictionaryName = reader.uint32();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return CVar;\n  }();\n\n  return CMsg_CVars;\n})();\n\nexports.CNETMsg_SetConVar = $root.CNETMsg_SetConVar = (() => {\n  /**\n   * Properties of a CNETMsg_SetConVar.\n   * @exports ICNETMsg_SetConVar\n   * @interface ICNETMsg_SetConVar\n   * @property {ICMsg_CVars|null} [convars] CNETMsg_SetConVar convars\n   */\n\n  /**\n   * Constructs a new CNETMsg_SetConVar.\n   * @exports CNETMsg_SetConVar\n   * @classdesc Represents a CNETMsg_SetConVar.\n   * @implements ICNETMsg_SetConVar\n   * @constructor\n   * @param {ICNETMsg_SetConVar=} [properties] Properties to set\n   */\n  function CNETMsg_SetConVar(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CNETMsg_SetConVar convars.\n   * @member {ICMsg_CVars|null|undefined} convars\n   * @memberof CNETMsg_SetConVar\n   * @instance\n   */\n\n\n  CNETMsg_SetConVar.prototype.convars = null;\n  /**\n   * Decodes a CNETMsg_SetConVar message from the specified reader or buffer.\n   * @function decode\n   * @memberof CNETMsg_SetConVar\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CNETMsg_SetConVar.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CNETMsg_SetConVar();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.convars = $root.CMsg_CVars.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CNETMsg_SetConVar;\n})();\n\nexports.CNETMsg_NOP = $root.CNETMsg_NOP = (() => {\n  /**\n   * Properties of a CNETMsg_NOP.\n   * @exports ICNETMsg_NOP\n   * @interface ICNETMsg_NOP\n   */\n\n  /**\n   * Constructs a new CNETMsg_NOP.\n   * @exports CNETMsg_NOP\n   * @classdesc Represents a CNETMsg_NOP.\n   * @implements ICNETMsg_NOP\n   * @constructor\n   * @param {ICNETMsg_NOP=} [properties] Properties to set\n   */\n  function CNETMsg_NOP(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * Decodes a CNETMsg_NOP message from the specified reader or buffer.\n   * @function decode\n   * @memberof CNETMsg_NOP\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CNETMsg_NOP} CNETMsg_NOP\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  CNETMsg_NOP.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CNETMsg_NOP();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CNETMsg_NOP;\n})();\n\nexports.CNETMsg_Disconnect = $root.CNETMsg_Disconnect = (() => {\n  /**\n   * Properties of a CNETMsg_Disconnect.\n   * @exports ICNETMsg_Disconnect\n   * @interface ICNETMsg_Disconnect\n   * @property {string|null} [text] CNETMsg_Disconnect text\n   */\n\n  /**\n   * Constructs a new CNETMsg_Disconnect.\n   * @exports CNETMsg_Disconnect\n   * @classdesc Represents a CNETMsg_Disconnect.\n   * @implements ICNETMsg_Disconnect\n   * @constructor\n   * @param {ICNETMsg_Disconnect=} [properties] Properties to set\n   */\n  function CNETMsg_Disconnect(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CNETMsg_Disconnect text.\n   * @member {string} text\n   * @memberof CNETMsg_Disconnect\n   * @instance\n   */\n\n\n  CNETMsg_Disconnect.prototype.text = \"\";\n  /**\n   * Decodes a CNETMsg_Disconnect message from the specified reader or buffer.\n   * @function decode\n   * @memberof CNETMsg_Disconnect\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CNETMsg_Disconnect.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CNETMsg_Disconnect();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.text = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CNETMsg_Disconnect;\n})();\n\nexports.CNETMsg_File = $root.CNETMsg_File = (() => {\n  /**\n   * Properties of a CNETMsg_File.\n   * @exports ICNETMsg_File\n   * @interface ICNETMsg_File\n   * @property {number|null} [transferId] CNETMsg_File transferId\n   * @property {string|null} [fileName] CNETMsg_File fileName\n   * @property {boolean|null} [isReplayDemoFile] CNETMsg_File isReplayDemoFile\n   * @property {boolean|null} [deny] CNETMsg_File deny\n   */\n\n  /**\n   * Constructs a new CNETMsg_File.\n   * @exports CNETMsg_File\n   * @classdesc Represents a CNETMsg_File.\n   * @implements ICNETMsg_File\n   * @constructor\n   * @param {ICNETMsg_File=} [properties] Properties to set\n   */\n  function CNETMsg_File(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CNETMsg_File transferId.\n   * @member {number} transferId\n   * @memberof CNETMsg_File\n   * @instance\n   */\n\n\n  CNETMsg_File.prototype.transferId = 0;\n  /**\n   * CNETMsg_File fileName.\n   * @member {string} fileName\n   * @memberof CNETMsg_File\n   * @instance\n   */\n\n  CNETMsg_File.prototype.fileName = \"\";\n  /**\n   * CNETMsg_File isReplayDemoFile.\n   * @member {boolean} isReplayDemoFile\n   * @memberof CNETMsg_File\n   * @instance\n   */\n\n  CNETMsg_File.prototype.isReplayDemoFile = false;\n  /**\n   * CNETMsg_File deny.\n   * @member {boolean} deny\n   * @memberof CNETMsg_File\n   * @instance\n   */\n\n  CNETMsg_File.prototype.deny = false;\n  /**\n   * Decodes a CNETMsg_File message from the specified reader or buffer.\n   * @function decode\n   * @memberof CNETMsg_File\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CNETMsg_File} CNETMsg_File\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CNETMsg_File.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CNETMsg_File();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.transferId = reader.int32();\n          break;\n\n        case 2:\n          message.fileName = reader.string();\n          break;\n\n        case 3:\n          message.isReplayDemoFile = reader.bool();\n          break;\n\n        case 4:\n          message.deny = reader.bool();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CNETMsg_File;\n})();\n\nexports.CNETMsg_SplitScreenUser = $root.CNETMsg_SplitScreenUser = (() => {\n  /**\n   * Properties of a CNETMsg_SplitScreenUser.\n   * @exports ICNETMsg_SplitScreenUser\n   * @interface ICNETMsg_SplitScreenUser\n   * @property {number|null} [slot] CNETMsg_SplitScreenUser slot\n   */\n\n  /**\n   * Constructs a new CNETMsg_SplitScreenUser.\n   * @exports CNETMsg_SplitScreenUser\n   * @classdesc Represents a CNETMsg_SplitScreenUser.\n   * @implements ICNETMsg_SplitScreenUser\n   * @constructor\n   * @param {ICNETMsg_SplitScreenUser=} [properties] Properties to set\n   */\n  function CNETMsg_SplitScreenUser(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CNETMsg_SplitScreenUser slot.\n   * @member {number} slot\n   * @memberof CNETMsg_SplitScreenUser\n   * @instance\n   */\n\n\n  CNETMsg_SplitScreenUser.prototype.slot = 0;\n  /**\n   * Decodes a CNETMsg_SplitScreenUser message from the specified reader or buffer.\n   * @function decode\n   * @memberof CNETMsg_SplitScreenUser\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CNETMsg_SplitScreenUser.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CNETMsg_SplitScreenUser();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.slot = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CNETMsg_SplitScreenUser;\n})();\n\nexports.CNETMsg_PlayerAvatarData = $root.CNETMsg_PlayerAvatarData = (() => {\n  /**\n   * Properties of a CNETMsg_PlayerAvatarData.\n   * @exports ICNETMsg_PlayerAvatarData\n   * @interface ICNETMsg_PlayerAvatarData\n   * @property {number|null} [accountid] CNETMsg_PlayerAvatarData accountid\n   * @property {Uint8Array|null} [rgb] CNETMsg_PlayerAvatarData rgb\n   */\n\n  /**\n   * Constructs a new CNETMsg_PlayerAvatarData.\n   * @exports CNETMsg_PlayerAvatarData\n   * @classdesc Represents a CNETMsg_PlayerAvatarData.\n   * @implements ICNETMsg_PlayerAvatarData\n   * @constructor\n   * @param {ICNETMsg_PlayerAvatarData=} [properties] Properties to set\n   */\n  function CNETMsg_PlayerAvatarData(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CNETMsg_PlayerAvatarData accountid.\n   * @member {number} accountid\n   * @memberof CNETMsg_PlayerAvatarData\n   * @instance\n   */\n\n\n  CNETMsg_PlayerAvatarData.prototype.accountid = 0;\n  /**\n   * CNETMsg_PlayerAvatarData rgb.\n   * @member {Uint8Array} rgb\n   * @memberof CNETMsg_PlayerAvatarData\n   * @instance\n   */\n\n  CNETMsg_PlayerAvatarData.prototype.rgb = $util.newBuffer([]);\n  /**\n   * Decodes a CNETMsg_PlayerAvatarData message from the specified reader or buffer.\n   * @function decode\n   * @memberof CNETMsg_PlayerAvatarData\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CNETMsg_PlayerAvatarData} CNETMsg_PlayerAvatarData\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CNETMsg_PlayerAvatarData.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CNETMsg_PlayerAvatarData();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.accountid = reader.uint32();\n          break;\n\n        case 2:\n          message.rgb = reader.bytes();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CNETMsg_PlayerAvatarData;\n})();\n\nexports.CCLCMsg_ClientInfo = $root.CCLCMsg_ClientInfo = (() => {\n  /**\n   * Properties of a CCLCMsg_ClientInfo.\n   * @exports ICCLCMsg_ClientInfo\n   * @interface ICCLCMsg_ClientInfo\n   * @property {number|null} [sendTableCrc] CCLCMsg_ClientInfo sendTableCrc\n   * @property {number|null} [serverCount] CCLCMsg_ClientInfo serverCount\n   * @property {boolean|null} [isHltv] CCLCMsg_ClientInfo isHltv\n   * @property {boolean|null} [isReplay] CCLCMsg_ClientInfo isReplay\n   * @property {number|null} [friendsId] CCLCMsg_ClientInfo friendsId\n   * @property {string|null} [friendsName] CCLCMsg_ClientInfo friendsName\n   * @property {Array.<number>|null} [customFiles] CCLCMsg_ClientInfo customFiles\n   */\n\n  /**\n   * Constructs a new CCLCMsg_ClientInfo.\n   * @exports CCLCMsg_ClientInfo\n   * @classdesc Represents a CCLCMsg_ClientInfo.\n   * @implements ICCLCMsg_ClientInfo\n   * @constructor\n   * @param {ICCLCMsg_ClientInfo=} [properties] Properties to set\n   */\n  function CCLCMsg_ClientInfo(properties) {\n    this.customFiles = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCLCMsg_ClientInfo sendTableCrc.\n   * @member {number} sendTableCrc\n   * @memberof CCLCMsg_ClientInfo\n   * @instance\n   */\n\n\n  CCLCMsg_ClientInfo.prototype.sendTableCrc = 0;\n  /**\n   * CCLCMsg_ClientInfo serverCount.\n   * @member {number} serverCount\n   * @memberof CCLCMsg_ClientInfo\n   * @instance\n   */\n\n  CCLCMsg_ClientInfo.prototype.serverCount = 0;\n  /**\n   * CCLCMsg_ClientInfo isHltv.\n   * @member {boolean} isHltv\n   * @memberof CCLCMsg_ClientInfo\n   * @instance\n   */\n\n  CCLCMsg_ClientInfo.prototype.isHltv = false;\n  /**\n   * CCLCMsg_ClientInfo isReplay.\n   * @member {boolean} isReplay\n   * @memberof CCLCMsg_ClientInfo\n   * @instance\n   */\n\n  CCLCMsg_ClientInfo.prototype.isReplay = false;\n  /**\n   * CCLCMsg_ClientInfo friendsId.\n   * @member {number} friendsId\n   * @memberof CCLCMsg_ClientInfo\n   * @instance\n   */\n\n  CCLCMsg_ClientInfo.prototype.friendsId = 0;\n  /**\n   * CCLCMsg_ClientInfo friendsName.\n   * @member {string} friendsName\n   * @memberof CCLCMsg_ClientInfo\n   * @instance\n   */\n\n  CCLCMsg_ClientInfo.prototype.friendsName = \"\";\n  /**\n   * CCLCMsg_ClientInfo customFiles.\n   * @member {Array.<number>} customFiles\n   * @memberof CCLCMsg_ClientInfo\n   * @instance\n   */\n\n  CCLCMsg_ClientInfo.prototype.customFiles = $util.emptyArray;\n  /**\n   * Decodes a CCLCMsg_ClientInfo message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCLCMsg_ClientInfo\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCLCMsg_ClientInfo} CCLCMsg_ClientInfo\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCLCMsg_ClientInfo.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCLCMsg_ClientInfo();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.sendTableCrc = reader.fixed32();\n          break;\n\n        case 2:\n          message.serverCount = reader.uint32();\n          break;\n\n        case 3:\n          message.isHltv = reader.bool();\n          break;\n\n        case 4:\n          message.isReplay = reader.bool();\n          break;\n\n        case 5:\n          message.friendsId = reader.uint32();\n          break;\n\n        case 6:\n          message.friendsName = reader.string();\n          break;\n\n        case 7:\n          if (!(message.customFiles && message.customFiles.length)) message.customFiles = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.customFiles.push(reader.fixed32());\n          } else message.customFiles.push(reader.fixed32());\n\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCLCMsg_ClientInfo;\n})();\n\nexports.CCLCMsg_Move = $root.CCLCMsg_Move = (() => {\n  /**\n   * Properties of a CCLCMsg_Move.\n   * @exports ICCLCMsg_Move\n   * @interface ICCLCMsg_Move\n   * @property {number|null} [numBackupCommands] CCLCMsg_Move numBackupCommands\n   * @property {number|null} [numNewCommands] CCLCMsg_Move numNewCommands\n   * @property {Uint8Array|null} [data] CCLCMsg_Move data\n   */\n\n  /**\n   * Constructs a new CCLCMsg_Move.\n   * @exports CCLCMsg_Move\n   * @classdesc Represents a CCLCMsg_Move.\n   * @implements ICCLCMsg_Move\n   * @constructor\n   * @param {ICCLCMsg_Move=} [properties] Properties to set\n   */\n  function CCLCMsg_Move(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCLCMsg_Move numBackupCommands.\n   * @member {number} numBackupCommands\n   * @memberof CCLCMsg_Move\n   * @instance\n   */\n\n\n  CCLCMsg_Move.prototype.numBackupCommands = 0;\n  /**\n   * CCLCMsg_Move numNewCommands.\n   * @member {number} numNewCommands\n   * @memberof CCLCMsg_Move\n   * @instance\n   */\n\n  CCLCMsg_Move.prototype.numNewCommands = 0;\n  /**\n   * CCLCMsg_Move data.\n   * @member {Uint8Array} data\n   * @memberof CCLCMsg_Move\n   * @instance\n   */\n\n  CCLCMsg_Move.prototype.data = $util.newBuffer([]);\n  /**\n   * Decodes a CCLCMsg_Move message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCLCMsg_Move\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCLCMsg_Move} CCLCMsg_Move\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCLCMsg_Move.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCLCMsg_Move();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.numBackupCommands = reader.uint32();\n          break;\n\n        case 2:\n          message.numNewCommands = reader.uint32();\n          break;\n\n        case 3:\n          message.data = reader.bytes();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCLCMsg_Move;\n})();\n\nexports.CCLCMsg_VoiceData = $root.CCLCMsg_VoiceData = (() => {\n  /**\n   * Properties of a CCLCMsg_VoiceData.\n   * @exports ICCLCMsg_VoiceData\n   * @interface ICCLCMsg_VoiceData\n   * @property {Uint8Array|null} [data] CCLCMsg_VoiceData data\n   * @property {number|Long|null} [xuid] CCLCMsg_VoiceData xuid\n   * @property {VoiceDataFormat_t|null} [format] CCLCMsg_VoiceData format\n   * @property {number|null} [sequenceBytes] CCLCMsg_VoiceData sequenceBytes\n   * @property {number|null} [sectionNumber] CCLCMsg_VoiceData sectionNumber\n   * @property {number|null} [uncompressedSampleOffset] CCLCMsg_VoiceData uncompressedSampleOffset\n   */\n\n  /**\n   * Constructs a new CCLCMsg_VoiceData.\n   * @exports CCLCMsg_VoiceData\n   * @classdesc Represents a CCLCMsg_VoiceData.\n   * @implements ICCLCMsg_VoiceData\n   * @constructor\n   * @param {ICCLCMsg_VoiceData=} [properties] Properties to set\n   */\n  function CCLCMsg_VoiceData(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCLCMsg_VoiceData data.\n   * @member {Uint8Array} data\n   * @memberof CCLCMsg_VoiceData\n   * @instance\n   */\n\n\n  CCLCMsg_VoiceData.prototype.data = $util.newBuffer([]);\n  /**\n   * CCLCMsg_VoiceData xuid.\n   * @member {number|Long} xuid\n   * @memberof CCLCMsg_VoiceData\n   * @instance\n   */\n\n  CCLCMsg_VoiceData.prototype.xuid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n  /**\n   * CCLCMsg_VoiceData format.\n   * @member {VoiceDataFormat_t} format\n   * @memberof CCLCMsg_VoiceData\n   * @instance\n   */\n\n  CCLCMsg_VoiceData.prototype.format = 1;\n  /**\n   * CCLCMsg_VoiceData sequenceBytes.\n   * @member {number} sequenceBytes\n   * @memberof CCLCMsg_VoiceData\n   * @instance\n   */\n\n  CCLCMsg_VoiceData.prototype.sequenceBytes = 0;\n  /**\n   * CCLCMsg_VoiceData sectionNumber.\n   * @member {number} sectionNumber\n   * @memberof CCLCMsg_VoiceData\n   * @instance\n   */\n\n  CCLCMsg_VoiceData.prototype.sectionNumber = 0;\n  /**\n   * CCLCMsg_VoiceData uncompressedSampleOffset.\n   * @member {number} uncompressedSampleOffset\n   * @memberof CCLCMsg_VoiceData\n   * @instance\n   */\n\n  CCLCMsg_VoiceData.prototype.uncompressedSampleOffset = 0;\n  /**\n   * Decodes a CCLCMsg_VoiceData message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCLCMsg_VoiceData\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCLCMsg_VoiceData} CCLCMsg_VoiceData\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCLCMsg_VoiceData.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCLCMsg_VoiceData();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.data = reader.bytes();\n          break;\n\n        case 2:\n          message.xuid = reader.fixed64();\n          break;\n\n        case 3:\n          message.format = reader.int32();\n          break;\n\n        case 4:\n          message.sequenceBytes = reader.int32();\n          break;\n\n        case 5:\n          message.sectionNumber = reader.uint32();\n          break;\n\n        case 6:\n          message.uncompressedSampleOffset = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCLCMsg_VoiceData;\n})();\n\nexports.CCLCMsg_BaselineAck = $root.CCLCMsg_BaselineAck = (() => {\n  /**\n   * Properties of a CCLCMsg_BaselineAck.\n   * @exports ICCLCMsg_BaselineAck\n   * @interface ICCLCMsg_BaselineAck\n   * @property {number|null} [baselineTick] CCLCMsg_BaselineAck baselineTick\n   * @property {number|null} [baselineNr] CCLCMsg_BaselineAck baselineNr\n   */\n\n  /**\n   * Constructs a new CCLCMsg_BaselineAck.\n   * @exports CCLCMsg_BaselineAck\n   * @classdesc Represents a CCLCMsg_BaselineAck.\n   * @implements ICCLCMsg_BaselineAck\n   * @constructor\n   * @param {ICCLCMsg_BaselineAck=} [properties] Properties to set\n   */\n  function CCLCMsg_BaselineAck(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCLCMsg_BaselineAck baselineTick.\n   * @member {number} baselineTick\n   * @memberof CCLCMsg_BaselineAck\n   * @instance\n   */\n\n\n  CCLCMsg_BaselineAck.prototype.baselineTick = 0;\n  /**\n   * CCLCMsg_BaselineAck baselineNr.\n   * @member {number} baselineNr\n   * @memberof CCLCMsg_BaselineAck\n   * @instance\n   */\n\n  CCLCMsg_BaselineAck.prototype.baselineNr = 0;\n  /**\n   * Decodes a CCLCMsg_BaselineAck message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCLCMsg_BaselineAck\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCLCMsg_BaselineAck} CCLCMsg_BaselineAck\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCLCMsg_BaselineAck.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCLCMsg_BaselineAck();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.baselineTick = reader.int32();\n          break;\n\n        case 2:\n          message.baselineNr = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCLCMsg_BaselineAck;\n})();\n\nexports.CCLCMsg_ListenEvents = $root.CCLCMsg_ListenEvents = (() => {\n  /**\n   * Properties of a CCLCMsg_ListenEvents.\n   * @exports ICCLCMsg_ListenEvents\n   * @interface ICCLCMsg_ListenEvents\n   * @property {Array.<number>|null} [eventMask] CCLCMsg_ListenEvents eventMask\n   */\n\n  /**\n   * Constructs a new CCLCMsg_ListenEvents.\n   * @exports CCLCMsg_ListenEvents\n   * @classdesc Represents a CCLCMsg_ListenEvents.\n   * @implements ICCLCMsg_ListenEvents\n   * @constructor\n   * @param {ICCLCMsg_ListenEvents=} [properties] Properties to set\n   */\n  function CCLCMsg_ListenEvents(properties) {\n    this.eventMask = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCLCMsg_ListenEvents eventMask.\n   * @member {Array.<number>} eventMask\n   * @memberof CCLCMsg_ListenEvents\n   * @instance\n   */\n\n\n  CCLCMsg_ListenEvents.prototype.eventMask = $util.emptyArray;\n  /**\n   * Decodes a CCLCMsg_ListenEvents message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCLCMsg_ListenEvents\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCLCMsg_ListenEvents} CCLCMsg_ListenEvents\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCLCMsg_ListenEvents.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCLCMsg_ListenEvents();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.eventMask && message.eventMask.length)) message.eventMask = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.eventMask.push(reader.fixed32());\n          } else message.eventMask.push(reader.fixed32());\n\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCLCMsg_ListenEvents;\n})();\n\nexports.CCLCMsg_RespondCvarValue = $root.CCLCMsg_RespondCvarValue = (() => {\n  /**\n   * Properties of a CCLCMsg_RespondCvarValue.\n   * @exports ICCLCMsg_RespondCvarValue\n   * @interface ICCLCMsg_RespondCvarValue\n   * @property {number|null} [cookie] CCLCMsg_RespondCvarValue cookie\n   * @property {number|null} [statusCode] CCLCMsg_RespondCvarValue statusCode\n   * @property {string|null} [name] CCLCMsg_RespondCvarValue name\n   * @property {string|null} [value] CCLCMsg_RespondCvarValue value\n   */\n\n  /**\n   * Constructs a new CCLCMsg_RespondCvarValue.\n   * @exports CCLCMsg_RespondCvarValue\n   * @classdesc Represents a CCLCMsg_RespondCvarValue.\n   * @implements ICCLCMsg_RespondCvarValue\n   * @constructor\n   * @param {ICCLCMsg_RespondCvarValue=} [properties] Properties to set\n   */\n  function CCLCMsg_RespondCvarValue(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCLCMsg_RespondCvarValue cookie.\n   * @member {number} cookie\n   * @memberof CCLCMsg_RespondCvarValue\n   * @instance\n   */\n\n\n  CCLCMsg_RespondCvarValue.prototype.cookie = 0;\n  /**\n   * CCLCMsg_RespondCvarValue statusCode.\n   * @member {number} statusCode\n   * @memberof CCLCMsg_RespondCvarValue\n   * @instance\n   */\n\n  CCLCMsg_RespondCvarValue.prototype.statusCode = 0;\n  /**\n   * CCLCMsg_RespondCvarValue name.\n   * @member {string} name\n   * @memberof CCLCMsg_RespondCvarValue\n   * @instance\n   */\n\n  CCLCMsg_RespondCvarValue.prototype.name = \"\";\n  /**\n   * CCLCMsg_RespondCvarValue value.\n   * @member {string} value\n   * @memberof CCLCMsg_RespondCvarValue\n   * @instance\n   */\n\n  CCLCMsg_RespondCvarValue.prototype.value = \"\";\n  /**\n   * Decodes a CCLCMsg_RespondCvarValue message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCLCMsg_RespondCvarValue\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCLCMsg_RespondCvarValue} CCLCMsg_RespondCvarValue\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCLCMsg_RespondCvarValue.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCLCMsg_RespondCvarValue();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.cookie = reader.int32();\n          break;\n\n        case 2:\n          message.statusCode = reader.int32();\n          break;\n\n        case 3:\n          message.name = reader.string();\n          break;\n\n        case 4:\n          message.value = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCLCMsg_RespondCvarValue;\n})();\n\nexports.CCLCMsg_FileCRCCheck = $root.CCLCMsg_FileCRCCheck = (() => {\n  /**\n   * Properties of a CCLCMsg_FileCRCCheck.\n   * @exports ICCLCMsg_FileCRCCheck\n   * @interface ICCLCMsg_FileCRCCheck\n   * @property {number|null} [codePath] CCLCMsg_FileCRCCheck codePath\n   * @property {string|null} [path] CCLCMsg_FileCRCCheck path\n   * @property {number|null} [codeFilename] CCLCMsg_FileCRCCheck codeFilename\n   * @property {string|null} [filename] CCLCMsg_FileCRCCheck filename\n   * @property {number|null} [fileFraction] CCLCMsg_FileCRCCheck fileFraction\n   * @property {Uint8Array|null} [md5] CCLCMsg_FileCRCCheck md5\n   * @property {number|null} [crc] CCLCMsg_FileCRCCheck crc\n   * @property {number|null} [fileHashType] CCLCMsg_FileCRCCheck fileHashType\n   * @property {number|null} [fileLen] CCLCMsg_FileCRCCheck fileLen\n   * @property {number|null} [packFileId] CCLCMsg_FileCRCCheck packFileId\n   * @property {number|null} [packFileNumber] CCLCMsg_FileCRCCheck packFileNumber\n   */\n\n  /**\n   * Constructs a new CCLCMsg_FileCRCCheck.\n   * @exports CCLCMsg_FileCRCCheck\n   * @classdesc Represents a CCLCMsg_FileCRCCheck.\n   * @implements ICCLCMsg_FileCRCCheck\n   * @constructor\n   * @param {ICCLCMsg_FileCRCCheck=} [properties] Properties to set\n   */\n  function CCLCMsg_FileCRCCheck(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCLCMsg_FileCRCCheck codePath.\n   * @member {number} codePath\n   * @memberof CCLCMsg_FileCRCCheck\n   * @instance\n   */\n\n\n  CCLCMsg_FileCRCCheck.prototype.codePath = 0;\n  /**\n   * CCLCMsg_FileCRCCheck path.\n   * @member {string} path\n   * @memberof CCLCMsg_FileCRCCheck\n   * @instance\n   */\n\n  CCLCMsg_FileCRCCheck.prototype.path = \"\";\n  /**\n   * CCLCMsg_FileCRCCheck codeFilename.\n   * @member {number} codeFilename\n   * @memberof CCLCMsg_FileCRCCheck\n   * @instance\n   */\n\n  CCLCMsg_FileCRCCheck.prototype.codeFilename = 0;\n  /**\n   * CCLCMsg_FileCRCCheck filename.\n   * @member {string} filename\n   * @memberof CCLCMsg_FileCRCCheck\n   * @instance\n   */\n\n  CCLCMsg_FileCRCCheck.prototype.filename = \"\";\n  /**\n   * CCLCMsg_FileCRCCheck fileFraction.\n   * @member {number} fileFraction\n   * @memberof CCLCMsg_FileCRCCheck\n   * @instance\n   */\n\n  CCLCMsg_FileCRCCheck.prototype.fileFraction = 0;\n  /**\n   * CCLCMsg_FileCRCCheck md5.\n   * @member {Uint8Array} md5\n   * @memberof CCLCMsg_FileCRCCheck\n   * @instance\n   */\n\n  CCLCMsg_FileCRCCheck.prototype.md5 = $util.newBuffer([]);\n  /**\n   * CCLCMsg_FileCRCCheck crc.\n   * @member {number} crc\n   * @memberof CCLCMsg_FileCRCCheck\n   * @instance\n   */\n\n  CCLCMsg_FileCRCCheck.prototype.crc = 0;\n  /**\n   * CCLCMsg_FileCRCCheck fileHashType.\n   * @member {number} fileHashType\n   * @memberof CCLCMsg_FileCRCCheck\n   * @instance\n   */\n\n  CCLCMsg_FileCRCCheck.prototype.fileHashType = 0;\n  /**\n   * CCLCMsg_FileCRCCheck fileLen.\n   * @member {number} fileLen\n   * @memberof CCLCMsg_FileCRCCheck\n   * @instance\n   */\n\n  CCLCMsg_FileCRCCheck.prototype.fileLen = 0;\n  /**\n   * CCLCMsg_FileCRCCheck packFileId.\n   * @member {number} packFileId\n   * @memberof CCLCMsg_FileCRCCheck\n   * @instance\n   */\n\n  CCLCMsg_FileCRCCheck.prototype.packFileId = 0;\n  /**\n   * CCLCMsg_FileCRCCheck packFileNumber.\n   * @member {number} packFileNumber\n   * @memberof CCLCMsg_FileCRCCheck\n   * @instance\n   */\n\n  CCLCMsg_FileCRCCheck.prototype.packFileNumber = 0;\n  /**\n   * Decodes a CCLCMsg_FileCRCCheck message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCLCMsg_FileCRCCheck\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCLCMsg_FileCRCCheck} CCLCMsg_FileCRCCheck\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCLCMsg_FileCRCCheck.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCLCMsg_FileCRCCheck();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.codePath = reader.int32();\n          break;\n\n        case 2:\n          message.path = reader.string();\n          break;\n\n        case 3:\n          message.codeFilename = reader.int32();\n          break;\n\n        case 4:\n          message.filename = reader.string();\n          break;\n\n        case 5:\n          message.fileFraction = reader.int32();\n          break;\n\n        case 6:\n          message.md5 = reader.bytes();\n          break;\n\n        case 7:\n          message.crc = reader.uint32();\n          break;\n\n        case 8:\n          message.fileHashType = reader.int32();\n          break;\n\n        case 9:\n          message.fileLen = reader.int32();\n          break;\n\n        case 10:\n          message.packFileId = reader.int32();\n          break;\n\n        case 11:\n          message.packFileNumber = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCLCMsg_FileCRCCheck;\n})();\n\nexports.CCLCMsg_LoadingProgress = $root.CCLCMsg_LoadingProgress = (() => {\n  /**\n   * Properties of a CCLCMsg_LoadingProgress.\n   * @exports ICCLCMsg_LoadingProgress\n   * @interface ICCLCMsg_LoadingProgress\n   * @property {number|null} [progress] CCLCMsg_LoadingProgress progress\n   */\n\n  /**\n   * Constructs a new CCLCMsg_LoadingProgress.\n   * @exports CCLCMsg_LoadingProgress\n   * @classdesc Represents a CCLCMsg_LoadingProgress.\n   * @implements ICCLCMsg_LoadingProgress\n   * @constructor\n   * @param {ICCLCMsg_LoadingProgress=} [properties] Properties to set\n   */\n  function CCLCMsg_LoadingProgress(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCLCMsg_LoadingProgress progress.\n   * @member {number} progress\n   * @memberof CCLCMsg_LoadingProgress\n   * @instance\n   */\n\n\n  CCLCMsg_LoadingProgress.prototype.progress = 0;\n  /**\n   * Decodes a CCLCMsg_LoadingProgress message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCLCMsg_LoadingProgress\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCLCMsg_LoadingProgress} CCLCMsg_LoadingProgress\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCLCMsg_LoadingProgress.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCLCMsg_LoadingProgress();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.progress = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCLCMsg_LoadingProgress;\n})();\n\nexports.CCLCMsg_SplitPlayerConnect = $root.CCLCMsg_SplitPlayerConnect = (() => {\n  /**\n   * Properties of a CCLCMsg_SplitPlayerConnect.\n   * @exports ICCLCMsg_SplitPlayerConnect\n   * @interface ICCLCMsg_SplitPlayerConnect\n   * @property {ICMsg_CVars|null} [convars] CCLCMsg_SplitPlayerConnect convars\n   */\n\n  /**\n   * Constructs a new CCLCMsg_SplitPlayerConnect.\n   * @exports CCLCMsg_SplitPlayerConnect\n   * @classdesc Represents a CCLCMsg_SplitPlayerConnect.\n   * @implements ICCLCMsg_SplitPlayerConnect\n   * @constructor\n   * @param {ICCLCMsg_SplitPlayerConnect=} [properties] Properties to set\n   */\n  function CCLCMsg_SplitPlayerConnect(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCLCMsg_SplitPlayerConnect convars.\n   * @member {ICMsg_CVars|null|undefined} convars\n   * @memberof CCLCMsg_SplitPlayerConnect\n   * @instance\n   */\n\n\n  CCLCMsg_SplitPlayerConnect.prototype.convars = null;\n  /**\n   * Decodes a CCLCMsg_SplitPlayerConnect message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCLCMsg_SplitPlayerConnect\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCLCMsg_SplitPlayerConnect} CCLCMsg_SplitPlayerConnect\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCLCMsg_SplitPlayerConnect.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCLCMsg_SplitPlayerConnect();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.convars = $root.CMsg_CVars.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCLCMsg_SplitPlayerConnect;\n})();\n\nexports.CCLCMsg_CmdKeyValues = $root.CCLCMsg_CmdKeyValues = (() => {\n  /**\n   * Properties of a CCLCMsg_CmdKeyValues.\n   * @exports ICCLCMsg_CmdKeyValues\n   * @interface ICCLCMsg_CmdKeyValues\n   * @property {Uint8Array|null} [keyvalues] CCLCMsg_CmdKeyValues keyvalues\n   */\n\n  /**\n   * Constructs a new CCLCMsg_CmdKeyValues.\n   * @exports CCLCMsg_CmdKeyValues\n   * @classdesc Represents a CCLCMsg_CmdKeyValues.\n   * @implements ICCLCMsg_CmdKeyValues\n   * @constructor\n   * @param {ICCLCMsg_CmdKeyValues=} [properties] Properties to set\n   */\n  function CCLCMsg_CmdKeyValues(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCLCMsg_CmdKeyValues keyvalues.\n   * @member {Uint8Array} keyvalues\n   * @memberof CCLCMsg_CmdKeyValues\n   * @instance\n   */\n\n\n  CCLCMsg_CmdKeyValues.prototype.keyvalues = $util.newBuffer([]);\n  /**\n   * Decodes a CCLCMsg_CmdKeyValues message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCLCMsg_CmdKeyValues\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCLCMsg_CmdKeyValues} CCLCMsg_CmdKeyValues\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCLCMsg_CmdKeyValues.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCLCMsg_CmdKeyValues();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.keyvalues = reader.bytes();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCLCMsg_CmdKeyValues;\n})();\n\nexports.CSVCMsg_ServerInfo = $root.CSVCMsg_ServerInfo = (() => {\n  /**\n   * Properties of a CSVCMsg_ServerInfo.\n   * @exports ICSVCMsg_ServerInfo\n   * @interface ICSVCMsg_ServerInfo\n   * @property {number|null} [protocol] CSVCMsg_ServerInfo protocol\n   * @property {number|null} [serverCount] CSVCMsg_ServerInfo serverCount\n   * @property {boolean|null} [isDedicated] CSVCMsg_ServerInfo isDedicated\n   * @property {boolean|null} [isOfficialValveServer] CSVCMsg_ServerInfo isOfficialValveServer\n   * @property {boolean|null} [isHltv] CSVCMsg_ServerInfo isHltv\n   * @property {boolean|null} [isReplay] CSVCMsg_ServerInfo isReplay\n   * @property {boolean|null} [isRedirectingToProxyRelay] CSVCMsg_ServerInfo isRedirectingToProxyRelay\n   * @property {number|null} [cOs] CSVCMsg_ServerInfo cOs\n   * @property {number|null} [mapCrc] CSVCMsg_ServerInfo mapCrc\n   * @property {number|null} [clientCrc] CSVCMsg_ServerInfo clientCrc\n   * @property {number|null} [stringTableCrc] CSVCMsg_ServerInfo stringTableCrc\n   * @property {number|null} [maxClients] CSVCMsg_ServerInfo maxClients\n   * @property {number|null} [maxClasses] CSVCMsg_ServerInfo maxClasses\n   * @property {number|null} [playerSlot] CSVCMsg_ServerInfo playerSlot\n   * @property {number|null} [tickInterval] CSVCMsg_ServerInfo tickInterval\n   * @property {string|null} [gameDir] CSVCMsg_ServerInfo gameDir\n   * @property {string|null} [mapName] CSVCMsg_ServerInfo mapName\n   * @property {string|null} [mapGroupName] CSVCMsg_ServerInfo mapGroupName\n   * @property {string|null} [skyName] CSVCMsg_ServerInfo skyName\n   * @property {string|null} [hostName] CSVCMsg_ServerInfo hostName\n   * @property {number|null} [publicIp] CSVCMsg_ServerInfo publicIp\n   * @property {number|Long|null} [ugcMapId] CSVCMsg_ServerInfo ugcMapId\n   */\n\n  /**\n   * Constructs a new CSVCMsg_ServerInfo.\n   * @exports CSVCMsg_ServerInfo\n   * @classdesc Represents a CSVCMsg_ServerInfo.\n   * @implements ICSVCMsg_ServerInfo\n   * @constructor\n   * @param {ICSVCMsg_ServerInfo=} [properties] Properties to set\n   */\n  function CSVCMsg_ServerInfo(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_ServerInfo protocol.\n   * @member {number} protocol\n   * @memberof CSVCMsg_ServerInfo\n   * @instance\n   */\n\n\n  CSVCMsg_ServerInfo.prototype.protocol = 0;\n  /**\n   * CSVCMsg_ServerInfo serverCount.\n   * @member {number} serverCount\n   * @memberof CSVCMsg_ServerInfo\n   * @instance\n   */\n\n  CSVCMsg_ServerInfo.prototype.serverCount = 0;\n  /**\n   * CSVCMsg_ServerInfo isDedicated.\n   * @member {boolean} isDedicated\n   * @memberof CSVCMsg_ServerInfo\n   * @instance\n   */\n\n  CSVCMsg_ServerInfo.prototype.isDedicated = false;\n  /**\n   * CSVCMsg_ServerInfo isOfficialValveServer.\n   * @member {boolean} isOfficialValveServer\n   * @memberof CSVCMsg_ServerInfo\n   * @instance\n   */\n\n  CSVCMsg_ServerInfo.prototype.isOfficialValveServer = false;\n  /**\n   * CSVCMsg_ServerInfo isHltv.\n   * @member {boolean} isHltv\n   * @memberof CSVCMsg_ServerInfo\n   * @instance\n   */\n\n  CSVCMsg_ServerInfo.prototype.isHltv = false;\n  /**\n   * CSVCMsg_ServerInfo isReplay.\n   * @member {boolean} isReplay\n   * @memberof CSVCMsg_ServerInfo\n   * @instance\n   */\n\n  CSVCMsg_ServerInfo.prototype.isReplay = false;\n  /**\n   * CSVCMsg_ServerInfo isRedirectingToProxyRelay.\n   * @member {boolean} isRedirectingToProxyRelay\n   * @memberof CSVCMsg_ServerInfo\n   * @instance\n   */\n\n  CSVCMsg_ServerInfo.prototype.isRedirectingToProxyRelay = false;\n  /**\n   * CSVCMsg_ServerInfo cOs.\n   * @member {number} cOs\n   * @memberof CSVCMsg_ServerInfo\n   * @instance\n   */\n\n  CSVCMsg_ServerInfo.prototype.cOs = 0;\n  /**\n   * CSVCMsg_ServerInfo mapCrc.\n   * @member {number} mapCrc\n   * @memberof CSVCMsg_ServerInfo\n   * @instance\n   */\n\n  CSVCMsg_ServerInfo.prototype.mapCrc = 0;\n  /**\n   * CSVCMsg_ServerInfo clientCrc.\n   * @member {number} clientCrc\n   * @memberof CSVCMsg_ServerInfo\n   * @instance\n   */\n\n  CSVCMsg_ServerInfo.prototype.clientCrc = 0;\n  /**\n   * CSVCMsg_ServerInfo stringTableCrc.\n   * @member {number} stringTableCrc\n   * @memberof CSVCMsg_ServerInfo\n   * @instance\n   */\n\n  CSVCMsg_ServerInfo.prototype.stringTableCrc = 0;\n  /**\n   * CSVCMsg_ServerInfo maxClients.\n   * @member {number} maxClients\n   * @memberof CSVCMsg_ServerInfo\n   * @instance\n   */\n\n  CSVCMsg_ServerInfo.prototype.maxClients = 0;\n  /**\n   * CSVCMsg_ServerInfo maxClasses.\n   * @member {number} maxClasses\n   * @memberof CSVCMsg_ServerInfo\n   * @instance\n   */\n\n  CSVCMsg_ServerInfo.prototype.maxClasses = 0;\n  /**\n   * CSVCMsg_ServerInfo playerSlot.\n   * @member {number} playerSlot\n   * @memberof CSVCMsg_ServerInfo\n   * @instance\n   */\n\n  CSVCMsg_ServerInfo.prototype.playerSlot = 0;\n  /**\n   * CSVCMsg_ServerInfo tickInterval.\n   * @member {number} tickInterval\n   * @memberof CSVCMsg_ServerInfo\n   * @instance\n   */\n\n  CSVCMsg_ServerInfo.prototype.tickInterval = 0;\n  /**\n   * CSVCMsg_ServerInfo gameDir.\n   * @member {string} gameDir\n   * @memberof CSVCMsg_ServerInfo\n   * @instance\n   */\n\n  CSVCMsg_ServerInfo.prototype.gameDir = \"\";\n  /**\n   * CSVCMsg_ServerInfo mapName.\n   * @member {string} mapName\n   * @memberof CSVCMsg_ServerInfo\n   * @instance\n   */\n\n  CSVCMsg_ServerInfo.prototype.mapName = \"\";\n  /**\n   * CSVCMsg_ServerInfo mapGroupName.\n   * @member {string} mapGroupName\n   * @memberof CSVCMsg_ServerInfo\n   * @instance\n   */\n\n  CSVCMsg_ServerInfo.prototype.mapGroupName = \"\";\n  /**\n   * CSVCMsg_ServerInfo skyName.\n   * @member {string} skyName\n   * @memberof CSVCMsg_ServerInfo\n   * @instance\n   */\n\n  CSVCMsg_ServerInfo.prototype.skyName = \"\";\n  /**\n   * CSVCMsg_ServerInfo hostName.\n   * @member {string} hostName\n   * @memberof CSVCMsg_ServerInfo\n   * @instance\n   */\n\n  CSVCMsg_ServerInfo.prototype.hostName = \"\";\n  /**\n   * CSVCMsg_ServerInfo publicIp.\n   * @member {number} publicIp\n   * @memberof CSVCMsg_ServerInfo\n   * @instance\n   */\n\n  CSVCMsg_ServerInfo.prototype.publicIp = 0;\n  /**\n   * CSVCMsg_ServerInfo ugcMapId.\n   * @member {number|Long} ugcMapId\n   * @memberof CSVCMsg_ServerInfo\n   * @instance\n   */\n\n  CSVCMsg_ServerInfo.prototype.ugcMapId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * Decodes a CSVCMsg_ServerInfo message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_ServerInfo\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_ServerInfo} CSVCMsg_ServerInfo\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_ServerInfo.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_ServerInfo();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.protocol = reader.int32();\n          break;\n\n        case 2:\n          message.serverCount = reader.int32();\n          break;\n\n        case 3:\n          message.isDedicated = reader.bool();\n          break;\n\n        case 4:\n          message.isOfficialValveServer = reader.bool();\n          break;\n\n        case 5:\n          message.isHltv = reader.bool();\n          break;\n\n        case 6:\n          message.isReplay = reader.bool();\n          break;\n\n        case 21:\n          message.isRedirectingToProxyRelay = reader.bool();\n          break;\n\n        case 7:\n          message.cOs = reader.int32();\n          break;\n\n        case 8:\n          message.mapCrc = reader.fixed32();\n          break;\n\n        case 9:\n          message.clientCrc = reader.fixed32();\n          break;\n\n        case 10:\n          message.stringTableCrc = reader.fixed32();\n          break;\n\n        case 11:\n          message.maxClients = reader.int32();\n          break;\n\n        case 12:\n          message.maxClasses = reader.int32();\n          break;\n\n        case 13:\n          message.playerSlot = reader.int32();\n          break;\n\n        case 14:\n          message.tickInterval = reader.float();\n          break;\n\n        case 15:\n          message.gameDir = reader.string();\n          break;\n\n        case 16:\n          message.mapName = reader.string();\n          break;\n\n        case 17:\n          message.mapGroupName = reader.string();\n          break;\n\n        case 18:\n          message.skyName = reader.string();\n          break;\n\n        case 19:\n          message.hostName = reader.string();\n          break;\n\n        case 20:\n          message.publicIp = reader.uint32();\n          break;\n\n        case 22:\n          message.ugcMapId = reader.uint64();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CSVCMsg_ServerInfo;\n})();\n\nexports.CSVCMsg_ClassInfo = $root.CSVCMsg_ClassInfo = (() => {\n  /**\n   * Properties of a CSVCMsg_ClassInfo.\n   * @exports ICSVCMsg_ClassInfo\n   * @interface ICSVCMsg_ClassInfo\n   * @property {boolean|null} [createOnClient] CSVCMsg_ClassInfo createOnClient\n   * @property {Array.<CSVCMsg_ClassInfo.Iclass_t>|null} [classes] CSVCMsg_ClassInfo classes\n   */\n\n  /**\n   * Constructs a new CSVCMsg_ClassInfo.\n   * @exports CSVCMsg_ClassInfo\n   * @classdesc Represents a CSVCMsg_ClassInfo.\n   * @implements ICSVCMsg_ClassInfo\n   * @constructor\n   * @param {ICSVCMsg_ClassInfo=} [properties] Properties to set\n   */\n  function CSVCMsg_ClassInfo(properties) {\n    this.classes = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_ClassInfo createOnClient.\n   * @member {boolean} createOnClient\n   * @memberof CSVCMsg_ClassInfo\n   * @instance\n   */\n\n\n  CSVCMsg_ClassInfo.prototype.createOnClient = false;\n  /**\n   * CSVCMsg_ClassInfo classes.\n   * @member {Array.<CSVCMsg_ClassInfo.Iclass_t>} classes\n   * @memberof CSVCMsg_ClassInfo\n   * @instance\n   */\n\n  CSVCMsg_ClassInfo.prototype.classes = $util.emptyArray;\n  /**\n   * Decodes a CSVCMsg_ClassInfo message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_ClassInfo\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_ClassInfo} CSVCMsg_ClassInfo\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_ClassInfo.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_ClassInfo();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.createOnClient = reader.bool();\n          break;\n\n        case 2:\n          if (!(message.classes && message.classes.length)) message.classes = [];\n          message.classes.push($root.CSVCMsg_ClassInfo.class_t.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CSVCMsg_ClassInfo.class_t = function () {\n    /**\n     * Properties of a class_t.\n     * @memberof CSVCMsg_ClassInfo\n     * @interface Iclass_t\n     * @property {number|null} [classId] class_t classId\n     * @property {string|null} [dataTableName] class_t dataTableName\n     * @property {string|null} [className] class_t className\n     */\n\n    /**\n     * Constructs a new class_t.\n     * @memberof CSVCMsg_ClassInfo\n     * @classdesc Represents a class_t.\n     * @implements Iclass_t\n     * @constructor\n     * @param {CSVCMsg_ClassInfo.Iclass_t=} [properties] Properties to set\n     */\n    function class_t(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * class_t classId.\n     * @member {number} classId\n     * @memberof CSVCMsg_ClassInfo.class_t\n     * @instance\n     */\n\n\n    class_t.prototype.classId = 0;\n    /**\n     * class_t dataTableName.\n     * @member {string} dataTableName\n     * @memberof CSVCMsg_ClassInfo.class_t\n     * @instance\n     */\n\n    class_t.prototype.dataTableName = \"\";\n    /**\n     * class_t className.\n     * @member {string} className\n     * @memberof CSVCMsg_ClassInfo.class_t\n     * @instance\n     */\n\n    class_t.prototype.className = \"\";\n    /**\n     * Decodes a class_t message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_ClassInfo.class_t\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_ClassInfo.class_t} class_t\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    class_t.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CSVCMsg_ClassInfo.class_t();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.classId = reader.int32();\n            break;\n\n          case 2:\n            message.dataTableName = reader.string();\n            break;\n\n          case 3:\n            message.className = reader.string();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return class_t;\n  }();\n\n  return CSVCMsg_ClassInfo;\n})();\n\nexports.CSVCMsg_SendTable = $root.CSVCMsg_SendTable = (() => {\n  /**\n   * Properties of a CSVCMsg_SendTable.\n   * @exports ICSVCMsg_SendTable\n   * @interface ICSVCMsg_SendTable\n   * @property {boolean|null} [isEnd] CSVCMsg_SendTable isEnd\n   * @property {string|null} [netTableName] CSVCMsg_SendTable netTableName\n   * @property {boolean|null} [needsDecoder] CSVCMsg_SendTable needsDecoder\n   * @property {Array.<CSVCMsg_SendTable.Isendprop_t>|null} [props] CSVCMsg_SendTable props\n   */\n\n  /**\n   * Constructs a new CSVCMsg_SendTable.\n   * @exports CSVCMsg_SendTable\n   * @classdesc Represents a CSVCMsg_SendTable.\n   * @implements ICSVCMsg_SendTable\n   * @constructor\n   * @param {ICSVCMsg_SendTable=} [properties] Properties to set\n   */\n  function CSVCMsg_SendTable(properties) {\n    this.props = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_SendTable isEnd.\n   * @member {boolean} isEnd\n   * @memberof CSVCMsg_SendTable\n   * @instance\n   */\n\n\n  CSVCMsg_SendTable.prototype.isEnd = false;\n  /**\n   * CSVCMsg_SendTable netTableName.\n   * @member {string} netTableName\n   * @memberof CSVCMsg_SendTable\n   * @instance\n   */\n\n  CSVCMsg_SendTable.prototype.netTableName = \"\";\n  /**\n   * CSVCMsg_SendTable needsDecoder.\n   * @member {boolean} needsDecoder\n   * @memberof CSVCMsg_SendTable\n   * @instance\n   */\n\n  CSVCMsg_SendTable.prototype.needsDecoder = false;\n  /**\n   * CSVCMsg_SendTable props.\n   * @member {Array.<CSVCMsg_SendTable.Isendprop_t>} props\n   * @memberof CSVCMsg_SendTable\n   * @instance\n   */\n\n  CSVCMsg_SendTable.prototype.props = $util.emptyArray;\n  /**\n   * Decodes a CSVCMsg_SendTable message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_SendTable\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_SendTable} CSVCMsg_SendTable\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_SendTable.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_SendTable();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.isEnd = reader.bool();\n          break;\n\n        case 2:\n          message.netTableName = reader.string();\n          break;\n\n        case 3:\n          message.needsDecoder = reader.bool();\n          break;\n\n        case 4:\n          if (!(message.props && message.props.length)) message.props = [];\n          message.props.push($root.CSVCMsg_SendTable.sendprop_t.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CSVCMsg_SendTable.sendprop_t = function () {\n    /**\n     * Properties of a sendprop_t.\n     * @memberof CSVCMsg_SendTable\n     * @interface Isendprop_t\n     * @property {number|null} [type] sendprop_t type\n     * @property {string|null} [varName] sendprop_t varName\n     * @property {number|null} [flags] sendprop_t flags\n     * @property {number|null} [priority] sendprop_t priority\n     * @property {string|null} [dtName] sendprop_t dtName\n     * @property {number|null} [numElements] sendprop_t numElements\n     * @property {number|null} [lowValue] sendprop_t lowValue\n     * @property {number|null} [highValue] sendprop_t highValue\n     * @property {number|null} [numBits] sendprop_t numBits\n     */\n\n    /**\n     * Constructs a new sendprop_t.\n     * @memberof CSVCMsg_SendTable\n     * @classdesc Represents a sendprop_t.\n     * @implements Isendprop_t\n     * @constructor\n     * @param {CSVCMsg_SendTable.Isendprop_t=} [properties] Properties to set\n     */\n    function sendprop_t(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * sendprop_t type.\n     * @member {number} type\n     * @memberof CSVCMsg_SendTable.sendprop_t\n     * @instance\n     */\n\n\n    sendprop_t.prototype.type = 0;\n    /**\n     * sendprop_t varName.\n     * @member {string} varName\n     * @memberof CSVCMsg_SendTable.sendprop_t\n     * @instance\n     */\n\n    sendprop_t.prototype.varName = \"\";\n    /**\n     * sendprop_t flags.\n     * @member {number} flags\n     * @memberof CSVCMsg_SendTable.sendprop_t\n     * @instance\n     */\n\n    sendprop_t.prototype.flags = 0;\n    /**\n     * sendprop_t priority.\n     * @member {number} priority\n     * @memberof CSVCMsg_SendTable.sendprop_t\n     * @instance\n     */\n\n    sendprop_t.prototype.priority = 0;\n    /**\n     * sendprop_t dtName.\n     * @member {string} dtName\n     * @memberof CSVCMsg_SendTable.sendprop_t\n     * @instance\n     */\n\n    sendprop_t.prototype.dtName = \"\";\n    /**\n     * sendprop_t numElements.\n     * @member {number} numElements\n     * @memberof CSVCMsg_SendTable.sendprop_t\n     * @instance\n     */\n\n    sendprop_t.prototype.numElements = 0;\n    /**\n     * sendprop_t lowValue.\n     * @member {number} lowValue\n     * @memberof CSVCMsg_SendTable.sendprop_t\n     * @instance\n     */\n\n    sendprop_t.prototype.lowValue = 0;\n    /**\n     * sendprop_t highValue.\n     * @member {number} highValue\n     * @memberof CSVCMsg_SendTable.sendprop_t\n     * @instance\n     */\n\n    sendprop_t.prototype.highValue = 0;\n    /**\n     * sendprop_t numBits.\n     * @member {number} numBits\n     * @memberof CSVCMsg_SendTable.sendprop_t\n     * @instance\n     */\n\n    sendprop_t.prototype.numBits = 0;\n    /**\n     * Decodes a sendprop_t message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_SendTable.sendprop_t\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_SendTable.sendprop_t} sendprop_t\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    sendprop_t.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CSVCMsg_SendTable.sendprop_t();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.type = reader.int32();\n            break;\n\n          case 2:\n            message.varName = reader.string();\n            break;\n\n          case 3:\n            message.flags = reader.int32();\n            break;\n\n          case 4:\n            message.priority = reader.int32();\n            break;\n\n          case 5:\n            message.dtName = reader.string();\n            break;\n\n          case 6:\n            message.numElements = reader.int32();\n            break;\n\n          case 7:\n            message.lowValue = reader.float();\n            break;\n\n          case 8:\n            message.highValue = reader.float();\n            break;\n\n          case 9:\n            message.numBits = reader.int32();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return sendprop_t;\n  }();\n\n  return CSVCMsg_SendTable;\n})();\n\nexports.CSVCMsg_Print = $root.CSVCMsg_Print = (() => {\n  /**\n   * Properties of a CSVCMsg_Print.\n   * @exports ICSVCMsg_Print\n   * @interface ICSVCMsg_Print\n   * @property {string|null} [text] CSVCMsg_Print text\n   */\n\n  /**\n   * Constructs a new CSVCMsg_Print.\n   * @exports CSVCMsg_Print\n   * @classdesc Represents a CSVCMsg_Print.\n   * @implements ICSVCMsg_Print\n   * @constructor\n   * @param {ICSVCMsg_Print=} [properties] Properties to set\n   */\n  function CSVCMsg_Print(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_Print text.\n   * @member {string} text\n   * @memberof CSVCMsg_Print\n   * @instance\n   */\n\n\n  CSVCMsg_Print.prototype.text = \"\";\n  /**\n   * Decodes a CSVCMsg_Print message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_Print\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_Print} CSVCMsg_Print\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_Print.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_Print();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.text = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CSVCMsg_Print;\n})();\n\nexports.CSVCMsg_SetPause = $root.CSVCMsg_SetPause = (() => {\n  /**\n   * Properties of a CSVCMsg_SetPause.\n   * @exports ICSVCMsg_SetPause\n   * @interface ICSVCMsg_SetPause\n   * @property {boolean|null} [paused] CSVCMsg_SetPause paused\n   */\n\n  /**\n   * Constructs a new CSVCMsg_SetPause.\n   * @exports CSVCMsg_SetPause\n   * @classdesc Represents a CSVCMsg_SetPause.\n   * @implements ICSVCMsg_SetPause\n   * @constructor\n   * @param {ICSVCMsg_SetPause=} [properties] Properties to set\n   */\n  function CSVCMsg_SetPause(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_SetPause paused.\n   * @member {boolean} paused\n   * @memberof CSVCMsg_SetPause\n   * @instance\n   */\n\n\n  CSVCMsg_SetPause.prototype.paused = false;\n  /**\n   * Decodes a CSVCMsg_SetPause message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_SetPause\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_SetPause} CSVCMsg_SetPause\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_SetPause.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_SetPause();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.paused = reader.bool();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CSVCMsg_SetPause;\n})();\n\nexports.CSVCMsg_SetView = $root.CSVCMsg_SetView = (() => {\n  /**\n   * Properties of a CSVCMsg_SetView.\n   * @exports ICSVCMsg_SetView\n   * @interface ICSVCMsg_SetView\n   * @property {number|null} [entityIndex] CSVCMsg_SetView entityIndex\n   */\n\n  /**\n   * Constructs a new CSVCMsg_SetView.\n   * @exports CSVCMsg_SetView\n   * @classdesc Represents a CSVCMsg_SetView.\n   * @implements ICSVCMsg_SetView\n   * @constructor\n   * @param {ICSVCMsg_SetView=} [properties] Properties to set\n   */\n  function CSVCMsg_SetView(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_SetView entityIndex.\n   * @member {number} entityIndex\n   * @memberof CSVCMsg_SetView\n   * @instance\n   */\n\n\n  CSVCMsg_SetView.prototype.entityIndex = 0;\n  /**\n   * Decodes a CSVCMsg_SetView message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_SetView\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_SetView} CSVCMsg_SetView\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_SetView.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_SetView();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.entityIndex = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CSVCMsg_SetView;\n})();\n\nexports.CSVCMsg_CreateStringTable = $root.CSVCMsg_CreateStringTable = (() => {\n  /**\n   * Properties of a CSVCMsg_CreateStringTable.\n   * @exports ICSVCMsg_CreateStringTable\n   * @interface ICSVCMsg_CreateStringTable\n   * @property {string|null} [name] CSVCMsg_CreateStringTable name\n   * @property {number|null} [maxEntries] CSVCMsg_CreateStringTable maxEntries\n   * @property {number|null} [numEntries] CSVCMsg_CreateStringTable numEntries\n   * @property {boolean|null} [userDataFixedSize] CSVCMsg_CreateStringTable userDataFixedSize\n   * @property {number|null} [userDataSize] CSVCMsg_CreateStringTable userDataSize\n   * @property {number|null} [userDataSizeBits] CSVCMsg_CreateStringTable userDataSizeBits\n   * @property {number|null} [flags] CSVCMsg_CreateStringTable flags\n   * @property {Uint8Array|null} [stringData] CSVCMsg_CreateStringTable stringData\n   */\n\n  /**\n   * Constructs a new CSVCMsg_CreateStringTable.\n   * @exports CSVCMsg_CreateStringTable\n   * @classdesc Represents a CSVCMsg_CreateStringTable.\n   * @implements ICSVCMsg_CreateStringTable\n   * @constructor\n   * @param {ICSVCMsg_CreateStringTable=} [properties] Properties to set\n   */\n  function CSVCMsg_CreateStringTable(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_CreateStringTable name.\n   * @member {string} name\n   * @memberof CSVCMsg_CreateStringTable\n   * @instance\n   */\n\n\n  CSVCMsg_CreateStringTable.prototype.name = \"\";\n  /**\n   * CSVCMsg_CreateStringTable maxEntries.\n   * @member {number} maxEntries\n   * @memberof CSVCMsg_CreateStringTable\n   * @instance\n   */\n\n  CSVCMsg_CreateStringTable.prototype.maxEntries = 0;\n  /**\n   * CSVCMsg_CreateStringTable numEntries.\n   * @member {number} numEntries\n   * @memberof CSVCMsg_CreateStringTable\n   * @instance\n   */\n\n  CSVCMsg_CreateStringTable.prototype.numEntries = 0;\n  /**\n   * CSVCMsg_CreateStringTable userDataFixedSize.\n   * @member {boolean} userDataFixedSize\n   * @memberof CSVCMsg_CreateStringTable\n   * @instance\n   */\n\n  CSVCMsg_CreateStringTable.prototype.userDataFixedSize = false;\n  /**\n   * CSVCMsg_CreateStringTable userDataSize.\n   * @member {number} userDataSize\n   * @memberof CSVCMsg_CreateStringTable\n   * @instance\n   */\n\n  CSVCMsg_CreateStringTable.prototype.userDataSize = 0;\n  /**\n   * CSVCMsg_CreateStringTable userDataSizeBits.\n   * @member {number} userDataSizeBits\n   * @memberof CSVCMsg_CreateStringTable\n   * @instance\n   */\n\n  CSVCMsg_CreateStringTable.prototype.userDataSizeBits = 0;\n  /**\n   * CSVCMsg_CreateStringTable flags.\n   * @member {number} flags\n   * @memberof CSVCMsg_CreateStringTable\n   * @instance\n   */\n\n  CSVCMsg_CreateStringTable.prototype.flags = 0;\n  /**\n   * CSVCMsg_CreateStringTable stringData.\n   * @member {Uint8Array} stringData\n   * @memberof CSVCMsg_CreateStringTable\n   * @instance\n   */\n\n  CSVCMsg_CreateStringTable.prototype.stringData = $util.newBuffer([]);\n  /**\n   * Decodes a CSVCMsg_CreateStringTable message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_CreateStringTable\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_CreateStringTable} CSVCMsg_CreateStringTable\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_CreateStringTable.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_CreateStringTable();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.name = reader.string();\n          break;\n\n        case 2:\n          message.maxEntries = reader.int32();\n          break;\n\n        case 3:\n          message.numEntries = reader.int32();\n          break;\n\n        case 4:\n          message.userDataFixedSize = reader.bool();\n          break;\n\n        case 5:\n          message.userDataSize = reader.int32();\n          break;\n\n        case 6:\n          message.userDataSizeBits = reader.int32();\n          break;\n\n        case 7:\n          message.flags = reader.int32();\n          break;\n\n        case 8:\n          message.stringData = reader.bytes();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CSVCMsg_CreateStringTable;\n})();\n\nexports.CSVCMsg_UpdateStringTable = $root.CSVCMsg_UpdateStringTable = (() => {\n  /**\n   * Properties of a CSVCMsg_UpdateStringTable.\n   * @exports ICSVCMsg_UpdateStringTable\n   * @interface ICSVCMsg_UpdateStringTable\n   * @property {number|null} [tableId] CSVCMsg_UpdateStringTable tableId\n   * @property {number|null} [numChangedEntries] CSVCMsg_UpdateStringTable numChangedEntries\n   * @property {Uint8Array|null} [stringData] CSVCMsg_UpdateStringTable stringData\n   */\n\n  /**\n   * Constructs a new CSVCMsg_UpdateStringTable.\n   * @exports CSVCMsg_UpdateStringTable\n   * @classdesc Represents a CSVCMsg_UpdateStringTable.\n   * @implements ICSVCMsg_UpdateStringTable\n   * @constructor\n   * @param {ICSVCMsg_UpdateStringTable=} [properties] Properties to set\n   */\n  function CSVCMsg_UpdateStringTable(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_UpdateStringTable tableId.\n   * @member {number} tableId\n   * @memberof CSVCMsg_UpdateStringTable\n   * @instance\n   */\n\n\n  CSVCMsg_UpdateStringTable.prototype.tableId = 0;\n  /**\n   * CSVCMsg_UpdateStringTable numChangedEntries.\n   * @member {number} numChangedEntries\n   * @memberof CSVCMsg_UpdateStringTable\n   * @instance\n   */\n\n  CSVCMsg_UpdateStringTable.prototype.numChangedEntries = 0;\n  /**\n   * CSVCMsg_UpdateStringTable stringData.\n   * @member {Uint8Array} stringData\n   * @memberof CSVCMsg_UpdateStringTable\n   * @instance\n   */\n\n  CSVCMsg_UpdateStringTable.prototype.stringData = $util.newBuffer([]);\n  /**\n   * Decodes a CSVCMsg_UpdateStringTable message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_UpdateStringTable\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_UpdateStringTable} CSVCMsg_UpdateStringTable\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_UpdateStringTable.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_UpdateStringTable();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.tableId = reader.int32();\n          break;\n\n        case 2:\n          message.numChangedEntries = reader.int32();\n          break;\n\n        case 3:\n          message.stringData = reader.bytes();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CSVCMsg_UpdateStringTable;\n})();\n\nexports.CSVCMsg_VoiceInit = $root.CSVCMsg_VoiceInit = (() => {\n  /**\n   * Properties of a CSVCMsg_VoiceInit.\n   * @exports ICSVCMsg_VoiceInit\n   * @interface ICSVCMsg_VoiceInit\n   * @property {number|null} [quality] CSVCMsg_VoiceInit quality\n   * @property {string|null} [codec] CSVCMsg_VoiceInit codec\n   * @property {number|null} [version] CSVCMsg_VoiceInit version\n   */\n\n  /**\n   * Constructs a new CSVCMsg_VoiceInit.\n   * @exports CSVCMsg_VoiceInit\n   * @classdesc Represents a CSVCMsg_VoiceInit.\n   * @implements ICSVCMsg_VoiceInit\n   * @constructor\n   * @param {ICSVCMsg_VoiceInit=} [properties] Properties to set\n   */\n  function CSVCMsg_VoiceInit(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_VoiceInit quality.\n   * @member {number} quality\n   * @memberof CSVCMsg_VoiceInit\n   * @instance\n   */\n\n\n  CSVCMsg_VoiceInit.prototype.quality = 0;\n  /**\n   * CSVCMsg_VoiceInit codec.\n   * @member {string} codec\n   * @memberof CSVCMsg_VoiceInit\n   * @instance\n   */\n\n  CSVCMsg_VoiceInit.prototype.codec = \"\";\n  /**\n   * CSVCMsg_VoiceInit version.\n   * @member {number} version\n   * @memberof CSVCMsg_VoiceInit\n   * @instance\n   */\n\n  CSVCMsg_VoiceInit.prototype.version = 0;\n  /**\n   * Decodes a CSVCMsg_VoiceInit message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_VoiceInit\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_VoiceInit} CSVCMsg_VoiceInit\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_VoiceInit.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_VoiceInit();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.quality = reader.int32();\n          break;\n\n        case 2:\n          message.codec = reader.string();\n          break;\n\n        case 3:\n          message.version = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CSVCMsg_VoiceInit;\n})();\n\nexports.CSVCMsg_VoiceData = $root.CSVCMsg_VoiceData = (() => {\n  /**\n   * Properties of a CSVCMsg_VoiceData.\n   * @exports ICSVCMsg_VoiceData\n   * @interface ICSVCMsg_VoiceData\n   * @property {number|null} [client] CSVCMsg_VoiceData client\n   * @property {boolean|null} [proximity] CSVCMsg_VoiceData proximity\n   * @property {number|Long|null} [xuid] CSVCMsg_VoiceData xuid\n   * @property {number|null} [audibleMask] CSVCMsg_VoiceData audibleMask\n   * @property {Uint8Array|null} [voiceData] CSVCMsg_VoiceData voiceData\n   * @property {boolean|null} [caster] CSVCMsg_VoiceData caster\n   * @property {VoiceDataFormat_t|null} [format] CSVCMsg_VoiceData format\n   * @property {number|null} [sequenceBytes] CSVCMsg_VoiceData sequenceBytes\n   * @property {number|null} [sectionNumber] CSVCMsg_VoiceData sectionNumber\n   * @property {number|null} [uncompressedSampleOffset] CSVCMsg_VoiceData uncompressedSampleOffset\n   */\n\n  /**\n   * Constructs a new CSVCMsg_VoiceData.\n   * @exports CSVCMsg_VoiceData\n   * @classdesc Represents a CSVCMsg_VoiceData.\n   * @implements ICSVCMsg_VoiceData\n   * @constructor\n   * @param {ICSVCMsg_VoiceData=} [properties] Properties to set\n   */\n  function CSVCMsg_VoiceData(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_VoiceData client.\n   * @member {number} client\n   * @memberof CSVCMsg_VoiceData\n   * @instance\n   */\n\n\n  CSVCMsg_VoiceData.prototype.client = 0;\n  /**\n   * CSVCMsg_VoiceData proximity.\n   * @member {boolean} proximity\n   * @memberof CSVCMsg_VoiceData\n   * @instance\n   */\n\n  CSVCMsg_VoiceData.prototype.proximity = false;\n  /**\n   * CSVCMsg_VoiceData xuid.\n   * @member {number|Long} xuid\n   * @memberof CSVCMsg_VoiceData\n   * @instance\n   */\n\n  CSVCMsg_VoiceData.prototype.xuid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n  /**\n   * CSVCMsg_VoiceData audibleMask.\n   * @member {number} audibleMask\n   * @memberof CSVCMsg_VoiceData\n   * @instance\n   */\n\n  CSVCMsg_VoiceData.prototype.audibleMask = 0;\n  /**\n   * CSVCMsg_VoiceData voiceData.\n   * @member {Uint8Array} voiceData\n   * @memberof CSVCMsg_VoiceData\n   * @instance\n   */\n\n  CSVCMsg_VoiceData.prototype.voiceData = $util.newBuffer([]);\n  /**\n   * CSVCMsg_VoiceData caster.\n   * @member {boolean} caster\n   * @memberof CSVCMsg_VoiceData\n   * @instance\n   */\n\n  CSVCMsg_VoiceData.prototype.caster = false;\n  /**\n   * CSVCMsg_VoiceData format.\n   * @member {VoiceDataFormat_t} format\n   * @memberof CSVCMsg_VoiceData\n   * @instance\n   */\n\n  CSVCMsg_VoiceData.prototype.format = 1;\n  /**\n   * CSVCMsg_VoiceData sequenceBytes.\n   * @member {number} sequenceBytes\n   * @memberof CSVCMsg_VoiceData\n   * @instance\n   */\n\n  CSVCMsg_VoiceData.prototype.sequenceBytes = 0;\n  /**\n   * CSVCMsg_VoiceData sectionNumber.\n   * @member {number} sectionNumber\n   * @memberof CSVCMsg_VoiceData\n   * @instance\n   */\n\n  CSVCMsg_VoiceData.prototype.sectionNumber = 0;\n  /**\n   * CSVCMsg_VoiceData uncompressedSampleOffset.\n   * @member {number} uncompressedSampleOffset\n   * @memberof CSVCMsg_VoiceData\n   * @instance\n   */\n\n  CSVCMsg_VoiceData.prototype.uncompressedSampleOffset = 0;\n  /**\n   * Decodes a CSVCMsg_VoiceData message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_VoiceData\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_VoiceData} CSVCMsg_VoiceData\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_VoiceData.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_VoiceData();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.client = reader.int32();\n          break;\n\n        case 2:\n          message.proximity = reader.bool();\n          break;\n\n        case 3:\n          message.xuid = reader.fixed64();\n          break;\n\n        case 4:\n          message.audibleMask = reader.int32();\n          break;\n\n        case 5:\n          message.voiceData = reader.bytes();\n          break;\n\n        case 6:\n          message.caster = reader.bool();\n          break;\n\n        case 7:\n          message.format = reader.int32();\n          break;\n\n        case 8:\n          message.sequenceBytes = reader.int32();\n          break;\n\n        case 9:\n          message.sectionNumber = reader.uint32();\n          break;\n\n        case 10:\n          message.uncompressedSampleOffset = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CSVCMsg_VoiceData;\n})();\n\nexports.CSVCMsg_FixAngle = $root.CSVCMsg_FixAngle = (() => {\n  /**\n   * Properties of a CSVCMsg_FixAngle.\n   * @exports ICSVCMsg_FixAngle\n   * @interface ICSVCMsg_FixAngle\n   * @property {boolean|null} [relative] CSVCMsg_FixAngle relative\n   * @property {ICMsgQAngle|null} [angle] CSVCMsg_FixAngle angle\n   */\n\n  /**\n   * Constructs a new CSVCMsg_FixAngle.\n   * @exports CSVCMsg_FixAngle\n   * @classdesc Represents a CSVCMsg_FixAngle.\n   * @implements ICSVCMsg_FixAngle\n   * @constructor\n   * @param {ICSVCMsg_FixAngle=} [properties] Properties to set\n   */\n  function CSVCMsg_FixAngle(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_FixAngle relative.\n   * @member {boolean} relative\n   * @memberof CSVCMsg_FixAngle\n   * @instance\n   */\n\n\n  CSVCMsg_FixAngle.prototype.relative = false;\n  /**\n   * CSVCMsg_FixAngle angle.\n   * @member {ICMsgQAngle|null|undefined} angle\n   * @memberof CSVCMsg_FixAngle\n   * @instance\n   */\n\n  CSVCMsg_FixAngle.prototype.angle = null;\n  /**\n   * Decodes a CSVCMsg_FixAngle message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_FixAngle\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_FixAngle} CSVCMsg_FixAngle\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_FixAngle.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_FixAngle();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.relative = reader.bool();\n          break;\n\n        case 2:\n          message.angle = $root.CMsgQAngle.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CSVCMsg_FixAngle;\n})();\n\nexports.CSVCMsg_CrosshairAngle = $root.CSVCMsg_CrosshairAngle = (() => {\n  /**\n   * Properties of a CSVCMsg_CrosshairAngle.\n   * @exports ICSVCMsg_CrosshairAngle\n   * @interface ICSVCMsg_CrosshairAngle\n   * @property {ICMsgQAngle|null} [angle] CSVCMsg_CrosshairAngle angle\n   */\n\n  /**\n   * Constructs a new CSVCMsg_CrosshairAngle.\n   * @exports CSVCMsg_CrosshairAngle\n   * @classdesc Represents a CSVCMsg_CrosshairAngle.\n   * @implements ICSVCMsg_CrosshairAngle\n   * @constructor\n   * @param {ICSVCMsg_CrosshairAngle=} [properties] Properties to set\n   */\n  function CSVCMsg_CrosshairAngle(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_CrosshairAngle angle.\n   * @member {ICMsgQAngle|null|undefined} angle\n   * @memberof CSVCMsg_CrosshairAngle\n   * @instance\n   */\n\n\n  CSVCMsg_CrosshairAngle.prototype.angle = null;\n  /**\n   * Decodes a CSVCMsg_CrosshairAngle message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_CrosshairAngle\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_CrosshairAngle} CSVCMsg_CrosshairAngle\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_CrosshairAngle.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_CrosshairAngle();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.angle = $root.CMsgQAngle.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CSVCMsg_CrosshairAngle;\n})();\n\nexports.CSVCMsg_Prefetch = $root.CSVCMsg_Prefetch = (() => {\n  /**\n   * Properties of a CSVCMsg_Prefetch.\n   * @exports ICSVCMsg_Prefetch\n   * @interface ICSVCMsg_Prefetch\n   * @property {number|null} [soundIndex] CSVCMsg_Prefetch soundIndex\n   */\n\n  /**\n   * Constructs a new CSVCMsg_Prefetch.\n   * @exports CSVCMsg_Prefetch\n   * @classdesc Represents a CSVCMsg_Prefetch.\n   * @implements ICSVCMsg_Prefetch\n   * @constructor\n   * @param {ICSVCMsg_Prefetch=} [properties] Properties to set\n   */\n  function CSVCMsg_Prefetch(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_Prefetch soundIndex.\n   * @member {number} soundIndex\n   * @memberof CSVCMsg_Prefetch\n   * @instance\n   */\n\n\n  CSVCMsg_Prefetch.prototype.soundIndex = 0;\n  /**\n   * Decodes a CSVCMsg_Prefetch message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_Prefetch\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_Prefetch} CSVCMsg_Prefetch\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_Prefetch.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_Prefetch();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.soundIndex = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CSVCMsg_Prefetch;\n})();\n\nexports.CSVCMsg_BSPDecal = $root.CSVCMsg_BSPDecal = (() => {\n  /**\n   * Properties of a CSVCMsg_BSPDecal.\n   * @exports ICSVCMsg_BSPDecal\n   * @interface ICSVCMsg_BSPDecal\n   * @property {ICMsgVector|null} [pos] CSVCMsg_BSPDecal pos\n   * @property {number|null} [decalTextureIndex] CSVCMsg_BSPDecal decalTextureIndex\n   * @property {number|null} [entityIndex] CSVCMsg_BSPDecal entityIndex\n   * @property {number|null} [modelIndex] CSVCMsg_BSPDecal modelIndex\n   * @property {boolean|null} [lowPriority] CSVCMsg_BSPDecal lowPriority\n   */\n\n  /**\n   * Constructs a new CSVCMsg_BSPDecal.\n   * @exports CSVCMsg_BSPDecal\n   * @classdesc Represents a CSVCMsg_BSPDecal.\n   * @implements ICSVCMsg_BSPDecal\n   * @constructor\n   * @param {ICSVCMsg_BSPDecal=} [properties] Properties to set\n   */\n  function CSVCMsg_BSPDecal(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_BSPDecal pos.\n   * @member {ICMsgVector|null|undefined} pos\n   * @memberof CSVCMsg_BSPDecal\n   * @instance\n   */\n\n\n  CSVCMsg_BSPDecal.prototype.pos = null;\n  /**\n   * CSVCMsg_BSPDecal decalTextureIndex.\n   * @member {number} decalTextureIndex\n   * @memberof CSVCMsg_BSPDecal\n   * @instance\n   */\n\n  CSVCMsg_BSPDecal.prototype.decalTextureIndex = 0;\n  /**\n   * CSVCMsg_BSPDecal entityIndex.\n   * @member {number} entityIndex\n   * @memberof CSVCMsg_BSPDecal\n   * @instance\n   */\n\n  CSVCMsg_BSPDecal.prototype.entityIndex = 0;\n  /**\n   * CSVCMsg_BSPDecal modelIndex.\n   * @member {number} modelIndex\n   * @memberof CSVCMsg_BSPDecal\n   * @instance\n   */\n\n  CSVCMsg_BSPDecal.prototype.modelIndex = 0;\n  /**\n   * CSVCMsg_BSPDecal lowPriority.\n   * @member {boolean} lowPriority\n   * @memberof CSVCMsg_BSPDecal\n   * @instance\n   */\n\n  CSVCMsg_BSPDecal.prototype.lowPriority = false;\n  /**\n   * Decodes a CSVCMsg_BSPDecal message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_BSPDecal\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_BSPDecal} CSVCMsg_BSPDecal\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_BSPDecal.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_BSPDecal();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.pos = $root.CMsgVector.decode(reader, reader.uint32());\n          break;\n\n        case 2:\n          message.decalTextureIndex = reader.int32();\n          break;\n\n        case 3:\n          message.entityIndex = reader.int32();\n          break;\n\n        case 4:\n          message.modelIndex = reader.int32();\n          break;\n\n        case 5:\n          message.lowPriority = reader.bool();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CSVCMsg_BSPDecal;\n})();\n\nexports.CSVCMsg_SplitScreen = $root.CSVCMsg_SplitScreen = (() => {\n  /**\n   * Properties of a CSVCMsg_SplitScreen.\n   * @exports ICSVCMsg_SplitScreen\n   * @interface ICSVCMsg_SplitScreen\n   * @property {ESplitScreenMessageType|null} [type] CSVCMsg_SplitScreen type\n   * @property {number|null} [slot] CSVCMsg_SplitScreen slot\n   * @property {number|null} [playerIndex] CSVCMsg_SplitScreen playerIndex\n   */\n\n  /**\n   * Constructs a new CSVCMsg_SplitScreen.\n   * @exports CSVCMsg_SplitScreen\n   * @classdesc Represents a CSVCMsg_SplitScreen.\n   * @implements ICSVCMsg_SplitScreen\n   * @constructor\n   * @param {ICSVCMsg_SplitScreen=} [properties] Properties to set\n   */\n  function CSVCMsg_SplitScreen(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_SplitScreen type.\n   * @member {ESplitScreenMessageType} type\n   * @memberof CSVCMsg_SplitScreen\n   * @instance\n   */\n\n\n  CSVCMsg_SplitScreen.prototype.type = 0;\n  /**\n   * CSVCMsg_SplitScreen slot.\n   * @member {number} slot\n   * @memberof CSVCMsg_SplitScreen\n   * @instance\n   */\n\n  CSVCMsg_SplitScreen.prototype.slot = 0;\n  /**\n   * CSVCMsg_SplitScreen playerIndex.\n   * @member {number} playerIndex\n   * @memberof CSVCMsg_SplitScreen\n   * @instance\n   */\n\n  CSVCMsg_SplitScreen.prototype.playerIndex = 0;\n  /**\n   * Decodes a CSVCMsg_SplitScreen message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_SplitScreen\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_SplitScreen} CSVCMsg_SplitScreen\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_SplitScreen.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_SplitScreen();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.int32();\n          break;\n\n        case 2:\n          message.slot = reader.int32();\n          break;\n\n        case 3:\n          message.playerIndex = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CSVCMsg_SplitScreen;\n})();\n\nexports.CSVCMsg_GetCvarValue = $root.CSVCMsg_GetCvarValue = (() => {\n  /**\n   * Properties of a CSVCMsg_GetCvarValue.\n   * @exports ICSVCMsg_GetCvarValue\n   * @interface ICSVCMsg_GetCvarValue\n   * @property {number|null} [cookie] CSVCMsg_GetCvarValue cookie\n   * @property {string|null} [cvarName] CSVCMsg_GetCvarValue cvarName\n   */\n\n  /**\n   * Constructs a new CSVCMsg_GetCvarValue.\n   * @exports CSVCMsg_GetCvarValue\n   * @classdesc Represents a CSVCMsg_GetCvarValue.\n   * @implements ICSVCMsg_GetCvarValue\n   * @constructor\n   * @param {ICSVCMsg_GetCvarValue=} [properties] Properties to set\n   */\n  function CSVCMsg_GetCvarValue(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_GetCvarValue cookie.\n   * @member {number} cookie\n   * @memberof CSVCMsg_GetCvarValue\n   * @instance\n   */\n\n\n  CSVCMsg_GetCvarValue.prototype.cookie = 0;\n  /**\n   * CSVCMsg_GetCvarValue cvarName.\n   * @member {string} cvarName\n   * @memberof CSVCMsg_GetCvarValue\n   * @instance\n   */\n\n  CSVCMsg_GetCvarValue.prototype.cvarName = \"\";\n  /**\n   * Decodes a CSVCMsg_GetCvarValue message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_GetCvarValue\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_GetCvarValue} CSVCMsg_GetCvarValue\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_GetCvarValue.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_GetCvarValue();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.cookie = reader.int32();\n          break;\n\n        case 2:\n          message.cvarName = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CSVCMsg_GetCvarValue;\n})();\n\nexports.CSVCMsg_Menu = $root.CSVCMsg_Menu = (() => {\n  /**\n   * Properties of a CSVCMsg_Menu.\n   * @exports ICSVCMsg_Menu\n   * @interface ICSVCMsg_Menu\n   * @property {number|null} [dialogType] CSVCMsg_Menu dialogType\n   * @property {Uint8Array|null} [menuKeyValues] CSVCMsg_Menu menuKeyValues\n   */\n\n  /**\n   * Constructs a new CSVCMsg_Menu.\n   * @exports CSVCMsg_Menu\n   * @classdesc Represents a CSVCMsg_Menu.\n   * @implements ICSVCMsg_Menu\n   * @constructor\n   * @param {ICSVCMsg_Menu=} [properties] Properties to set\n   */\n  function CSVCMsg_Menu(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_Menu dialogType.\n   * @member {number} dialogType\n   * @memberof CSVCMsg_Menu\n   * @instance\n   */\n\n\n  CSVCMsg_Menu.prototype.dialogType = 0;\n  /**\n   * CSVCMsg_Menu menuKeyValues.\n   * @member {Uint8Array} menuKeyValues\n   * @memberof CSVCMsg_Menu\n   * @instance\n   */\n\n  CSVCMsg_Menu.prototype.menuKeyValues = $util.newBuffer([]);\n  /**\n   * Decodes a CSVCMsg_Menu message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_Menu\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_Menu} CSVCMsg_Menu\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_Menu.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_Menu();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.dialogType = reader.int32();\n          break;\n\n        case 2:\n          message.menuKeyValues = reader.bytes();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CSVCMsg_Menu;\n})();\n\nexports.CSVCMsg_UserMessage = $root.CSVCMsg_UserMessage = (() => {\n  /**\n   * Properties of a CSVCMsg_UserMessage.\n   * @exports ICSVCMsg_UserMessage\n   * @interface ICSVCMsg_UserMessage\n   * @property {number|null} [msgType] CSVCMsg_UserMessage msgType\n   * @property {Uint8Array|null} [msgData] CSVCMsg_UserMessage msgData\n   * @property {number|null} [passthrough] CSVCMsg_UserMessage passthrough\n   */\n\n  /**\n   * Constructs a new CSVCMsg_UserMessage.\n   * @exports CSVCMsg_UserMessage\n   * @classdesc Represents a CSVCMsg_UserMessage.\n   * @implements ICSVCMsg_UserMessage\n   * @constructor\n   * @param {ICSVCMsg_UserMessage=} [properties] Properties to set\n   */\n  function CSVCMsg_UserMessage(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_UserMessage msgType.\n   * @member {number} msgType\n   * @memberof CSVCMsg_UserMessage\n   * @instance\n   */\n\n\n  CSVCMsg_UserMessage.prototype.msgType = 0;\n  /**\n   * CSVCMsg_UserMessage msgData.\n   * @member {Uint8Array} msgData\n   * @memberof CSVCMsg_UserMessage\n   * @instance\n   */\n\n  CSVCMsg_UserMessage.prototype.msgData = $util.newBuffer([]);\n  /**\n   * CSVCMsg_UserMessage passthrough.\n   * @member {number} passthrough\n   * @memberof CSVCMsg_UserMessage\n   * @instance\n   */\n\n  CSVCMsg_UserMessage.prototype.passthrough = 0;\n  /**\n   * Decodes a CSVCMsg_UserMessage message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_UserMessage\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_UserMessage.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_UserMessage();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.msgType = reader.int32();\n          break;\n\n        case 2:\n          message.msgData = reader.bytes();\n          break;\n\n        case 3:\n          message.passthrough = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CSVCMsg_UserMessage;\n})();\n\nexports.CSVCMsg_PaintmapData = $root.CSVCMsg_PaintmapData = (() => {\n  /**\n   * Properties of a CSVCMsg_PaintmapData.\n   * @exports ICSVCMsg_PaintmapData\n   * @interface ICSVCMsg_PaintmapData\n   * @property {Uint8Array|null} [paintmap] CSVCMsg_PaintmapData paintmap\n   */\n\n  /**\n   * Constructs a new CSVCMsg_PaintmapData.\n   * @exports CSVCMsg_PaintmapData\n   * @classdesc Represents a CSVCMsg_PaintmapData.\n   * @implements ICSVCMsg_PaintmapData\n   * @constructor\n   * @param {ICSVCMsg_PaintmapData=} [properties] Properties to set\n   */\n  function CSVCMsg_PaintmapData(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_PaintmapData paintmap.\n   * @member {Uint8Array} paintmap\n   * @memberof CSVCMsg_PaintmapData\n   * @instance\n   */\n\n\n  CSVCMsg_PaintmapData.prototype.paintmap = $util.newBuffer([]);\n  /**\n   * Decodes a CSVCMsg_PaintmapData message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_PaintmapData\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_PaintmapData} CSVCMsg_PaintmapData\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_PaintmapData.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_PaintmapData();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.paintmap = reader.bytes();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CSVCMsg_PaintmapData;\n})();\n\nexports.CSVCMsg_GameEvent = $root.CSVCMsg_GameEvent = (() => {\n  /**\n   * Properties of a CSVCMsg_GameEvent.\n   * @exports ICSVCMsg_GameEvent\n   * @interface ICSVCMsg_GameEvent\n   * @property {string|null} [eventName] CSVCMsg_GameEvent eventName\n   * @property {number|null} [eventid] CSVCMsg_GameEvent eventid\n   * @property {Array.<CSVCMsg_GameEvent.Ikey_t>|null} [keys] CSVCMsg_GameEvent keys\n   * @property {number|null} [passthrough] CSVCMsg_GameEvent passthrough\n   */\n\n  /**\n   * Constructs a new CSVCMsg_GameEvent.\n   * @exports CSVCMsg_GameEvent\n   * @classdesc Represents a CSVCMsg_GameEvent.\n   * @implements ICSVCMsg_GameEvent\n   * @constructor\n   * @param {ICSVCMsg_GameEvent=} [properties] Properties to set\n   */\n  function CSVCMsg_GameEvent(properties) {\n    this.keys = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_GameEvent eventName.\n   * @member {string} eventName\n   * @memberof CSVCMsg_GameEvent\n   * @instance\n   */\n\n\n  CSVCMsg_GameEvent.prototype.eventName = \"\";\n  /**\n   * CSVCMsg_GameEvent eventid.\n   * @member {number} eventid\n   * @memberof CSVCMsg_GameEvent\n   * @instance\n   */\n\n  CSVCMsg_GameEvent.prototype.eventid = 0;\n  /**\n   * CSVCMsg_GameEvent keys.\n   * @member {Array.<CSVCMsg_GameEvent.Ikey_t>} keys\n   * @memberof CSVCMsg_GameEvent\n   * @instance\n   */\n\n  CSVCMsg_GameEvent.prototype.keys = $util.emptyArray;\n  /**\n   * CSVCMsg_GameEvent passthrough.\n   * @member {number} passthrough\n   * @memberof CSVCMsg_GameEvent\n   * @instance\n   */\n\n  CSVCMsg_GameEvent.prototype.passthrough = 0;\n  /**\n   * Decodes a CSVCMsg_GameEvent message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_GameEvent\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_GameEvent.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_GameEvent();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.eventName = reader.string();\n          break;\n\n        case 2:\n          message.eventid = reader.int32();\n          break;\n\n        case 3:\n          if (!(message.keys && message.keys.length)) message.keys = [];\n          message.keys.push($root.CSVCMsg_GameEvent.key_t.decode(reader, reader.uint32()));\n          break;\n\n        case 4:\n          message.passthrough = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CSVCMsg_GameEvent.key_t = function () {\n    /**\n     * Properties of a key_t.\n     * @memberof CSVCMsg_GameEvent\n     * @interface Ikey_t\n     * @property {number|null} [type] key_t type\n     * @property {string|null} [valString] key_t valString\n     * @property {number|null} [valFloat] key_t valFloat\n     * @property {number|null} [valLong] key_t valLong\n     * @property {number|null} [valShort] key_t valShort\n     * @property {number|null} [valByte] key_t valByte\n     * @property {boolean|null} [valBool] key_t valBool\n     * @property {number|Long|null} [valUint64] key_t valUint64\n     * @property {Uint8Array|null} [valWstring] key_t valWstring\n     */\n\n    /**\n     * Constructs a new key_t.\n     * @memberof CSVCMsg_GameEvent\n     * @classdesc Represents a key_t.\n     * @implements Ikey_t\n     * @constructor\n     * @param {CSVCMsg_GameEvent.Ikey_t=} [properties] Properties to set\n     */\n    function key_t(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * key_t type.\n     * @member {number} type\n     * @memberof CSVCMsg_GameEvent.key_t\n     * @instance\n     */\n\n\n    key_t.prototype.type = 0;\n    /**\n     * key_t valString.\n     * @member {string} valString\n     * @memberof CSVCMsg_GameEvent.key_t\n     * @instance\n     */\n\n    key_t.prototype.valString = \"\";\n    /**\n     * key_t valFloat.\n     * @member {number} valFloat\n     * @memberof CSVCMsg_GameEvent.key_t\n     * @instance\n     */\n\n    key_t.prototype.valFloat = 0;\n    /**\n     * key_t valLong.\n     * @member {number} valLong\n     * @memberof CSVCMsg_GameEvent.key_t\n     * @instance\n     */\n\n    key_t.prototype.valLong = 0;\n    /**\n     * key_t valShort.\n     * @member {number} valShort\n     * @memberof CSVCMsg_GameEvent.key_t\n     * @instance\n     */\n\n    key_t.prototype.valShort = 0;\n    /**\n     * key_t valByte.\n     * @member {number} valByte\n     * @memberof CSVCMsg_GameEvent.key_t\n     * @instance\n     */\n\n    key_t.prototype.valByte = 0;\n    /**\n     * key_t valBool.\n     * @member {boolean} valBool\n     * @memberof CSVCMsg_GameEvent.key_t\n     * @instance\n     */\n\n    key_t.prototype.valBool = false;\n    /**\n     * key_t valUint64.\n     * @member {number|Long} valUint64\n     * @memberof CSVCMsg_GameEvent.key_t\n     * @instance\n     */\n\n    key_t.prototype.valUint64 = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n    /**\n     * key_t valWstring.\n     * @member {Uint8Array} valWstring\n     * @memberof CSVCMsg_GameEvent.key_t\n     * @instance\n     */\n\n    key_t.prototype.valWstring = $util.newBuffer([]);\n    /**\n     * Decodes a key_t message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_GameEvent.key_t\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_GameEvent.key_t} key_t\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    key_t.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CSVCMsg_GameEvent.key_t();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.type = reader.int32();\n            break;\n\n          case 2:\n            message.valString = reader.string();\n            break;\n\n          case 3:\n            message.valFloat = reader.float();\n            break;\n\n          case 4:\n            message.valLong = reader.int32();\n            break;\n\n          case 5:\n            message.valShort = reader.int32();\n            break;\n\n          case 6:\n            message.valByte = reader.int32();\n            break;\n\n          case 7:\n            message.valBool = reader.bool();\n            break;\n\n          case 8:\n            message.valUint64 = reader.uint64();\n            break;\n\n          case 9:\n            message.valWstring = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return key_t;\n  }();\n\n  return CSVCMsg_GameEvent;\n})();\n\nexports.CSVCMsg_GameEventList = $root.CSVCMsg_GameEventList = (() => {\n  /**\n   * Properties of a CSVCMsg_GameEventList.\n   * @exports ICSVCMsg_GameEventList\n   * @interface ICSVCMsg_GameEventList\n   * @property {Array.<CSVCMsg_GameEventList.Idescriptor_t>|null} [descriptors] CSVCMsg_GameEventList descriptors\n   */\n\n  /**\n   * Constructs a new CSVCMsg_GameEventList.\n   * @exports CSVCMsg_GameEventList\n   * @classdesc Represents a CSVCMsg_GameEventList.\n   * @implements ICSVCMsg_GameEventList\n   * @constructor\n   * @param {ICSVCMsg_GameEventList=} [properties] Properties to set\n   */\n  function CSVCMsg_GameEventList(properties) {\n    this.descriptors = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_GameEventList descriptors.\n   * @member {Array.<CSVCMsg_GameEventList.Idescriptor_t>} descriptors\n   * @memberof CSVCMsg_GameEventList\n   * @instance\n   */\n\n\n  CSVCMsg_GameEventList.prototype.descriptors = $util.emptyArray;\n  /**\n   * Decodes a CSVCMsg_GameEventList message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_GameEventList\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_GameEventList} CSVCMsg_GameEventList\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_GameEventList.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_GameEventList();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.descriptors && message.descriptors.length)) message.descriptors = [];\n          message.descriptors.push($root.CSVCMsg_GameEventList.descriptor_t.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CSVCMsg_GameEventList.key_t = function () {\n    /**\n     * Properties of a key_t.\n     * @memberof CSVCMsg_GameEventList\n     * @interface Ikey_t\n     * @property {number|null} [type] key_t type\n     * @property {string|null} [name] key_t name\n     */\n\n    /**\n     * Constructs a new key_t.\n     * @memberof CSVCMsg_GameEventList\n     * @classdesc Represents a key_t.\n     * @implements Ikey_t\n     * @constructor\n     * @param {CSVCMsg_GameEventList.Ikey_t=} [properties] Properties to set\n     */\n    function key_t(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * key_t type.\n     * @member {number} type\n     * @memberof CSVCMsg_GameEventList.key_t\n     * @instance\n     */\n\n\n    key_t.prototype.type = 0;\n    /**\n     * key_t name.\n     * @member {string} name\n     * @memberof CSVCMsg_GameEventList.key_t\n     * @instance\n     */\n\n    key_t.prototype.name = \"\";\n    /**\n     * Decodes a key_t message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_GameEventList.key_t\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_GameEventList.key_t} key_t\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    key_t.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CSVCMsg_GameEventList.key_t();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.type = reader.int32();\n            break;\n\n          case 2:\n            message.name = reader.string();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return key_t;\n  }();\n\n  CSVCMsg_GameEventList.descriptor_t = function () {\n    /**\n     * Properties of a descriptor_t.\n     * @memberof CSVCMsg_GameEventList\n     * @interface Idescriptor_t\n     * @property {number|null} [eventid] descriptor_t eventid\n     * @property {string|null} [name] descriptor_t name\n     * @property {Array.<CSVCMsg_GameEventList.Ikey_t>|null} [keys] descriptor_t keys\n     */\n\n    /**\n     * Constructs a new descriptor_t.\n     * @memberof CSVCMsg_GameEventList\n     * @classdesc Represents a descriptor_t.\n     * @implements Idescriptor_t\n     * @constructor\n     * @param {CSVCMsg_GameEventList.Idescriptor_t=} [properties] Properties to set\n     */\n    function descriptor_t(properties) {\n      this.keys = [];\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * descriptor_t eventid.\n     * @member {number} eventid\n     * @memberof CSVCMsg_GameEventList.descriptor_t\n     * @instance\n     */\n\n\n    descriptor_t.prototype.eventid = 0;\n    /**\n     * descriptor_t name.\n     * @member {string} name\n     * @memberof CSVCMsg_GameEventList.descriptor_t\n     * @instance\n     */\n\n    descriptor_t.prototype.name = \"\";\n    /**\n     * descriptor_t keys.\n     * @member {Array.<CSVCMsg_GameEventList.Ikey_t>} keys\n     * @memberof CSVCMsg_GameEventList.descriptor_t\n     * @instance\n     */\n\n    descriptor_t.prototype.keys = $util.emptyArray;\n    /**\n     * Decodes a descriptor_t message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_GameEventList.descriptor_t\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_GameEventList.descriptor_t} descriptor_t\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    descriptor_t.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CSVCMsg_GameEventList.descriptor_t();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.eventid = reader.int32();\n            break;\n\n          case 2:\n            message.name = reader.string();\n            break;\n\n          case 3:\n            if (!(message.keys && message.keys.length)) message.keys = [];\n            message.keys.push($root.CSVCMsg_GameEventList.key_t.decode(reader, reader.uint32()));\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return descriptor_t;\n  }();\n\n  return CSVCMsg_GameEventList;\n})();\n\nexports.CSVCMsg_TempEntities = $root.CSVCMsg_TempEntities = (() => {\n  /**\n   * Properties of a CSVCMsg_TempEntities.\n   * @exports ICSVCMsg_TempEntities\n   * @interface ICSVCMsg_TempEntities\n   * @property {boolean|null} [reliable] CSVCMsg_TempEntities reliable\n   * @property {number|null} [numEntries] CSVCMsg_TempEntities numEntries\n   * @property {Uint8Array|null} [entityData] CSVCMsg_TempEntities entityData\n   */\n\n  /**\n   * Constructs a new CSVCMsg_TempEntities.\n   * @exports CSVCMsg_TempEntities\n   * @classdesc Represents a CSVCMsg_TempEntities.\n   * @implements ICSVCMsg_TempEntities\n   * @constructor\n   * @param {ICSVCMsg_TempEntities=} [properties] Properties to set\n   */\n  function CSVCMsg_TempEntities(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_TempEntities reliable.\n   * @member {boolean} reliable\n   * @memberof CSVCMsg_TempEntities\n   * @instance\n   */\n\n\n  CSVCMsg_TempEntities.prototype.reliable = false;\n  /**\n   * CSVCMsg_TempEntities numEntries.\n   * @member {number} numEntries\n   * @memberof CSVCMsg_TempEntities\n   * @instance\n   */\n\n  CSVCMsg_TempEntities.prototype.numEntries = 0;\n  /**\n   * CSVCMsg_TempEntities entityData.\n   * @member {Uint8Array} entityData\n   * @memberof CSVCMsg_TempEntities\n   * @instance\n   */\n\n  CSVCMsg_TempEntities.prototype.entityData = $util.newBuffer([]);\n  /**\n   * Decodes a CSVCMsg_TempEntities message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_TempEntities\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_TempEntities} CSVCMsg_TempEntities\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_TempEntities.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_TempEntities();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.reliable = reader.bool();\n          break;\n\n        case 2:\n          message.numEntries = reader.int32();\n          break;\n\n        case 3:\n          message.entityData = reader.bytes();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CSVCMsg_TempEntities;\n})();\n\nexports.CSVCMsg_PacketEntities = $root.CSVCMsg_PacketEntities = (() => {\n  /**\n   * Properties of a CSVCMsg_PacketEntities.\n   * @exports ICSVCMsg_PacketEntities\n   * @interface ICSVCMsg_PacketEntities\n   * @property {number|null} [maxEntries] CSVCMsg_PacketEntities maxEntries\n   * @property {number|null} [updatedEntries] CSVCMsg_PacketEntities updatedEntries\n   * @property {boolean|null} [isDelta] CSVCMsg_PacketEntities isDelta\n   * @property {boolean|null} [updateBaseline] CSVCMsg_PacketEntities updateBaseline\n   * @property {number|null} [baseline] CSVCMsg_PacketEntities baseline\n   * @property {number|null} [deltaFrom] CSVCMsg_PacketEntities deltaFrom\n   * @property {Uint8Array|null} [entityData] CSVCMsg_PacketEntities entityData\n   */\n\n  /**\n   * Constructs a new CSVCMsg_PacketEntities.\n   * @exports CSVCMsg_PacketEntities\n   * @classdesc Represents a CSVCMsg_PacketEntities.\n   * @implements ICSVCMsg_PacketEntities\n   * @constructor\n   * @param {ICSVCMsg_PacketEntities=} [properties] Properties to set\n   */\n  function CSVCMsg_PacketEntities(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_PacketEntities maxEntries.\n   * @member {number} maxEntries\n   * @memberof CSVCMsg_PacketEntities\n   * @instance\n   */\n\n\n  CSVCMsg_PacketEntities.prototype.maxEntries = 0;\n  /**\n   * CSVCMsg_PacketEntities updatedEntries.\n   * @member {number} updatedEntries\n   * @memberof CSVCMsg_PacketEntities\n   * @instance\n   */\n\n  CSVCMsg_PacketEntities.prototype.updatedEntries = 0;\n  /**\n   * CSVCMsg_PacketEntities isDelta.\n   * @member {boolean} isDelta\n   * @memberof CSVCMsg_PacketEntities\n   * @instance\n   */\n\n  CSVCMsg_PacketEntities.prototype.isDelta = false;\n  /**\n   * CSVCMsg_PacketEntities updateBaseline.\n   * @member {boolean} updateBaseline\n   * @memberof CSVCMsg_PacketEntities\n   * @instance\n   */\n\n  CSVCMsg_PacketEntities.prototype.updateBaseline = false;\n  /**\n   * CSVCMsg_PacketEntities baseline.\n   * @member {number} baseline\n   * @memberof CSVCMsg_PacketEntities\n   * @instance\n   */\n\n  CSVCMsg_PacketEntities.prototype.baseline = 0;\n  /**\n   * CSVCMsg_PacketEntities deltaFrom.\n   * @member {number} deltaFrom\n   * @memberof CSVCMsg_PacketEntities\n   * @instance\n   */\n\n  CSVCMsg_PacketEntities.prototype.deltaFrom = 0;\n  /**\n   * CSVCMsg_PacketEntities entityData.\n   * @member {Uint8Array} entityData\n   * @memberof CSVCMsg_PacketEntities\n   * @instance\n   */\n\n  CSVCMsg_PacketEntities.prototype.entityData = $util.newBuffer([]);\n  /**\n   * Decodes a CSVCMsg_PacketEntities message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_PacketEntities\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_PacketEntities} CSVCMsg_PacketEntities\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_PacketEntities.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_PacketEntities();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.maxEntries = reader.int32();\n          break;\n\n        case 2:\n          message.updatedEntries = reader.int32();\n          break;\n\n        case 3:\n          message.isDelta = reader.bool();\n          break;\n\n        case 4:\n          message.updateBaseline = reader.bool();\n          break;\n\n        case 5:\n          message.baseline = reader.int32();\n          break;\n\n        case 6:\n          message.deltaFrom = reader.int32();\n          break;\n\n        case 7:\n          message.entityData = reader.bytes();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CSVCMsg_PacketEntities;\n})();\n\nexports.CSVCMsg_Sounds = $root.CSVCMsg_Sounds = (() => {\n  /**\n   * Properties of a CSVCMsg_Sounds.\n   * @exports ICSVCMsg_Sounds\n   * @interface ICSVCMsg_Sounds\n   * @property {boolean|null} [reliableSound] CSVCMsg_Sounds reliableSound\n   * @property {Array.<CSVCMsg_Sounds.Isounddata_t>|null} [sounds] CSVCMsg_Sounds sounds\n   */\n\n  /**\n   * Constructs a new CSVCMsg_Sounds.\n   * @exports CSVCMsg_Sounds\n   * @classdesc Represents a CSVCMsg_Sounds.\n   * @implements ICSVCMsg_Sounds\n   * @constructor\n   * @param {ICSVCMsg_Sounds=} [properties] Properties to set\n   */\n  function CSVCMsg_Sounds(properties) {\n    this.sounds = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_Sounds reliableSound.\n   * @member {boolean} reliableSound\n   * @memberof CSVCMsg_Sounds\n   * @instance\n   */\n\n\n  CSVCMsg_Sounds.prototype.reliableSound = false;\n  /**\n   * CSVCMsg_Sounds sounds.\n   * @member {Array.<CSVCMsg_Sounds.Isounddata_t>} sounds\n   * @memberof CSVCMsg_Sounds\n   * @instance\n   */\n\n  CSVCMsg_Sounds.prototype.sounds = $util.emptyArray;\n  /**\n   * Decodes a CSVCMsg_Sounds message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_Sounds\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_Sounds} CSVCMsg_Sounds\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_Sounds.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_Sounds();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.reliableSound = reader.bool();\n          break;\n\n        case 2:\n          if (!(message.sounds && message.sounds.length)) message.sounds = [];\n          message.sounds.push($root.CSVCMsg_Sounds.sounddata_t.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CSVCMsg_Sounds.sounddata_t = function () {\n    /**\n     * Properties of a sounddata_t.\n     * @memberof CSVCMsg_Sounds\n     * @interface Isounddata_t\n     * @property {number|null} [originX] sounddata_t originX\n     * @property {number|null} [originY] sounddata_t originY\n     * @property {number|null} [originZ] sounddata_t originZ\n     * @property {number|null} [volume] sounddata_t volume\n     * @property {number|null} [delayValue] sounddata_t delayValue\n     * @property {number|null} [sequenceNumber] sounddata_t sequenceNumber\n     * @property {number|null} [entityIndex] sounddata_t entityIndex\n     * @property {number|null} [channel] sounddata_t channel\n     * @property {number|null} [pitch] sounddata_t pitch\n     * @property {number|null} [flags] sounddata_t flags\n     * @property {number|null} [soundNum] sounddata_t soundNum\n     * @property {number|null} [soundNumHandle] sounddata_t soundNumHandle\n     * @property {number|null} [speakerEntity] sounddata_t speakerEntity\n     * @property {number|null} [randomSeed] sounddata_t randomSeed\n     * @property {number|null} [soundLevel] sounddata_t soundLevel\n     * @property {boolean|null} [isSentence] sounddata_t isSentence\n     * @property {boolean|null} [isAmbient] sounddata_t isAmbient\n     */\n\n    /**\n     * Constructs a new sounddata_t.\n     * @memberof CSVCMsg_Sounds\n     * @classdesc Represents a sounddata_t.\n     * @implements Isounddata_t\n     * @constructor\n     * @param {CSVCMsg_Sounds.Isounddata_t=} [properties] Properties to set\n     */\n    function sounddata_t(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * sounddata_t originX.\n     * @member {number} originX\n     * @memberof CSVCMsg_Sounds.sounddata_t\n     * @instance\n     */\n\n\n    sounddata_t.prototype.originX = 0;\n    /**\n     * sounddata_t originY.\n     * @member {number} originY\n     * @memberof CSVCMsg_Sounds.sounddata_t\n     * @instance\n     */\n\n    sounddata_t.prototype.originY = 0;\n    /**\n     * sounddata_t originZ.\n     * @member {number} originZ\n     * @memberof CSVCMsg_Sounds.sounddata_t\n     * @instance\n     */\n\n    sounddata_t.prototype.originZ = 0;\n    /**\n     * sounddata_t volume.\n     * @member {number} volume\n     * @memberof CSVCMsg_Sounds.sounddata_t\n     * @instance\n     */\n\n    sounddata_t.prototype.volume = 0;\n    /**\n     * sounddata_t delayValue.\n     * @member {number} delayValue\n     * @memberof CSVCMsg_Sounds.sounddata_t\n     * @instance\n     */\n\n    sounddata_t.prototype.delayValue = 0;\n    /**\n     * sounddata_t sequenceNumber.\n     * @member {number} sequenceNumber\n     * @memberof CSVCMsg_Sounds.sounddata_t\n     * @instance\n     */\n\n    sounddata_t.prototype.sequenceNumber = 0;\n    /**\n     * sounddata_t entityIndex.\n     * @member {number} entityIndex\n     * @memberof CSVCMsg_Sounds.sounddata_t\n     * @instance\n     */\n\n    sounddata_t.prototype.entityIndex = 0;\n    /**\n     * sounddata_t channel.\n     * @member {number} channel\n     * @memberof CSVCMsg_Sounds.sounddata_t\n     * @instance\n     */\n\n    sounddata_t.prototype.channel = 0;\n    /**\n     * sounddata_t pitch.\n     * @member {number} pitch\n     * @memberof CSVCMsg_Sounds.sounddata_t\n     * @instance\n     */\n\n    sounddata_t.prototype.pitch = 0;\n    /**\n     * sounddata_t flags.\n     * @member {number} flags\n     * @memberof CSVCMsg_Sounds.sounddata_t\n     * @instance\n     */\n\n    sounddata_t.prototype.flags = 0;\n    /**\n     * sounddata_t soundNum.\n     * @member {number} soundNum\n     * @memberof CSVCMsg_Sounds.sounddata_t\n     * @instance\n     */\n\n    sounddata_t.prototype.soundNum = 0;\n    /**\n     * sounddata_t soundNumHandle.\n     * @member {number} soundNumHandle\n     * @memberof CSVCMsg_Sounds.sounddata_t\n     * @instance\n     */\n\n    sounddata_t.prototype.soundNumHandle = 0;\n    /**\n     * sounddata_t speakerEntity.\n     * @member {number} speakerEntity\n     * @memberof CSVCMsg_Sounds.sounddata_t\n     * @instance\n     */\n\n    sounddata_t.prototype.speakerEntity = 0;\n    /**\n     * sounddata_t randomSeed.\n     * @member {number} randomSeed\n     * @memberof CSVCMsg_Sounds.sounddata_t\n     * @instance\n     */\n\n    sounddata_t.prototype.randomSeed = 0;\n    /**\n     * sounddata_t soundLevel.\n     * @member {number} soundLevel\n     * @memberof CSVCMsg_Sounds.sounddata_t\n     * @instance\n     */\n\n    sounddata_t.prototype.soundLevel = 0;\n    /**\n     * sounddata_t isSentence.\n     * @member {boolean} isSentence\n     * @memberof CSVCMsg_Sounds.sounddata_t\n     * @instance\n     */\n\n    sounddata_t.prototype.isSentence = false;\n    /**\n     * sounddata_t isAmbient.\n     * @member {boolean} isAmbient\n     * @memberof CSVCMsg_Sounds.sounddata_t\n     * @instance\n     */\n\n    sounddata_t.prototype.isAmbient = false;\n    /**\n     * Decodes a sounddata_t message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_Sounds.sounddata_t\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_Sounds.sounddata_t} sounddata_t\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    sounddata_t.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CSVCMsg_Sounds.sounddata_t();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.originX = reader.sint32();\n            break;\n\n          case 2:\n            message.originY = reader.sint32();\n            break;\n\n          case 3:\n            message.originZ = reader.sint32();\n            break;\n\n          case 4:\n            message.volume = reader.uint32();\n            break;\n\n          case 5:\n            message.delayValue = reader.float();\n            break;\n\n          case 6:\n            message.sequenceNumber = reader.int32();\n            break;\n\n          case 7:\n            message.entityIndex = reader.int32();\n            break;\n\n          case 8:\n            message.channel = reader.int32();\n            break;\n\n          case 9:\n            message.pitch = reader.int32();\n            break;\n\n          case 10:\n            message.flags = reader.int32();\n            break;\n\n          case 11:\n            message.soundNum = reader.uint32();\n            break;\n\n          case 12:\n            message.soundNumHandle = reader.fixed32();\n            break;\n\n          case 13:\n            message.speakerEntity = reader.int32();\n            break;\n\n          case 14:\n            message.randomSeed = reader.int32();\n            break;\n\n          case 15:\n            message.soundLevel = reader.int32();\n            break;\n\n          case 16:\n            message.isSentence = reader.bool();\n            break;\n\n          case 17:\n            message.isAmbient = reader.bool();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return sounddata_t;\n  }();\n\n  return CSVCMsg_Sounds;\n})();\n\nexports.CSVCMsg_EntityMsg = $root.CSVCMsg_EntityMsg = (() => {\n  /**\n   * Properties of a CSVCMsg_EntityMsg.\n   * @exports ICSVCMsg_EntityMsg\n   * @interface ICSVCMsg_EntityMsg\n   * @property {number|null} [entIndex] CSVCMsg_EntityMsg entIndex\n   * @property {number|null} [classId] CSVCMsg_EntityMsg classId\n   * @property {Uint8Array|null} [entData] CSVCMsg_EntityMsg entData\n   */\n\n  /**\n   * Constructs a new CSVCMsg_EntityMsg.\n   * @exports CSVCMsg_EntityMsg\n   * @classdesc Represents a CSVCMsg_EntityMsg.\n   * @implements ICSVCMsg_EntityMsg\n   * @constructor\n   * @param {ICSVCMsg_EntityMsg=} [properties] Properties to set\n   */\n  function CSVCMsg_EntityMsg(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_EntityMsg entIndex.\n   * @member {number} entIndex\n   * @memberof CSVCMsg_EntityMsg\n   * @instance\n   */\n\n\n  CSVCMsg_EntityMsg.prototype.entIndex = 0;\n  /**\n   * CSVCMsg_EntityMsg classId.\n   * @member {number} classId\n   * @memberof CSVCMsg_EntityMsg\n   * @instance\n   */\n\n  CSVCMsg_EntityMsg.prototype.classId = 0;\n  /**\n   * CSVCMsg_EntityMsg entData.\n   * @member {Uint8Array} entData\n   * @memberof CSVCMsg_EntityMsg\n   * @instance\n   */\n\n  CSVCMsg_EntityMsg.prototype.entData = $util.newBuffer([]);\n  /**\n   * Decodes a CSVCMsg_EntityMsg message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_EntityMsg\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_EntityMsg} CSVCMsg_EntityMsg\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_EntityMsg.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_EntityMsg();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.entIndex = reader.int32();\n          break;\n\n        case 2:\n          message.classId = reader.int32();\n          break;\n\n        case 3:\n          message.entData = reader.bytes();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CSVCMsg_EntityMsg;\n})();\n\nexports.CSVCMsg_CmdKeyValues = $root.CSVCMsg_CmdKeyValues = (() => {\n  /**\n   * Properties of a CSVCMsg_CmdKeyValues.\n   * @exports ICSVCMsg_CmdKeyValues\n   * @interface ICSVCMsg_CmdKeyValues\n   * @property {Uint8Array|null} [keyvalues] CSVCMsg_CmdKeyValues keyvalues\n   */\n\n  /**\n   * Constructs a new CSVCMsg_CmdKeyValues.\n   * @exports CSVCMsg_CmdKeyValues\n   * @classdesc Represents a CSVCMsg_CmdKeyValues.\n   * @implements ICSVCMsg_CmdKeyValues\n   * @constructor\n   * @param {ICSVCMsg_CmdKeyValues=} [properties] Properties to set\n   */\n  function CSVCMsg_CmdKeyValues(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_CmdKeyValues keyvalues.\n   * @member {Uint8Array} keyvalues\n   * @memberof CSVCMsg_CmdKeyValues\n   * @instance\n   */\n\n\n  CSVCMsg_CmdKeyValues.prototype.keyvalues = $util.newBuffer([]);\n  /**\n   * Decodes a CSVCMsg_CmdKeyValues message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_CmdKeyValues\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_CmdKeyValues} CSVCMsg_CmdKeyValues\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_CmdKeyValues.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_CmdKeyValues();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.keyvalues = reader.bytes();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CSVCMsg_CmdKeyValues;\n})();\n\nexports.CSVCMsg_EncryptedData = $root.CSVCMsg_EncryptedData = (() => {\n  /**\n   * Properties of a CSVCMsg_EncryptedData.\n   * @exports ICSVCMsg_EncryptedData\n   * @interface ICSVCMsg_EncryptedData\n   * @property {Uint8Array|null} [encrypted] CSVCMsg_EncryptedData encrypted\n   * @property {number|null} [keyType] CSVCMsg_EncryptedData keyType\n   */\n\n  /**\n   * Constructs a new CSVCMsg_EncryptedData.\n   * @exports CSVCMsg_EncryptedData\n   * @classdesc Represents a CSVCMsg_EncryptedData.\n   * @implements ICSVCMsg_EncryptedData\n   * @constructor\n   * @param {ICSVCMsg_EncryptedData=} [properties] Properties to set\n   */\n  function CSVCMsg_EncryptedData(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_EncryptedData encrypted.\n   * @member {Uint8Array} encrypted\n   * @memberof CSVCMsg_EncryptedData\n   * @instance\n   */\n\n\n  CSVCMsg_EncryptedData.prototype.encrypted = $util.newBuffer([]);\n  /**\n   * CSVCMsg_EncryptedData keyType.\n   * @member {number} keyType\n   * @memberof CSVCMsg_EncryptedData\n   * @instance\n   */\n\n  CSVCMsg_EncryptedData.prototype.keyType = 0;\n  /**\n   * Decodes a CSVCMsg_EncryptedData message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_EncryptedData\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_EncryptedData} CSVCMsg_EncryptedData\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_EncryptedData.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_EncryptedData();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.encrypted = reader.bytes();\n          break;\n\n        case 2:\n          message.keyType = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CSVCMsg_EncryptedData;\n})();\n\nexports.CSVCMsg_HltvReplay = $root.CSVCMsg_HltvReplay = (() => {\n  /**\n   * Properties of a CSVCMsg_HltvReplay.\n   * @exports ICSVCMsg_HltvReplay\n   * @interface ICSVCMsg_HltvReplay\n   * @property {number|null} [delay] CSVCMsg_HltvReplay delay\n   * @property {number|null} [primaryTarget] CSVCMsg_HltvReplay primaryTarget\n   * @property {number|null} [replayStopAt] CSVCMsg_HltvReplay replayStopAt\n   * @property {number|null} [replayStartAt] CSVCMsg_HltvReplay replayStartAt\n   * @property {number|null} [replaySlowdownBegin] CSVCMsg_HltvReplay replaySlowdownBegin\n   * @property {number|null} [replaySlowdownEnd] CSVCMsg_HltvReplay replaySlowdownEnd\n   * @property {number|null} [replaySlowdownRate] CSVCMsg_HltvReplay replaySlowdownRate\n   */\n\n  /**\n   * Constructs a new CSVCMsg_HltvReplay.\n   * @exports CSVCMsg_HltvReplay\n   * @classdesc Represents a CSVCMsg_HltvReplay.\n   * @implements ICSVCMsg_HltvReplay\n   * @constructor\n   * @param {ICSVCMsg_HltvReplay=} [properties] Properties to set\n   */\n  function CSVCMsg_HltvReplay(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSVCMsg_HltvReplay delay.\n   * @member {number} delay\n   * @memberof CSVCMsg_HltvReplay\n   * @instance\n   */\n\n\n  CSVCMsg_HltvReplay.prototype.delay = 0;\n  /**\n   * CSVCMsg_HltvReplay primaryTarget.\n   * @member {number} primaryTarget\n   * @memberof CSVCMsg_HltvReplay\n   * @instance\n   */\n\n  CSVCMsg_HltvReplay.prototype.primaryTarget = 0;\n  /**\n   * CSVCMsg_HltvReplay replayStopAt.\n   * @member {number} replayStopAt\n   * @memberof CSVCMsg_HltvReplay\n   * @instance\n   */\n\n  CSVCMsg_HltvReplay.prototype.replayStopAt = 0;\n  /**\n   * CSVCMsg_HltvReplay replayStartAt.\n   * @member {number} replayStartAt\n   * @memberof CSVCMsg_HltvReplay\n   * @instance\n   */\n\n  CSVCMsg_HltvReplay.prototype.replayStartAt = 0;\n  /**\n   * CSVCMsg_HltvReplay replaySlowdownBegin.\n   * @member {number} replaySlowdownBegin\n   * @memberof CSVCMsg_HltvReplay\n   * @instance\n   */\n\n  CSVCMsg_HltvReplay.prototype.replaySlowdownBegin = 0;\n  /**\n   * CSVCMsg_HltvReplay replaySlowdownEnd.\n   * @member {number} replaySlowdownEnd\n   * @memberof CSVCMsg_HltvReplay\n   * @instance\n   */\n\n  CSVCMsg_HltvReplay.prototype.replaySlowdownEnd = 0;\n  /**\n   * CSVCMsg_HltvReplay replaySlowdownRate.\n   * @member {number} replaySlowdownRate\n   * @memberof CSVCMsg_HltvReplay\n   * @instance\n   */\n\n  CSVCMsg_HltvReplay.prototype.replaySlowdownRate = 0;\n  /**\n   * Decodes a CSVCMsg_HltvReplay message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSVCMsg_HltvReplay\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSVCMsg_HltvReplay} CSVCMsg_HltvReplay\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSVCMsg_HltvReplay.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSVCMsg_HltvReplay();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.delay = reader.int32();\n          break;\n\n        case 2:\n          message.primaryTarget = reader.int32();\n          break;\n\n        case 3:\n          message.replayStopAt = reader.int32();\n          break;\n\n        case 4:\n          message.replayStartAt = reader.int32();\n          break;\n\n        case 5:\n          message.replaySlowdownBegin = reader.int32();\n          break;\n\n        case 6:\n          message.replaySlowdownEnd = reader.int32();\n          break;\n\n        case 7:\n          message.replaySlowdownRate = reader.float();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CSVCMsg_HltvReplay;\n})();\n\nexports.CCLCMsg_HltvReplay = $root.CCLCMsg_HltvReplay = (() => {\n  /**\n   * Properties of a CCLCMsg_HltvReplay.\n   * @exports ICCLCMsg_HltvReplay\n   * @interface ICCLCMsg_HltvReplay\n   * @property {number|null} [request] CCLCMsg_HltvReplay request\n   * @property {number|null} [slowdownLength] CCLCMsg_HltvReplay slowdownLength\n   * @property {number|null} [slowdownRate] CCLCMsg_HltvReplay slowdownRate\n   * @property {number|null} [primaryTargetEntIndex] CCLCMsg_HltvReplay primaryTargetEntIndex\n   * @property {number|null} [eventTime] CCLCMsg_HltvReplay eventTime\n   */\n\n  /**\n   * Constructs a new CCLCMsg_HltvReplay.\n   * @exports CCLCMsg_HltvReplay\n   * @classdesc Represents a CCLCMsg_HltvReplay.\n   * @implements ICCLCMsg_HltvReplay\n   * @constructor\n   * @param {ICCLCMsg_HltvReplay=} [properties] Properties to set\n   */\n  function CCLCMsg_HltvReplay(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CCLCMsg_HltvReplay request.\n   * @member {number} request\n   * @memberof CCLCMsg_HltvReplay\n   * @instance\n   */\n\n\n  CCLCMsg_HltvReplay.prototype.request = 0;\n  /**\n   * CCLCMsg_HltvReplay slowdownLength.\n   * @member {number} slowdownLength\n   * @memberof CCLCMsg_HltvReplay\n   * @instance\n   */\n\n  CCLCMsg_HltvReplay.prototype.slowdownLength = 0;\n  /**\n   * CCLCMsg_HltvReplay slowdownRate.\n   * @member {number} slowdownRate\n   * @memberof CCLCMsg_HltvReplay\n   * @instance\n   */\n\n  CCLCMsg_HltvReplay.prototype.slowdownRate = 0;\n  /**\n   * CCLCMsg_HltvReplay primaryTargetEntIndex.\n   * @member {number} primaryTargetEntIndex\n   * @memberof CCLCMsg_HltvReplay\n   * @instance\n   */\n\n  CCLCMsg_HltvReplay.prototype.primaryTargetEntIndex = 0;\n  /**\n   * CCLCMsg_HltvReplay eventTime.\n   * @member {number} eventTime\n   * @memberof CCLCMsg_HltvReplay\n   * @instance\n   */\n\n  CCLCMsg_HltvReplay.prototype.eventTime = 0;\n  /**\n   * Decodes a CCLCMsg_HltvReplay message from the specified reader or buffer.\n   * @function decode\n   * @memberof CCLCMsg_HltvReplay\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CCLCMsg_HltvReplay} CCLCMsg_HltvReplay\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CCLCMsg_HltvReplay.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CCLCMsg_HltvReplay();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.request = reader.int32();\n          break;\n\n        case 2:\n          message.slowdownLength = reader.float();\n          break;\n\n        case 3:\n          message.slowdownRate = reader.float();\n          break;\n\n        case 4:\n          message.primaryTargetEntIndex = reader.int32();\n          break;\n\n        case 5:\n          message.eventTime = reader.float();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CCLCMsg_HltvReplay;\n})();\n/**\n * ECsgoGCMsg enum.\n * @exports ECsgoGCMsg\n * @enum {string}\n * @property {number} k_EMsgGCCStrike15_v2_Base=9100 k_EMsgGCCStrike15_v2_Base value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingStart=9101 k_EMsgGCCStrike15_v2_MatchmakingStart value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingStop=9102 k_EMsgGCCStrike15_v2_MatchmakingStop value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing=9103 k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate=9104 k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ServerReserve=9105 k_EMsgGCCStrike15_v2_MatchmakingGC2ServerReserve value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse=9106 k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve=9107 k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingServerRoundStats=9108 k_EMsgGCCStrike15_v2_MatchmakingServerRoundStats value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello=9109 k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello=9110 k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingServerMatchEnd=9111 k_EMsgGCCStrike15_v2_MatchmakingServerMatchEnd value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon=9112 k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick=9113 k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm=9114 k_EMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats=9115 k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate=9116 k_EMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate=9117 k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate value\n * @property {number} k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty=9118 k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty value\n * @property {number} k_EMsgGCCStrike15_v2_ClientReportPlayer=9119 k_EMsgGCCStrike15_v2_ClientReportPlayer value\n * @property {number} k_EMsgGCCStrike15_v2_ClientReportServer=9120 k_EMsgGCCStrike15_v2_ClientReportServer value\n * @property {number} k_EMsgGCCStrike15_v2_ClientCommendPlayer=9121 k_EMsgGCCStrike15_v2_ClientCommendPlayer value\n * @property {number} k_EMsgGCCStrike15_v2_ClientReportResponse=9122 k_EMsgGCCStrike15_v2_ClientReportResponse value\n * @property {number} k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery=9123 k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery value\n * @property {number} k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse=9124 k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse value\n * @property {number} k_EMsgGCCStrike15_v2_WatchInfoUsers=9126 k_EMsgGCCStrike15_v2_WatchInfoUsers value\n * @property {number} k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile=9127 k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile value\n * @property {number} k_EMsgGCCStrike15_v2_PlayersProfile=9128 k_EMsgGCCStrike15_v2_PlayersProfile value\n * @property {number} k_EMsgGCCStrike15_v2_SetMyMedalsInfo=9129 k_EMsgGCCStrike15_v2_SetMyMedalsInfo value\n * @property {number} k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate=9131 k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate value\n * @property {number} k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment=9132 k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment value\n * @property {number} k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus=9133 k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus value\n * @property {number} k_EMsgGCCStrike15_v2_GC2ClientTextMsg=9134 k_EMsgGCCStrike15_v2_GC2ClientTextMsg value\n * @property {number} k_EMsgGCCStrike15_v2_Client2GCTextMsg=9135 k_EMsgGCCStrike15_v2_Client2GCTextMsg value\n * @property {number} k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops=9136 k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops value\n * @property {number} k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification=9137 k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification value\n * @property {number} k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2=9138 k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2 value\n * @property {number} k_EMsgGCCStrike15_v2_MatchList=9139 k_EMsgGCCStrike15_v2_MatchList value\n * @property {number} k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames=9140 k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames value\n * @property {number} k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames=9141 k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames value\n * @property {number} k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate=9142 k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate value\n * @property {number} k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo=9144 k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo value\n * @property {number} k_EMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification=9145 k_EMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification value\n * @property {number} k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames=9146 k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames value\n * @property {number} k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo=9147 k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo value\n * @property {number} k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest=9148 k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest value\n * @property {number} k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse=9149 k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse value\n * @property {number} k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo=9150 k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo value\n * @property {number} k_EMsgGCToGCReloadVersions=9151 k_EMsgGCToGCReloadVersions value\n * @property {number} k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote=9152 k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote value\n * @property {number} k_EMsgGCCStrike15_v2_Server2GCClientValidate=9153 k_EMsgGCCStrike15_v2_Server2GCClientValidate value\n * @property {number} k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser=9154 k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser value\n * @property {number} k_EMsgGCCStrike15_v2_Server2GCPureServerValidationFailure=9155 k_EMsgGCCStrike15_v2_Server2GCPureServerValidationFailure value\n * @property {number} k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest=9156 k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest value\n * @property {number} k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse=9157 k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse value\n * @property {number} k_EMsgGCCStrike15_v2_AccountPrivacySettings=9158 k_EMsgGCCStrike15_v2_AccountPrivacySettings value\n * @property {number} k_EMsgGCCStrike15_v2_SetMyActivityInfo=9159 k_EMsgGCCStrike15_v2_SetMyActivityInfo value\n * @property {number} k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions=9160 k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions value\n * @property {number} k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions=9161 k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions value\n * @property {number} k_EMsgGCCStrike15_v2_DraftSummary=9162 k_EMsgGCCStrike15_v2_DraftSummary value\n * @property {number} k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData=9163 k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData value\n * @property {number} k_EMsgGCCStrike15_v2_ClientRequestJoinServerData=9164 k_EMsgGCCStrike15_v2_ClientRequestJoinServerData value\n * @property {number} k_EMsgGCCStrike15_v2_ClientRequestNewMission=9165 k_EMsgGCCStrike15_v2_ClientRequestNewMission value\n * @property {number} k_EMsgGCCStrike15_v2_GC2ServerNotifyXPRewarded=9166 k_EMsgGCCStrike15_v2_GC2ServerNotifyXPRewarded value\n * @property {number} k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo=9167 k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo value\n * @property {number} k_EMsgGC_GlobalGame_Subscribe=9168 k_EMsgGC_GlobalGame_Subscribe value\n * @property {number} k_EMsgGC_GlobalGame_Unsubscribe=9169 k_EMsgGC_GlobalGame_Unsubscribe value\n * @property {number} k_EMsgGC_GlobalGame_Play=9170 k_EMsgGC_GlobalGame_Play value\n * @property {number} k_EMsgGCCStrike15_v2_AcknowledgePenalty=9171 k_EMsgGCCStrike15_v2_AcknowledgePenalty value\n * @property {number} k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin=9172 k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin value\n * @property {number} k_EMsgGCCStrike15_v2_GC2ClientGlobalStats=9173 k_EMsgGCCStrike15_v2_GC2ClientGlobalStats value\n * @property {number} k_EMsgGCCStrike15_v2_Client2GCStreamUnlock=9174 k_EMsgGCCStrike15_v2_Client2GCStreamUnlock value\n * @property {number} k_EMsgGCCStrike15_v2_FantasyRequestClientData=9175 k_EMsgGCCStrike15_v2_FantasyRequestClientData value\n * @property {number} k_EMsgGCCStrike15_v2_FantasyUpdateClientData=9176 k_EMsgGCCStrike15_v2_FantasyUpdateClientData value\n */\n\n\n$root.ECsgoGCMsg = function () {\n  const valuesById = {},\n        values = Object.create(valuesById);\n  values[valuesById[9100] = \"k_EMsgGCCStrike15_v2_Base\"] = 9100;\n  values[valuesById[9101] = \"k_EMsgGCCStrike15_v2_MatchmakingStart\"] = 9101;\n  values[valuesById[9102] = \"k_EMsgGCCStrike15_v2_MatchmakingStop\"] = 9102;\n  values[valuesById[9103] = \"k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing\"] = 9103;\n  values[valuesById[9104] = \"k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\"] = 9104;\n  values[valuesById[9105] = \"k_EMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\"] = 9105;\n  values[valuesById[9106] = \"k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse\"] = 9106;\n  values[valuesById[9107] = \"k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\"] = 9107;\n  values[valuesById[9108] = \"k_EMsgGCCStrike15_v2_MatchmakingServerRoundStats\"] = 9108;\n  values[valuesById[9109] = \"k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello\"] = 9109;\n  values[valuesById[9110] = \"k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello\"] = 9110;\n  values[valuesById[9111] = \"k_EMsgGCCStrike15_v2_MatchmakingServerMatchEnd\"] = 9111;\n  values[valuesById[9112] = \"k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon\"] = 9112;\n  values[valuesById[9113] = \"k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick\"] = 9113;\n  values[valuesById[9114] = \"k_EMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm\"] = 9114;\n  values[valuesById[9115] = \"k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats\"] = 9115;\n  values[valuesById[9116] = \"k_EMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate\"] = 9116;\n  values[valuesById[9117] = \"k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate\"] = 9117;\n  values[valuesById[9118] = \"k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty\"] = 9118;\n  values[valuesById[9119] = \"k_EMsgGCCStrike15_v2_ClientReportPlayer\"] = 9119;\n  values[valuesById[9120] = \"k_EMsgGCCStrike15_v2_ClientReportServer\"] = 9120;\n  values[valuesById[9121] = \"k_EMsgGCCStrike15_v2_ClientCommendPlayer\"] = 9121;\n  values[valuesById[9122] = \"k_EMsgGCCStrike15_v2_ClientReportResponse\"] = 9122;\n  values[valuesById[9123] = \"k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery\"] = 9123;\n  values[valuesById[9124] = \"k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse\"] = 9124;\n  values[valuesById[9126] = \"k_EMsgGCCStrike15_v2_WatchInfoUsers\"] = 9126;\n  values[valuesById[9127] = \"k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile\"] = 9127;\n  values[valuesById[9128] = \"k_EMsgGCCStrike15_v2_PlayersProfile\"] = 9128;\n  values[valuesById[9129] = \"k_EMsgGCCStrike15_v2_SetMyMedalsInfo\"] = 9129;\n  values[valuesById[9131] = \"k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\"] = 9131;\n  values[valuesById[9132] = \"k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\"] = 9132;\n  values[valuesById[9133] = \"k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus\"] = 9133;\n  values[valuesById[9134] = \"k_EMsgGCCStrike15_v2_GC2ClientTextMsg\"] = 9134;\n  values[valuesById[9135] = \"k_EMsgGCCStrike15_v2_Client2GCTextMsg\"] = 9135;\n  values[valuesById[9136] = \"k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops\"] = 9136;\n  values[valuesById[9137] = \"k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification\"] = 9137;\n  values[valuesById[9138] = \"k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2\"] = 9138;\n  values[valuesById[9139] = \"k_EMsgGCCStrike15_v2_MatchList\"] = 9139;\n  values[valuesById[9140] = \"k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames\"] = 9140;\n  values[valuesById[9141] = \"k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames\"] = 9141;\n  values[valuesById[9142] = \"k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate\"] = 9142;\n  values[valuesById[9144] = \"k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo\"] = 9144;\n  values[valuesById[9145] = \"k_EMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification\"] = 9145;\n  values[valuesById[9146] = \"k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames\"] = 9146;\n  values[valuesById[9147] = \"k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo\"] = 9147;\n  values[valuesById[9148] = \"k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest\"] = 9148;\n  values[valuesById[9149] = \"k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse\"] = 9149;\n  values[valuesById[9150] = \"k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo\"] = 9150;\n  values[valuesById[9151] = \"k_EMsgGCToGCReloadVersions\"] = 9151;\n  values[valuesById[9152] = \"k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote\"] = 9152;\n  values[valuesById[9153] = \"k_EMsgGCCStrike15_v2_Server2GCClientValidate\"] = 9153;\n  values[valuesById[9154] = \"k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser\"] = 9154;\n  values[valuesById[9155] = \"k_EMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\"] = 9155;\n  values[valuesById[9156] = \"k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest\"] = 9156;\n  values[valuesById[9157] = \"k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse\"] = 9157;\n  values[valuesById[9158] = \"k_EMsgGCCStrike15_v2_AccountPrivacySettings\"] = 9158;\n  values[valuesById[9159] = \"k_EMsgGCCStrike15_v2_SetMyActivityInfo\"] = 9159;\n  values[valuesById[9160] = \"k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions\"] = 9160;\n  values[valuesById[9161] = \"k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions\"] = 9161;\n  values[valuesById[9162] = \"k_EMsgGCCStrike15_v2_DraftSummary\"] = 9162;\n  values[valuesById[9163] = \"k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData\"] = 9163;\n  values[valuesById[9164] = \"k_EMsgGCCStrike15_v2_ClientRequestJoinServerData\"] = 9164;\n  values[valuesById[9165] = \"k_EMsgGCCStrike15_v2_ClientRequestNewMission\"] = 9165;\n  values[valuesById[9166] = \"k_EMsgGCCStrike15_v2_GC2ServerNotifyXPRewarded\"] = 9166;\n  values[valuesById[9167] = \"k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo\"] = 9167;\n  values[valuesById[9168] = \"k_EMsgGC_GlobalGame_Subscribe\"] = 9168;\n  values[valuesById[9169] = \"k_EMsgGC_GlobalGame_Unsubscribe\"] = 9169;\n  values[valuesById[9170] = \"k_EMsgGC_GlobalGame_Play\"] = 9170;\n  values[valuesById[9171] = \"k_EMsgGCCStrike15_v2_AcknowledgePenalty\"] = 9171;\n  values[valuesById[9172] = \"k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin\"] = 9172;\n  values[valuesById[9173] = \"k_EMsgGCCStrike15_v2_GC2ClientGlobalStats\"] = 9173;\n  values[valuesById[9174] = \"k_EMsgGCCStrike15_v2_Client2GCStreamUnlock\"] = 9174;\n  values[valuesById[9175] = \"k_EMsgGCCStrike15_v2_FantasyRequestClientData\"] = 9175;\n  values[valuesById[9176] = \"k_EMsgGCCStrike15_v2_FantasyUpdateClientData\"] = 9176;\n  return values;\n}();\n\nexports.GameServerPing = $root.GameServerPing = (() => {\n  /**\n   * Properties of a GameServerPing.\n   * @exports IGameServerPing\n   * @interface IGameServerPing\n   * @property {number|Long|null} [gameserverId] GameServerPing gameserverId\n   * @property {number|null} [ping] GameServerPing ping\n   * @property {number|null} [ip] GameServerPing ip\n   * @property {number|null} [port] GameServerPing port\n   * @property {number|null} [instances] GameServerPing instances\n   */\n\n  /**\n   * Constructs a new GameServerPing.\n   * @exports GameServerPing\n   * @classdesc Represents a GameServerPing.\n   * @implements IGameServerPing\n   * @constructor\n   * @param {IGameServerPing=} [properties] Properties to set\n   */\n  function GameServerPing(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * GameServerPing gameserverId.\n   * @member {number|Long} gameserverId\n   * @memberof GameServerPing\n   * @instance\n   */\n\n\n  GameServerPing.prototype.gameserverId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * GameServerPing ping.\n   * @member {number} ping\n   * @memberof GameServerPing\n   * @instance\n   */\n\n  GameServerPing.prototype.ping = 0;\n  /**\n   * GameServerPing ip.\n   * @member {number} ip\n   * @memberof GameServerPing\n   * @instance\n   */\n\n  GameServerPing.prototype.ip = 0;\n  /**\n   * GameServerPing port.\n   * @member {number} port\n   * @memberof GameServerPing\n   * @instance\n   */\n\n  GameServerPing.prototype.port = 0;\n  /**\n   * GameServerPing instances.\n   * @member {number} instances\n   * @memberof GameServerPing\n   * @instance\n   */\n\n  GameServerPing.prototype.instances = 0;\n  /**\n   * Decodes a GameServerPing message from the specified reader or buffer.\n   * @function decode\n   * @memberof GameServerPing\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {GameServerPing} GameServerPing\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  GameServerPing.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.GameServerPing();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.gameserverId = reader.uint64();\n          break;\n\n        case 2:\n          message.ping = reader.int32();\n          break;\n\n        case 3:\n          message.ip = reader.uint32();\n          break;\n\n        case 4:\n          message.port = reader.uint32();\n          break;\n\n        case 5:\n          message.instances = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return GameServerPing;\n})();\n\nexports.DetailedSearchStatistic = $root.DetailedSearchStatistic = (() => {\n  /**\n   * Properties of a DetailedSearchStatistic.\n   * @exports IDetailedSearchStatistic\n   * @interface IDetailedSearchStatistic\n   * @property {number|null} [gameType] DetailedSearchStatistic gameType\n   * @property {number|null} [searchTimeAvg] DetailedSearchStatistic searchTimeAvg\n   * @property {number|null} [playersSearching] DetailedSearchStatistic playersSearching\n   */\n\n  /**\n   * Constructs a new DetailedSearchStatistic.\n   * @exports DetailedSearchStatistic\n   * @classdesc Represents a DetailedSearchStatistic.\n   * @implements IDetailedSearchStatistic\n   * @constructor\n   * @param {IDetailedSearchStatistic=} [properties] Properties to set\n   */\n  function DetailedSearchStatistic(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * DetailedSearchStatistic gameType.\n   * @member {number} gameType\n   * @memberof DetailedSearchStatistic\n   * @instance\n   */\n\n\n  DetailedSearchStatistic.prototype.gameType = 0;\n  /**\n   * DetailedSearchStatistic searchTimeAvg.\n   * @member {number} searchTimeAvg\n   * @memberof DetailedSearchStatistic\n   * @instance\n   */\n\n  DetailedSearchStatistic.prototype.searchTimeAvg = 0;\n  /**\n   * DetailedSearchStatistic playersSearching.\n   * @member {number} playersSearching\n   * @memberof DetailedSearchStatistic\n   * @instance\n   */\n\n  DetailedSearchStatistic.prototype.playersSearching = 0;\n  /**\n   * Decodes a DetailedSearchStatistic message from the specified reader or buffer.\n   * @function decode\n   * @memberof DetailedSearchStatistic\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {DetailedSearchStatistic} DetailedSearchStatistic\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  DetailedSearchStatistic.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.DetailedSearchStatistic();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.gameType = reader.uint32();\n          break;\n\n        case 2:\n          message.searchTimeAvg = reader.uint32();\n          break;\n\n        case 4:\n          message.playersSearching = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return DetailedSearchStatistic;\n})();\n\nexports.TournamentPlayer = $root.TournamentPlayer = (() => {\n  /**\n   * Properties of a TournamentPlayer.\n   * @exports ITournamentPlayer\n   * @interface ITournamentPlayer\n   * @property {number|null} [accountId] TournamentPlayer accountId\n   * @property {string|null} [playerNick] TournamentPlayer playerNick\n   * @property {string|null} [playerName] TournamentPlayer playerName\n   * @property {number|null} [playerDob] TournamentPlayer playerDob\n   * @property {string|null} [playerFlag] TournamentPlayer playerFlag\n   * @property {string|null} [playerLocation] TournamentPlayer playerLocation\n   * @property {string|null} [playerDesc] TournamentPlayer playerDesc\n   */\n\n  /**\n   * Constructs a new TournamentPlayer.\n   * @exports TournamentPlayer\n   * @classdesc Represents a TournamentPlayer.\n   * @implements ITournamentPlayer\n   * @constructor\n   * @param {ITournamentPlayer=} [properties] Properties to set\n   */\n  function TournamentPlayer(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * TournamentPlayer accountId.\n   * @member {number} accountId\n   * @memberof TournamentPlayer\n   * @instance\n   */\n\n\n  TournamentPlayer.prototype.accountId = 0;\n  /**\n   * TournamentPlayer playerNick.\n   * @member {string} playerNick\n   * @memberof TournamentPlayer\n   * @instance\n   */\n\n  TournamentPlayer.prototype.playerNick = \"\";\n  /**\n   * TournamentPlayer playerName.\n   * @member {string} playerName\n   * @memberof TournamentPlayer\n   * @instance\n   */\n\n  TournamentPlayer.prototype.playerName = \"\";\n  /**\n   * TournamentPlayer playerDob.\n   * @member {number} playerDob\n   * @memberof TournamentPlayer\n   * @instance\n   */\n\n  TournamentPlayer.prototype.playerDob = 0;\n  /**\n   * TournamentPlayer playerFlag.\n   * @member {string} playerFlag\n   * @memberof TournamentPlayer\n   * @instance\n   */\n\n  TournamentPlayer.prototype.playerFlag = \"\";\n  /**\n   * TournamentPlayer playerLocation.\n   * @member {string} playerLocation\n   * @memberof TournamentPlayer\n   * @instance\n   */\n\n  TournamentPlayer.prototype.playerLocation = \"\";\n  /**\n   * TournamentPlayer playerDesc.\n   * @member {string} playerDesc\n   * @memberof TournamentPlayer\n   * @instance\n   */\n\n  TournamentPlayer.prototype.playerDesc = \"\";\n  /**\n   * Decodes a TournamentPlayer message from the specified reader or buffer.\n   * @function decode\n   * @memberof TournamentPlayer\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {TournamentPlayer} TournamentPlayer\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  TournamentPlayer.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.TournamentPlayer();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.accountId = reader.uint32();\n          break;\n\n        case 2:\n          message.playerNick = reader.string();\n          break;\n\n        case 3:\n          message.playerName = reader.string();\n          break;\n\n        case 4:\n          message.playerDob = reader.uint32();\n          break;\n\n        case 5:\n          message.playerFlag = reader.string();\n          break;\n\n        case 6:\n          message.playerLocation = reader.string();\n          break;\n\n        case 7:\n          message.playerDesc = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return TournamentPlayer;\n})();\n\nexports.TournamentTeam = $root.TournamentTeam = (() => {\n  /**\n   * Properties of a TournamentTeam.\n   * @exports ITournamentTeam\n   * @interface ITournamentTeam\n   * @property {number|null} [teamId] TournamentTeam teamId\n   * @property {string|null} [teamTag] TournamentTeam teamTag\n   * @property {string|null} [teamFlag] TournamentTeam teamFlag\n   * @property {string|null} [teamName] TournamentTeam teamName\n   * @property {Array.<ITournamentPlayer>|null} [players] TournamentTeam players\n   */\n\n  /**\n   * Constructs a new TournamentTeam.\n   * @exports TournamentTeam\n   * @classdesc Represents a TournamentTeam.\n   * @implements ITournamentTeam\n   * @constructor\n   * @param {ITournamentTeam=} [properties] Properties to set\n   */\n  function TournamentTeam(properties) {\n    this.players = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * TournamentTeam teamId.\n   * @member {number} teamId\n   * @memberof TournamentTeam\n   * @instance\n   */\n\n\n  TournamentTeam.prototype.teamId = 0;\n  /**\n   * TournamentTeam teamTag.\n   * @member {string} teamTag\n   * @memberof TournamentTeam\n   * @instance\n   */\n\n  TournamentTeam.prototype.teamTag = \"\";\n  /**\n   * TournamentTeam teamFlag.\n   * @member {string} teamFlag\n   * @memberof TournamentTeam\n   * @instance\n   */\n\n  TournamentTeam.prototype.teamFlag = \"\";\n  /**\n   * TournamentTeam teamName.\n   * @member {string} teamName\n   * @memberof TournamentTeam\n   * @instance\n   */\n\n  TournamentTeam.prototype.teamName = \"\";\n  /**\n   * TournamentTeam players.\n   * @member {Array.<ITournamentPlayer>} players\n   * @memberof TournamentTeam\n   * @instance\n   */\n\n  TournamentTeam.prototype.players = $util.emptyArray;\n  /**\n   * Decodes a TournamentTeam message from the specified reader or buffer.\n   * @function decode\n   * @memberof TournamentTeam\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {TournamentTeam} TournamentTeam\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  TournamentTeam.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.TournamentTeam();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.teamId = reader.int32();\n          break;\n\n        case 2:\n          message.teamTag = reader.string();\n          break;\n\n        case 3:\n          message.teamFlag = reader.string();\n          break;\n\n        case 4:\n          message.teamName = reader.string();\n          break;\n\n        case 5:\n          if (!(message.players && message.players.length)) message.players = [];\n          message.players.push($root.TournamentPlayer.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return TournamentTeam;\n})();\n\nexports.TournamentEvent = $root.TournamentEvent = (() => {\n  /**\n   * Properties of a TournamentEvent.\n   * @exports ITournamentEvent\n   * @interface ITournamentEvent\n   * @property {number|null} [eventId] TournamentEvent eventId\n   * @property {string|null} [eventTag] TournamentEvent eventTag\n   * @property {string|null} [eventName] TournamentEvent eventName\n   * @property {number|null} [eventTimeStart] TournamentEvent eventTimeStart\n   * @property {number|null} [eventTimeEnd] TournamentEvent eventTimeEnd\n   * @property {number|null} [eventPublic] TournamentEvent eventPublic\n   * @property {number|null} [eventStageId] TournamentEvent eventStageId\n   * @property {string|null} [eventStageName] TournamentEvent eventStageName\n   * @property {number|null} [activeSectionId] TournamentEvent activeSectionId\n   */\n\n  /**\n   * Constructs a new TournamentEvent.\n   * @exports TournamentEvent\n   * @classdesc Represents a TournamentEvent.\n   * @implements ITournamentEvent\n   * @constructor\n   * @param {ITournamentEvent=} [properties] Properties to set\n   */\n  function TournamentEvent(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * TournamentEvent eventId.\n   * @member {number} eventId\n   * @memberof TournamentEvent\n   * @instance\n   */\n\n\n  TournamentEvent.prototype.eventId = 0;\n  /**\n   * TournamentEvent eventTag.\n   * @member {string} eventTag\n   * @memberof TournamentEvent\n   * @instance\n   */\n\n  TournamentEvent.prototype.eventTag = \"\";\n  /**\n   * TournamentEvent eventName.\n   * @member {string} eventName\n   * @memberof TournamentEvent\n   * @instance\n   */\n\n  TournamentEvent.prototype.eventName = \"\";\n  /**\n   * TournamentEvent eventTimeStart.\n   * @member {number} eventTimeStart\n   * @memberof TournamentEvent\n   * @instance\n   */\n\n  TournamentEvent.prototype.eventTimeStart = 0;\n  /**\n   * TournamentEvent eventTimeEnd.\n   * @member {number} eventTimeEnd\n   * @memberof TournamentEvent\n   * @instance\n   */\n\n  TournamentEvent.prototype.eventTimeEnd = 0;\n  /**\n   * TournamentEvent eventPublic.\n   * @member {number} eventPublic\n   * @memberof TournamentEvent\n   * @instance\n   */\n\n  TournamentEvent.prototype.eventPublic = 0;\n  /**\n   * TournamentEvent eventStageId.\n   * @member {number} eventStageId\n   * @memberof TournamentEvent\n   * @instance\n   */\n\n  TournamentEvent.prototype.eventStageId = 0;\n  /**\n   * TournamentEvent eventStageName.\n   * @member {string} eventStageName\n   * @memberof TournamentEvent\n   * @instance\n   */\n\n  TournamentEvent.prototype.eventStageName = \"\";\n  /**\n   * TournamentEvent activeSectionId.\n   * @member {number} activeSectionId\n   * @memberof TournamentEvent\n   * @instance\n   */\n\n  TournamentEvent.prototype.activeSectionId = 0;\n  /**\n   * Decodes a TournamentEvent message from the specified reader or buffer.\n   * @function decode\n   * @memberof TournamentEvent\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {TournamentEvent} TournamentEvent\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  TournamentEvent.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.TournamentEvent();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.eventId = reader.int32();\n          break;\n\n        case 2:\n          message.eventTag = reader.string();\n          break;\n\n        case 3:\n          message.eventName = reader.string();\n          break;\n\n        case 4:\n          message.eventTimeStart = reader.uint32();\n          break;\n\n        case 5:\n          message.eventTimeEnd = reader.uint32();\n          break;\n\n        case 6:\n          message.eventPublic = reader.int32();\n          break;\n\n        case 7:\n          message.eventStageId = reader.int32();\n          break;\n\n        case 8:\n          message.eventStageName = reader.string();\n          break;\n\n        case 9:\n          message.activeSectionId = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return TournamentEvent;\n})();\n\nexports.GlobalStatistics = $root.GlobalStatistics = (() => {\n  /**\n   * Properties of a GlobalStatistics.\n   * @exports IGlobalStatistics\n   * @interface IGlobalStatistics\n   * @property {number|null} [playersOnline] GlobalStatistics playersOnline\n   * @property {number|null} [serversOnline] GlobalStatistics serversOnline\n   * @property {number|null} [playersSearching] GlobalStatistics playersSearching\n   * @property {number|null} [serversAvailable] GlobalStatistics serversAvailable\n   * @property {number|null} [ongoingMatches] GlobalStatistics ongoingMatches\n   * @property {number|null} [searchTimeAvg] GlobalStatistics searchTimeAvg\n   * @property {Array.<IDetailedSearchStatistic>|null} [searchStatistics] GlobalStatistics searchStatistics\n   * @property {string|null} [mainPostUrl] GlobalStatistics mainPostUrl\n   * @property {number|null} [requiredAppidVersion] GlobalStatistics requiredAppidVersion\n   * @property {number|null} [pricesheetVersion] GlobalStatistics pricesheetVersion\n   * @property {number|null} [twitchStreamsVersion] GlobalStatistics twitchStreamsVersion\n   * @property {number|null} [activeTournamentEventid] GlobalStatistics activeTournamentEventid\n   * @property {number|null} [activeSurveyId] GlobalStatistics activeSurveyId\n   */\n\n  /**\n   * Constructs a new GlobalStatistics.\n   * @exports GlobalStatistics\n   * @classdesc Represents a GlobalStatistics.\n   * @implements IGlobalStatistics\n   * @constructor\n   * @param {IGlobalStatistics=} [properties] Properties to set\n   */\n  function GlobalStatistics(properties) {\n    this.searchStatistics = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * GlobalStatistics playersOnline.\n   * @member {number} playersOnline\n   * @memberof GlobalStatistics\n   * @instance\n   */\n\n\n  GlobalStatistics.prototype.playersOnline = 0;\n  /**\n   * GlobalStatistics serversOnline.\n   * @member {number} serversOnline\n   * @memberof GlobalStatistics\n   * @instance\n   */\n\n  GlobalStatistics.prototype.serversOnline = 0;\n  /**\n   * GlobalStatistics playersSearching.\n   * @member {number} playersSearching\n   * @memberof GlobalStatistics\n   * @instance\n   */\n\n  GlobalStatistics.prototype.playersSearching = 0;\n  /**\n   * GlobalStatistics serversAvailable.\n   * @member {number} serversAvailable\n   * @memberof GlobalStatistics\n   * @instance\n   */\n\n  GlobalStatistics.prototype.serversAvailable = 0;\n  /**\n   * GlobalStatistics ongoingMatches.\n   * @member {number} ongoingMatches\n   * @memberof GlobalStatistics\n   * @instance\n   */\n\n  GlobalStatistics.prototype.ongoingMatches = 0;\n  /**\n   * GlobalStatistics searchTimeAvg.\n   * @member {number} searchTimeAvg\n   * @memberof GlobalStatistics\n   * @instance\n   */\n\n  GlobalStatistics.prototype.searchTimeAvg = 0;\n  /**\n   * GlobalStatistics searchStatistics.\n   * @member {Array.<IDetailedSearchStatistic>} searchStatistics\n   * @memberof GlobalStatistics\n   * @instance\n   */\n\n  GlobalStatistics.prototype.searchStatistics = $util.emptyArray;\n  /**\n   * GlobalStatistics mainPostUrl.\n   * @member {string} mainPostUrl\n   * @memberof GlobalStatistics\n   * @instance\n   */\n\n  GlobalStatistics.prototype.mainPostUrl = \"\";\n  /**\n   * GlobalStatistics requiredAppidVersion.\n   * @member {number} requiredAppidVersion\n   * @memberof GlobalStatistics\n   * @instance\n   */\n\n  GlobalStatistics.prototype.requiredAppidVersion = 0;\n  /**\n   * GlobalStatistics pricesheetVersion.\n   * @member {number} pricesheetVersion\n   * @memberof GlobalStatistics\n   * @instance\n   */\n\n  GlobalStatistics.prototype.pricesheetVersion = 0;\n  /**\n   * GlobalStatistics twitchStreamsVersion.\n   * @member {number} twitchStreamsVersion\n   * @memberof GlobalStatistics\n   * @instance\n   */\n\n  GlobalStatistics.prototype.twitchStreamsVersion = 0;\n  /**\n   * GlobalStatistics activeTournamentEventid.\n   * @member {number} activeTournamentEventid\n   * @memberof GlobalStatistics\n   * @instance\n   */\n\n  GlobalStatistics.prototype.activeTournamentEventid = 0;\n  /**\n   * GlobalStatistics activeSurveyId.\n   * @member {number} activeSurveyId\n   * @memberof GlobalStatistics\n   * @instance\n   */\n\n  GlobalStatistics.prototype.activeSurveyId = 0;\n  /**\n   * Decodes a GlobalStatistics message from the specified reader or buffer.\n   * @function decode\n   * @memberof GlobalStatistics\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {GlobalStatistics} GlobalStatistics\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  GlobalStatistics.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.GlobalStatistics();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.playersOnline = reader.uint32();\n          break;\n\n        case 2:\n          message.serversOnline = reader.uint32();\n          break;\n\n        case 3:\n          message.playersSearching = reader.uint32();\n          break;\n\n        case 4:\n          message.serversAvailable = reader.uint32();\n          break;\n\n        case 5:\n          message.ongoingMatches = reader.uint32();\n          break;\n\n        case 6:\n          message.searchTimeAvg = reader.uint32();\n          break;\n\n        case 7:\n          if (!(message.searchStatistics && message.searchStatistics.length)) message.searchStatistics = [];\n          message.searchStatistics.push($root.DetailedSearchStatistic.decode(reader, reader.uint32()));\n          break;\n\n        case 8:\n          message.mainPostUrl = reader.string();\n          break;\n\n        case 9:\n          message.requiredAppidVersion = reader.uint32();\n          break;\n\n        case 10:\n          message.pricesheetVersion = reader.uint32();\n          break;\n\n        case 11:\n          message.twitchStreamsVersion = reader.uint32();\n          break;\n\n        case 12:\n          message.activeTournamentEventid = reader.uint32();\n          break;\n\n        case 13:\n          message.activeSurveyId = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return GlobalStatistics;\n})();\n\nexports.OperationalStatisticDescription = $root.OperationalStatisticDescription = (() => {\n  /**\n   * Properties of an OperationalStatisticDescription.\n   * @exports IOperationalStatisticDescription\n   * @interface IOperationalStatisticDescription\n   * @property {string|null} [name] OperationalStatisticDescription name\n   * @property {number|null} [idkey] OperationalStatisticDescription idkey\n   */\n\n  /**\n   * Constructs a new OperationalStatisticDescription.\n   * @exports OperationalStatisticDescription\n   * @classdesc Represents an OperationalStatisticDescription.\n   * @implements IOperationalStatisticDescription\n   * @constructor\n   * @param {IOperationalStatisticDescription=} [properties] Properties to set\n   */\n  function OperationalStatisticDescription(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * OperationalStatisticDescription name.\n   * @member {string} name\n   * @memberof OperationalStatisticDescription\n   * @instance\n   */\n\n\n  OperationalStatisticDescription.prototype.name = \"\";\n  /**\n   * OperationalStatisticDescription idkey.\n   * @member {number} idkey\n   * @memberof OperationalStatisticDescription\n   * @instance\n   */\n\n  OperationalStatisticDescription.prototype.idkey = 0;\n  /**\n   * Decodes an OperationalStatisticDescription message from the specified reader or buffer.\n   * @function decode\n   * @memberof OperationalStatisticDescription\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {OperationalStatisticDescription} OperationalStatisticDescription\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  OperationalStatisticDescription.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.OperationalStatisticDescription();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.name = reader.string();\n          break;\n\n        case 2:\n          message.idkey = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return OperationalStatisticDescription;\n})();\n\nexports.OperationalStatisticElement = $root.OperationalStatisticElement = (() => {\n  /**\n   * Properties of an OperationalStatisticElement.\n   * @exports IOperationalStatisticElement\n   * @interface IOperationalStatisticElement\n   * @property {number|null} [idkey] OperationalStatisticElement idkey\n   * @property {Array.<number>|null} [values] OperationalStatisticElement values\n   */\n\n  /**\n   * Constructs a new OperationalStatisticElement.\n   * @exports OperationalStatisticElement\n   * @classdesc Represents an OperationalStatisticElement.\n   * @implements IOperationalStatisticElement\n   * @constructor\n   * @param {IOperationalStatisticElement=} [properties] Properties to set\n   */\n  function OperationalStatisticElement(properties) {\n    this.values = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * OperationalStatisticElement idkey.\n   * @member {number} idkey\n   * @memberof OperationalStatisticElement\n   * @instance\n   */\n\n\n  OperationalStatisticElement.prototype.idkey = 0;\n  /**\n   * OperationalStatisticElement values.\n   * @member {Array.<number>} values\n   * @memberof OperationalStatisticElement\n   * @instance\n   */\n\n  OperationalStatisticElement.prototype.values = $util.emptyArray;\n  /**\n   * Decodes an OperationalStatisticElement message from the specified reader or buffer.\n   * @function decode\n   * @memberof OperationalStatisticElement\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {OperationalStatisticElement} OperationalStatisticElement\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  OperationalStatisticElement.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.OperationalStatisticElement();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.idkey = reader.uint32();\n          break;\n\n        case 2:\n          if (!(message.values && message.values.length)) message.values = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.values.push(reader.int32());\n          } else message.values.push(reader.int32());\n\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return OperationalStatisticElement;\n})();\n\nexports.OperationalStatisticsPacket = $root.OperationalStatisticsPacket = (() => {\n  /**\n   * Properties of an OperationalStatisticsPacket.\n   * @exports IOperationalStatisticsPacket\n   * @interface IOperationalStatisticsPacket\n   * @property {number|null} [packetid] OperationalStatisticsPacket packetid\n   * @property {number|null} [mstimestamp] OperationalStatisticsPacket mstimestamp\n   * @property {Array.<IOperationalStatisticElement>|null} [values] OperationalStatisticsPacket values\n   */\n\n  /**\n   * Constructs a new OperationalStatisticsPacket.\n   * @exports OperationalStatisticsPacket\n   * @classdesc Represents an OperationalStatisticsPacket.\n   * @implements IOperationalStatisticsPacket\n   * @constructor\n   * @param {IOperationalStatisticsPacket=} [properties] Properties to set\n   */\n  function OperationalStatisticsPacket(properties) {\n    this.values = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * OperationalStatisticsPacket packetid.\n   * @member {number} packetid\n   * @memberof OperationalStatisticsPacket\n   * @instance\n   */\n\n\n  OperationalStatisticsPacket.prototype.packetid = 0;\n  /**\n   * OperationalStatisticsPacket mstimestamp.\n   * @member {number} mstimestamp\n   * @memberof OperationalStatisticsPacket\n   * @instance\n   */\n\n  OperationalStatisticsPacket.prototype.mstimestamp = 0;\n  /**\n   * OperationalStatisticsPacket values.\n   * @member {Array.<IOperationalStatisticElement>} values\n   * @memberof OperationalStatisticsPacket\n   * @instance\n   */\n\n  OperationalStatisticsPacket.prototype.values = $util.emptyArray;\n  /**\n   * Decodes an OperationalStatisticsPacket message from the specified reader or buffer.\n   * @function decode\n   * @memberof OperationalStatisticsPacket\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {OperationalStatisticsPacket} OperationalStatisticsPacket\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  OperationalStatisticsPacket.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.OperationalStatisticsPacket();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.packetid = reader.int32();\n          break;\n\n        case 2:\n          message.mstimestamp = reader.int32();\n          break;\n\n        case 3:\n          if (!(message.values && message.values.length)) message.values = [];\n          message.values.push($root.OperationalStatisticElement.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return OperationalStatisticsPacket;\n})();\n\nexports.PlayerRankingInfo = $root.PlayerRankingInfo = (() => {\n  /**\n   * Properties of a PlayerRankingInfo.\n   * @exports IPlayerRankingInfo\n   * @interface IPlayerRankingInfo\n   * @property {number|null} [accountId] PlayerRankingInfo accountId\n   * @property {number|null} [rankId] PlayerRankingInfo rankId\n   * @property {number|null} [wins] PlayerRankingInfo wins\n   * @property {number|null} [rankChange] PlayerRankingInfo rankChange\n   */\n\n  /**\n   * Constructs a new PlayerRankingInfo.\n   * @exports PlayerRankingInfo\n   * @classdesc Represents a PlayerRankingInfo.\n   * @implements IPlayerRankingInfo\n   * @constructor\n   * @param {IPlayerRankingInfo=} [properties] Properties to set\n   */\n  function PlayerRankingInfo(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * PlayerRankingInfo accountId.\n   * @member {number} accountId\n   * @memberof PlayerRankingInfo\n   * @instance\n   */\n\n\n  PlayerRankingInfo.prototype.accountId = 0;\n  /**\n   * PlayerRankingInfo rankId.\n   * @member {number} rankId\n   * @memberof PlayerRankingInfo\n   * @instance\n   */\n\n  PlayerRankingInfo.prototype.rankId = 0;\n  /**\n   * PlayerRankingInfo wins.\n   * @member {number} wins\n   * @memberof PlayerRankingInfo\n   * @instance\n   */\n\n  PlayerRankingInfo.prototype.wins = 0;\n  /**\n   * PlayerRankingInfo rankChange.\n   * @member {number} rankChange\n   * @memberof PlayerRankingInfo\n   * @instance\n   */\n\n  PlayerRankingInfo.prototype.rankChange = 0;\n  /**\n   * Decodes a PlayerRankingInfo message from the specified reader or buffer.\n   * @function decode\n   * @memberof PlayerRankingInfo\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {PlayerRankingInfo} PlayerRankingInfo\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  PlayerRankingInfo.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.PlayerRankingInfo();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.accountId = reader.uint32();\n          break;\n\n        case 2:\n          message.rankId = reader.uint32();\n          break;\n\n        case 3:\n          message.wins = reader.uint32();\n          break;\n\n        case 4:\n          message.rankChange = reader.float();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return PlayerRankingInfo;\n})();\n\nexports.PlayerCommendationInfo = $root.PlayerCommendationInfo = (() => {\n  /**\n   * Properties of a PlayerCommendationInfo.\n   * @exports IPlayerCommendationInfo\n   * @interface IPlayerCommendationInfo\n   * @property {number|null} [cmdFriendly] PlayerCommendationInfo cmdFriendly\n   * @property {number|null} [cmdTeaching] PlayerCommendationInfo cmdTeaching\n   * @property {number|null} [cmdLeader] PlayerCommendationInfo cmdLeader\n   */\n\n  /**\n   * Constructs a new PlayerCommendationInfo.\n   * @exports PlayerCommendationInfo\n   * @classdesc Represents a PlayerCommendationInfo.\n   * @implements IPlayerCommendationInfo\n   * @constructor\n   * @param {IPlayerCommendationInfo=} [properties] Properties to set\n   */\n  function PlayerCommendationInfo(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * PlayerCommendationInfo cmdFriendly.\n   * @member {number} cmdFriendly\n   * @memberof PlayerCommendationInfo\n   * @instance\n   */\n\n\n  PlayerCommendationInfo.prototype.cmdFriendly = 0;\n  /**\n   * PlayerCommendationInfo cmdTeaching.\n   * @member {number} cmdTeaching\n   * @memberof PlayerCommendationInfo\n   * @instance\n   */\n\n  PlayerCommendationInfo.prototype.cmdTeaching = 0;\n  /**\n   * PlayerCommendationInfo cmdLeader.\n   * @member {number} cmdLeader\n   * @memberof PlayerCommendationInfo\n   * @instance\n   */\n\n  PlayerCommendationInfo.prototype.cmdLeader = 0;\n  /**\n   * Decodes a PlayerCommendationInfo message from the specified reader or buffer.\n   * @function decode\n   * @memberof PlayerCommendationInfo\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {PlayerCommendationInfo} PlayerCommendationInfo\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  PlayerCommendationInfo.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.PlayerCommendationInfo();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.cmdFriendly = reader.uint32();\n          break;\n\n        case 2:\n          message.cmdTeaching = reader.uint32();\n          break;\n\n        case 4:\n          message.cmdLeader = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return PlayerCommendationInfo;\n})();\n\nexports.PlayerMedalsInfo = $root.PlayerMedalsInfo = (() => {\n  /**\n   * Properties of a PlayerMedalsInfo.\n   * @exports IPlayerMedalsInfo\n   * @interface IPlayerMedalsInfo\n   * @property {number|null} [medalTeam] PlayerMedalsInfo medalTeam\n   * @property {number|null} [medalCombat] PlayerMedalsInfo medalCombat\n   * @property {number|null} [medalWeapon] PlayerMedalsInfo medalWeapon\n   * @property {number|null} [medalGlobal] PlayerMedalsInfo medalGlobal\n   * @property {number|null} [medalArms] PlayerMedalsInfo medalArms\n   * @property {Array.<number>|null} [displayItemsDefidx] PlayerMedalsInfo displayItemsDefidx\n   * @property {number|null} [featuredDisplayItemDefidx] PlayerMedalsInfo featuredDisplayItemDefidx\n   */\n\n  /**\n   * Constructs a new PlayerMedalsInfo.\n   * @exports PlayerMedalsInfo\n   * @classdesc Represents a PlayerMedalsInfo.\n   * @implements IPlayerMedalsInfo\n   * @constructor\n   * @param {IPlayerMedalsInfo=} [properties] Properties to set\n   */\n  function PlayerMedalsInfo(properties) {\n    this.displayItemsDefidx = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * PlayerMedalsInfo medalTeam.\n   * @member {number} medalTeam\n   * @memberof PlayerMedalsInfo\n   * @instance\n   */\n\n\n  PlayerMedalsInfo.prototype.medalTeam = 0;\n  /**\n   * PlayerMedalsInfo medalCombat.\n   * @member {number} medalCombat\n   * @memberof PlayerMedalsInfo\n   * @instance\n   */\n\n  PlayerMedalsInfo.prototype.medalCombat = 0;\n  /**\n   * PlayerMedalsInfo medalWeapon.\n   * @member {number} medalWeapon\n   * @memberof PlayerMedalsInfo\n   * @instance\n   */\n\n  PlayerMedalsInfo.prototype.medalWeapon = 0;\n  /**\n   * PlayerMedalsInfo medalGlobal.\n   * @member {number} medalGlobal\n   * @memberof PlayerMedalsInfo\n   * @instance\n   */\n\n  PlayerMedalsInfo.prototype.medalGlobal = 0;\n  /**\n   * PlayerMedalsInfo medalArms.\n   * @member {number} medalArms\n   * @memberof PlayerMedalsInfo\n   * @instance\n   */\n\n  PlayerMedalsInfo.prototype.medalArms = 0;\n  /**\n   * PlayerMedalsInfo displayItemsDefidx.\n   * @member {Array.<number>} displayItemsDefidx\n   * @memberof PlayerMedalsInfo\n   * @instance\n   */\n\n  PlayerMedalsInfo.prototype.displayItemsDefidx = $util.emptyArray;\n  /**\n   * PlayerMedalsInfo featuredDisplayItemDefidx.\n   * @member {number} featuredDisplayItemDefidx\n   * @memberof PlayerMedalsInfo\n   * @instance\n   */\n\n  PlayerMedalsInfo.prototype.featuredDisplayItemDefidx = 0;\n  /**\n   * Decodes a PlayerMedalsInfo message from the specified reader or buffer.\n   * @function decode\n   * @memberof PlayerMedalsInfo\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {PlayerMedalsInfo} PlayerMedalsInfo\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  PlayerMedalsInfo.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.PlayerMedalsInfo();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.medalTeam = reader.uint32();\n          break;\n\n        case 2:\n          message.medalCombat = reader.uint32();\n          break;\n\n        case 3:\n          message.medalWeapon = reader.uint32();\n          break;\n\n        case 4:\n          message.medalGlobal = reader.uint32();\n          break;\n\n        case 5:\n          message.medalArms = reader.uint32();\n          break;\n\n        case 7:\n          if (!(message.displayItemsDefidx && message.displayItemsDefidx.length)) message.displayItemsDefidx = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.displayItemsDefidx.push(reader.uint32());\n          } else message.displayItemsDefidx.push(reader.uint32());\n\n          break;\n\n        case 8:\n          message.featuredDisplayItemDefidx = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return PlayerMedalsInfo;\n})();\n\nexports.AccountActivity = $root.AccountActivity = (() => {\n  /**\n   * Properties of an AccountActivity.\n   * @exports IAccountActivity\n   * @interface IAccountActivity\n   * @property {number|null} [activity] AccountActivity activity\n   * @property {number|null} [mode] AccountActivity mode\n   * @property {number|null} [map] AccountActivity map\n   */\n\n  /**\n   * Constructs a new AccountActivity.\n   * @exports AccountActivity\n   * @classdesc Represents an AccountActivity.\n   * @implements IAccountActivity\n   * @constructor\n   * @param {IAccountActivity=} [properties] Properties to set\n   */\n  function AccountActivity(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * AccountActivity activity.\n   * @member {number} activity\n   * @memberof AccountActivity\n   * @instance\n   */\n\n\n  AccountActivity.prototype.activity = 0;\n  /**\n   * AccountActivity mode.\n   * @member {number} mode\n   * @memberof AccountActivity\n   * @instance\n   */\n\n  AccountActivity.prototype.mode = 0;\n  /**\n   * AccountActivity map.\n   * @member {number} map\n   * @memberof AccountActivity\n   * @instance\n   */\n\n  AccountActivity.prototype.map = 0;\n  /**\n   * Decodes an AccountActivity message from the specified reader or buffer.\n   * @function decode\n   * @memberof AccountActivity\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {AccountActivity} AccountActivity\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  AccountActivity.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.AccountActivity();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.activity = reader.uint32();\n          break;\n\n        case 2:\n          message.mode = reader.uint32();\n          break;\n\n        case 3:\n          message.map = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return AccountActivity;\n})();\n\nexports.TournamentMatchSetup = $root.TournamentMatchSetup = (() => {\n  /**\n   * Properties of a TournamentMatchSetup.\n   * @exports ITournamentMatchSetup\n   * @interface ITournamentMatchSetup\n   * @property {number|null} [eventId] TournamentMatchSetup eventId\n   * @property {number|null} [teamIdCt] TournamentMatchSetup teamIdCt\n   * @property {number|null} [teamIdT] TournamentMatchSetup teamIdT\n   * @property {number|null} [eventStageId] TournamentMatchSetup eventStageId\n   */\n\n  /**\n   * Constructs a new TournamentMatchSetup.\n   * @exports TournamentMatchSetup\n   * @classdesc Represents a TournamentMatchSetup.\n   * @implements ITournamentMatchSetup\n   * @constructor\n   * @param {ITournamentMatchSetup=} [properties] Properties to set\n   */\n  function TournamentMatchSetup(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * TournamentMatchSetup eventId.\n   * @member {number} eventId\n   * @memberof TournamentMatchSetup\n   * @instance\n   */\n\n\n  TournamentMatchSetup.prototype.eventId = 0;\n  /**\n   * TournamentMatchSetup teamIdCt.\n   * @member {number} teamIdCt\n   * @memberof TournamentMatchSetup\n   * @instance\n   */\n\n  TournamentMatchSetup.prototype.teamIdCt = 0;\n  /**\n   * TournamentMatchSetup teamIdT.\n   * @member {number} teamIdT\n   * @memberof TournamentMatchSetup\n   * @instance\n   */\n\n  TournamentMatchSetup.prototype.teamIdT = 0;\n  /**\n   * TournamentMatchSetup eventStageId.\n   * @member {number} eventStageId\n   * @memberof TournamentMatchSetup\n   * @instance\n   */\n\n  TournamentMatchSetup.prototype.eventStageId = 0;\n  /**\n   * Decodes a TournamentMatchSetup message from the specified reader or buffer.\n   * @function decode\n   * @memberof TournamentMatchSetup\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {TournamentMatchSetup} TournamentMatchSetup\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  TournamentMatchSetup.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.TournamentMatchSetup();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.eventId = reader.int32();\n          break;\n\n        case 2:\n          message.teamIdCt = reader.int32();\n          break;\n\n        case 3:\n          message.teamIdT = reader.int32();\n          break;\n\n        case 4:\n          message.eventStageId = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return TournamentMatchSetup;\n})();\n\nexports.ServerHltvInfo = $root.ServerHltvInfo = (() => {\n  /**\n   * Properties of a ServerHltvInfo.\n   * @exports IServerHltvInfo\n   * @interface IServerHltvInfo\n   * @property {number|null} [tvUdpPort] ServerHltvInfo tvUdpPort\n   * @property {number|Long|null} [tvWatchKey] ServerHltvInfo tvWatchKey\n   * @property {number|null} [tvSlots] ServerHltvInfo tvSlots\n   * @property {number|null} [tvClients] ServerHltvInfo tvClients\n   * @property {number|null} [tvProxies] ServerHltvInfo tvProxies\n   * @property {number|null} [tvTime] ServerHltvInfo tvTime\n   * @property {number|null} [gameType] ServerHltvInfo gameType\n   * @property {string|null} [gameMapgroup] ServerHltvInfo gameMapgroup\n   * @property {string|null} [gameMap] ServerHltvInfo gameMap\n   * @property {number|Long|null} [tvMasterSteamid] ServerHltvInfo tvMasterSteamid\n   * @property {number|null} [tvLocalSlots] ServerHltvInfo tvLocalSlots\n   * @property {number|null} [tvLocalClients] ServerHltvInfo tvLocalClients\n   * @property {number|null} [tvLocalProxies] ServerHltvInfo tvLocalProxies\n   * @property {number|null} [tvRelaySlots] ServerHltvInfo tvRelaySlots\n   * @property {number|null} [tvRelayClients] ServerHltvInfo tvRelayClients\n   * @property {number|null} [tvRelayProxies] ServerHltvInfo tvRelayProxies\n   * @property {number|null} [tvRelayAddress] ServerHltvInfo tvRelayAddress\n   * @property {number|null} [tvRelayPort] ServerHltvInfo tvRelayPort\n   * @property {number|Long|null} [tvRelaySteamid] ServerHltvInfo tvRelaySteamid\n   */\n\n  /**\n   * Constructs a new ServerHltvInfo.\n   * @exports ServerHltvInfo\n   * @classdesc Represents a ServerHltvInfo.\n   * @implements IServerHltvInfo\n   * @constructor\n   * @param {IServerHltvInfo=} [properties] Properties to set\n   */\n  function ServerHltvInfo(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * ServerHltvInfo tvUdpPort.\n   * @member {number} tvUdpPort\n   * @memberof ServerHltvInfo\n   * @instance\n   */\n\n\n  ServerHltvInfo.prototype.tvUdpPort = 0;\n  /**\n   * ServerHltvInfo tvWatchKey.\n   * @member {number|Long} tvWatchKey\n   * @memberof ServerHltvInfo\n   * @instance\n   */\n\n  ServerHltvInfo.prototype.tvWatchKey = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * ServerHltvInfo tvSlots.\n   * @member {number} tvSlots\n   * @memberof ServerHltvInfo\n   * @instance\n   */\n\n  ServerHltvInfo.prototype.tvSlots = 0;\n  /**\n   * ServerHltvInfo tvClients.\n   * @member {number} tvClients\n   * @memberof ServerHltvInfo\n   * @instance\n   */\n\n  ServerHltvInfo.prototype.tvClients = 0;\n  /**\n   * ServerHltvInfo tvProxies.\n   * @member {number} tvProxies\n   * @memberof ServerHltvInfo\n   * @instance\n   */\n\n  ServerHltvInfo.prototype.tvProxies = 0;\n  /**\n   * ServerHltvInfo tvTime.\n   * @member {number} tvTime\n   * @memberof ServerHltvInfo\n   * @instance\n   */\n\n  ServerHltvInfo.prototype.tvTime = 0;\n  /**\n   * ServerHltvInfo gameType.\n   * @member {number} gameType\n   * @memberof ServerHltvInfo\n   * @instance\n   */\n\n  ServerHltvInfo.prototype.gameType = 0;\n  /**\n   * ServerHltvInfo gameMapgroup.\n   * @member {string} gameMapgroup\n   * @memberof ServerHltvInfo\n   * @instance\n   */\n\n  ServerHltvInfo.prototype.gameMapgroup = \"\";\n  /**\n   * ServerHltvInfo gameMap.\n   * @member {string} gameMap\n   * @memberof ServerHltvInfo\n   * @instance\n   */\n\n  ServerHltvInfo.prototype.gameMap = \"\";\n  /**\n   * ServerHltvInfo tvMasterSteamid.\n   * @member {number|Long} tvMasterSteamid\n   * @memberof ServerHltvInfo\n   * @instance\n   */\n\n  ServerHltvInfo.prototype.tvMasterSteamid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * ServerHltvInfo tvLocalSlots.\n   * @member {number} tvLocalSlots\n   * @memberof ServerHltvInfo\n   * @instance\n   */\n\n  ServerHltvInfo.prototype.tvLocalSlots = 0;\n  /**\n   * ServerHltvInfo tvLocalClients.\n   * @member {number} tvLocalClients\n   * @memberof ServerHltvInfo\n   * @instance\n   */\n\n  ServerHltvInfo.prototype.tvLocalClients = 0;\n  /**\n   * ServerHltvInfo tvLocalProxies.\n   * @member {number} tvLocalProxies\n   * @memberof ServerHltvInfo\n   * @instance\n   */\n\n  ServerHltvInfo.prototype.tvLocalProxies = 0;\n  /**\n   * ServerHltvInfo tvRelaySlots.\n   * @member {number} tvRelaySlots\n   * @memberof ServerHltvInfo\n   * @instance\n   */\n\n  ServerHltvInfo.prototype.tvRelaySlots = 0;\n  /**\n   * ServerHltvInfo tvRelayClients.\n   * @member {number} tvRelayClients\n   * @memberof ServerHltvInfo\n   * @instance\n   */\n\n  ServerHltvInfo.prototype.tvRelayClients = 0;\n  /**\n   * ServerHltvInfo tvRelayProxies.\n   * @member {number} tvRelayProxies\n   * @memberof ServerHltvInfo\n   * @instance\n   */\n\n  ServerHltvInfo.prototype.tvRelayProxies = 0;\n  /**\n   * ServerHltvInfo tvRelayAddress.\n   * @member {number} tvRelayAddress\n   * @memberof ServerHltvInfo\n   * @instance\n   */\n\n  ServerHltvInfo.prototype.tvRelayAddress = 0;\n  /**\n   * ServerHltvInfo tvRelayPort.\n   * @member {number} tvRelayPort\n   * @memberof ServerHltvInfo\n   * @instance\n   */\n\n  ServerHltvInfo.prototype.tvRelayPort = 0;\n  /**\n   * ServerHltvInfo tvRelaySteamid.\n   * @member {number|Long} tvRelaySteamid\n   * @memberof ServerHltvInfo\n   * @instance\n   */\n\n  ServerHltvInfo.prototype.tvRelaySteamid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * Decodes a ServerHltvInfo message from the specified reader or buffer.\n   * @function decode\n   * @memberof ServerHltvInfo\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {ServerHltvInfo} ServerHltvInfo\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  ServerHltvInfo.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.ServerHltvInfo();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.tvUdpPort = reader.uint32();\n          break;\n\n        case 2:\n          message.tvWatchKey = reader.uint64();\n          break;\n\n        case 3:\n          message.tvSlots = reader.uint32();\n          break;\n\n        case 4:\n          message.tvClients = reader.uint32();\n          break;\n\n        case 5:\n          message.tvProxies = reader.uint32();\n          break;\n\n        case 6:\n          message.tvTime = reader.uint32();\n          break;\n\n        case 8:\n          message.gameType = reader.uint32();\n          break;\n\n        case 9:\n          message.gameMapgroup = reader.string();\n          break;\n\n        case 10:\n          message.gameMap = reader.string();\n          break;\n\n        case 11:\n          message.tvMasterSteamid = reader.uint64();\n          break;\n\n        case 12:\n          message.tvLocalSlots = reader.uint32();\n          break;\n\n        case 13:\n          message.tvLocalClients = reader.uint32();\n          break;\n\n        case 14:\n          message.tvLocalProxies = reader.uint32();\n          break;\n\n        case 15:\n          message.tvRelaySlots = reader.uint32();\n          break;\n\n        case 16:\n          message.tvRelayClients = reader.uint32();\n          break;\n\n        case 17:\n          message.tvRelayProxies = reader.uint32();\n          break;\n\n        case 18:\n          message.tvRelayAddress = reader.uint32();\n          break;\n\n        case 19:\n          message.tvRelayPort = reader.uint32();\n          break;\n\n        case 20:\n          message.tvRelaySteamid = reader.uint64();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return ServerHltvInfo;\n})();\n\nexports.IpAddressMask = $root.IpAddressMask = (() => {\n  /**\n   * Properties of an IpAddressMask.\n   * @exports IIpAddressMask\n   * @interface IIpAddressMask\n   * @property {number|null} [a] IpAddressMask a\n   * @property {number|null} [b] IpAddressMask b\n   * @property {number|null} [c] IpAddressMask c\n   * @property {number|null} [d] IpAddressMask d\n   * @property {number|null} [bits] IpAddressMask bits\n   * @property {number|null} [token] IpAddressMask token\n   */\n\n  /**\n   * Constructs a new IpAddressMask.\n   * @exports IpAddressMask\n   * @classdesc Represents an IpAddressMask.\n   * @implements IIpAddressMask\n   * @constructor\n   * @param {IIpAddressMask=} [properties] Properties to set\n   */\n  function IpAddressMask(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * IpAddressMask a.\n   * @member {number} a\n   * @memberof IpAddressMask\n   * @instance\n   */\n\n\n  IpAddressMask.prototype.a = 0;\n  /**\n   * IpAddressMask b.\n   * @member {number} b\n   * @memberof IpAddressMask\n   * @instance\n   */\n\n  IpAddressMask.prototype.b = 0;\n  /**\n   * IpAddressMask c.\n   * @member {number} c\n   * @memberof IpAddressMask\n   * @instance\n   */\n\n  IpAddressMask.prototype.c = 0;\n  /**\n   * IpAddressMask d.\n   * @member {number} d\n   * @memberof IpAddressMask\n   * @instance\n   */\n\n  IpAddressMask.prototype.d = 0;\n  /**\n   * IpAddressMask bits.\n   * @member {number} bits\n   * @memberof IpAddressMask\n   * @instance\n   */\n\n  IpAddressMask.prototype.bits = 0;\n  /**\n   * IpAddressMask token.\n   * @member {number} token\n   * @memberof IpAddressMask\n   * @instance\n   */\n\n  IpAddressMask.prototype.token = 0;\n  /**\n   * Decodes an IpAddressMask message from the specified reader or buffer.\n   * @function decode\n   * @memberof IpAddressMask\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {IpAddressMask} IpAddressMask\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  IpAddressMask.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.IpAddressMask();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.a = reader.uint32();\n          break;\n\n        case 2:\n          message.b = reader.uint32();\n          break;\n\n        case 3:\n          message.c = reader.uint32();\n          break;\n\n        case 4:\n          message.d = reader.uint32();\n          break;\n\n        case 5:\n          message.bits = reader.uint32();\n          break;\n\n        case 6:\n          message.token = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return IpAddressMask;\n})();\n\nexports.XpProgressData = $root.XpProgressData = (() => {\n  /**\n   * Properties of a XpProgressData.\n   * @exports IXpProgressData\n   * @interface IXpProgressData\n   * @property {number|null} [xpPoints] XpProgressData xpPoints\n   * @property {number|null} [xpCategory] XpProgressData xpCategory\n   */\n\n  /**\n   * Constructs a new XpProgressData.\n   * @exports XpProgressData\n   * @classdesc Represents a XpProgressData.\n   * @implements IXpProgressData\n   * @constructor\n   * @param {IXpProgressData=} [properties] Properties to set\n   */\n  function XpProgressData(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * XpProgressData xpPoints.\n   * @member {number} xpPoints\n   * @memberof XpProgressData\n   * @instance\n   */\n\n\n  XpProgressData.prototype.xpPoints = 0;\n  /**\n   * XpProgressData xpCategory.\n   * @member {number} xpCategory\n   * @memberof XpProgressData\n   * @instance\n   */\n\n  XpProgressData.prototype.xpCategory = 0;\n  /**\n   * Decodes a XpProgressData message from the specified reader or buffer.\n   * @function decode\n   * @memberof XpProgressData\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {XpProgressData} XpProgressData\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  XpProgressData.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.XpProgressData();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.xpPoints = reader.uint32();\n          break;\n\n        case 2:\n          message.xpCategory = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return XpProgressData;\n})();\n\nexports.MatchEndItemUpdates = $root.MatchEndItemUpdates = (() => {\n  /**\n   * Properties of a MatchEndItemUpdates.\n   * @exports IMatchEndItemUpdates\n   * @interface IMatchEndItemUpdates\n   * @property {number|Long|null} [itemId] MatchEndItemUpdates itemId\n   * @property {number|null} [itemAttrDefidx] MatchEndItemUpdates itemAttrDefidx\n   * @property {number|null} [itemAttrDeltaValue] MatchEndItemUpdates itemAttrDeltaValue\n   */\n\n  /**\n   * Constructs a new MatchEndItemUpdates.\n   * @exports MatchEndItemUpdates\n   * @classdesc Represents a MatchEndItemUpdates.\n   * @implements IMatchEndItemUpdates\n   * @constructor\n   * @param {IMatchEndItemUpdates=} [properties] Properties to set\n   */\n  function MatchEndItemUpdates(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * MatchEndItemUpdates itemId.\n   * @member {number|Long} itemId\n   * @memberof MatchEndItemUpdates\n   * @instance\n   */\n\n\n  MatchEndItemUpdates.prototype.itemId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * MatchEndItemUpdates itemAttrDefidx.\n   * @member {number} itemAttrDefidx\n   * @memberof MatchEndItemUpdates\n   * @instance\n   */\n\n  MatchEndItemUpdates.prototype.itemAttrDefidx = 0;\n  /**\n   * MatchEndItemUpdates itemAttrDeltaValue.\n   * @member {number} itemAttrDeltaValue\n   * @memberof MatchEndItemUpdates\n   * @instance\n   */\n\n  MatchEndItemUpdates.prototype.itemAttrDeltaValue = 0;\n  /**\n   * Decodes a MatchEndItemUpdates message from the specified reader or buffer.\n   * @function decode\n   * @memberof MatchEndItemUpdates\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {MatchEndItemUpdates} MatchEndItemUpdates\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  MatchEndItemUpdates.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.MatchEndItemUpdates();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.itemId = reader.uint64();\n          break;\n\n        case 2:\n          message.itemAttrDefidx = reader.uint32();\n          break;\n\n        case 3:\n          message.itemAttrDeltaValue = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return MatchEndItemUpdates;\n})();\n\nexports.PlayerQuestData = $root.PlayerQuestData = (() => {\n  /**\n   * Properties of a PlayerQuestData.\n   * @exports IPlayerQuestData\n   * @interface IPlayerQuestData\n   * @property {number|null} [questerAccountId] PlayerQuestData questerAccountId\n   * @property {Array.<PlayerQuestData.IQuestItemData>|null} [questItemData] PlayerQuestData questItemData\n   * @property {Array.<IXpProgressData>|null} [xpProgressData] PlayerQuestData xpProgressData\n   * @property {number|null} [timePlayed] PlayerQuestData timePlayed\n   * @property {number|null} [mmGameMode] PlayerQuestData mmGameMode\n   * @property {Array.<IMatchEndItemUpdates>|null} [itemUpdates] PlayerQuestData itemUpdates\n   */\n\n  /**\n   * Constructs a new PlayerQuestData.\n   * @exports PlayerQuestData\n   * @classdesc Represents a PlayerQuestData.\n   * @implements IPlayerQuestData\n   * @constructor\n   * @param {IPlayerQuestData=} [properties] Properties to set\n   */\n  function PlayerQuestData(properties) {\n    this.questItemData = [];\n    this.xpProgressData = [];\n    this.itemUpdates = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * PlayerQuestData questerAccountId.\n   * @member {number} questerAccountId\n   * @memberof PlayerQuestData\n   * @instance\n   */\n\n\n  PlayerQuestData.prototype.questerAccountId = 0;\n  /**\n   * PlayerQuestData questItemData.\n   * @member {Array.<PlayerQuestData.IQuestItemData>} questItemData\n   * @memberof PlayerQuestData\n   * @instance\n   */\n\n  PlayerQuestData.prototype.questItemData = $util.emptyArray;\n  /**\n   * PlayerQuestData xpProgressData.\n   * @member {Array.<IXpProgressData>} xpProgressData\n   * @memberof PlayerQuestData\n   * @instance\n   */\n\n  PlayerQuestData.prototype.xpProgressData = $util.emptyArray;\n  /**\n   * PlayerQuestData timePlayed.\n   * @member {number} timePlayed\n   * @memberof PlayerQuestData\n   * @instance\n   */\n\n  PlayerQuestData.prototype.timePlayed = 0;\n  /**\n   * PlayerQuestData mmGameMode.\n   * @member {number} mmGameMode\n   * @memberof PlayerQuestData\n   * @instance\n   */\n\n  PlayerQuestData.prototype.mmGameMode = 0;\n  /**\n   * PlayerQuestData itemUpdates.\n   * @member {Array.<IMatchEndItemUpdates>} itemUpdates\n   * @memberof PlayerQuestData\n   * @instance\n   */\n\n  PlayerQuestData.prototype.itemUpdates = $util.emptyArray;\n  /**\n   * Decodes a PlayerQuestData message from the specified reader or buffer.\n   * @function decode\n   * @memberof PlayerQuestData\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {PlayerQuestData} PlayerQuestData\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  PlayerQuestData.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.PlayerQuestData();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.questerAccountId = reader.uint32();\n          break;\n\n        case 2:\n          if (!(message.questItemData && message.questItemData.length)) message.questItemData = [];\n          message.questItemData.push($root.PlayerQuestData.QuestItemData.decode(reader, reader.uint32()));\n          break;\n\n        case 3:\n          if (!(message.xpProgressData && message.xpProgressData.length)) message.xpProgressData = [];\n          message.xpProgressData.push($root.XpProgressData.decode(reader, reader.uint32()));\n          break;\n\n        case 4:\n          message.timePlayed = reader.uint32();\n          break;\n\n        case 5:\n          message.mmGameMode = reader.uint32();\n          break;\n\n        case 6:\n          if (!(message.itemUpdates && message.itemUpdates.length)) message.itemUpdates = [];\n          message.itemUpdates.push($root.MatchEndItemUpdates.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  PlayerQuestData.QuestItemData = function () {\n    /**\n     * Properties of a QuestItemData.\n     * @memberof PlayerQuestData\n     * @interface IQuestItemData\n     * @property {number|Long|null} [questId] QuestItemData questId\n     * @property {number|null} [questNormalPointsEarned] QuestItemData questNormalPointsEarned\n     * @property {number|null} [questBonusPointsEarned] QuestItemData questBonusPointsEarned\n     */\n\n    /**\n     * Constructs a new QuestItemData.\n     * @memberof PlayerQuestData\n     * @classdesc Represents a QuestItemData.\n     * @implements IQuestItemData\n     * @constructor\n     * @param {PlayerQuestData.IQuestItemData=} [properties] Properties to set\n     */\n    function QuestItemData(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * QuestItemData questId.\n     * @member {number|Long} questId\n     * @memberof PlayerQuestData.QuestItemData\n     * @instance\n     */\n\n\n    QuestItemData.prototype.questId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n    /**\n     * QuestItemData questNormalPointsEarned.\n     * @member {number} questNormalPointsEarned\n     * @memberof PlayerQuestData.QuestItemData\n     * @instance\n     */\n\n    QuestItemData.prototype.questNormalPointsEarned = 0;\n    /**\n     * QuestItemData questBonusPointsEarned.\n     * @member {number} questBonusPointsEarned\n     * @memberof PlayerQuestData.QuestItemData\n     * @instance\n     */\n\n    QuestItemData.prototype.questBonusPointsEarned = 0;\n    /**\n     * Decodes a QuestItemData message from the specified reader or buffer.\n     * @function decode\n     * @memberof PlayerQuestData.QuestItemData\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {PlayerQuestData.QuestItemData} QuestItemData\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    QuestItemData.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.PlayerQuestData.QuestItemData();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.questId = reader.uint64();\n            break;\n\n          case 2:\n            message.questNormalPointsEarned = reader.int32();\n            break;\n\n          case 3:\n            message.questBonusPointsEarned = reader.int32();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return QuestItemData;\n  }();\n\n  return PlayerQuestData;\n})();\n\nexports.CMsgGC_ServerQuestUpdateData = $root.CMsgGC_ServerQuestUpdateData = (() => {\n  /**\n   * Properties of a CMsgGC_ServerQuestUpdateData.\n   * @exports ICMsgGC_ServerQuestUpdateData\n   * @interface ICMsgGC_ServerQuestUpdateData\n   * @property {Array.<IPlayerQuestData>|null} [playerQuestData] CMsgGC_ServerQuestUpdateData playerQuestData\n   */\n\n  /**\n   * Constructs a new CMsgGC_ServerQuestUpdateData.\n   * @exports CMsgGC_ServerQuestUpdateData\n   * @classdesc Represents a CMsgGC_ServerQuestUpdateData.\n   * @implements ICMsgGC_ServerQuestUpdateData\n   * @constructor\n   * @param {ICMsgGC_ServerQuestUpdateData=} [properties] Properties to set\n   */\n  function CMsgGC_ServerQuestUpdateData(properties) {\n    this.playerQuestData = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGC_ServerQuestUpdateData playerQuestData.\n   * @member {Array.<IPlayerQuestData>} playerQuestData\n   * @memberof CMsgGC_ServerQuestUpdateData\n   * @instance\n   */\n\n\n  CMsgGC_ServerQuestUpdateData.prototype.playerQuestData = $util.emptyArray;\n  /**\n   * Decodes a CMsgGC_ServerQuestUpdateData message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGC_ServerQuestUpdateData\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGC_ServerQuestUpdateData} CMsgGC_ServerQuestUpdateData\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGC_ServerQuestUpdateData.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGC_ServerQuestUpdateData();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.playerQuestData && message.playerQuestData.length)) message.playerQuestData = [];\n          message.playerQuestData.push($root.PlayerQuestData.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGC_ServerQuestUpdateData;\n})();\n\nexports.CMsgGCCStrike15_v2_MatchmakingGCOperationalStats = $root.CMsgGCCStrike15_v2_MatchmakingGCOperationalStats = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.\n   * @exports ICMsgGCCStrike15_v2_MatchmakingGCOperationalStats\n   * @interface ICMsgGCCStrike15_v2_MatchmakingGCOperationalStats\n   * @property {number|null} [packetid] CMsgGCCStrike15_v2_MatchmakingGCOperationalStats packetid\n   * @property {Array.<IOperationalStatisticDescription>|null} [namekeys] CMsgGCCStrike15_v2_MatchmakingGCOperationalStats namekeys\n   * @property {Array.<IOperationalStatisticsPacket>|null} [packets] CMsgGCCStrike15_v2_MatchmakingGCOperationalStats packets\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.\n   * @exports CMsgGCCStrike15_v2_MatchmakingGCOperationalStats\n   * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.\n   * @implements ICMsgGCCStrike15_v2_MatchmakingGCOperationalStats\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_MatchmakingGCOperationalStats=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_MatchmakingGCOperationalStats(properties) {\n    this.namekeys = [];\n    this.packets = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGCOperationalStats packetid.\n   * @member {number} packetid\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGCOperationalStats\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.prototype.packetid = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGCOperationalStats namekeys.\n   * @member {Array.<IOperationalStatisticDescription>} namekeys\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGCOperationalStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.prototype.namekeys = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGCOperationalStats packets.\n   * @member {Array.<IOperationalStatisticsPacket>} packets\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGCOperationalStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.prototype.packets = $util.emptyArray;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_MatchmakingGCOperationalStats message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGCOperationalStats\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_MatchmakingGCOperationalStats} CMsgGCCStrike15_v2_MatchmakingGCOperationalStats\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_MatchmakingGCOperationalStats();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.packetid = reader.int32();\n          break;\n\n        case 2:\n          if (!(message.namekeys && message.namekeys.length)) message.namekeys = [];\n          message.namekeys.push($root.OperationalStatisticDescription.decode(reader, reader.uint32()));\n          break;\n\n        case 3:\n          if (!(message.packets && message.packets.length)) message.packets = [];\n          message.packets.push($root.OperationalStatisticsPacket.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_MatchmakingGCOperationalStats;\n})();\n\nexports.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.\n   * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm\n   * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm\n   * @property {number|null} [token] CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm token\n   * @property {number|null} [stamp] CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm stamp\n   * @property {number|Long|null} [exchange] CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm exchange\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.\n   * @exports CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm\n   * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.\n   * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm token.\n   * @member {number} token\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.prototype.token = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm stamp.\n   * @member {number} stamp\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.prototype.stamp = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm exchange.\n   * @member {number|Long} exchange\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.prototype.exchange = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm} CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.token = reader.uint32();\n          break;\n\n        case 2:\n          message.stamp = reader.uint32();\n          break;\n\n        case 3:\n          message.exchange = reader.uint64();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm;\n})();\n\nexports.CMsgGCCStrike15_v2_GC2ServerReservationUpdate = $root.CMsgGCCStrike15_v2_GC2ServerReservationUpdate = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_GC2ServerReservationUpdate.\n   * @exports ICMsgGCCStrike15_v2_GC2ServerReservationUpdate\n   * @interface ICMsgGCCStrike15_v2_GC2ServerReservationUpdate\n   * @property {number|null} [viewersExternalTotal] CMsgGCCStrike15_v2_GC2ServerReservationUpdate viewersExternalTotal\n   * @property {number|null} [viewersExternalSteam] CMsgGCCStrike15_v2_GC2ServerReservationUpdate viewersExternalSteam\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_GC2ServerReservationUpdate.\n   * @exports CMsgGCCStrike15_v2_GC2ServerReservationUpdate\n   * @classdesc Represents a CMsgGCCStrike15_v2_GC2ServerReservationUpdate.\n   * @implements ICMsgGCCStrike15_v2_GC2ServerReservationUpdate\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_GC2ServerReservationUpdate=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_GC2ServerReservationUpdate(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_GC2ServerReservationUpdate viewersExternalTotal.\n   * @member {number} viewersExternalTotal\n   * @memberof CMsgGCCStrike15_v2_GC2ServerReservationUpdate\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_GC2ServerReservationUpdate.prototype.viewersExternalTotal = 0;\n  /**\n   * CMsgGCCStrike15_v2_GC2ServerReservationUpdate viewersExternalSteam.\n   * @member {number} viewersExternalSteam\n   * @memberof CMsgGCCStrike15_v2_GC2ServerReservationUpdate\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_GC2ServerReservationUpdate.prototype.viewersExternalSteam = 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_GC2ServerReservationUpdate message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_GC2ServerReservationUpdate\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_GC2ServerReservationUpdate} CMsgGCCStrike15_v2_GC2ServerReservationUpdate\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_GC2ServerReservationUpdate.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_GC2ServerReservationUpdate();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.viewersExternalTotal = reader.uint32();\n          break;\n\n        case 2:\n          message.viewersExternalSteam = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_GC2ServerReservationUpdate;\n})();\n\nexports.CMsgGCCStrike15_v2_MatchmakingStart = $root.CMsgGCCStrike15_v2_MatchmakingStart = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_MatchmakingStart.\n   * @exports ICMsgGCCStrike15_v2_MatchmakingStart\n   * @interface ICMsgGCCStrike15_v2_MatchmakingStart\n   * @property {Array.<number>|null} [accountIds] CMsgGCCStrike15_v2_MatchmakingStart accountIds\n   * @property {number|null} [gameType] CMsgGCCStrike15_v2_MatchmakingStart gameType\n   * @property {string|null} [ticketData] CMsgGCCStrike15_v2_MatchmakingStart ticketData\n   * @property {number|null} [clientVersion] CMsgGCCStrike15_v2_MatchmakingStart clientVersion\n   * @property {ITournamentMatchSetup|null} [tournamentMatch] CMsgGCCStrike15_v2_MatchmakingStart tournamentMatch\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_MatchmakingStart.\n   * @exports CMsgGCCStrike15_v2_MatchmakingStart\n   * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingStart.\n   * @implements ICMsgGCCStrike15_v2_MatchmakingStart\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_MatchmakingStart=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_MatchmakingStart(properties) {\n    this.accountIds = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingStart accountIds.\n   * @member {Array.<number>} accountIds\n   * @memberof CMsgGCCStrike15_v2_MatchmakingStart\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_MatchmakingStart.prototype.accountIds = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingStart gameType.\n   * @member {number} gameType\n   * @memberof CMsgGCCStrike15_v2_MatchmakingStart\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingStart.prototype.gameType = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingStart ticketData.\n   * @member {string} ticketData\n   * @memberof CMsgGCCStrike15_v2_MatchmakingStart\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingStart.prototype.ticketData = \"\";\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingStart clientVersion.\n   * @member {number} clientVersion\n   * @memberof CMsgGCCStrike15_v2_MatchmakingStart\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingStart.prototype.clientVersion = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingStart tournamentMatch.\n   * @member {ITournamentMatchSetup|null|undefined} tournamentMatch\n   * @memberof CMsgGCCStrike15_v2_MatchmakingStart\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingStart.prototype.tournamentMatch = null;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_MatchmakingStart message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_MatchmakingStart\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_MatchmakingStart} CMsgGCCStrike15_v2_MatchmakingStart\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingStart.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_MatchmakingStart();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.accountIds && message.accountIds.length)) message.accountIds = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.accountIds.push(reader.uint32());\n          } else message.accountIds.push(reader.uint32());\n\n          break;\n\n        case 2:\n          message.gameType = reader.uint32();\n          break;\n\n        case 3:\n          message.ticketData = reader.string();\n          break;\n\n        case 4:\n          message.clientVersion = reader.uint32();\n          break;\n\n        case 5:\n          message.tournamentMatch = $root.TournamentMatchSetup.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_MatchmakingStart;\n})();\n\nexports.CMsgGCCStrike15_v2_MatchmakingStop = $root.CMsgGCCStrike15_v2_MatchmakingStop = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_MatchmakingStop.\n   * @exports ICMsgGCCStrike15_v2_MatchmakingStop\n   * @interface ICMsgGCCStrike15_v2_MatchmakingStop\n   * @property {number|null} [abandon] CMsgGCCStrike15_v2_MatchmakingStop abandon\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_MatchmakingStop.\n   * @exports CMsgGCCStrike15_v2_MatchmakingStop\n   * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingStop.\n   * @implements ICMsgGCCStrike15_v2_MatchmakingStop\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_MatchmakingStop=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_MatchmakingStop(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingStop abandon.\n   * @member {number} abandon\n   * @memberof CMsgGCCStrike15_v2_MatchmakingStop\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_MatchmakingStop.prototype.abandon = 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_MatchmakingStop message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_MatchmakingStop\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_MatchmakingStop} CMsgGCCStrike15_v2_MatchmakingStop\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingStop.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_MatchmakingStop();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.abandon = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_MatchmakingStop;\n})();\n\nexports.CMsgGCCStrike15_v2_MatchmakingClient2ServerPing = $root.CMsgGCCStrike15_v2_MatchmakingClient2ServerPing = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.\n   * @exports ICMsgGCCStrike15_v2_MatchmakingClient2ServerPing\n   * @interface ICMsgGCCStrike15_v2_MatchmakingClient2ServerPing\n   * @property {Array.<IGameServerPing>|null} [gameserverpings] CMsgGCCStrike15_v2_MatchmakingClient2ServerPing gameserverpings\n   * @property {number|null} [offsetIndex] CMsgGCCStrike15_v2_MatchmakingClient2ServerPing offsetIndex\n   * @property {number|null} [finalBatch] CMsgGCCStrike15_v2_MatchmakingClient2ServerPing finalBatch\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.\n   * @exports CMsgGCCStrike15_v2_MatchmakingClient2ServerPing\n   * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.\n   * @implements ICMsgGCCStrike15_v2_MatchmakingClient2ServerPing\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_MatchmakingClient2ServerPing=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_MatchmakingClient2ServerPing(properties) {\n    this.gameserverpings = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingClient2ServerPing gameserverpings.\n   * @member {Array.<IGameServerPing>} gameserverpings\n   * @memberof CMsgGCCStrike15_v2_MatchmakingClient2ServerPing\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.prototype.gameserverpings = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingClient2ServerPing offsetIndex.\n   * @member {number} offsetIndex\n   * @memberof CMsgGCCStrike15_v2_MatchmakingClient2ServerPing\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.prototype.offsetIndex = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingClient2ServerPing finalBatch.\n   * @member {number} finalBatch\n   * @memberof CMsgGCCStrike15_v2_MatchmakingClient2ServerPing\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.prototype.finalBatch = 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_MatchmakingClient2ServerPing message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_MatchmakingClient2ServerPing\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_MatchmakingClient2ServerPing} CMsgGCCStrike15_v2_MatchmakingClient2ServerPing\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_MatchmakingClient2ServerPing();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.gameserverpings && message.gameserverpings.length)) message.gameserverpings = [];\n          message.gameserverpings.push($root.GameServerPing.decode(reader, reader.uint32()));\n          break;\n\n        case 2:\n          message.offsetIndex = reader.int32();\n          break;\n\n        case 3:\n          message.finalBatch = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_MatchmakingClient2ServerPing;\n})();\n\nexports.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate = $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.\n   * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n   * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n   * @property {number|null} [matchmaking] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate matchmaking\n   * @property {Array.<number>|null} [waitingAccountIdSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate waitingAccountIdSessions\n   * @property {string|null} [error] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate error\n   * @property {Array.<number>|null} [ongoingmatchAccountIdSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate ongoingmatchAccountIdSessions\n   * @property {IGlobalStatistics|null} [globalStats] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate globalStats\n   * @property {Array.<number>|null} [failpingAccountIdSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate failpingAccountIdSessions\n   * @property {Array.<number>|null} [penaltyAccountIdSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate penaltyAccountIdSessions\n   * @property {Array.<number>|null} [failreadyAccountIdSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate failreadyAccountIdSessions\n   * @property {Array.<number>|null} [vacbannedAccountIdSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate vacbannedAccountIdSessions\n   * @property {IIpAddressMask|null} [serverIpaddressMask] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate serverIpaddressMask\n   * @property {Array.<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.INote>|null} [notes] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate notes\n   * @property {Array.<number>|null} [penaltyAccountIdSessionsGreen] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate penaltyAccountIdSessionsGreen\n   * @property {Array.<number>|null} [insufficientlevelSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate insufficientlevelSessions\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.\n   * @exports CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n   * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.\n   * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate(properties) {\n    this.waitingAccountIdSessions = [];\n    this.ongoingmatchAccountIdSessions = [];\n    this.failpingAccountIdSessions = [];\n    this.penaltyAccountIdSessions = [];\n    this.failreadyAccountIdSessions = [];\n    this.vacbannedAccountIdSessions = [];\n    this.notes = [];\n    this.penaltyAccountIdSessionsGreen = [];\n    this.insufficientlevelSessions = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate matchmaking.\n   * @member {number} matchmaking\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.matchmaking = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate waitingAccountIdSessions.\n   * @member {Array.<number>} waitingAccountIdSessions\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.waitingAccountIdSessions = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate error.\n   * @member {string} error\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.error = \"\";\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate ongoingmatchAccountIdSessions.\n   * @member {Array.<number>} ongoingmatchAccountIdSessions\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.ongoingmatchAccountIdSessions = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate globalStats.\n   * @member {IGlobalStatistics|null|undefined} globalStats\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.globalStats = null;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate failpingAccountIdSessions.\n   * @member {Array.<number>} failpingAccountIdSessions\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.failpingAccountIdSessions = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate penaltyAccountIdSessions.\n   * @member {Array.<number>} penaltyAccountIdSessions\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.penaltyAccountIdSessions = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate failreadyAccountIdSessions.\n   * @member {Array.<number>} failreadyAccountIdSessions\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.failreadyAccountIdSessions = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate vacbannedAccountIdSessions.\n   * @member {Array.<number>} vacbannedAccountIdSessions\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.vacbannedAccountIdSessions = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate serverIpaddressMask.\n   * @member {IIpAddressMask|null|undefined} serverIpaddressMask\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.serverIpaddressMask = null;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate notes.\n   * @member {Array.<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.INote>} notes\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.notes = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate penaltyAccountIdSessionsGreen.\n   * @member {Array.<number>} penaltyAccountIdSessionsGreen\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.penaltyAccountIdSessionsGreen = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate insufficientlevelSessions.\n   * @member {Array.<number>} insufficientlevelSessions\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.insufficientlevelSessions = $util.emptyArray;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate} CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.matchmaking = reader.int32();\n          break;\n\n        case 2:\n          if (!(message.waitingAccountIdSessions && message.waitingAccountIdSessions.length)) message.waitingAccountIdSessions = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.waitingAccountIdSessions.push(reader.uint32());\n          } else message.waitingAccountIdSessions.push(reader.uint32());\n\n          break;\n\n        case 3:\n          message.error = reader.string();\n          break;\n\n        case 6:\n          if (!(message.ongoingmatchAccountIdSessions && message.ongoingmatchAccountIdSessions.length)) message.ongoingmatchAccountIdSessions = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.ongoingmatchAccountIdSessions.push(reader.uint32());\n          } else message.ongoingmatchAccountIdSessions.push(reader.uint32());\n\n          break;\n\n        case 7:\n          message.globalStats = $root.GlobalStatistics.decode(reader, reader.uint32());\n          break;\n\n        case 8:\n          if (!(message.failpingAccountIdSessions && message.failpingAccountIdSessions.length)) message.failpingAccountIdSessions = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.failpingAccountIdSessions.push(reader.uint32());\n          } else message.failpingAccountIdSessions.push(reader.uint32());\n\n          break;\n\n        case 9:\n          if (!(message.penaltyAccountIdSessions && message.penaltyAccountIdSessions.length)) message.penaltyAccountIdSessions = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.penaltyAccountIdSessions.push(reader.uint32());\n          } else message.penaltyAccountIdSessions.push(reader.uint32());\n\n          break;\n\n        case 10:\n          if (!(message.failreadyAccountIdSessions && message.failreadyAccountIdSessions.length)) message.failreadyAccountIdSessions = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.failreadyAccountIdSessions.push(reader.uint32());\n          } else message.failreadyAccountIdSessions.push(reader.uint32());\n\n          break;\n\n        case 11:\n          if (!(message.vacbannedAccountIdSessions && message.vacbannedAccountIdSessions.length)) message.vacbannedAccountIdSessions = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.vacbannedAccountIdSessions.push(reader.uint32());\n          } else message.vacbannedAccountIdSessions.push(reader.uint32());\n\n          break;\n\n        case 12:\n          message.serverIpaddressMask = $root.IpAddressMask.decode(reader, reader.uint32());\n          break;\n\n        case 13:\n          if (!(message.notes && message.notes.length)) message.notes = [];\n          message.notes.push($root.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note.decode(reader, reader.uint32()));\n          break;\n\n        case 14:\n          if (!(message.penaltyAccountIdSessionsGreen && message.penaltyAccountIdSessionsGreen.length)) message.penaltyAccountIdSessionsGreen = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.penaltyAccountIdSessionsGreen.push(reader.uint32());\n          } else message.penaltyAccountIdSessionsGreen.push(reader.uint32());\n\n          break;\n\n        case 15:\n          if (!(message.insufficientlevelSessions && message.insufficientlevelSessions.length)) message.insufficientlevelSessions = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.insufficientlevelSessions.push(reader.uint32());\n          } else message.insufficientlevelSessions.push(reader.uint32());\n\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note = function () {\n    /**\n     * Properties of a Note.\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n     * @interface INote\n     * @property {number|null} [type] Note type\n     * @property {number|null} [regionId] Note regionId\n     * @property {number|null} [regionR] Note regionR\n     * @property {number|null} [distance] Note distance\n     */\n\n    /**\n     * Constructs a new Note.\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n     * @classdesc Represents a Note.\n     * @implements INote\n     * @constructor\n     * @param {CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.INote=} [properties] Properties to set\n     */\n    function Note(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Note type.\n     * @member {number} type\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note\n     * @instance\n     */\n\n\n    Note.prototype.type = 0;\n    /**\n     * Note regionId.\n     * @member {number} regionId\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note\n     * @instance\n     */\n\n    Note.prototype.regionId = 0;\n    /**\n     * Note regionR.\n     * @member {number} regionR\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note\n     * @instance\n     */\n\n    Note.prototype.regionR = 0;\n    /**\n     * Note distance.\n     * @member {number} distance\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note\n     * @instance\n     */\n\n    Note.prototype.distance = 0;\n    /**\n     * Decodes a Note message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note} Note\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    Note.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.type = reader.int32();\n            break;\n\n          case 2:\n            message.regionId = reader.int32();\n            break;\n\n          case 3:\n            message.regionR = reader.float();\n            break;\n\n          case 4:\n            message.distance = reader.float();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return Note;\n  }();\n\n  return CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate;\n})();\n\nexports.CDataGCCStrike15_v2_TournamentMatchDraft = $root.CDataGCCStrike15_v2_TournamentMatchDraft = (() => {\n  /**\n   * Properties of a CDataGCCStrike15_v2_TournamentMatchDraft.\n   * @exports ICDataGCCStrike15_v2_TournamentMatchDraft\n   * @interface ICDataGCCStrike15_v2_TournamentMatchDraft\n   * @property {number|null} [eventId] CDataGCCStrike15_v2_TournamentMatchDraft eventId\n   * @property {number|null} [eventStageId] CDataGCCStrike15_v2_TournamentMatchDraft eventStageId\n   * @property {number|null} [teamId_0] CDataGCCStrike15_v2_TournamentMatchDraft teamId_0\n   * @property {number|null} [teamId_1] CDataGCCStrike15_v2_TournamentMatchDraft teamId_1\n   * @property {number|null} [mapsCount] CDataGCCStrike15_v2_TournamentMatchDraft mapsCount\n   * @property {number|null} [mapsCurrent] CDataGCCStrike15_v2_TournamentMatchDraft mapsCurrent\n   * @property {number|null} [teamIdStart] CDataGCCStrike15_v2_TournamentMatchDraft teamIdStart\n   * @property {number|null} [teamIdVeto1] CDataGCCStrike15_v2_TournamentMatchDraft teamIdVeto1\n   * @property {number|null} [teamIdPickn] CDataGCCStrike15_v2_TournamentMatchDraft teamIdPickn\n   * @property {Array.<CDataGCCStrike15_v2_TournamentMatchDraft.IEntry>|null} [drafts] CDataGCCStrike15_v2_TournamentMatchDraft drafts\n   */\n\n  /**\n   * Constructs a new CDataGCCStrike15_v2_TournamentMatchDraft.\n   * @exports CDataGCCStrike15_v2_TournamentMatchDraft\n   * @classdesc Represents a CDataGCCStrike15_v2_TournamentMatchDraft.\n   * @implements ICDataGCCStrike15_v2_TournamentMatchDraft\n   * @constructor\n   * @param {ICDataGCCStrike15_v2_TournamentMatchDraft=} [properties] Properties to set\n   */\n  function CDataGCCStrike15_v2_TournamentMatchDraft(properties) {\n    this.drafts = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CDataGCCStrike15_v2_TournamentMatchDraft eventId.\n   * @member {number} eventId\n   * @memberof CDataGCCStrike15_v2_TournamentMatchDraft\n   * @instance\n   */\n\n\n  CDataGCCStrike15_v2_TournamentMatchDraft.prototype.eventId = 0;\n  /**\n   * CDataGCCStrike15_v2_TournamentMatchDraft eventStageId.\n   * @member {number} eventStageId\n   * @memberof CDataGCCStrike15_v2_TournamentMatchDraft\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_TournamentMatchDraft.prototype.eventStageId = 0;\n  /**\n   * CDataGCCStrike15_v2_TournamentMatchDraft teamId_0.\n   * @member {number} teamId_0\n   * @memberof CDataGCCStrike15_v2_TournamentMatchDraft\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_TournamentMatchDraft.prototype.teamId_0 = 0;\n  /**\n   * CDataGCCStrike15_v2_TournamentMatchDraft teamId_1.\n   * @member {number} teamId_1\n   * @memberof CDataGCCStrike15_v2_TournamentMatchDraft\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_TournamentMatchDraft.prototype.teamId_1 = 0;\n  /**\n   * CDataGCCStrike15_v2_TournamentMatchDraft mapsCount.\n   * @member {number} mapsCount\n   * @memberof CDataGCCStrike15_v2_TournamentMatchDraft\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_TournamentMatchDraft.prototype.mapsCount = 0;\n  /**\n   * CDataGCCStrike15_v2_TournamentMatchDraft mapsCurrent.\n   * @member {number} mapsCurrent\n   * @memberof CDataGCCStrike15_v2_TournamentMatchDraft\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_TournamentMatchDraft.prototype.mapsCurrent = 0;\n  /**\n   * CDataGCCStrike15_v2_TournamentMatchDraft teamIdStart.\n   * @member {number} teamIdStart\n   * @memberof CDataGCCStrike15_v2_TournamentMatchDraft\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_TournamentMatchDraft.prototype.teamIdStart = 0;\n  /**\n   * CDataGCCStrike15_v2_TournamentMatchDraft teamIdVeto1.\n   * @member {number} teamIdVeto1\n   * @memberof CDataGCCStrike15_v2_TournamentMatchDraft\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_TournamentMatchDraft.prototype.teamIdVeto1 = 0;\n  /**\n   * CDataGCCStrike15_v2_TournamentMatchDraft teamIdPickn.\n   * @member {number} teamIdPickn\n   * @memberof CDataGCCStrike15_v2_TournamentMatchDraft\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_TournamentMatchDraft.prototype.teamIdPickn = 0;\n  /**\n   * CDataGCCStrike15_v2_TournamentMatchDraft drafts.\n   * @member {Array.<CDataGCCStrike15_v2_TournamentMatchDraft.IEntry>} drafts\n   * @memberof CDataGCCStrike15_v2_TournamentMatchDraft\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_TournamentMatchDraft.prototype.drafts = $util.emptyArray;\n  /**\n   * Decodes a CDataGCCStrike15_v2_TournamentMatchDraft message from the specified reader or buffer.\n   * @function decode\n   * @memberof CDataGCCStrike15_v2_TournamentMatchDraft\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CDataGCCStrike15_v2_TournamentMatchDraft} CDataGCCStrike15_v2_TournamentMatchDraft\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CDataGCCStrike15_v2_TournamentMatchDraft.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CDataGCCStrike15_v2_TournamentMatchDraft();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.eventId = reader.int32();\n          break;\n\n        case 2:\n          message.eventStageId = reader.int32();\n          break;\n\n        case 3:\n          message.teamId_0 = reader.int32();\n          break;\n\n        case 4:\n          message.teamId_1 = reader.int32();\n          break;\n\n        case 5:\n          message.mapsCount = reader.int32();\n          break;\n\n        case 6:\n          message.mapsCurrent = reader.int32();\n          break;\n\n        case 7:\n          message.teamIdStart = reader.int32();\n          break;\n\n        case 8:\n          message.teamIdVeto1 = reader.int32();\n          break;\n\n        case 9:\n          message.teamIdPickn = reader.int32();\n          break;\n\n        case 10:\n          if (!(message.drafts && message.drafts.length)) message.drafts = [];\n          message.drafts.push($root.CDataGCCStrike15_v2_TournamentMatchDraft.Entry.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CDataGCCStrike15_v2_TournamentMatchDraft.Entry = function () {\n    /**\n     * Properties of an Entry.\n     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft\n     * @interface IEntry\n     * @property {number|null} [mapid] Entry mapid\n     * @property {number|null} [teamIdCt] Entry teamIdCt\n     */\n\n    /**\n     * Constructs a new Entry.\n     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft\n     * @classdesc Represents an Entry.\n     * @implements IEntry\n     * @constructor\n     * @param {CDataGCCStrike15_v2_TournamentMatchDraft.IEntry=} [properties] Properties to set\n     */\n    function Entry(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Entry mapid.\n     * @member {number} mapid\n     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft.Entry\n     * @instance\n     */\n\n\n    Entry.prototype.mapid = 0;\n    /**\n     * Entry teamIdCt.\n     * @member {number} teamIdCt\n     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft.Entry\n     * @instance\n     */\n\n    Entry.prototype.teamIdCt = 0;\n    /**\n     * Decodes an Entry message from the specified reader or buffer.\n     * @function decode\n     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft.Entry\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CDataGCCStrike15_v2_TournamentMatchDraft.Entry} Entry\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    Entry.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CDataGCCStrike15_v2_TournamentMatchDraft.Entry();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.mapid = reader.int32();\n            break;\n\n          case 2:\n            message.teamIdCt = reader.int32();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return Entry;\n  }();\n\n  return CDataGCCStrike15_v2_TournamentMatchDraft;\n})();\n\nexports.CPreMatchInfoData = $root.CPreMatchInfoData = (() => {\n  /**\n   * Properties of a CPreMatchInfoData.\n   * @exports ICPreMatchInfoData\n   * @interface ICPreMatchInfoData\n   * @property {number|null} [predictionsPct] CPreMatchInfoData predictionsPct\n   * @property {ICDataGCCStrike15_v2_TournamentMatchDraft|null} [draft] CPreMatchInfoData draft\n   * @property {Array.<CPreMatchInfoData.ITeamStats>|null} [stats] CPreMatchInfoData stats\n   */\n\n  /**\n   * Constructs a new CPreMatchInfoData.\n   * @exports CPreMatchInfoData\n   * @classdesc Represents a CPreMatchInfoData.\n   * @implements ICPreMatchInfoData\n   * @constructor\n   * @param {ICPreMatchInfoData=} [properties] Properties to set\n   */\n  function CPreMatchInfoData(properties) {\n    this.stats = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CPreMatchInfoData predictionsPct.\n   * @member {number} predictionsPct\n   * @memberof CPreMatchInfoData\n   * @instance\n   */\n\n\n  CPreMatchInfoData.prototype.predictionsPct = 0;\n  /**\n   * CPreMatchInfoData draft.\n   * @member {ICDataGCCStrike15_v2_TournamentMatchDraft|null|undefined} draft\n   * @memberof CPreMatchInfoData\n   * @instance\n   */\n\n  CPreMatchInfoData.prototype.draft = null;\n  /**\n   * CPreMatchInfoData stats.\n   * @member {Array.<CPreMatchInfoData.ITeamStats>} stats\n   * @memberof CPreMatchInfoData\n   * @instance\n   */\n\n  CPreMatchInfoData.prototype.stats = $util.emptyArray;\n  /**\n   * Decodes a CPreMatchInfoData message from the specified reader or buffer.\n   * @function decode\n   * @memberof CPreMatchInfoData\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CPreMatchInfoData} CPreMatchInfoData\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CPreMatchInfoData.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CPreMatchInfoData();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.predictionsPct = reader.int32();\n          break;\n\n        case 4:\n          message.draft = $root.CDataGCCStrike15_v2_TournamentMatchDraft.decode(reader, reader.uint32());\n          break;\n\n        case 5:\n          if (!(message.stats && message.stats.length)) message.stats = [];\n          message.stats.push($root.CPreMatchInfoData.TeamStats.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CPreMatchInfoData.TeamStats = function () {\n    /**\n     * Properties of a TeamStats.\n     * @memberof CPreMatchInfoData\n     * @interface ITeamStats\n     * @property {number|null} [matchInfoIdxtxt] TeamStats matchInfoIdxtxt\n     * @property {string|null} [matchInfoTxt] TeamStats matchInfoTxt\n     * @property {Array.<string>|null} [matchInfoTeams] TeamStats matchInfoTeams\n     */\n\n    /**\n     * Constructs a new TeamStats.\n     * @memberof CPreMatchInfoData\n     * @classdesc Represents a TeamStats.\n     * @implements ITeamStats\n     * @constructor\n     * @param {CPreMatchInfoData.ITeamStats=} [properties] Properties to set\n     */\n    function TeamStats(properties) {\n      this.matchInfoTeams = [];\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * TeamStats matchInfoIdxtxt.\n     * @member {number} matchInfoIdxtxt\n     * @memberof CPreMatchInfoData.TeamStats\n     * @instance\n     */\n\n\n    TeamStats.prototype.matchInfoIdxtxt = 0;\n    /**\n     * TeamStats matchInfoTxt.\n     * @member {string} matchInfoTxt\n     * @memberof CPreMatchInfoData.TeamStats\n     * @instance\n     */\n\n    TeamStats.prototype.matchInfoTxt = \"\";\n    /**\n     * TeamStats matchInfoTeams.\n     * @member {Array.<string>} matchInfoTeams\n     * @memberof CPreMatchInfoData.TeamStats\n     * @instance\n     */\n\n    TeamStats.prototype.matchInfoTeams = $util.emptyArray;\n    /**\n     * Decodes a TeamStats message from the specified reader or buffer.\n     * @function decode\n     * @memberof CPreMatchInfoData.TeamStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CPreMatchInfoData.TeamStats} TeamStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    TeamStats.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CPreMatchInfoData.TeamStats();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.matchInfoIdxtxt = reader.int32();\n            break;\n\n          case 2:\n            message.matchInfoTxt = reader.string();\n            break;\n\n          case 3:\n            if (!(message.matchInfoTeams && message.matchInfoTeams.length)) message.matchInfoTeams = [];\n            message.matchInfoTeams.push(reader.string());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return TeamStats;\n  }();\n\n  return CPreMatchInfoData;\n})();\n\nexports.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.\n   * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n   * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n   * @property {Array.<number>|null} [accountIds] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve accountIds\n   * @property {number|null} [gameType] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve gameType\n   * @property {number|Long|null} [matchId] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve matchId\n   * @property {number|null} [serverVersion] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve serverVersion\n   * @property {Array.<IPlayerRankingInfo>|null} [rankings] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve rankings\n   * @property {number|Long|null} [encryptionKey] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve encryptionKey\n   * @property {number|Long|null} [encryptionKeyPub] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve encryptionKeyPub\n   * @property {Array.<number>|null} [partyIds] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve partyIds\n   * @property {Array.<IIpAddressMask>|null} [whitelist] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve whitelist\n   * @property {number|Long|null} [tvMasterSteamid] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tvMasterSteamid\n   * @property {ITournamentEvent|null} [tournamentEvent] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tournamentEvent\n   * @property {Array.<ITournamentTeam>|null} [tournamentTeams] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tournamentTeams\n   * @property {Array.<number>|null} [tournamentCastersAccountIds] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tournamentCastersAccountIds\n   * @property {number|Long|null} [tvRelaySteamid] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tvRelaySteamid\n   * @property {ICPreMatchInfoData|null} [preMatchData] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve preMatchData\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.\n   * @exports CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n   * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.\n   * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve(properties) {\n    this.accountIds = [];\n    this.rankings = [];\n    this.partyIds = [];\n    this.whitelist = [];\n    this.tournamentTeams = [];\n    this.tournamentCastersAccountIds = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve accountIds.\n   * @member {Array.<number>} accountIds\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.accountIds = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve gameType.\n   * @member {number} gameType\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.gameType = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve matchId.\n   * @member {number|Long} matchId\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.matchId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve serverVersion.\n   * @member {number} serverVersion\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.serverVersion = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve rankings.\n   * @member {Array.<IPlayerRankingInfo>} rankings\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.rankings = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve encryptionKey.\n   * @member {number|Long} encryptionKey\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.encryptionKey = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve encryptionKeyPub.\n   * @member {number|Long} encryptionKeyPub\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.encryptionKeyPub = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve partyIds.\n   * @member {Array.<number>} partyIds\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.partyIds = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve whitelist.\n   * @member {Array.<IIpAddressMask>} whitelist\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.whitelist = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tvMasterSteamid.\n   * @member {number|Long} tvMasterSteamid\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.tvMasterSteamid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tournamentEvent.\n   * @member {ITournamentEvent|null|undefined} tournamentEvent\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.tournamentEvent = null;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tournamentTeams.\n   * @member {Array.<ITournamentTeam>} tournamentTeams\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.tournamentTeams = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tournamentCastersAccountIds.\n   * @member {Array.<number>} tournamentCastersAccountIds\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.tournamentCastersAccountIds = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tvRelaySteamid.\n   * @member {number|Long} tvRelaySteamid\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.tvRelaySteamid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve preMatchData.\n   * @member {ICPreMatchInfoData|null|undefined} preMatchData\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.preMatchData = null;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve} CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.accountIds && message.accountIds.length)) message.accountIds = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.accountIds.push(reader.uint32());\n          } else message.accountIds.push(reader.uint32());\n\n          break;\n\n        case 2:\n          message.gameType = reader.uint32();\n          break;\n\n        case 3:\n          message.matchId = reader.uint64();\n          break;\n\n        case 4:\n          message.serverVersion = reader.uint32();\n          break;\n\n        case 5:\n          if (!(message.rankings && message.rankings.length)) message.rankings = [];\n          message.rankings.push($root.PlayerRankingInfo.decode(reader, reader.uint32()));\n          break;\n\n        case 6:\n          message.encryptionKey = reader.uint64();\n          break;\n\n        case 7:\n          message.encryptionKeyPub = reader.uint64();\n          break;\n\n        case 8:\n          if (!(message.partyIds && message.partyIds.length)) message.partyIds = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.partyIds.push(reader.uint32());\n          } else message.partyIds.push(reader.uint32());\n\n          break;\n\n        case 9:\n          if (!(message.whitelist && message.whitelist.length)) message.whitelist = [];\n          message.whitelist.push($root.IpAddressMask.decode(reader, reader.uint32()));\n          break;\n\n        case 10:\n          message.tvMasterSteamid = reader.uint64();\n          break;\n\n        case 11:\n          message.tournamentEvent = $root.TournamentEvent.decode(reader, reader.uint32());\n          break;\n\n        case 12:\n          if (!(message.tournamentTeams && message.tournamentTeams.length)) message.tournamentTeams = [];\n          message.tournamentTeams.push($root.TournamentTeam.decode(reader, reader.uint32()));\n          break;\n\n        case 13:\n          if (!(message.tournamentCastersAccountIds && message.tournamentCastersAccountIds.length)) message.tournamentCastersAccountIds = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.tournamentCastersAccountIds.push(reader.uint32());\n          } else message.tournamentCastersAccountIds.push(reader.uint32());\n\n          break;\n\n        case 14:\n          message.tvRelaySteamid = reader.uint64();\n          break;\n\n        case 15:\n          message.preMatchData = $root.CPreMatchInfoData.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve;\n})();\n\nexports.CMsgGCCStrike15_v2_MatchmakingServerReservationResponse = $root.CMsgGCCStrike15_v2_MatchmakingServerReservationResponse = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.\n   * @exports ICMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n   * @interface ICMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n   * @property {number|Long|null} [reservationid] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse reservationid\n   * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null} [reservation] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse reservation\n   * @property {string|null} [map] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse map\n   * @property {number|Long|null} [gcReservationSent] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse gcReservationSent\n   * @property {number|null} [serverVersion] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse serverVersion\n   * @property {IServerHltvInfo|null} [tvInfo] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse tvInfo\n   * @property {Array.<number>|null} [rewardPlayerAccounts] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardPlayerAccounts\n   * @property {Array.<number>|null} [idlePlayerAccounts] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse idlePlayerAccounts\n   * @property {number|null} [rewardItemAttrDefIdx] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardItemAttrDefIdx\n   * @property {number|null} [rewardItemAttrValue] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardItemAttrValue\n   * @property {number|null} [rewardItemAttrRewardIdx] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardItemAttrRewardIdx\n   * @property {number|null} [rewardDropList] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardDropList\n   * @property {string|null} [tournamentTag] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse tournamentTag\n   * @property {number|null} [steamdatagramPort] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse steamdatagramPort\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.\n   * @exports CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n   * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.\n   * @implements ICMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_MatchmakingServerReservationResponse=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_MatchmakingServerReservationResponse(properties) {\n    this.rewardPlayerAccounts = [];\n    this.idlePlayerAccounts = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse reservationid.\n   * @member {number|Long} reservationid\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.reservationid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse reservation.\n   * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null|undefined} reservation\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.reservation = null;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse map.\n   * @member {string} map\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.map = \"\";\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse gcReservationSent.\n   * @member {number|Long} gcReservationSent\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.gcReservationSent = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse serverVersion.\n   * @member {number} serverVersion\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.serverVersion = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse tvInfo.\n   * @member {IServerHltvInfo|null|undefined} tvInfo\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.tvInfo = null;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardPlayerAccounts.\n   * @member {Array.<number>} rewardPlayerAccounts\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.rewardPlayerAccounts = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse idlePlayerAccounts.\n   * @member {Array.<number>} idlePlayerAccounts\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.idlePlayerAccounts = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardItemAttrDefIdx.\n   * @member {number} rewardItemAttrDefIdx\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.rewardItemAttrDefIdx = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardItemAttrValue.\n   * @member {number} rewardItemAttrValue\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.rewardItemAttrValue = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardItemAttrRewardIdx.\n   * @member {number} rewardItemAttrRewardIdx\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.rewardItemAttrRewardIdx = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardDropList.\n   * @member {number} rewardDropList\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.rewardDropList = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse tournamentTag.\n   * @member {string} tournamentTag\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.tournamentTag = \"\";\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse steamdatagramPort.\n   * @member {number} steamdatagramPort\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.steamdatagramPort = 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_MatchmakingServerReservationResponse message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_MatchmakingServerReservationResponse} CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_MatchmakingServerReservationResponse();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.reservationid = reader.uint64();\n          break;\n\n        case 2:\n          message.reservation = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.decode(reader, reader.uint32());\n          break;\n\n        case 3:\n          message.map = reader.string();\n          break;\n\n        case 4:\n          message.gcReservationSent = reader.uint64();\n          break;\n\n        case 5:\n          message.serverVersion = reader.uint32();\n          break;\n\n        case 6:\n          message.tvInfo = $root.ServerHltvInfo.decode(reader, reader.uint32());\n          break;\n\n        case 7:\n          if (!(message.rewardPlayerAccounts && message.rewardPlayerAccounts.length)) message.rewardPlayerAccounts = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.rewardPlayerAccounts.push(reader.uint32());\n          } else message.rewardPlayerAccounts.push(reader.uint32());\n\n          break;\n\n        case 8:\n          if (!(message.idlePlayerAccounts && message.idlePlayerAccounts.length)) message.idlePlayerAccounts = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.idlePlayerAccounts.push(reader.uint32());\n          } else message.idlePlayerAccounts.push(reader.uint32());\n\n          break;\n\n        case 9:\n          message.rewardItemAttrDefIdx = reader.uint32();\n          break;\n\n        case 10:\n          message.rewardItemAttrValue = reader.uint32();\n          break;\n\n        case 11:\n          message.rewardItemAttrRewardIdx = reader.uint32();\n          break;\n\n        case 12:\n          message.rewardDropList = reader.uint32();\n          break;\n\n        case 13:\n          message.tournamentTag = reader.string();\n          break;\n\n        case 14:\n          message.steamdatagramPort = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_MatchmakingServerReservationResponse;\n})();\n\nexports.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve = $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.\n   * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\n   * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\n   * @property {number|Long|null} [serverid] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve serverid\n   * @property {string|null} [serverAddress] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve serverAddress\n   * @property {number|null} [legacyServerip] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve legacyServerip\n   * @property {number|null} [legacyServerport] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve legacyServerport\n   * @property {number|Long|null} [reservationid] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve reservationid\n   * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null} [reservation] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve reservation\n   * @property {string|null} [map] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve map\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.\n   * @exports CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\n   * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.\n   * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve serverid.\n   * @member {number|Long} serverid\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.serverid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve serverAddress.\n   * @member {string} serverAddress\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.serverAddress = \"\";\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve legacyServerip.\n   * @member {number} legacyServerip\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.legacyServerip = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve legacyServerport.\n   * @member {number} legacyServerport\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.legacyServerport = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve reservationid.\n   * @member {number|Long} reservationid\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.reservationid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve reservation.\n   * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null|undefined} reservation\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.reservation = null;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve map.\n   * @member {string} map\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.map = \"\";\n  /**\n   * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve} CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.serverid = reader.uint64();\n          break;\n\n        case 7:\n          message.serverAddress = reader.string();\n          break;\n\n        case 2:\n          message.legacyServerip = reader.uint32();\n          break;\n\n        case 3:\n          message.legacyServerport = reader.uint32();\n          break;\n\n        case 4:\n          message.reservationid = reader.uint64();\n          break;\n\n        case 5:\n          message.reservation = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.decode(reader, reader.uint32());\n          break;\n\n        case 6:\n          message.map = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve;\n})();\n\nexports.CMsgGCCStrike15_v2_MatchmakingServerRoundStats = $root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_MatchmakingServerRoundStats.\n   * @exports ICMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @interface ICMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @property {number|Long|null} [reservationid] CMsgGCCStrike15_v2_MatchmakingServerRoundStats reservationid\n   * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null} [reservation] CMsgGCCStrike15_v2_MatchmakingServerRoundStats reservation\n   * @property {string|null} [map] CMsgGCCStrike15_v2_MatchmakingServerRoundStats map\n   * @property {number|null} [round] CMsgGCCStrike15_v2_MatchmakingServerRoundStats round\n   * @property {Array.<number>|null} [kills] CMsgGCCStrike15_v2_MatchmakingServerRoundStats kills\n   * @property {Array.<number>|null} [assists] CMsgGCCStrike15_v2_MatchmakingServerRoundStats assists\n   * @property {Array.<number>|null} [deaths] CMsgGCCStrike15_v2_MatchmakingServerRoundStats deaths\n   * @property {Array.<number>|null} [scores] CMsgGCCStrike15_v2_MatchmakingServerRoundStats scores\n   * @property {Array.<number>|null} [pings] CMsgGCCStrike15_v2_MatchmakingServerRoundStats pings\n   * @property {number|null} [roundResult] CMsgGCCStrike15_v2_MatchmakingServerRoundStats roundResult\n   * @property {number|null} [matchResult] CMsgGCCStrike15_v2_MatchmakingServerRoundStats matchResult\n   * @property {Array.<number>|null} [teamScores] CMsgGCCStrike15_v2_MatchmakingServerRoundStats teamScores\n   * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm|null} [confirm] CMsgGCCStrike15_v2_MatchmakingServerRoundStats confirm\n   * @property {number|null} [reservationStage] CMsgGCCStrike15_v2_MatchmakingServerRoundStats reservationStage\n   * @property {number|null} [matchDuration] CMsgGCCStrike15_v2_MatchmakingServerRoundStats matchDuration\n   * @property {Array.<number>|null} [enemyKills] CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemyKills\n   * @property {Array.<number>|null} [enemyHeadshots] CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemyHeadshots\n   * @property {Array.<number>|null} [enemy_3ks] CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemy_3ks\n   * @property {Array.<number>|null} [enemy_4ks] CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemy_4ks\n   * @property {Array.<number>|null} [enemy_5ks] CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemy_5ks\n   * @property {Array.<number>|null} [mvps] CMsgGCCStrike15_v2_MatchmakingServerRoundStats mvps\n   * @property {number|null} [spectatorsCount] CMsgGCCStrike15_v2_MatchmakingServerRoundStats spectatorsCount\n   * @property {number|null} [spectatorsCountTv] CMsgGCCStrike15_v2_MatchmakingServerRoundStats spectatorsCountTv\n   * @property {number|null} [spectatorsCountLnk] CMsgGCCStrike15_v2_MatchmakingServerRoundStats spectatorsCountLnk\n   * @property {Array.<number>|null} [enemyKillsAgg] CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemyKillsAgg\n   * @property {CMsgGCCStrike15_v2_MatchmakingServerRoundStats.IDropInfo|null} [dropInfo] CMsgGCCStrike15_v2_MatchmakingServerRoundStats dropInfo\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_MatchmakingServerRoundStats.\n   * @exports CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingServerRoundStats.\n   * @implements ICMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_MatchmakingServerRoundStats=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_MatchmakingServerRoundStats(properties) {\n    this.kills = [];\n    this.assists = [];\n    this.deaths = [];\n    this.scores = [];\n    this.pings = [];\n    this.teamScores = [];\n    this.enemyKills = [];\n    this.enemyHeadshots = [];\n    this.enemy_3ks = [];\n    this.enemy_4ks = [];\n    this.enemy_5ks = [];\n    this.mvps = [];\n    this.enemyKillsAgg = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerRoundStats reservationid.\n   * @member {number|Long} reservationid\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.reservationid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerRoundStats reservation.\n   * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null|undefined} reservation\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.reservation = null;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerRoundStats map.\n   * @member {string} map\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.map = \"\";\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerRoundStats round.\n   * @member {number} round\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.round = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerRoundStats kills.\n   * @member {Array.<number>} kills\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.kills = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerRoundStats assists.\n   * @member {Array.<number>} assists\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.assists = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerRoundStats deaths.\n   * @member {Array.<number>} deaths\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.deaths = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerRoundStats scores.\n   * @member {Array.<number>} scores\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.scores = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerRoundStats pings.\n   * @member {Array.<number>} pings\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.pings = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerRoundStats roundResult.\n   * @member {number} roundResult\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.roundResult = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerRoundStats matchResult.\n   * @member {number} matchResult\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.matchResult = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerRoundStats teamScores.\n   * @member {Array.<number>} teamScores\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.teamScores = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerRoundStats confirm.\n   * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm|null|undefined} confirm\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.confirm = null;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerRoundStats reservationStage.\n   * @member {number} reservationStage\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.reservationStage = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerRoundStats matchDuration.\n   * @member {number} matchDuration\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.matchDuration = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemyKills.\n   * @member {Array.<number>} enemyKills\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.enemyKills = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemyHeadshots.\n   * @member {Array.<number>} enemyHeadshots\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.enemyHeadshots = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemy_3ks.\n   * @member {Array.<number>} enemy_3ks\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.enemy_3ks = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemy_4ks.\n   * @member {Array.<number>} enemy_4ks\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.enemy_4ks = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemy_5ks.\n   * @member {Array.<number>} enemy_5ks\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.enemy_5ks = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerRoundStats mvps.\n   * @member {Array.<number>} mvps\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.mvps = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerRoundStats spectatorsCount.\n   * @member {number} spectatorsCount\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.spectatorsCount = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerRoundStats spectatorsCountTv.\n   * @member {number} spectatorsCountTv\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.spectatorsCountTv = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerRoundStats spectatorsCountLnk.\n   * @member {number} spectatorsCountLnk\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.spectatorsCountLnk = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemyKillsAgg.\n   * @member {Array.<number>} enemyKillsAgg\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.enemyKillsAgg = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerRoundStats dropInfo.\n   * @member {CMsgGCCStrike15_v2_MatchmakingServerRoundStats.IDropInfo|null|undefined} dropInfo\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.dropInfo = null;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_MatchmakingServerRoundStats message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_MatchmakingServerRoundStats} CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.reservationid = reader.uint64();\n          break;\n\n        case 2:\n          message.reservation = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.decode(reader, reader.uint32());\n          break;\n\n        case 3:\n          message.map = reader.string();\n          break;\n\n        case 4:\n          message.round = reader.int32();\n          break;\n\n        case 5:\n          if (!(message.kills && message.kills.length)) message.kills = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.kills.push(reader.int32());\n          } else message.kills.push(reader.int32());\n\n          break;\n\n        case 6:\n          if (!(message.assists && message.assists.length)) message.assists = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.assists.push(reader.int32());\n          } else message.assists.push(reader.int32());\n\n          break;\n\n        case 7:\n          if (!(message.deaths && message.deaths.length)) message.deaths = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.deaths.push(reader.int32());\n          } else message.deaths.push(reader.int32());\n\n          break;\n\n        case 8:\n          if (!(message.scores && message.scores.length)) message.scores = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.scores.push(reader.int32());\n          } else message.scores.push(reader.int32());\n\n          break;\n\n        case 9:\n          if (!(message.pings && message.pings.length)) message.pings = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.pings.push(reader.int32());\n          } else message.pings.push(reader.int32());\n\n          break;\n\n        case 10:\n          message.roundResult = reader.int32();\n          break;\n\n        case 11:\n          message.matchResult = reader.int32();\n          break;\n\n        case 12:\n          if (!(message.teamScores && message.teamScores.length)) message.teamScores = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.teamScores.push(reader.int32());\n          } else message.teamScores.push(reader.int32());\n\n          break;\n\n        case 13:\n          message.confirm = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.decode(reader, reader.uint32());\n          break;\n\n        case 14:\n          message.reservationStage = reader.int32();\n          break;\n\n        case 15:\n          message.matchDuration = reader.int32();\n          break;\n\n        case 16:\n          if (!(message.enemyKills && message.enemyKills.length)) message.enemyKills = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.enemyKills.push(reader.int32());\n          } else message.enemyKills.push(reader.int32());\n\n          break;\n\n        case 17:\n          if (!(message.enemyHeadshots && message.enemyHeadshots.length)) message.enemyHeadshots = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.enemyHeadshots.push(reader.int32());\n          } else message.enemyHeadshots.push(reader.int32());\n\n          break;\n\n        case 18:\n          if (!(message.enemy_3ks && message.enemy_3ks.length)) message.enemy_3ks = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.enemy_3ks.push(reader.int32());\n          } else message.enemy_3ks.push(reader.int32());\n\n          break;\n\n        case 19:\n          if (!(message.enemy_4ks && message.enemy_4ks.length)) message.enemy_4ks = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.enemy_4ks.push(reader.int32());\n          } else message.enemy_4ks.push(reader.int32());\n\n          break;\n\n        case 20:\n          if (!(message.enemy_5ks && message.enemy_5ks.length)) message.enemy_5ks = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.enemy_5ks.push(reader.int32());\n          } else message.enemy_5ks.push(reader.int32());\n\n          break;\n\n        case 21:\n          if (!(message.mvps && message.mvps.length)) message.mvps = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.mvps.push(reader.int32());\n          } else message.mvps.push(reader.int32());\n\n          break;\n\n        case 22:\n          message.spectatorsCount = reader.uint32();\n          break;\n\n        case 23:\n          message.spectatorsCountTv = reader.uint32();\n          break;\n\n        case 24:\n          message.spectatorsCountLnk = reader.uint32();\n          break;\n\n        case 25:\n          if (!(message.enemyKillsAgg && message.enemyKillsAgg.length)) message.enemyKillsAgg = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.enemyKillsAgg.push(reader.int32());\n          } else message.enemyKillsAgg.push(reader.int32());\n\n          break;\n\n        case 26:\n          message.dropInfo = $root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo = function () {\n    /**\n     * Properties of a DropInfo.\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @interface IDropInfo\n     * @property {number|null} [accountMvp] DropInfo accountMvp\n     */\n\n    /**\n     * Constructs a new DropInfo.\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @classdesc Represents a DropInfo.\n     * @implements IDropInfo\n     * @constructor\n     * @param {CMsgGCCStrike15_v2_MatchmakingServerRoundStats.IDropInfo=} [properties] Properties to set\n     */\n    function DropInfo(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * DropInfo accountMvp.\n     * @member {number} accountMvp\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo\n     * @instance\n     */\n\n\n    DropInfo.prototype.accountMvp = 0;\n    /**\n     * Decodes a DropInfo message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo} DropInfo\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    DropInfo.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.accountMvp = reader.uint32();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return DropInfo;\n  }();\n\n  return CMsgGCCStrike15_v2_MatchmakingServerRoundStats;\n})();\n\nexports.CMsgGCCStrike15_v2_MatchmakingServerMatchEnd = $root.CMsgGCCStrike15_v2_MatchmakingServerMatchEnd = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.\n   * @exports ICMsgGCCStrike15_v2_MatchmakingServerMatchEnd\n   * @interface ICMsgGCCStrike15_v2_MatchmakingServerMatchEnd\n   * @property {ICMsgGCCStrike15_v2_MatchmakingServerRoundStats|null} [stats] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd stats\n   * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm|null} [confirm] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd confirm\n   * @property {number|Long|null} [rematch] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd rematch\n   * @property {number|null} [replayToken] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd replayToken\n   * @property {number|null} [replayClusterId] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd replayClusterId\n   * @property {boolean|null} [abortedMatch] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd abortedMatch\n   * @property {ICMsgGC_ServerQuestUpdateData|null} [matchEndQuestData] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd matchEndQuestData\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.\n   * @exports CMsgGCCStrike15_v2_MatchmakingServerMatchEnd\n   * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.\n   * @implements ICMsgGCCStrike15_v2_MatchmakingServerMatchEnd\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_MatchmakingServerMatchEnd=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_MatchmakingServerMatchEnd(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd stats.\n   * @member {ICMsgGCCStrike15_v2_MatchmakingServerRoundStats|null|undefined} stats\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.stats = null;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd confirm.\n   * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm|null|undefined} confirm\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.confirm = null;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd rematch.\n   * @member {number|Long} rematch\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.rematch = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd replayToken.\n   * @member {number} replayToken\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.replayToken = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd replayClusterId.\n   * @member {number} replayClusterId\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.replayClusterId = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd abortedMatch.\n   * @member {boolean} abortedMatch\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.abortedMatch = false;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd matchEndQuestData.\n   * @member {ICMsgGC_ServerQuestUpdateData|null|undefined} matchEndQuestData\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.matchEndQuestData = null;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_MatchmakingServerMatchEnd message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_MatchmakingServerMatchEnd} CMsgGCCStrike15_v2_MatchmakingServerMatchEnd\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_MatchmakingServerMatchEnd();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.stats = $root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats.decode(reader, reader.uint32());\n          break;\n\n        case 3:\n          message.confirm = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.decode(reader, reader.uint32());\n          break;\n\n        case 4:\n          message.rematch = reader.uint64();\n          break;\n\n        case 5:\n          message.replayToken = reader.uint32();\n          break;\n\n        case 6:\n          message.replayClusterId = reader.uint32();\n          break;\n\n        case 7:\n          message.abortedMatch = reader.bool();\n          break;\n\n        case 8:\n          message.matchEndQuestData = $root.CMsgGC_ServerQuestUpdateData.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_MatchmakingServerMatchEnd;\n})();\n\nexports.CMsgGCCStrike15_v2_MatchmakingClient2GCHello = $root.CMsgGCCStrike15_v2_MatchmakingClient2GCHello = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_MatchmakingClient2GCHello.\n   * @exports ICMsgGCCStrike15_v2_MatchmakingClient2GCHello\n   * @interface ICMsgGCCStrike15_v2_MatchmakingClient2GCHello\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_MatchmakingClient2GCHello.\n   * @exports CMsgGCCStrike15_v2_MatchmakingClient2GCHello\n   * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingClient2GCHello.\n   * @implements ICMsgGCCStrike15_v2_MatchmakingClient2GCHello\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_MatchmakingClient2GCHello=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_MatchmakingClient2GCHello(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * Decodes a CMsgGCCStrike15_v2_MatchmakingClient2GCHello message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_MatchmakingClient2GCHello\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_MatchmakingClient2GCHello} CMsgGCCStrike15_v2_MatchmakingClient2GCHello\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  CMsgGCCStrike15_v2_MatchmakingClient2GCHello.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_MatchmakingClient2GCHello();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_MatchmakingClient2GCHello;\n})();\n\nexports.CMsgGCCStrike15_v2_MatchmakingGC2ClientHello = $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientHello = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.\n   * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n   * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n   * @property {number|null} [accountId] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello accountId\n   * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null} [ongoingmatch] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello ongoingmatch\n   * @property {IGlobalStatistics|null} [globalStats] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello globalStats\n   * @property {number|null} [penaltySeconds] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello penaltySeconds\n   * @property {number|null} [penaltyReason] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello penaltyReason\n   * @property {number|null} [vacBanned] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello vacBanned\n   * @property {IPlayerRankingInfo|null} [ranking] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello ranking\n   * @property {IPlayerCommendationInfo|null} [commendation] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello commendation\n   * @property {IPlayerMedalsInfo|null} [medals] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello medals\n   * @property {ITournamentEvent|null} [myCurrentEvent] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentEvent\n   * @property {Array.<ITournamentTeam>|null} [myCurrentEventTeams] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentEventTeams\n   * @property {ITournamentTeam|null} [myCurrentTeam] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentTeam\n   * @property {Array.<ITournamentEvent>|null} [myCurrentEventStages] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentEventStages\n   * @property {number|null} [surveyVote] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello surveyVote\n   * @property {IAccountActivity|null} [activity] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello activity\n   * @property {number|null} [playerLevel] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello playerLevel\n   * @property {number|null} [playerCurXp] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello playerCurXp\n   * @property {number|null} [playerXpBonusFlags] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello playerXpBonusFlags\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.\n   * @exports CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n   * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.\n   * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ClientHello=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_MatchmakingGC2ClientHello(properties) {\n    this.myCurrentEventTeams = [];\n    this.myCurrentEventStages = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello accountId.\n   * @member {number} accountId\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.accountId = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello ongoingmatch.\n   * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null|undefined} ongoingmatch\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.ongoingmatch = null;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello globalStats.\n   * @member {IGlobalStatistics|null|undefined} globalStats\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.globalStats = null;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello penaltySeconds.\n   * @member {number} penaltySeconds\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.penaltySeconds = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello penaltyReason.\n   * @member {number} penaltyReason\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.penaltyReason = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello vacBanned.\n   * @member {number} vacBanned\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.vacBanned = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello ranking.\n   * @member {IPlayerRankingInfo|null|undefined} ranking\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.ranking = null;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello commendation.\n   * @member {IPlayerCommendationInfo|null|undefined} commendation\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.commendation = null;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello medals.\n   * @member {IPlayerMedalsInfo|null|undefined} medals\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.medals = null;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentEvent.\n   * @member {ITournamentEvent|null|undefined} myCurrentEvent\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.myCurrentEvent = null;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentEventTeams.\n   * @member {Array.<ITournamentTeam>} myCurrentEventTeams\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.myCurrentEventTeams = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentTeam.\n   * @member {ITournamentTeam|null|undefined} myCurrentTeam\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.myCurrentTeam = null;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentEventStages.\n   * @member {Array.<ITournamentEvent>} myCurrentEventStages\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.myCurrentEventStages = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello surveyVote.\n   * @member {number} surveyVote\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.surveyVote = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello activity.\n   * @member {IAccountActivity|null|undefined} activity\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.activity = null;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello playerLevel.\n   * @member {number} playerLevel\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.playerLevel = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello playerCurXp.\n   * @member {number} playerCurXp\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.playerCurXp = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello playerXpBonusFlags.\n   * @member {number} playerXpBonusFlags\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.playerXpBonusFlags = 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ClientHello message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ClientHello} CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientHello();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.accountId = reader.uint32();\n          break;\n\n        case 2:\n          message.ongoingmatch = $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.decode(reader, reader.uint32());\n          break;\n\n        case 3:\n          message.globalStats = $root.GlobalStatistics.decode(reader, reader.uint32());\n          break;\n\n        case 4:\n          message.penaltySeconds = reader.uint32();\n          break;\n\n        case 5:\n          message.penaltyReason = reader.uint32();\n          break;\n\n        case 6:\n          message.vacBanned = reader.int32();\n          break;\n\n        case 7:\n          message.ranking = $root.PlayerRankingInfo.decode(reader, reader.uint32());\n          break;\n\n        case 8:\n          message.commendation = $root.PlayerCommendationInfo.decode(reader, reader.uint32());\n          break;\n\n        case 9:\n          message.medals = $root.PlayerMedalsInfo.decode(reader, reader.uint32());\n          break;\n\n        case 10:\n          message.myCurrentEvent = $root.TournamentEvent.decode(reader, reader.uint32());\n          break;\n\n        case 11:\n          if (!(message.myCurrentEventTeams && message.myCurrentEventTeams.length)) message.myCurrentEventTeams = [];\n          message.myCurrentEventTeams.push($root.TournamentTeam.decode(reader, reader.uint32()));\n          break;\n\n        case 12:\n          message.myCurrentTeam = $root.TournamentTeam.decode(reader, reader.uint32());\n          break;\n\n        case 13:\n          if (!(message.myCurrentEventStages && message.myCurrentEventStages.length)) message.myCurrentEventStages = [];\n          message.myCurrentEventStages.push($root.TournamentEvent.decode(reader, reader.uint32()));\n          break;\n\n        case 14:\n          message.surveyVote = reader.uint32();\n          break;\n\n        case 15:\n          message.activity = $root.AccountActivity.decode(reader, reader.uint32());\n          break;\n\n        case 17:\n          message.playerLevel = reader.int32();\n          break;\n\n        case 18:\n          message.playerCurXp = reader.int32();\n          break;\n\n        case 19:\n          message.playerXpBonusFlags = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_MatchmakingGC2ClientHello;\n})();\n\nexports.CMsgGCCStrike15_v2_AccountPrivacySettings = $root.CMsgGCCStrike15_v2_AccountPrivacySettings = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_AccountPrivacySettings.\n   * @exports ICMsgGCCStrike15_v2_AccountPrivacySettings\n   * @interface ICMsgGCCStrike15_v2_AccountPrivacySettings\n   * @property {Array.<CMsgGCCStrike15_v2_AccountPrivacySettings.ISetting>|null} [settings] CMsgGCCStrike15_v2_AccountPrivacySettings settings\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_AccountPrivacySettings.\n   * @exports CMsgGCCStrike15_v2_AccountPrivacySettings\n   * @classdesc Represents a CMsgGCCStrike15_v2_AccountPrivacySettings.\n   * @implements ICMsgGCCStrike15_v2_AccountPrivacySettings\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_AccountPrivacySettings=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_AccountPrivacySettings(properties) {\n    this.settings = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_AccountPrivacySettings settings.\n   * @member {Array.<CMsgGCCStrike15_v2_AccountPrivacySettings.ISetting>} settings\n   * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_AccountPrivacySettings.prototype.settings = $util.emptyArray;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_AccountPrivacySettings message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_AccountPrivacySettings} CMsgGCCStrike15_v2_AccountPrivacySettings\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_AccountPrivacySettings.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_AccountPrivacySettings();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.settings && message.settings.length)) message.settings = [];\n          message.settings.push($root.CMsgGCCStrike15_v2_AccountPrivacySettings.Setting.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CMsgGCCStrike15_v2_AccountPrivacySettings.Setting = function () {\n    /**\n     * Properties of a Setting.\n     * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings\n     * @interface ISetting\n     * @property {number|null} [settingType] Setting settingType\n     * @property {number|null} [settingValue] Setting settingValue\n     */\n\n    /**\n     * Constructs a new Setting.\n     * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings\n     * @classdesc Represents a Setting.\n     * @implements ISetting\n     * @constructor\n     * @param {CMsgGCCStrike15_v2_AccountPrivacySettings.ISetting=} [properties] Properties to set\n     */\n    function Setting(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Setting settingType.\n     * @member {number} settingType\n     * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings.Setting\n     * @instance\n     */\n\n\n    Setting.prototype.settingType = 0;\n    /**\n     * Setting settingValue.\n     * @member {number} settingValue\n     * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings.Setting\n     * @instance\n     */\n\n    Setting.prototype.settingValue = 0;\n    /**\n     * Decodes a Setting message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings.Setting\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_AccountPrivacySettings.Setting} Setting\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    Setting.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CMsgGCCStrike15_v2_AccountPrivacySettings.Setting();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.settingType = reader.uint32();\n            break;\n\n          case 2:\n            message.settingValue = reader.uint32();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return Setting;\n  }();\n\n  return CMsgGCCStrike15_v2_AccountPrivacySettings;\n})();\n\nexports.CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon = $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.\n   * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon\n   * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon\n   * @property {number|null} [accountId] CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon accountId\n   * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null} [abandonedMatch] CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon abandonedMatch\n   * @property {number|null} [penaltySeconds] CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon penaltySeconds\n   * @property {number|null} [penaltyReason] CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon penaltyReason\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.\n   * @exports CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon\n   * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.\n   * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon accountId.\n   * @member {number} accountId\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.prototype.accountId = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon abandonedMatch.\n   * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null|undefined} abandonedMatch\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.prototype.abandonedMatch = null;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon penaltySeconds.\n   * @member {number} penaltySeconds\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.prototype.penaltySeconds = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon penaltyReason.\n   * @member {number} penaltyReason\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.prototype.penaltyReason = 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon} CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.accountId = reader.uint32();\n          break;\n\n        case 2:\n          message.abandonedMatch = $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.decode(reader, reader.uint32());\n          break;\n\n        case 3:\n          message.penaltySeconds = reader.uint32();\n          break;\n\n        case 4:\n          message.penaltyReason = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon;\n})();\n\nexports.CMsgGCCStrike15_v2_MatchmakingServer2GCKick = $root.CMsgGCCStrike15_v2_MatchmakingServer2GCKick = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_MatchmakingServer2GCKick.\n   * @exports ICMsgGCCStrike15_v2_MatchmakingServer2GCKick\n   * @interface ICMsgGCCStrike15_v2_MatchmakingServer2GCKick\n   * @property {number|null} [accountId] CMsgGCCStrike15_v2_MatchmakingServer2GCKick accountId\n   * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null} [reservation] CMsgGCCStrike15_v2_MatchmakingServer2GCKick reservation\n   * @property {number|null} [reason] CMsgGCCStrike15_v2_MatchmakingServer2GCKick reason\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_MatchmakingServer2GCKick.\n   * @exports CMsgGCCStrike15_v2_MatchmakingServer2GCKick\n   * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingServer2GCKick.\n   * @implements ICMsgGCCStrike15_v2_MatchmakingServer2GCKick\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_MatchmakingServer2GCKick=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_MatchmakingServer2GCKick(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServer2GCKick accountId.\n   * @member {number} accountId\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServer2GCKick\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_MatchmakingServer2GCKick.prototype.accountId = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServer2GCKick reservation.\n   * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null|undefined} reservation\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServer2GCKick\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServer2GCKick.prototype.reservation = null;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingServer2GCKick reason.\n   * @member {number} reason\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServer2GCKick\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServer2GCKick.prototype.reason = 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_MatchmakingServer2GCKick message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_MatchmakingServer2GCKick\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_MatchmakingServer2GCKick} CMsgGCCStrike15_v2_MatchmakingServer2GCKick\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingServer2GCKick.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_MatchmakingServer2GCKick();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.accountId = reader.uint32();\n          break;\n\n        case 2:\n          message.reservation = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.decode(reader, reader.uint32());\n          break;\n\n        case 3:\n          message.reason = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_MatchmakingServer2GCKick;\n})();\n\nexports.CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.\n   * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate\n   * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate\n   * @property {Array.<IPlayerRankingInfo>|null} [rankings] CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate rankings\n   * @property {number|Long|null} [matchId] CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate matchId\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.\n   * @exports CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate\n   * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.\n   * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate(properties) {\n    this.rankings = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate rankings.\n   * @member {Array.<IPlayerRankingInfo>} rankings\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.prototype.rankings = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate matchId.\n   * @member {number|Long} matchId\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.prototype.matchId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate} CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.rankings && message.rankings.length)) message.rankings = [];\n          message.rankings.push($root.PlayerRankingInfo.decode(reader, reader.uint32()));\n          break;\n\n        case 2:\n          message.matchId = reader.uint64();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate;\n})();\n\nexports.CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate = $root.CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate.\n   * @exports ICMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate\n   * @interface ICMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate\n   * @property {string|null} [mainPostUrl] CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate mainPostUrl\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate.\n   * @exports CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate\n   * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate.\n   * @implements ICMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate mainPostUrl.\n   * @member {string} mainPostUrl\n   * @memberof CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate.prototype.mainPostUrl = \"\";\n  /**\n   * Decodes a CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate} CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.mainPostUrl = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate;\n})();\n\nexports.CMsgGCCStrike15_v2_ServerNotificationForUserPenalty = $root.CMsgGCCStrike15_v2_ServerNotificationForUserPenalty = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.\n   * @exports ICMsgGCCStrike15_v2_ServerNotificationForUserPenalty\n   * @interface ICMsgGCCStrike15_v2_ServerNotificationForUserPenalty\n   * @property {number|null} [accountId] CMsgGCCStrike15_v2_ServerNotificationForUserPenalty accountId\n   * @property {number|null} [reason] CMsgGCCStrike15_v2_ServerNotificationForUserPenalty reason\n   * @property {number|null} [seconds] CMsgGCCStrike15_v2_ServerNotificationForUserPenalty seconds\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.\n   * @exports CMsgGCCStrike15_v2_ServerNotificationForUserPenalty\n   * @classdesc Represents a CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.\n   * @implements ICMsgGCCStrike15_v2_ServerNotificationForUserPenalty\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_ServerNotificationForUserPenalty=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_ServerNotificationForUserPenalty(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_ServerNotificationForUserPenalty accountId.\n   * @member {number} accountId\n   * @memberof CMsgGCCStrike15_v2_ServerNotificationForUserPenalty\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.prototype.accountId = 0;\n  /**\n   * CMsgGCCStrike15_v2_ServerNotificationForUserPenalty reason.\n   * @member {number} reason\n   * @memberof CMsgGCCStrike15_v2_ServerNotificationForUserPenalty\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.prototype.reason = 0;\n  /**\n   * CMsgGCCStrike15_v2_ServerNotificationForUserPenalty seconds.\n   * @member {number} seconds\n   * @memberof CMsgGCCStrike15_v2_ServerNotificationForUserPenalty\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.prototype.seconds = 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_ServerNotificationForUserPenalty message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_ServerNotificationForUserPenalty\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_ServerNotificationForUserPenalty} CMsgGCCStrike15_v2_ServerNotificationForUserPenalty\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_ServerNotificationForUserPenalty();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.accountId = reader.uint32();\n          break;\n\n        case 2:\n          message.reason = reader.uint32();\n          break;\n\n        case 3:\n          message.seconds = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_ServerNotificationForUserPenalty;\n})();\n\nexports.CMsgGCCStrike15_v2_ClientReportPlayer = $root.CMsgGCCStrike15_v2_ClientReportPlayer = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_ClientReportPlayer.\n   * @exports ICMsgGCCStrike15_v2_ClientReportPlayer\n   * @interface ICMsgGCCStrike15_v2_ClientReportPlayer\n   * @property {number|null} [accountId] CMsgGCCStrike15_v2_ClientReportPlayer accountId\n   * @property {number|null} [rptAimbot] CMsgGCCStrike15_v2_ClientReportPlayer rptAimbot\n   * @property {number|null} [rptWallhack] CMsgGCCStrike15_v2_ClientReportPlayer rptWallhack\n   * @property {number|null} [rptSpeedhack] CMsgGCCStrike15_v2_ClientReportPlayer rptSpeedhack\n   * @property {number|null} [rptTeamharm] CMsgGCCStrike15_v2_ClientReportPlayer rptTeamharm\n   * @property {number|null} [rptTextabuse] CMsgGCCStrike15_v2_ClientReportPlayer rptTextabuse\n   * @property {number|null} [rptVoiceabuse] CMsgGCCStrike15_v2_ClientReportPlayer rptVoiceabuse\n   * @property {number|Long|null} [matchId] CMsgGCCStrike15_v2_ClientReportPlayer matchId\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_ClientReportPlayer.\n   * @exports CMsgGCCStrike15_v2_ClientReportPlayer\n   * @classdesc Represents a CMsgGCCStrike15_v2_ClientReportPlayer.\n   * @implements ICMsgGCCStrike15_v2_ClientReportPlayer\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_ClientReportPlayer=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_ClientReportPlayer(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_ClientReportPlayer accountId.\n   * @member {number} accountId\n   * @memberof CMsgGCCStrike15_v2_ClientReportPlayer\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_ClientReportPlayer.prototype.accountId = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientReportPlayer rptAimbot.\n   * @member {number} rptAimbot\n   * @memberof CMsgGCCStrike15_v2_ClientReportPlayer\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientReportPlayer.prototype.rptAimbot = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientReportPlayer rptWallhack.\n   * @member {number} rptWallhack\n   * @memberof CMsgGCCStrike15_v2_ClientReportPlayer\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientReportPlayer.prototype.rptWallhack = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientReportPlayer rptSpeedhack.\n   * @member {number} rptSpeedhack\n   * @memberof CMsgGCCStrike15_v2_ClientReportPlayer\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientReportPlayer.prototype.rptSpeedhack = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientReportPlayer rptTeamharm.\n   * @member {number} rptTeamharm\n   * @memberof CMsgGCCStrike15_v2_ClientReportPlayer\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientReportPlayer.prototype.rptTeamharm = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientReportPlayer rptTextabuse.\n   * @member {number} rptTextabuse\n   * @memberof CMsgGCCStrike15_v2_ClientReportPlayer\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientReportPlayer.prototype.rptTextabuse = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientReportPlayer rptVoiceabuse.\n   * @member {number} rptVoiceabuse\n   * @memberof CMsgGCCStrike15_v2_ClientReportPlayer\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientReportPlayer.prototype.rptVoiceabuse = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientReportPlayer matchId.\n   * @member {number|Long} matchId\n   * @memberof CMsgGCCStrike15_v2_ClientReportPlayer\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientReportPlayer.prototype.matchId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_ClientReportPlayer message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_ClientReportPlayer\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_ClientReportPlayer} CMsgGCCStrike15_v2_ClientReportPlayer\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_ClientReportPlayer.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_ClientReportPlayer();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.accountId = reader.uint32();\n          break;\n\n        case 2:\n          message.rptAimbot = reader.uint32();\n          break;\n\n        case 3:\n          message.rptWallhack = reader.uint32();\n          break;\n\n        case 4:\n          message.rptSpeedhack = reader.uint32();\n          break;\n\n        case 5:\n          message.rptTeamharm = reader.uint32();\n          break;\n\n        case 6:\n          message.rptTextabuse = reader.uint32();\n          break;\n\n        case 7:\n          message.rptVoiceabuse = reader.uint32();\n          break;\n\n        case 8:\n          message.matchId = reader.uint64();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_ClientReportPlayer;\n})();\n\nexports.CMsgGCCStrike15_v2_ClientCommendPlayer = $root.CMsgGCCStrike15_v2_ClientCommendPlayer = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_ClientCommendPlayer.\n   * @exports ICMsgGCCStrike15_v2_ClientCommendPlayer\n   * @interface ICMsgGCCStrike15_v2_ClientCommendPlayer\n   * @property {number|null} [accountId] CMsgGCCStrike15_v2_ClientCommendPlayer accountId\n   * @property {number|Long|null} [matchId] CMsgGCCStrike15_v2_ClientCommendPlayer matchId\n   * @property {IPlayerCommendationInfo|null} [commendation] CMsgGCCStrike15_v2_ClientCommendPlayer commendation\n   * @property {number|null} [tokens] CMsgGCCStrike15_v2_ClientCommendPlayer tokens\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_ClientCommendPlayer.\n   * @exports CMsgGCCStrike15_v2_ClientCommendPlayer\n   * @classdesc Represents a CMsgGCCStrike15_v2_ClientCommendPlayer.\n   * @implements ICMsgGCCStrike15_v2_ClientCommendPlayer\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_ClientCommendPlayer=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_ClientCommendPlayer(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_ClientCommendPlayer accountId.\n   * @member {number} accountId\n   * @memberof CMsgGCCStrike15_v2_ClientCommendPlayer\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_ClientCommendPlayer.prototype.accountId = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientCommendPlayer matchId.\n   * @member {number|Long} matchId\n   * @memberof CMsgGCCStrike15_v2_ClientCommendPlayer\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientCommendPlayer.prototype.matchId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientCommendPlayer commendation.\n   * @member {IPlayerCommendationInfo|null|undefined} commendation\n   * @memberof CMsgGCCStrike15_v2_ClientCommendPlayer\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientCommendPlayer.prototype.commendation = null;\n  /**\n   * CMsgGCCStrike15_v2_ClientCommendPlayer tokens.\n   * @member {number} tokens\n   * @memberof CMsgGCCStrike15_v2_ClientCommendPlayer\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientCommendPlayer.prototype.tokens = 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_ClientCommendPlayer message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_ClientCommendPlayer\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_ClientCommendPlayer} CMsgGCCStrike15_v2_ClientCommendPlayer\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_ClientCommendPlayer.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_ClientCommendPlayer();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.accountId = reader.uint32();\n          break;\n\n        case 8:\n          message.matchId = reader.uint64();\n          break;\n\n        case 9:\n          message.commendation = $root.PlayerCommendationInfo.decode(reader, reader.uint32());\n          break;\n\n        case 10:\n          message.tokens = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_ClientCommendPlayer;\n})();\n\nexports.CMsgGCCStrike15_v2_ClientReportServer = $root.CMsgGCCStrike15_v2_ClientReportServer = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_ClientReportServer.\n   * @exports ICMsgGCCStrike15_v2_ClientReportServer\n   * @interface ICMsgGCCStrike15_v2_ClientReportServer\n   * @property {number|null} [rptPoorperf] CMsgGCCStrike15_v2_ClientReportServer rptPoorperf\n   * @property {number|null} [rptAbusivemodels] CMsgGCCStrike15_v2_ClientReportServer rptAbusivemodels\n   * @property {number|null} [rptBadmotd] CMsgGCCStrike15_v2_ClientReportServer rptBadmotd\n   * @property {number|null} [rptListingabuse] CMsgGCCStrike15_v2_ClientReportServer rptListingabuse\n   * @property {number|null} [rptInventoryabuse] CMsgGCCStrike15_v2_ClientReportServer rptInventoryabuse\n   * @property {number|Long|null} [matchId] CMsgGCCStrike15_v2_ClientReportServer matchId\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_ClientReportServer.\n   * @exports CMsgGCCStrike15_v2_ClientReportServer\n   * @classdesc Represents a CMsgGCCStrike15_v2_ClientReportServer.\n   * @implements ICMsgGCCStrike15_v2_ClientReportServer\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_ClientReportServer=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_ClientReportServer(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_ClientReportServer rptPoorperf.\n   * @member {number} rptPoorperf\n   * @memberof CMsgGCCStrike15_v2_ClientReportServer\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_ClientReportServer.prototype.rptPoorperf = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientReportServer rptAbusivemodels.\n   * @member {number} rptAbusivemodels\n   * @memberof CMsgGCCStrike15_v2_ClientReportServer\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientReportServer.prototype.rptAbusivemodels = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientReportServer rptBadmotd.\n   * @member {number} rptBadmotd\n   * @memberof CMsgGCCStrike15_v2_ClientReportServer\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientReportServer.prototype.rptBadmotd = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientReportServer rptListingabuse.\n   * @member {number} rptListingabuse\n   * @memberof CMsgGCCStrike15_v2_ClientReportServer\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientReportServer.prototype.rptListingabuse = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientReportServer rptInventoryabuse.\n   * @member {number} rptInventoryabuse\n   * @memberof CMsgGCCStrike15_v2_ClientReportServer\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientReportServer.prototype.rptInventoryabuse = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientReportServer matchId.\n   * @member {number|Long} matchId\n   * @memberof CMsgGCCStrike15_v2_ClientReportServer\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientReportServer.prototype.matchId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_ClientReportServer message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_ClientReportServer\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_ClientReportServer} CMsgGCCStrike15_v2_ClientReportServer\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_ClientReportServer.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_ClientReportServer();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.rptPoorperf = reader.uint32();\n          break;\n\n        case 2:\n          message.rptAbusivemodels = reader.uint32();\n          break;\n\n        case 3:\n          message.rptBadmotd = reader.uint32();\n          break;\n\n        case 4:\n          message.rptListingabuse = reader.uint32();\n          break;\n\n        case 5:\n          message.rptInventoryabuse = reader.uint32();\n          break;\n\n        case 8:\n          message.matchId = reader.uint64();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_ClientReportServer;\n})();\n\nexports.CMsgGCCStrike15_v2_ClientReportResponse = $root.CMsgGCCStrike15_v2_ClientReportResponse = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_ClientReportResponse.\n   * @exports ICMsgGCCStrike15_v2_ClientReportResponse\n   * @interface ICMsgGCCStrike15_v2_ClientReportResponse\n   * @property {number|Long|null} [confirmationId] CMsgGCCStrike15_v2_ClientReportResponse confirmationId\n   * @property {number|null} [accountId] CMsgGCCStrike15_v2_ClientReportResponse accountId\n   * @property {number|null} [serverIp] CMsgGCCStrike15_v2_ClientReportResponse serverIp\n   * @property {number|null} [responseType] CMsgGCCStrike15_v2_ClientReportResponse responseType\n   * @property {number|null} [responseResult] CMsgGCCStrike15_v2_ClientReportResponse responseResult\n   * @property {number|null} [tokens] CMsgGCCStrike15_v2_ClientReportResponse tokens\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_ClientReportResponse.\n   * @exports CMsgGCCStrike15_v2_ClientReportResponse\n   * @classdesc Represents a CMsgGCCStrike15_v2_ClientReportResponse.\n   * @implements ICMsgGCCStrike15_v2_ClientReportResponse\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_ClientReportResponse=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_ClientReportResponse(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_ClientReportResponse confirmationId.\n   * @member {number|Long} confirmationId\n   * @memberof CMsgGCCStrike15_v2_ClientReportResponse\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_ClientReportResponse.prototype.confirmationId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientReportResponse accountId.\n   * @member {number} accountId\n   * @memberof CMsgGCCStrike15_v2_ClientReportResponse\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientReportResponse.prototype.accountId = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientReportResponse serverIp.\n   * @member {number} serverIp\n   * @memberof CMsgGCCStrike15_v2_ClientReportResponse\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientReportResponse.prototype.serverIp = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientReportResponse responseType.\n   * @member {number} responseType\n   * @memberof CMsgGCCStrike15_v2_ClientReportResponse\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientReportResponse.prototype.responseType = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientReportResponse responseResult.\n   * @member {number} responseResult\n   * @memberof CMsgGCCStrike15_v2_ClientReportResponse\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientReportResponse.prototype.responseResult = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientReportResponse tokens.\n   * @member {number} tokens\n   * @memberof CMsgGCCStrike15_v2_ClientReportResponse\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientReportResponse.prototype.tokens = 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_ClientReportResponse message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_ClientReportResponse\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_ClientReportResponse} CMsgGCCStrike15_v2_ClientReportResponse\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_ClientReportResponse.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_ClientReportResponse();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.confirmationId = reader.uint64();\n          break;\n\n        case 2:\n          message.accountId = reader.uint32();\n          break;\n\n        case 3:\n          message.serverIp = reader.uint32();\n          break;\n\n        case 4:\n          message.responseType = reader.uint32();\n          break;\n\n        case 5:\n          message.responseResult = reader.uint32();\n          break;\n\n        case 6:\n          message.tokens = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_ClientReportResponse;\n})();\n\nexports.CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends = $root.CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.\n   * @exports ICMsgGCCStrike15_v2_ClientRequestWatchInfoFriends\n   * @interface ICMsgGCCStrike15_v2_ClientRequestWatchInfoFriends\n   * @property {number|null} [requestId] CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends requestId\n   * @property {Array.<number>|null} [accountIds] CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends accountIds\n   * @property {number|Long|null} [serverid] CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends serverid\n   * @property {number|Long|null} [matchid] CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends matchid\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.\n   * @exports CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends\n   * @classdesc Represents a CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.\n   * @implements ICMsgGCCStrike15_v2_ClientRequestWatchInfoFriends\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_ClientRequestWatchInfoFriends=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends(properties) {\n    this.accountIds = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends requestId.\n   * @member {number} requestId\n   * @memberof CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.prototype.requestId = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends accountIds.\n   * @member {Array.<number>} accountIds\n   * @memberof CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.prototype.accountIds = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends serverid.\n   * @member {number|Long} serverid\n   * @memberof CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.prototype.serverid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends matchid.\n   * @member {number|Long} matchid\n   * @memberof CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.prototype.matchid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends} CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.requestId = reader.uint32();\n          break;\n\n        case 2:\n          if (!(message.accountIds && message.accountIds.length)) message.accountIds = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.accountIds.push(reader.uint32());\n          } else message.accountIds.push(reader.uint32());\n\n          break;\n\n        case 3:\n          message.serverid = reader.uint64();\n          break;\n\n        case 4:\n          message.matchid = reader.uint64();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends;\n})();\n\nexports.WatchableMatchInfo = $root.WatchableMatchInfo = (() => {\n  /**\n   * Properties of a WatchableMatchInfo.\n   * @exports IWatchableMatchInfo\n   * @interface IWatchableMatchInfo\n   * @property {number|null} [serverIp] WatchableMatchInfo serverIp\n   * @property {number|null} [tvPort] WatchableMatchInfo tvPort\n   * @property {number|null} [tvSpectators] WatchableMatchInfo tvSpectators\n   * @property {number|null} [tvTime] WatchableMatchInfo tvTime\n   * @property {Uint8Array|null} [tvWatchPassword] WatchableMatchInfo tvWatchPassword\n   * @property {number|Long|null} [clDecryptdataKey] WatchableMatchInfo clDecryptdataKey\n   * @property {number|Long|null} [clDecryptdataKeyPub] WatchableMatchInfo clDecryptdataKeyPub\n   * @property {number|null} [gameType] WatchableMatchInfo gameType\n   * @property {string|null} [gameMapgroup] WatchableMatchInfo gameMapgroup\n   * @property {string|null} [gameMap] WatchableMatchInfo gameMap\n   * @property {number|Long|null} [serverId] WatchableMatchInfo serverId\n   * @property {number|Long|null} [matchId] WatchableMatchInfo matchId\n   * @property {number|Long|null} [reservationId] WatchableMatchInfo reservationId\n   */\n\n  /**\n   * Constructs a new WatchableMatchInfo.\n   * @exports WatchableMatchInfo\n   * @classdesc Represents a WatchableMatchInfo.\n   * @implements IWatchableMatchInfo\n   * @constructor\n   * @param {IWatchableMatchInfo=} [properties] Properties to set\n   */\n  function WatchableMatchInfo(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * WatchableMatchInfo serverIp.\n   * @member {number} serverIp\n   * @memberof WatchableMatchInfo\n   * @instance\n   */\n\n\n  WatchableMatchInfo.prototype.serverIp = 0;\n  /**\n   * WatchableMatchInfo tvPort.\n   * @member {number} tvPort\n   * @memberof WatchableMatchInfo\n   * @instance\n   */\n\n  WatchableMatchInfo.prototype.tvPort = 0;\n  /**\n   * WatchableMatchInfo tvSpectators.\n   * @member {number} tvSpectators\n   * @memberof WatchableMatchInfo\n   * @instance\n   */\n\n  WatchableMatchInfo.prototype.tvSpectators = 0;\n  /**\n   * WatchableMatchInfo tvTime.\n   * @member {number} tvTime\n   * @memberof WatchableMatchInfo\n   * @instance\n   */\n\n  WatchableMatchInfo.prototype.tvTime = 0;\n  /**\n   * WatchableMatchInfo tvWatchPassword.\n   * @member {Uint8Array} tvWatchPassword\n   * @memberof WatchableMatchInfo\n   * @instance\n   */\n\n  WatchableMatchInfo.prototype.tvWatchPassword = $util.newBuffer([]);\n  /**\n   * WatchableMatchInfo clDecryptdataKey.\n   * @member {number|Long} clDecryptdataKey\n   * @memberof WatchableMatchInfo\n   * @instance\n   */\n\n  WatchableMatchInfo.prototype.clDecryptdataKey = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * WatchableMatchInfo clDecryptdataKeyPub.\n   * @member {number|Long} clDecryptdataKeyPub\n   * @memberof WatchableMatchInfo\n   * @instance\n   */\n\n  WatchableMatchInfo.prototype.clDecryptdataKeyPub = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * WatchableMatchInfo gameType.\n   * @member {number} gameType\n   * @memberof WatchableMatchInfo\n   * @instance\n   */\n\n  WatchableMatchInfo.prototype.gameType = 0;\n  /**\n   * WatchableMatchInfo gameMapgroup.\n   * @member {string} gameMapgroup\n   * @memberof WatchableMatchInfo\n   * @instance\n   */\n\n  WatchableMatchInfo.prototype.gameMapgroup = \"\";\n  /**\n   * WatchableMatchInfo gameMap.\n   * @member {string} gameMap\n   * @memberof WatchableMatchInfo\n   * @instance\n   */\n\n  WatchableMatchInfo.prototype.gameMap = \"\";\n  /**\n   * WatchableMatchInfo serverId.\n   * @member {number|Long} serverId\n   * @memberof WatchableMatchInfo\n   * @instance\n   */\n\n  WatchableMatchInfo.prototype.serverId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * WatchableMatchInfo matchId.\n   * @member {number|Long} matchId\n   * @memberof WatchableMatchInfo\n   * @instance\n   */\n\n  WatchableMatchInfo.prototype.matchId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * WatchableMatchInfo reservationId.\n   * @member {number|Long} reservationId\n   * @memberof WatchableMatchInfo\n   * @instance\n   */\n\n  WatchableMatchInfo.prototype.reservationId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * Decodes a WatchableMatchInfo message from the specified reader or buffer.\n   * @function decode\n   * @memberof WatchableMatchInfo\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {WatchableMatchInfo} WatchableMatchInfo\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  WatchableMatchInfo.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.WatchableMatchInfo();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.serverIp = reader.uint32();\n          break;\n\n        case 2:\n          message.tvPort = reader.uint32();\n          break;\n\n        case 3:\n          message.tvSpectators = reader.uint32();\n          break;\n\n        case 4:\n          message.tvTime = reader.uint32();\n          break;\n\n        case 5:\n          message.tvWatchPassword = reader.bytes();\n          break;\n\n        case 6:\n          message.clDecryptdataKey = reader.uint64();\n          break;\n\n        case 7:\n          message.clDecryptdataKeyPub = reader.uint64();\n          break;\n\n        case 8:\n          message.gameType = reader.uint32();\n          break;\n\n        case 9:\n          message.gameMapgroup = reader.string();\n          break;\n\n        case 10:\n          message.gameMap = reader.string();\n          break;\n\n        case 11:\n          message.serverId = reader.uint64();\n          break;\n\n        case 12:\n          message.matchId = reader.uint64();\n          break;\n\n        case 13:\n          message.reservationId = reader.uint64();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return WatchableMatchInfo;\n})();\n\nexports.CMsgGCCStrike15_v2_ClientRequestJoinFriendData = $root.CMsgGCCStrike15_v2_ClientRequestJoinFriendData = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_ClientRequestJoinFriendData.\n   * @exports ICMsgGCCStrike15_v2_ClientRequestJoinFriendData\n   * @interface ICMsgGCCStrike15_v2_ClientRequestJoinFriendData\n   * @property {number|null} [version] CMsgGCCStrike15_v2_ClientRequestJoinFriendData version\n   * @property {number|null} [accountId] CMsgGCCStrike15_v2_ClientRequestJoinFriendData accountId\n   * @property {number|null} [joinToken] CMsgGCCStrike15_v2_ClientRequestJoinFriendData joinToken\n   * @property {number|null} [joinIpp] CMsgGCCStrike15_v2_ClientRequestJoinFriendData joinIpp\n   * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null} [res] CMsgGCCStrike15_v2_ClientRequestJoinFriendData res\n   * @property {string|null} [errormsg] CMsgGCCStrike15_v2_ClientRequestJoinFriendData errormsg\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_ClientRequestJoinFriendData.\n   * @exports CMsgGCCStrike15_v2_ClientRequestJoinFriendData\n   * @classdesc Represents a CMsgGCCStrike15_v2_ClientRequestJoinFriendData.\n   * @implements ICMsgGCCStrike15_v2_ClientRequestJoinFriendData\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_ClientRequestJoinFriendData=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_ClientRequestJoinFriendData(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_ClientRequestJoinFriendData version.\n   * @member {number} version\n   * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_ClientRequestJoinFriendData.prototype.version = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientRequestJoinFriendData accountId.\n   * @member {number} accountId\n   * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientRequestJoinFriendData.prototype.accountId = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientRequestJoinFriendData joinToken.\n   * @member {number} joinToken\n   * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientRequestJoinFriendData.prototype.joinToken = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientRequestJoinFriendData joinIpp.\n   * @member {number} joinIpp\n   * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientRequestJoinFriendData.prototype.joinIpp = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientRequestJoinFriendData res.\n   * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null|undefined} res\n   * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientRequestJoinFriendData.prototype.res = null;\n  /**\n   * CMsgGCCStrike15_v2_ClientRequestJoinFriendData errormsg.\n   * @member {string} errormsg\n   * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientRequestJoinFriendData.prototype.errormsg = \"\";\n  /**\n   * Decodes a CMsgGCCStrike15_v2_ClientRequestJoinFriendData message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_ClientRequestJoinFriendData} CMsgGCCStrike15_v2_ClientRequestJoinFriendData\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_ClientRequestJoinFriendData.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_ClientRequestJoinFriendData();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.version = reader.uint32();\n          break;\n\n        case 2:\n          message.accountId = reader.uint32();\n          break;\n\n        case 3:\n          message.joinToken = reader.uint32();\n          break;\n\n        case 4:\n          message.joinIpp = reader.uint32();\n          break;\n\n        case 5:\n          message.res = $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.decode(reader, reader.uint32());\n          break;\n\n        case 6:\n          message.errormsg = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_ClientRequestJoinFriendData;\n})();\n\nexports.CMsgGCCStrike15_v2_ClientRequestJoinServerData = $root.CMsgGCCStrike15_v2_ClientRequestJoinServerData = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_ClientRequestJoinServerData.\n   * @exports ICMsgGCCStrike15_v2_ClientRequestJoinServerData\n   * @interface ICMsgGCCStrike15_v2_ClientRequestJoinServerData\n   * @property {number|null} [version] CMsgGCCStrike15_v2_ClientRequestJoinServerData version\n   * @property {number|null} [accountId] CMsgGCCStrike15_v2_ClientRequestJoinServerData accountId\n   * @property {number|Long|null} [serverid] CMsgGCCStrike15_v2_ClientRequestJoinServerData serverid\n   * @property {number|null} [serverIp] CMsgGCCStrike15_v2_ClientRequestJoinServerData serverIp\n   * @property {number|null} [serverPort] CMsgGCCStrike15_v2_ClientRequestJoinServerData serverPort\n   * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null} [res] CMsgGCCStrike15_v2_ClientRequestJoinServerData res\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_ClientRequestJoinServerData.\n   * @exports CMsgGCCStrike15_v2_ClientRequestJoinServerData\n   * @classdesc Represents a CMsgGCCStrike15_v2_ClientRequestJoinServerData.\n   * @implements ICMsgGCCStrike15_v2_ClientRequestJoinServerData\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_ClientRequestJoinServerData=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_ClientRequestJoinServerData(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_ClientRequestJoinServerData version.\n   * @member {number} version\n   * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_ClientRequestJoinServerData.prototype.version = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientRequestJoinServerData accountId.\n   * @member {number} accountId\n   * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientRequestJoinServerData.prototype.accountId = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientRequestJoinServerData serverid.\n   * @member {number|Long} serverid\n   * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientRequestJoinServerData.prototype.serverid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientRequestJoinServerData serverIp.\n   * @member {number} serverIp\n   * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientRequestJoinServerData.prototype.serverIp = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientRequestJoinServerData serverPort.\n   * @member {number} serverPort\n   * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientRequestJoinServerData.prototype.serverPort = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientRequestJoinServerData res.\n   * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null|undefined} res\n   * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientRequestJoinServerData.prototype.res = null;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_ClientRequestJoinServerData message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_ClientRequestJoinServerData} CMsgGCCStrike15_v2_ClientRequestJoinServerData\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_ClientRequestJoinServerData.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_ClientRequestJoinServerData();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.version = reader.uint32();\n          break;\n\n        case 2:\n          message.accountId = reader.uint32();\n          break;\n\n        case 3:\n          message.serverid = reader.uint64();\n          break;\n\n        case 4:\n          message.serverIp = reader.uint32();\n          break;\n\n        case 5:\n          message.serverPort = reader.uint32();\n          break;\n\n        case 6:\n          message.res = $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_ClientRequestJoinServerData;\n})();\n\nexports.CMsgGCCstrike15_v2_ClientRequestNewMission = $root.CMsgGCCstrike15_v2_ClientRequestNewMission = (() => {\n  /**\n   * Properties of a CMsgGCCstrike15_v2_ClientRequestNewMission.\n   * @exports ICMsgGCCstrike15_v2_ClientRequestNewMission\n   * @interface ICMsgGCCstrike15_v2_ClientRequestNewMission\n   * @property {number|null} [missionId] CMsgGCCstrike15_v2_ClientRequestNewMission missionId\n   * @property {number|null} [campaignId] CMsgGCCstrike15_v2_ClientRequestNewMission campaignId\n   */\n\n  /**\n   * Constructs a new CMsgGCCstrike15_v2_ClientRequestNewMission.\n   * @exports CMsgGCCstrike15_v2_ClientRequestNewMission\n   * @classdesc Represents a CMsgGCCstrike15_v2_ClientRequestNewMission.\n   * @implements ICMsgGCCstrike15_v2_ClientRequestNewMission\n   * @constructor\n   * @param {ICMsgGCCstrike15_v2_ClientRequestNewMission=} [properties] Properties to set\n   */\n  function CMsgGCCstrike15_v2_ClientRequestNewMission(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCstrike15_v2_ClientRequestNewMission missionId.\n   * @member {number} missionId\n   * @memberof CMsgGCCstrike15_v2_ClientRequestNewMission\n   * @instance\n   */\n\n\n  CMsgGCCstrike15_v2_ClientRequestNewMission.prototype.missionId = 0;\n  /**\n   * CMsgGCCstrike15_v2_ClientRequestNewMission campaignId.\n   * @member {number} campaignId\n   * @memberof CMsgGCCstrike15_v2_ClientRequestNewMission\n   * @instance\n   */\n\n  CMsgGCCstrike15_v2_ClientRequestNewMission.prototype.campaignId = 0;\n  /**\n   * Decodes a CMsgGCCstrike15_v2_ClientRequestNewMission message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCstrike15_v2_ClientRequestNewMission\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCstrike15_v2_ClientRequestNewMission} CMsgGCCstrike15_v2_ClientRequestNewMission\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCstrike15_v2_ClientRequestNewMission.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCstrike15_v2_ClientRequestNewMission();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 2:\n          message.missionId = reader.uint32();\n          break;\n\n        case 3:\n          message.campaignId = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCstrike15_v2_ClientRequestNewMission;\n})();\n\nexports.CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded = $root.CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded = (() => {\n  /**\n   * Properties of a CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.\n   * @exports ICMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded\n   * @interface ICMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded\n   * @property {Array.<IXpProgressData>|null} [xpProgressData] CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded xpProgressData\n   * @property {number|null} [accountId] CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded accountId\n   * @property {number|null} [currentXp] CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded currentXp\n   * @property {number|null} [currentLevel] CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded currentLevel\n   * @property {number|null} [upgradedDefidx] CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded upgradedDefidx\n   */\n\n  /**\n   * Constructs a new CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.\n   * @exports CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded\n   * @classdesc Represents a CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.\n   * @implements ICMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded\n   * @constructor\n   * @param {ICMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded=} [properties] Properties to set\n   */\n  function CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded(properties) {\n    this.xpProgressData = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded xpProgressData.\n   * @member {Array.<IXpProgressData>} xpProgressData\n   * @memberof CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded\n   * @instance\n   */\n\n\n  CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.prototype.xpProgressData = $util.emptyArray;\n  /**\n   * CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded accountId.\n   * @member {number} accountId\n   * @memberof CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded\n   * @instance\n   */\n\n  CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.prototype.accountId = 0;\n  /**\n   * CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded currentXp.\n   * @member {number} currentXp\n   * @memberof CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded\n   * @instance\n   */\n\n  CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.prototype.currentXp = 0;\n  /**\n   * CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded currentLevel.\n   * @member {number} currentLevel\n   * @memberof CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded\n   * @instance\n   */\n\n  CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.prototype.currentLevel = 0;\n  /**\n   * CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded upgradedDefidx.\n   * @member {number} upgradedDefidx\n   * @memberof CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded\n   * @instance\n   */\n\n  CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.prototype.upgradedDefidx = 0;\n  /**\n   * Decodes a CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded} CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.xpProgressData && message.xpProgressData.length)) message.xpProgressData = [];\n          message.xpProgressData.push($root.XpProgressData.decode(reader, reader.uint32()));\n          break;\n\n        case 2:\n          message.accountId = reader.uint32();\n          break;\n\n        case 3:\n          message.currentXp = reader.uint32();\n          break;\n\n        case 4:\n          message.currentLevel = reader.uint32();\n          break;\n\n        case 5:\n          message.upgradedDefidx = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded;\n})();\n\nexports.CMsgGCCStrike15_v2_WatchInfoUsers = $root.CMsgGCCStrike15_v2_WatchInfoUsers = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_WatchInfoUsers.\n   * @exports ICMsgGCCStrike15_v2_WatchInfoUsers\n   * @interface ICMsgGCCStrike15_v2_WatchInfoUsers\n   * @property {number|null} [requestId] CMsgGCCStrike15_v2_WatchInfoUsers requestId\n   * @property {Array.<number>|null} [accountIds] CMsgGCCStrike15_v2_WatchInfoUsers accountIds\n   * @property {Array.<IWatchableMatchInfo>|null} [watchableMatchInfos] CMsgGCCStrike15_v2_WatchInfoUsers watchableMatchInfos\n   * @property {number|null} [extendedTimeout] CMsgGCCStrike15_v2_WatchInfoUsers extendedTimeout\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_WatchInfoUsers.\n   * @exports CMsgGCCStrike15_v2_WatchInfoUsers\n   * @classdesc Represents a CMsgGCCStrike15_v2_WatchInfoUsers.\n   * @implements ICMsgGCCStrike15_v2_WatchInfoUsers\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_WatchInfoUsers=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_WatchInfoUsers(properties) {\n    this.accountIds = [];\n    this.watchableMatchInfos = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_WatchInfoUsers requestId.\n   * @member {number} requestId\n   * @memberof CMsgGCCStrike15_v2_WatchInfoUsers\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_WatchInfoUsers.prototype.requestId = 0;\n  /**\n   * CMsgGCCStrike15_v2_WatchInfoUsers accountIds.\n   * @member {Array.<number>} accountIds\n   * @memberof CMsgGCCStrike15_v2_WatchInfoUsers\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_WatchInfoUsers.prototype.accountIds = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_WatchInfoUsers watchableMatchInfos.\n   * @member {Array.<IWatchableMatchInfo>} watchableMatchInfos\n   * @memberof CMsgGCCStrike15_v2_WatchInfoUsers\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_WatchInfoUsers.prototype.watchableMatchInfos = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_WatchInfoUsers extendedTimeout.\n   * @member {number} extendedTimeout\n   * @memberof CMsgGCCStrike15_v2_WatchInfoUsers\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_WatchInfoUsers.prototype.extendedTimeout = 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_WatchInfoUsers message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_WatchInfoUsers\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_WatchInfoUsers} CMsgGCCStrike15_v2_WatchInfoUsers\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_WatchInfoUsers.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_WatchInfoUsers();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.requestId = reader.uint32();\n          break;\n\n        case 2:\n          if (!(message.accountIds && message.accountIds.length)) message.accountIds = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.accountIds.push(reader.uint32());\n          } else message.accountIds.push(reader.uint32());\n\n          break;\n\n        case 3:\n          if (!(message.watchableMatchInfos && message.watchableMatchInfos.length)) message.watchableMatchInfos = [];\n          message.watchableMatchInfos.push($root.WatchableMatchInfo.decode(reader, reader.uint32()));\n          break;\n\n        case 5:\n          message.extendedTimeout = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_WatchInfoUsers;\n})();\n\nexports.CMsgGCCStrike15_v2_ClientRequestPlayersProfile = $root.CMsgGCCStrike15_v2_ClientRequestPlayersProfile = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_ClientRequestPlayersProfile.\n   * @exports ICMsgGCCStrike15_v2_ClientRequestPlayersProfile\n   * @interface ICMsgGCCStrike15_v2_ClientRequestPlayersProfile\n   * @property {number|null} [requestId_Deprecated] CMsgGCCStrike15_v2_ClientRequestPlayersProfile requestId_Deprecated\n   * @property {Array.<number>|null} [accountIds_Deprecated] CMsgGCCStrike15_v2_ClientRequestPlayersProfile accountIds_Deprecated\n   * @property {number|null} [accountId] CMsgGCCStrike15_v2_ClientRequestPlayersProfile accountId\n   * @property {number|null} [requestLevel] CMsgGCCStrike15_v2_ClientRequestPlayersProfile requestLevel\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_ClientRequestPlayersProfile.\n   * @exports CMsgGCCStrike15_v2_ClientRequestPlayersProfile\n   * @classdesc Represents a CMsgGCCStrike15_v2_ClientRequestPlayersProfile.\n   * @implements ICMsgGCCStrike15_v2_ClientRequestPlayersProfile\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_ClientRequestPlayersProfile=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_ClientRequestPlayersProfile(properties) {\n    this.accountIds_Deprecated = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_ClientRequestPlayersProfile requestId_Deprecated.\n   * @member {number} requestId_Deprecated\n   * @memberof CMsgGCCStrike15_v2_ClientRequestPlayersProfile\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_ClientRequestPlayersProfile.prototype.requestId_Deprecated = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientRequestPlayersProfile accountIds_Deprecated.\n   * @member {Array.<number>} accountIds_Deprecated\n   * @memberof CMsgGCCStrike15_v2_ClientRequestPlayersProfile\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientRequestPlayersProfile.prototype.accountIds_Deprecated = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_ClientRequestPlayersProfile accountId.\n   * @member {number} accountId\n   * @memberof CMsgGCCStrike15_v2_ClientRequestPlayersProfile\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientRequestPlayersProfile.prototype.accountId = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientRequestPlayersProfile requestLevel.\n   * @member {number} requestLevel\n   * @memberof CMsgGCCStrike15_v2_ClientRequestPlayersProfile\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientRequestPlayersProfile.prototype.requestLevel = 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_ClientRequestPlayersProfile message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_ClientRequestPlayersProfile\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_ClientRequestPlayersProfile} CMsgGCCStrike15_v2_ClientRequestPlayersProfile\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_ClientRequestPlayersProfile.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_ClientRequestPlayersProfile();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.requestId_Deprecated = reader.uint32();\n          break;\n\n        case 2:\n          if (!(message.accountIds_Deprecated && message.accountIds_Deprecated.length)) message.accountIds_Deprecated = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.accountIds_Deprecated.push(reader.uint32());\n          } else message.accountIds_Deprecated.push(reader.uint32());\n\n          break;\n\n        case 3:\n          message.accountId = reader.uint32();\n          break;\n\n        case 4:\n          message.requestLevel = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_ClientRequestPlayersProfile;\n})();\n\nexports.CMsgGCCStrike15_v2_PlayersProfile = $root.CMsgGCCStrike15_v2_PlayersProfile = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_PlayersProfile.\n   * @exports ICMsgGCCStrike15_v2_PlayersProfile\n   * @interface ICMsgGCCStrike15_v2_PlayersProfile\n   * @property {number|null} [requestId] CMsgGCCStrike15_v2_PlayersProfile requestId\n   * @property {Array.<ICMsgGCCStrike15_v2_MatchmakingGC2ClientHello>|null} [accountProfiles] CMsgGCCStrike15_v2_PlayersProfile accountProfiles\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_PlayersProfile.\n   * @exports CMsgGCCStrike15_v2_PlayersProfile\n   * @classdesc Represents a CMsgGCCStrike15_v2_PlayersProfile.\n   * @implements ICMsgGCCStrike15_v2_PlayersProfile\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_PlayersProfile=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_PlayersProfile(properties) {\n    this.accountProfiles = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_PlayersProfile requestId.\n   * @member {number} requestId\n   * @memberof CMsgGCCStrike15_v2_PlayersProfile\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_PlayersProfile.prototype.requestId = 0;\n  /**\n   * CMsgGCCStrike15_v2_PlayersProfile accountProfiles.\n   * @member {Array.<ICMsgGCCStrike15_v2_MatchmakingGC2ClientHello>} accountProfiles\n   * @memberof CMsgGCCStrike15_v2_PlayersProfile\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_PlayersProfile.prototype.accountProfiles = $util.emptyArray;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_PlayersProfile message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_PlayersProfile\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_PlayersProfile} CMsgGCCStrike15_v2_PlayersProfile\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_PlayersProfile.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_PlayersProfile();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.requestId = reader.uint32();\n          break;\n\n        case 2:\n          if (!(message.accountProfiles && message.accountProfiles.length)) message.accountProfiles = [];\n          message.accountProfiles.push($root.CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_PlayersProfile;\n})();\n\nexports.CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate = $root.CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.\n   * @exports ICMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n   * @interface ICMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n   * @property {number|Long|null} [caseid] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate caseid\n   * @property {number|null} [suspectid] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate suspectid\n   * @property {number|null} [fractionid] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate fractionid\n   * @property {number|null} [rptAimbot] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptAimbot\n   * @property {number|null} [rptWallhack] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptWallhack\n   * @property {number|null} [rptSpeedhack] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptSpeedhack\n   * @property {number|null} [rptTeamharm] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptTeamharm\n   * @property {number|null} [reason] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate reason\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.\n   * @exports CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n   * @classdesc Represents a CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.\n   * @implements ICMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate caseid.\n   * @member {number|Long} caseid\n   * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.caseid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate suspectid.\n   * @member {number} suspectid\n   * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.suspectid = 0;\n  /**\n   * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate fractionid.\n   * @member {number} fractionid\n   * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.fractionid = 0;\n  /**\n   * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptAimbot.\n   * @member {number} rptAimbot\n   * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.rptAimbot = 0;\n  /**\n   * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptWallhack.\n   * @member {number} rptWallhack\n   * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.rptWallhack = 0;\n  /**\n   * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptSpeedhack.\n   * @member {number} rptSpeedhack\n   * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.rptSpeedhack = 0;\n  /**\n   * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptTeamharm.\n   * @member {number} rptTeamharm\n   * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.rptTeamharm = 0;\n  /**\n   * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate reason.\n   * @member {number} reason\n   * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.reason = 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate} CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.caseid = reader.uint64();\n          break;\n\n        case 3:\n          message.suspectid = reader.uint32();\n          break;\n\n        case 4:\n          message.fractionid = reader.uint32();\n          break;\n\n        case 5:\n          message.rptAimbot = reader.uint32();\n          break;\n\n        case 6:\n          message.rptWallhack = reader.uint32();\n          break;\n\n        case 7:\n          message.rptSpeedhack = reader.uint32();\n          break;\n\n        case 8:\n          message.rptTeamharm = reader.uint32();\n          break;\n\n        case 9:\n          message.reason = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate;\n})();\n\nexports.CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment = $root.CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.\n   * @exports ICMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n   * @interface ICMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n   * @property {number|Long|null} [caseid] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment caseid\n   * @property {string|null} [caseurl] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment caseurl\n   * @property {number|null} [verdict] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment verdict\n   * @property {number|null} [timestamp] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment timestamp\n   * @property {number|null} [throttleseconds] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment throttleseconds\n   * @property {number|null} [suspectid] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment suspectid\n   * @property {number|null} [fractionid] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment fractionid\n   * @property {number|null} [numrounds] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment numrounds\n   * @property {number|null} [fractionrounds] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment fractionrounds\n   * @property {number|null} [streakconvictions] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment streakconvictions\n   * @property {number|null} [reason] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment reason\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.\n   * @exports CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n   * @classdesc Represents a CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.\n   * @implements ICMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment caseid.\n   * @member {number|Long} caseid\n   * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.caseid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment caseurl.\n   * @member {string} caseurl\n   * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.caseurl = \"\";\n  /**\n   * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment verdict.\n   * @member {number} verdict\n   * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.verdict = 0;\n  /**\n   * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment timestamp.\n   * @member {number} timestamp\n   * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.timestamp = 0;\n  /**\n   * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment throttleseconds.\n   * @member {number} throttleseconds\n   * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.throttleseconds = 0;\n  /**\n   * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment suspectid.\n   * @member {number} suspectid\n   * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.suspectid = 0;\n  /**\n   * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment fractionid.\n   * @member {number} fractionid\n   * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.fractionid = 0;\n  /**\n   * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment numrounds.\n   * @member {number} numrounds\n   * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.numrounds = 0;\n  /**\n   * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment fractionrounds.\n   * @member {number} fractionrounds\n   * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.fractionrounds = 0;\n  /**\n   * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment streakconvictions.\n   * @member {number} streakconvictions\n   * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.streakconvictions = 0;\n  /**\n   * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment reason.\n   * @member {number} reason\n   * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.reason = 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment} CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.caseid = reader.uint64();\n          break;\n\n        case 2:\n          message.caseurl = reader.string();\n          break;\n\n        case 3:\n          message.verdict = reader.uint32();\n          break;\n\n        case 4:\n          message.timestamp = reader.uint32();\n          break;\n\n        case 5:\n          message.throttleseconds = reader.uint32();\n          break;\n\n        case 6:\n          message.suspectid = reader.uint32();\n          break;\n\n        case 7:\n          message.fractionid = reader.uint32();\n          break;\n\n        case 8:\n          message.numrounds = reader.uint32();\n          break;\n\n        case 9:\n          message.fractionrounds = reader.uint32();\n          break;\n\n        case 10:\n          message.streakconvictions = reader.int32();\n          break;\n\n        case 11:\n          message.reason = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment;\n})();\n\nexports.CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus = $root.CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.\n   * @exports ICMsgGCCStrike15_v2_PlayerOverwatchCaseStatus\n   * @interface ICMsgGCCStrike15_v2_PlayerOverwatchCaseStatus\n   * @property {number|Long|null} [caseid] CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus caseid\n   * @property {number|null} [statusid] CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus statusid\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.\n   * @exports CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus\n   * @classdesc Represents a CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.\n   * @implements ICMsgGCCStrike15_v2_PlayerOverwatchCaseStatus\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_PlayerOverwatchCaseStatus=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus caseid.\n   * @member {number|Long} caseid\n   * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.prototype.caseid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus statusid.\n   * @member {number} statusid\n   * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.prototype.statusid = 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus} CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.caseid = reader.uint64();\n          break;\n\n        case 2:\n          message.statusid = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus;\n})();\n\nexports.CClientHeaderOverwatchEvidence = $root.CClientHeaderOverwatchEvidence = (() => {\n  /**\n   * Properties of a CClientHeaderOverwatchEvidence.\n   * @exports ICClientHeaderOverwatchEvidence\n   * @interface ICClientHeaderOverwatchEvidence\n   * @property {number|null} [accountid] CClientHeaderOverwatchEvidence accountid\n   * @property {number|Long|null} [caseid] CClientHeaderOverwatchEvidence caseid\n   */\n\n  /**\n   * Constructs a new CClientHeaderOverwatchEvidence.\n   * @exports CClientHeaderOverwatchEvidence\n   * @classdesc Represents a CClientHeaderOverwatchEvidence.\n   * @implements ICClientHeaderOverwatchEvidence\n   * @constructor\n   * @param {ICClientHeaderOverwatchEvidence=} [properties] Properties to set\n   */\n  function CClientHeaderOverwatchEvidence(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CClientHeaderOverwatchEvidence accountid.\n   * @member {number} accountid\n   * @memberof CClientHeaderOverwatchEvidence\n   * @instance\n   */\n\n\n  CClientHeaderOverwatchEvidence.prototype.accountid = 0;\n  /**\n   * CClientHeaderOverwatchEvidence caseid.\n   * @member {number|Long} caseid\n   * @memberof CClientHeaderOverwatchEvidence\n   * @instance\n   */\n\n  CClientHeaderOverwatchEvidence.prototype.caseid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * Decodes a CClientHeaderOverwatchEvidence message from the specified reader or buffer.\n   * @function decode\n   * @memberof CClientHeaderOverwatchEvidence\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CClientHeaderOverwatchEvidence} CClientHeaderOverwatchEvidence\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CClientHeaderOverwatchEvidence.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CClientHeaderOverwatchEvidence();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.accountid = reader.uint32();\n          break;\n\n        case 2:\n          message.caseid = reader.uint64();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CClientHeaderOverwatchEvidence;\n})();\n\nexports.CMsgGCCStrike15_v2_GC2ClientTextMsg = $root.CMsgGCCStrike15_v2_GC2ClientTextMsg = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_GC2ClientTextMsg.\n   * @exports ICMsgGCCStrike15_v2_GC2ClientTextMsg\n   * @interface ICMsgGCCStrike15_v2_GC2ClientTextMsg\n   * @property {number|null} [id] CMsgGCCStrike15_v2_GC2ClientTextMsg id\n   * @property {number|null} [type] CMsgGCCStrike15_v2_GC2ClientTextMsg type\n   * @property {Uint8Array|null} [payload] CMsgGCCStrike15_v2_GC2ClientTextMsg payload\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_GC2ClientTextMsg.\n   * @exports CMsgGCCStrike15_v2_GC2ClientTextMsg\n   * @classdesc Represents a CMsgGCCStrike15_v2_GC2ClientTextMsg.\n   * @implements ICMsgGCCStrike15_v2_GC2ClientTextMsg\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_GC2ClientTextMsg=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_GC2ClientTextMsg(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_GC2ClientTextMsg id.\n   * @member {number} id\n   * @memberof CMsgGCCStrike15_v2_GC2ClientTextMsg\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_GC2ClientTextMsg.prototype.id = 0;\n  /**\n   * CMsgGCCStrike15_v2_GC2ClientTextMsg type.\n   * @member {number} type\n   * @memberof CMsgGCCStrike15_v2_GC2ClientTextMsg\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_GC2ClientTextMsg.prototype.type = 0;\n  /**\n   * CMsgGCCStrike15_v2_GC2ClientTextMsg payload.\n   * @member {Uint8Array} payload\n   * @memberof CMsgGCCStrike15_v2_GC2ClientTextMsg\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_GC2ClientTextMsg.prototype.payload = $util.newBuffer([]);\n  /**\n   * Decodes a CMsgGCCStrike15_v2_GC2ClientTextMsg message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_GC2ClientTextMsg\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_GC2ClientTextMsg} CMsgGCCStrike15_v2_GC2ClientTextMsg\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_GC2ClientTextMsg.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_GC2ClientTextMsg();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.uint32();\n          break;\n\n        case 2:\n          message.type = reader.uint32();\n          break;\n\n        case 3:\n          message.payload = reader.bytes();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_GC2ClientTextMsg;\n})();\n\nexports.CMsgGCCStrike15_v2_Client2GCTextMsg = $root.CMsgGCCStrike15_v2_Client2GCTextMsg = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_Client2GCTextMsg.\n   * @exports ICMsgGCCStrike15_v2_Client2GCTextMsg\n   * @interface ICMsgGCCStrike15_v2_Client2GCTextMsg\n   * @property {number|null} [id] CMsgGCCStrike15_v2_Client2GCTextMsg id\n   * @property {Array.<Uint8Array>|null} [args] CMsgGCCStrike15_v2_Client2GCTextMsg args\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_Client2GCTextMsg.\n   * @exports CMsgGCCStrike15_v2_Client2GCTextMsg\n   * @classdesc Represents a CMsgGCCStrike15_v2_Client2GCTextMsg.\n   * @implements ICMsgGCCStrike15_v2_Client2GCTextMsg\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_Client2GCTextMsg=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_Client2GCTextMsg(properties) {\n    this.args = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_Client2GCTextMsg id.\n   * @member {number} id\n   * @memberof CMsgGCCStrike15_v2_Client2GCTextMsg\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_Client2GCTextMsg.prototype.id = 0;\n  /**\n   * CMsgGCCStrike15_v2_Client2GCTextMsg args.\n   * @member {Array.<Uint8Array>} args\n   * @memberof CMsgGCCStrike15_v2_Client2GCTextMsg\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_Client2GCTextMsg.prototype.args = $util.emptyArray;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_Client2GCTextMsg message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_Client2GCTextMsg\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_Client2GCTextMsg} CMsgGCCStrike15_v2_Client2GCTextMsg\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_Client2GCTextMsg.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_Client2GCTextMsg();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.uint32();\n          break;\n\n        case 2:\n          if (!(message.args && message.args.length)) message.args = [];\n          message.args.push(reader.bytes());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_Client2GCTextMsg;\n})();\n\nexports.CMsgGCCStrike15_v2_MatchEndRunRewardDrops = $root.CMsgGCCStrike15_v2_MatchEndRunRewardDrops = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_MatchEndRunRewardDrops.\n   * @exports ICMsgGCCStrike15_v2_MatchEndRunRewardDrops\n   * @interface ICMsgGCCStrike15_v2_MatchEndRunRewardDrops\n   * @property {ICMsgGCCStrike15_v2_MatchmakingServerReservationResponse|null} [serverinfo] CMsgGCCStrike15_v2_MatchEndRunRewardDrops serverinfo\n   * @property {ICMsgGC_ServerQuestUpdateData|null} [matchEndQuestData] CMsgGCCStrike15_v2_MatchEndRunRewardDrops matchEndQuestData\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_MatchEndRunRewardDrops.\n   * @exports CMsgGCCStrike15_v2_MatchEndRunRewardDrops\n   * @classdesc Represents a CMsgGCCStrike15_v2_MatchEndRunRewardDrops.\n   * @implements ICMsgGCCStrike15_v2_MatchEndRunRewardDrops\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_MatchEndRunRewardDrops=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_MatchEndRunRewardDrops(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_MatchEndRunRewardDrops serverinfo.\n   * @member {ICMsgGCCStrike15_v2_MatchmakingServerReservationResponse|null|undefined} serverinfo\n   * @memberof CMsgGCCStrike15_v2_MatchEndRunRewardDrops\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_MatchEndRunRewardDrops.prototype.serverinfo = null;\n  /**\n   * CMsgGCCStrike15_v2_MatchEndRunRewardDrops matchEndQuestData.\n   * @member {ICMsgGC_ServerQuestUpdateData|null|undefined} matchEndQuestData\n   * @memberof CMsgGCCStrike15_v2_MatchEndRunRewardDrops\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchEndRunRewardDrops.prototype.matchEndQuestData = null;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_MatchEndRunRewardDrops message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_MatchEndRunRewardDrops\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_MatchEndRunRewardDrops} CMsgGCCStrike15_v2_MatchEndRunRewardDrops\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_MatchEndRunRewardDrops.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_MatchEndRunRewardDrops();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 3:\n          message.serverinfo = $root.CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.decode(reader, reader.uint32());\n          break;\n\n        case 4:\n          message.matchEndQuestData = $root.CMsgGC_ServerQuestUpdateData.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_MatchEndRunRewardDrops;\n})();\n\nexports.CEconItemPreviewDataBlock = $root.CEconItemPreviewDataBlock = (() => {\n  /**\n   * Properties of a CEconItemPreviewDataBlock.\n   * @exports ICEconItemPreviewDataBlock\n   * @interface ICEconItemPreviewDataBlock\n   * @property {number|null} [accountid] CEconItemPreviewDataBlock accountid\n   * @property {number|Long|null} [itemid] CEconItemPreviewDataBlock itemid\n   * @property {number|null} [defindex] CEconItemPreviewDataBlock defindex\n   * @property {number|null} [paintindex] CEconItemPreviewDataBlock paintindex\n   * @property {number|null} [rarity] CEconItemPreviewDataBlock rarity\n   * @property {number|null} [quality] CEconItemPreviewDataBlock quality\n   * @property {number|null} [paintwear] CEconItemPreviewDataBlock paintwear\n   * @property {number|null} [paintseed] CEconItemPreviewDataBlock paintseed\n   * @property {number|null} [killeaterscoretype] CEconItemPreviewDataBlock killeaterscoretype\n   * @property {number|null} [killeatervalue] CEconItemPreviewDataBlock killeatervalue\n   * @property {string|null} [customname] CEconItemPreviewDataBlock customname\n   * @property {Array.<CEconItemPreviewDataBlock.ISticker>|null} [stickers] CEconItemPreviewDataBlock stickers\n   * @property {number|null} [inventory] CEconItemPreviewDataBlock inventory\n   * @property {number|null} [origin] CEconItemPreviewDataBlock origin\n   * @property {number|null} [questid] CEconItemPreviewDataBlock questid\n   * @property {number|null} [dropreason] CEconItemPreviewDataBlock dropreason\n   */\n\n  /**\n   * Constructs a new CEconItemPreviewDataBlock.\n   * @exports CEconItemPreviewDataBlock\n   * @classdesc Represents a CEconItemPreviewDataBlock.\n   * @implements ICEconItemPreviewDataBlock\n   * @constructor\n   * @param {ICEconItemPreviewDataBlock=} [properties] Properties to set\n   */\n  function CEconItemPreviewDataBlock(properties) {\n    this.stickers = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CEconItemPreviewDataBlock accountid.\n   * @member {number} accountid\n   * @memberof CEconItemPreviewDataBlock\n   * @instance\n   */\n\n\n  CEconItemPreviewDataBlock.prototype.accountid = 0;\n  /**\n   * CEconItemPreviewDataBlock itemid.\n   * @member {number|Long} itemid\n   * @memberof CEconItemPreviewDataBlock\n   * @instance\n   */\n\n  CEconItemPreviewDataBlock.prototype.itemid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CEconItemPreviewDataBlock defindex.\n   * @member {number} defindex\n   * @memberof CEconItemPreviewDataBlock\n   * @instance\n   */\n\n  CEconItemPreviewDataBlock.prototype.defindex = 0;\n  /**\n   * CEconItemPreviewDataBlock paintindex.\n   * @member {number} paintindex\n   * @memberof CEconItemPreviewDataBlock\n   * @instance\n   */\n\n  CEconItemPreviewDataBlock.prototype.paintindex = 0;\n  /**\n   * CEconItemPreviewDataBlock rarity.\n   * @member {number} rarity\n   * @memberof CEconItemPreviewDataBlock\n   * @instance\n   */\n\n  CEconItemPreviewDataBlock.prototype.rarity = 0;\n  /**\n   * CEconItemPreviewDataBlock quality.\n   * @member {number} quality\n   * @memberof CEconItemPreviewDataBlock\n   * @instance\n   */\n\n  CEconItemPreviewDataBlock.prototype.quality = 0;\n  /**\n   * CEconItemPreviewDataBlock paintwear.\n   * @member {number} paintwear\n   * @memberof CEconItemPreviewDataBlock\n   * @instance\n   */\n\n  CEconItemPreviewDataBlock.prototype.paintwear = 0;\n  /**\n   * CEconItemPreviewDataBlock paintseed.\n   * @member {number} paintseed\n   * @memberof CEconItemPreviewDataBlock\n   * @instance\n   */\n\n  CEconItemPreviewDataBlock.prototype.paintseed = 0;\n  /**\n   * CEconItemPreviewDataBlock killeaterscoretype.\n   * @member {number} killeaterscoretype\n   * @memberof CEconItemPreviewDataBlock\n   * @instance\n   */\n\n  CEconItemPreviewDataBlock.prototype.killeaterscoretype = 0;\n  /**\n   * CEconItemPreviewDataBlock killeatervalue.\n   * @member {number} killeatervalue\n   * @memberof CEconItemPreviewDataBlock\n   * @instance\n   */\n\n  CEconItemPreviewDataBlock.prototype.killeatervalue = 0;\n  /**\n   * CEconItemPreviewDataBlock customname.\n   * @member {string} customname\n   * @memberof CEconItemPreviewDataBlock\n   * @instance\n   */\n\n  CEconItemPreviewDataBlock.prototype.customname = \"\";\n  /**\n   * CEconItemPreviewDataBlock stickers.\n   * @member {Array.<CEconItemPreviewDataBlock.ISticker>} stickers\n   * @memberof CEconItemPreviewDataBlock\n   * @instance\n   */\n\n  CEconItemPreviewDataBlock.prototype.stickers = $util.emptyArray;\n  /**\n   * CEconItemPreviewDataBlock inventory.\n   * @member {number} inventory\n   * @memberof CEconItemPreviewDataBlock\n   * @instance\n   */\n\n  CEconItemPreviewDataBlock.prototype.inventory = 0;\n  /**\n   * CEconItemPreviewDataBlock origin.\n   * @member {number} origin\n   * @memberof CEconItemPreviewDataBlock\n   * @instance\n   */\n\n  CEconItemPreviewDataBlock.prototype.origin = 0;\n  /**\n   * CEconItemPreviewDataBlock questid.\n   * @member {number} questid\n   * @memberof CEconItemPreviewDataBlock\n   * @instance\n   */\n\n  CEconItemPreviewDataBlock.prototype.questid = 0;\n  /**\n   * CEconItemPreviewDataBlock dropreason.\n   * @member {number} dropreason\n   * @memberof CEconItemPreviewDataBlock\n   * @instance\n   */\n\n  CEconItemPreviewDataBlock.prototype.dropreason = 0;\n  /**\n   * Decodes a CEconItemPreviewDataBlock message from the specified reader or buffer.\n   * @function decode\n   * @memberof CEconItemPreviewDataBlock\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CEconItemPreviewDataBlock} CEconItemPreviewDataBlock\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CEconItemPreviewDataBlock.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CEconItemPreviewDataBlock();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.accountid = reader.uint32();\n          break;\n\n        case 2:\n          message.itemid = reader.uint64();\n          break;\n\n        case 3:\n          message.defindex = reader.uint32();\n          break;\n\n        case 4:\n          message.paintindex = reader.uint32();\n          break;\n\n        case 5:\n          message.rarity = reader.uint32();\n          break;\n\n        case 6:\n          message.quality = reader.uint32();\n          break;\n\n        case 7:\n          message.paintwear = reader.uint32();\n          break;\n\n        case 8:\n          message.paintseed = reader.uint32();\n          break;\n\n        case 9:\n          message.killeaterscoretype = reader.uint32();\n          break;\n\n        case 10:\n          message.killeatervalue = reader.uint32();\n          break;\n\n        case 11:\n          message.customname = reader.string();\n          break;\n\n        case 12:\n          if (!(message.stickers && message.stickers.length)) message.stickers = [];\n          message.stickers.push($root.CEconItemPreviewDataBlock.Sticker.decode(reader, reader.uint32()));\n          break;\n\n        case 13:\n          message.inventory = reader.uint32();\n          break;\n\n        case 14:\n          message.origin = reader.uint32();\n          break;\n\n        case 15:\n          message.questid = reader.uint32();\n          break;\n\n        case 16:\n          message.dropreason = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CEconItemPreviewDataBlock.Sticker = function () {\n    /**\n     * Properties of a Sticker.\n     * @memberof CEconItemPreviewDataBlock\n     * @interface ISticker\n     * @property {number|null} [slot] Sticker slot\n     * @property {number|null} [stickerId] Sticker stickerId\n     * @property {number|null} [wear] Sticker wear\n     * @property {number|null} [scale] Sticker scale\n     * @property {number|null} [rotation] Sticker rotation\n     */\n\n    /**\n     * Constructs a new Sticker.\n     * @memberof CEconItemPreviewDataBlock\n     * @classdesc Represents a Sticker.\n     * @implements ISticker\n     * @constructor\n     * @param {CEconItemPreviewDataBlock.ISticker=} [properties] Properties to set\n     */\n    function Sticker(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Sticker slot.\n     * @member {number} slot\n     * @memberof CEconItemPreviewDataBlock.Sticker\n     * @instance\n     */\n\n\n    Sticker.prototype.slot = 0;\n    /**\n     * Sticker stickerId.\n     * @member {number} stickerId\n     * @memberof CEconItemPreviewDataBlock.Sticker\n     * @instance\n     */\n\n    Sticker.prototype.stickerId = 0;\n    /**\n     * Sticker wear.\n     * @member {number} wear\n     * @memberof CEconItemPreviewDataBlock.Sticker\n     * @instance\n     */\n\n    Sticker.prototype.wear = 0;\n    /**\n     * Sticker scale.\n     * @member {number} scale\n     * @memberof CEconItemPreviewDataBlock.Sticker\n     * @instance\n     */\n\n    Sticker.prototype.scale = 0;\n    /**\n     * Sticker rotation.\n     * @member {number} rotation\n     * @memberof CEconItemPreviewDataBlock.Sticker\n     * @instance\n     */\n\n    Sticker.prototype.rotation = 0;\n    /**\n     * Decodes a Sticker message from the specified reader or buffer.\n     * @function decode\n     * @memberof CEconItemPreviewDataBlock.Sticker\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CEconItemPreviewDataBlock.Sticker} Sticker\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    Sticker.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CEconItemPreviewDataBlock.Sticker();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.slot = reader.uint32();\n            break;\n\n          case 2:\n            message.stickerId = reader.uint32();\n            break;\n\n          case 3:\n            message.wear = reader.float();\n            break;\n\n          case 4:\n            message.scale = reader.float();\n            break;\n\n          case 5:\n            message.rotation = reader.float();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return Sticker;\n  }();\n\n  return CEconItemPreviewDataBlock;\n})();\n\nexports.CMsgGCCStrike15_v2_MatchEndRewardDropsNotification = $root.CMsgGCCStrike15_v2_MatchEndRewardDropsNotification = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_MatchEndRewardDropsNotification.\n   * @exports ICMsgGCCStrike15_v2_MatchEndRewardDropsNotification\n   * @interface ICMsgGCCStrike15_v2_MatchEndRewardDropsNotification\n   * @property {ICEconItemPreviewDataBlock|null} [iteminfo] CMsgGCCStrike15_v2_MatchEndRewardDropsNotification iteminfo\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_MatchEndRewardDropsNotification.\n   * @exports CMsgGCCStrike15_v2_MatchEndRewardDropsNotification\n   * @classdesc Represents a CMsgGCCStrike15_v2_MatchEndRewardDropsNotification.\n   * @implements ICMsgGCCStrike15_v2_MatchEndRewardDropsNotification\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_MatchEndRewardDropsNotification=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_MatchEndRewardDropsNotification(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_MatchEndRewardDropsNotification iteminfo.\n   * @member {ICEconItemPreviewDataBlock|null|undefined} iteminfo\n   * @memberof CMsgGCCStrike15_v2_MatchEndRewardDropsNotification\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_MatchEndRewardDropsNotification.prototype.iteminfo = null;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_MatchEndRewardDropsNotification message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_MatchEndRewardDropsNotification\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_MatchEndRewardDropsNotification} CMsgGCCStrike15_v2_MatchEndRewardDropsNotification\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_MatchEndRewardDropsNotification.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_MatchEndRewardDropsNotification();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 6:\n          message.iteminfo = $root.CEconItemPreviewDataBlock.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_MatchEndRewardDropsNotification;\n})();\n\nexports.CMsgItemAcknowledged = $root.CMsgItemAcknowledged = (() => {\n  /**\n   * Properties of a CMsgItemAcknowledged.\n   * @exports ICMsgItemAcknowledged\n   * @interface ICMsgItemAcknowledged\n   * @property {ICEconItemPreviewDataBlock|null} [iteminfo] CMsgItemAcknowledged iteminfo\n   */\n\n  /**\n   * Constructs a new CMsgItemAcknowledged.\n   * @exports CMsgItemAcknowledged\n   * @classdesc Represents a CMsgItemAcknowledged.\n   * @implements ICMsgItemAcknowledged\n   * @constructor\n   * @param {ICMsgItemAcknowledged=} [properties] Properties to set\n   */\n  function CMsgItemAcknowledged(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgItemAcknowledged iteminfo.\n   * @member {ICEconItemPreviewDataBlock|null|undefined} iteminfo\n   * @memberof CMsgItemAcknowledged\n   * @instance\n   */\n\n\n  CMsgItemAcknowledged.prototype.iteminfo = null;\n  /**\n   * Decodes a CMsgItemAcknowledged message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgItemAcknowledged\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgItemAcknowledged} CMsgItemAcknowledged\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgItemAcknowledged.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgItemAcknowledged();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.iteminfo = $root.CEconItemPreviewDataBlock.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgItemAcknowledged;\n})();\n\nexports.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest = $root.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.\n   * @exports ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest\n   * @interface ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest\n   * @property {number|Long|null} [paramS] CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramS\n   * @property {number|Long|null} [paramA] CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramA\n   * @property {number|Long|null} [paramD] CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramD\n   * @property {number|Long|null} [paramM] CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramM\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.\n   * @exports CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest\n   * @classdesc Represents a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.\n   * @implements ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramS.\n   * @member {number|Long} paramS\n   * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.prototype.paramS = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramA.\n   * @member {number|Long} paramA\n   * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.prototype.paramA = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramD.\n   * @member {number|Long} paramD\n   * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.prototype.paramD = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramM.\n   * @member {number|Long} paramM\n   * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.prototype.paramM = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest} CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.paramS = reader.uint64();\n          break;\n\n        case 2:\n          message.paramA = reader.uint64();\n          break;\n\n        case 3:\n          message.paramD = reader.uint64();\n          break;\n\n        case 4:\n          message.paramM = reader.uint64();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest;\n})();\n\nexports.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse = $root.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse.\n   * @exports ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse\n   * @interface ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse\n   * @property {ICEconItemPreviewDataBlock|null} [iteminfo] CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse iteminfo\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse.\n   * @exports CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse\n   * @classdesc Represents a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse.\n   * @implements ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse iteminfo.\n   * @member {ICEconItemPreviewDataBlock|null|undefined} iteminfo\n   * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse.prototype.iteminfo = null;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse} CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.iteminfo = $root.CEconItemPreviewDataBlock.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse;\n})();\n\nexports.CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification = $root.CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.\n   * @exports ICMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification\n   * @interface ICMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification\n   * @property {number|Long|null} [matchId] CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification matchId\n   * @property {number|null} [defindex] CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification defindex\n   * @property {Array.<number>|null} [accountids] CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification accountids\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.\n   * @exports CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification\n   * @classdesc Represents a CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.\n   * @implements ICMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification(properties) {\n    this.accountids = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification matchId.\n   * @member {number|Long} matchId\n   * @memberof CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.prototype.matchId = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification defindex.\n   * @member {number} defindex\n   * @memberof CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.prototype.defindex = 0;\n  /**\n   * CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification accountids.\n   * @member {Array.<number>} accountids\n   * @memberof CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.prototype.accountids = $util.emptyArray;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification} CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.matchId = reader.uint64();\n          break;\n\n        case 2:\n          message.defindex = reader.uint32();\n          break;\n\n        case 3:\n          if (!(message.accountids && message.accountids.length)) message.accountids = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.accountids.push(reader.uint32());\n          } else message.accountids.push(reader.uint32());\n\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification;\n})();\n\nexports.CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames = $root.CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames.\n   * @exports ICMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames\n   * @interface ICMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames.\n   * @exports CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames\n   * @classdesc Represents a CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames.\n   * @implements ICMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * Decodes a CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames} CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames;\n})();\n\nexports.CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser = $root.CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser.\n   * @exports ICMsgGCCStrike15_v2_MatchListRequestLiveGameForUser\n   * @interface ICMsgGCCStrike15_v2_MatchListRequestLiveGameForUser\n   * @property {number|null} [accountid] CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser accountid\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser.\n   * @exports CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser\n   * @classdesc Represents a CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser.\n   * @implements ICMsgGCCStrike15_v2_MatchListRequestLiveGameForUser\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_MatchListRequestLiveGameForUser=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser accountid.\n   * @member {number} accountid\n   * @memberof CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser.prototype.accountid = 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser} CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.accountid = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser;\n})();\n\nexports.CMsgGCCStrike15_v2_MatchListRequestRecentUserGames = $root.CMsgGCCStrike15_v2_MatchListRequestRecentUserGames = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_MatchListRequestRecentUserGames.\n   * @exports ICMsgGCCStrike15_v2_MatchListRequestRecentUserGames\n   * @interface ICMsgGCCStrike15_v2_MatchListRequestRecentUserGames\n   * @property {number|null} [accountid] CMsgGCCStrike15_v2_MatchListRequestRecentUserGames accountid\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_MatchListRequestRecentUserGames.\n   * @exports CMsgGCCStrike15_v2_MatchListRequestRecentUserGames\n   * @classdesc Represents a CMsgGCCStrike15_v2_MatchListRequestRecentUserGames.\n   * @implements ICMsgGCCStrike15_v2_MatchListRequestRecentUserGames\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_MatchListRequestRecentUserGames=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_MatchListRequestRecentUserGames(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_MatchListRequestRecentUserGames accountid.\n   * @member {number} accountid\n   * @memberof CMsgGCCStrike15_v2_MatchListRequestRecentUserGames\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_MatchListRequestRecentUserGames.prototype.accountid = 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_MatchListRequestRecentUserGames message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_MatchListRequestRecentUserGames\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_MatchListRequestRecentUserGames} CMsgGCCStrike15_v2_MatchListRequestRecentUserGames\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_MatchListRequestRecentUserGames.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_MatchListRequestRecentUserGames();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.accountid = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_MatchListRequestRecentUserGames;\n})();\n\nexports.CMsgGCCStrike15_v2_MatchListRequestTournamentGames = $root.CMsgGCCStrike15_v2_MatchListRequestTournamentGames = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_MatchListRequestTournamentGames.\n   * @exports ICMsgGCCStrike15_v2_MatchListRequestTournamentGames\n   * @interface ICMsgGCCStrike15_v2_MatchListRequestTournamentGames\n   * @property {number|null} [eventid] CMsgGCCStrike15_v2_MatchListRequestTournamentGames eventid\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_MatchListRequestTournamentGames.\n   * @exports CMsgGCCStrike15_v2_MatchListRequestTournamentGames\n   * @classdesc Represents a CMsgGCCStrike15_v2_MatchListRequestTournamentGames.\n   * @implements ICMsgGCCStrike15_v2_MatchListRequestTournamentGames\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_MatchListRequestTournamentGames=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_MatchListRequestTournamentGames(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_MatchListRequestTournamentGames eventid.\n   * @member {number} eventid\n   * @memberof CMsgGCCStrike15_v2_MatchListRequestTournamentGames\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_MatchListRequestTournamentGames.prototype.eventid = 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_MatchListRequestTournamentGames message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_MatchListRequestTournamentGames\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_MatchListRequestTournamentGames} CMsgGCCStrike15_v2_MatchListRequestTournamentGames\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_MatchListRequestTournamentGames.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_MatchListRequestTournamentGames();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.eventid = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_MatchListRequestTournamentGames;\n})();\n\nexports.CMsgGCCStrike15_v2_MatchListRequestFullGameInfo = $root.CMsgGCCStrike15_v2_MatchListRequestFullGameInfo = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.\n   * @exports ICMsgGCCStrike15_v2_MatchListRequestFullGameInfo\n   * @interface ICMsgGCCStrike15_v2_MatchListRequestFullGameInfo\n   * @property {number|Long|null} [matchid] CMsgGCCStrike15_v2_MatchListRequestFullGameInfo matchid\n   * @property {number|Long|null} [outcomeid] CMsgGCCStrike15_v2_MatchListRequestFullGameInfo outcomeid\n   * @property {number|null} [token] CMsgGCCStrike15_v2_MatchListRequestFullGameInfo token\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.\n   * @exports CMsgGCCStrike15_v2_MatchListRequestFullGameInfo\n   * @classdesc Represents a CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.\n   * @implements ICMsgGCCStrike15_v2_MatchListRequestFullGameInfo\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_MatchListRequestFullGameInfo=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_MatchListRequestFullGameInfo(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_MatchListRequestFullGameInfo matchid.\n   * @member {number|Long} matchid\n   * @memberof CMsgGCCStrike15_v2_MatchListRequestFullGameInfo\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.prototype.matchid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchListRequestFullGameInfo outcomeid.\n   * @member {number|Long} outcomeid\n   * @memberof CMsgGCCStrike15_v2_MatchListRequestFullGameInfo\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.prototype.outcomeid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchListRequestFullGameInfo token.\n   * @member {number} token\n   * @memberof CMsgGCCStrike15_v2_MatchListRequestFullGameInfo\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.prototype.token = 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_MatchListRequestFullGameInfo message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_MatchListRequestFullGameInfo\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_MatchListRequestFullGameInfo} CMsgGCCStrike15_v2_MatchListRequestFullGameInfo\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_MatchListRequestFullGameInfo();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.matchid = reader.uint64();\n          break;\n\n        case 2:\n          message.outcomeid = reader.uint64();\n          break;\n\n        case 3:\n          message.token = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_MatchListRequestFullGameInfo;\n})();\n\nexports.CDataGCCStrike15_v2_MatchInfo = $root.CDataGCCStrike15_v2_MatchInfo = (() => {\n  /**\n   * Properties of a CDataGCCStrike15_v2_MatchInfo.\n   * @exports ICDataGCCStrike15_v2_MatchInfo\n   * @interface ICDataGCCStrike15_v2_MatchInfo\n   * @property {number|Long|null} [matchid] CDataGCCStrike15_v2_MatchInfo matchid\n   * @property {number|null} [matchtime] CDataGCCStrike15_v2_MatchInfo matchtime\n   * @property {IWatchableMatchInfo|null} [watchablematchinfo] CDataGCCStrike15_v2_MatchInfo watchablematchinfo\n   * @property {ICMsgGCCStrike15_v2_MatchmakingServerRoundStats|null} [roundstatsLegacy] CDataGCCStrike15_v2_MatchInfo roundstatsLegacy\n   * @property {Array.<ICMsgGCCStrike15_v2_MatchmakingServerRoundStats>|null} [roundstatsall] CDataGCCStrike15_v2_MatchInfo roundstatsall\n   */\n\n  /**\n   * Constructs a new CDataGCCStrike15_v2_MatchInfo.\n   * @exports CDataGCCStrike15_v2_MatchInfo\n   * @classdesc Represents a CDataGCCStrike15_v2_MatchInfo.\n   * @implements ICDataGCCStrike15_v2_MatchInfo\n   * @constructor\n   * @param {ICDataGCCStrike15_v2_MatchInfo=} [properties] Properties to set\n   */\n  function CDataGCCStrike15_v2_MatchInfo(properties) {\n    this.roundstatsall = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CDataGCCStrike15_v2_MatchInfo matchid.\n   * @member {number|Long} matchid\n   * @memberof CDataGCCStrike15_v2_MatchInfo\n   * @instance\n   */\n\n\n  CDataGCCStrike15_v2_MatchInfo.prototype.matchid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CDataGCCStrike15_v2_MatchInfo matchtime.\n   * @member {number} matchtime\n   * @memberof CDataGCCStrike15_v2_MatchInfo\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_MatchInfo.prototype.matchtime = 0;\n  /**\n   * CDataGCCStrike15_v2_MatchInfo watchablematchinfo.\n   * @member {IWatchableMatchInfo|null|undefined} watchablematchinfo\n   * @memberof CDataGCCStrike15_v2_MatchInfo\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_MatchInfo.prototype.watchablematchinfo = null;\n  /**\n   * CDataGCCStrike15_v2_MatchInfo roundstatsLegacy.\n   * @member {ICMsgGCCStrike15_v2_MatchmakingServerRoundStats|null|undefined} roundstatsLegacy\n   * @memberof CDataGCCStrike15_v2_MatchInfo\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_MatchInfo.prototype.roundstatsLegacy = null;\n  /**\n   * CDataGCCStrike15_v2_MatchInfo roundstatsall.\n   * @member {Array.<ICMsgGCCStrike15_v2_MatchmakingServerRoundStats>} roundstatsall\n   * @memberof CDataGCCStrike15_v2_MatchInfo\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_MatchInfo.prototype.roundstatsall = $util.emptyArray;\n  /**\n   * Decodes a CDataGCCStrike15_v2_MatchInfo message from the specified reader or buffer.\n   * @function decode\n   * @memberof CDataGCCStrike15_v2_MatchInfo\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CDataGCCStrike15_v2_MatchInfo} CDataGCCStrike15_v2_MatchInfo\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CDataGCCStrike15_v2_MatchInfo.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CDataGCCStrike15_v2_MatchInfo();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.matchid = reader.uint64();\n          break;\n\n        case 2:\n          message.matchtime = reader.uint32();\n          break;\n\n        case 3:\n          message.watchablematchinfo = $root.WatchableMatchInfo.decode(reader, reader.uint32());\n          break;\n\n        case 4:\n          message.roundstatsLegacy = $root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats.decode(reader, reader.uint32());\n          break;\n\n        case 5:\n          if (!(message.roundstatsall && message.roundstatsall.length)) message.roundstatsall = [];\n          message.roundstatsall.push($root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CDataGCCStrike15_v2_MatchInfo;\n})();\n\nexports.CDataGCCStrike15_v2_TournamentGroupTeam = $root.CDataGCCStrike15_v2_TournamentGroupTeam = (() => {\n  /**\n   * Properties of a CDataGCCStrike15_v2_TournamentGroupTeam.\n   * @exports ICDataGCCStrike15_v2_TournamentGroupTeam\n   * @interface ICDataGCCStrike15_v2_TournamentGroupTeam\n   * @property {number|null} [teamId] CDataGCCStrike15_v2_TournamentGroupTeam teamId\n   * @property {number|null} [score] CDataGCCStrike15_v2_TournamentGroupTeam score\n   * @property {boolean|null} [correctpick] CDataGCCStrike15_v2_TournamentGroupTeam correctpick\n   */\n\n  /**\n   * Constructs a new CDataGCCStrike15_v2_TournamentGroupTeam.\n   * @exports CDataGCCStrike15_v2_TournamentGroupTeam\n   * @classdesc Represents a CDataGCCStrike15_v2_TournamentGroupTeam.\n   * @implements ICDataGCCStrike15_v2_TournamentGroupTeam\n   * @constructor\n   * @param {ICDataGCCStrike15_v2_TournamentGroupTeam=} [properties] Properties to set\n   */\n  function CDataGCCStrike15_v2_TournamentGroupTeam(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CDataGCCStrike15_v2_TournamentGroupTeam teamId.\n   * @member {number} teamId\n   * @memberof CDataGCCStrike15_v2_TournamentGroupTeam\n   * @instance\n   */\n\n\n  CDataGCCStrike15_v2_TournamentGroupTeam.prototype.teamId = 0;\n  /**\n   * CDataGCCStrike15_v2_TournamentGroupTeam score.\n   * @member {number} score\n   * @memberof CDataGCCStrike15_v2_TournamentGroupTeam\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_TournamentGroupTeam.prototype.score = 0;\n  /**\n   * CDataGCCStrike15_v2_TournamentGroupTeam correctpick.\n   * @member {boolean} correctpick\n   * @memberof CDataGCCStrike15_v2_TournamentGroupTeam\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_TournamentGroupTeam.prototype.correctpick = false;\n  /**\n   * Decodes a CDataGCCStrike15_v2_TournamentGroupTeam message from the specified reader or buffer.\n   * @function decode\n   * @memberof CDataGCCStrike15_v2_TournamentGroupTeam\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CDataGCCStrike15_v2_TournamentGroupTeam} CDataGCCStrike15_v2_TournamentGroupTeam\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CDataGCCStrike15_v2_TournamentGroupTeam.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CDataGCCStrike15_v2_TournamentGroupTeam();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.teamId = reader.int32();\n          break;\n\n        case 2:\n          message.score = reader.int32();\n          break;\n\n        case 3:\n          message.correctpick = reader.bool();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CDataGCCStrike15_v2_TournamentGroupTeam;\n})();\n\nexports.CDataGCCStrike15_v2_TournamentGroup = $root.CDataGCCStrike15_v2_TournamentGroup = (() => {\n  /**\n   * Properties of a CDataGCCStrike15_v2_TournamentGroup.\n   * @exports ICDataGCCStrike15_v2_TournamentGroup\n   * @interface ICDataGCCStrike15_v2_TournamentGroup\n   * @property {number|null} [groupid] CDataGCCStrike15_v2_TournamentGroup groupid\n   * @property {string|null} [name] CDataGCCStrike15_v2_TournamentGroup name\n   * @property {string|null} [desc] CDataGCCStrike15_v2_TournamentGroup desc\n   * @property {number|null} [picks_Deprecated] CDataGCCStrike15_v2_TournamentGroup picks_Deprecated\n   * @property {Array.<ICDataGCCStrike15_v2_TournamentGroupTeam>|null} [teams] CDataGCCStrike15_v2_TournamentGroup teams\n   * @property {Array.<number>|null} [stageIds] CDataGCCStrike15_v2_TournamentGroup stageIds\n   * @property {number|null} [picklockuntiltime] CDataGCCStrike15_v2_TournamentGroup picklockuntiltime\n   * @property {number|null} [pickableteams] CDataGCCStrike15_v2_TournamentGroup pickableteams\n   * @property {number|null} [pointsPerPick] CDataGCCStrike15_v2_TournamentGroup pointsPerPick\n   * @property {Array.<CDataGCCStrike15_v2_TournamentGroup.IPicks>|null} [picks] CDataGCCStrike15_v2_TournamentGroup picks\n   */\n\n  /**\n   * Constructs a new CDataGCCStrike15_v2_TournamentGroup.\n   * @exports CDataGCCStrike15_v2_TournamentGroup\n   * @classdesc Represents a CDataGCCStrike15_v2_TournamentGroup.\n   * @implements ICDataGCCStrike15_v2_TournamentGroup\n   * @constructor\n   * @param {ICDataGCCStrike15_v2_TournamentGroup=} [properties] Properties to set\n   */\n  function CDataGCCStrike15_v2_TournamentGroup(properties) {\n    this.teams = [];\n    this.stageIds = [];\n    this.picks = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CDataGCCStrike15_v2_TournamentGroup groupid.\n   * @member {number} groupid\n   * @memberof CDataGCCStrike15_v2_TournamentGroup\n   * @instance\n   */\n\n\n  CDataGCCStrike15_v2_TournamentGroup.prototype.groupid = 0;\n  /**\n   * CDataGCCStrike15_v2_TournamentGroup name.\n   * @member {string} name\n   * @memberof CDataGCCStrike15_v2_TournamentGroup\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_TournamentGroup.prototype.name = \"\";\n  /**\n   * CDataGCCStrike15_v2_TournamentGroup desc.\n   * @member {string} desc\n   * @memberof CDataGCCStrike15_v2_TournamentGroup\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_TournamentGroup.prototype.desc = \"\";\n  /**\n   * CDataGCCStrike15_v2_TournamentGroup picks_Deprecated.\n   * @member {number} picks_Deprecated\n   * @memberof CDataGCCStrike15_v2_TournamentGroup\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_TournamentGroup.prototype.picks_Deprecated = 0;\n  /**\n   * CDataGCCStrike15_v2_TournamentGroup teams.\n   * @member {Array.<ICDataGCCStrike15_v2_TournamentGroupTeam>} teams\n   * @memberof CDataGCCStrike15_v2_TournamentGroup\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_TournamentGroup.prototype.teams = $util.emptyArray;\n  /**\n   * CDataGCCStrike15_v2_TournamentGroup stageIds.\n   * @member {Array.<number>} stageIds\n   * @memberof CDataGCCStrike15_v2_TournamentGroup\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_TournamentGroup.prototype.stageIds = $util.emptyArray;\n  /**\n   * CDataGCCStrike15_v2_TournamentGroup picklockuntiltime.\n   * @member {number} picklockuntiltime\n   * @memberof CDataGCCStrike15_v2_TournamentGroup\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_TournamentGroup.prototype.picklockuntiltime = 0;\n  /**\n   * CDataGCCStrike15_v2_TournamentGroup pickableteams.\n   * @member {number} pickableteams\n   * @memberof CDataGCCStrike15_v2_TournamentGroup\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_TournamentGroup.prototype.pickableteams = 0;\n  /**\n   * CDataGCCStrike15_v2_TournamentGroup pointsPerPick.\n   * @member {number} pointsPerPick\n   * @memberof CDataGCCStrike15_v2_TournamentGroup\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_TournamentGroup.prototype.pointsPerPick = 0;\n  /**\n   * CDataGCCStrike15_v2_TournamentGroup picks.\n   * @member {Array.<CDataGCCStrike15_v2_TournamentGroup.IPicks>} picks\n   * @memberof CDataGCCStrike15_v2_TournamentGroup\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_TournamentGroup.prototype.picks = $util.emptyArray;\n  /**\n   * Decodes a CDataGCCStrike15_v2_TournamentGroup message from the specified reader or buffer.\n   * @function decode\n   * @memberof CDataGCCStrike15_v2_TournamentGroup\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CDataGCCStrike15_v2_TournamentGroup} CDataGCCStrike15_v2_TournamentGroup\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CDataGCCStrike15_v2_TournamentGroup.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CDataGCCStrike15_v2_TournamentGroup();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.groupid = reader.uint32();\n          break;\n\n        case 2:\n          message.name = reader.string();\n          break;\n\n        case 3:\n          message.desc = reader.string();\n          break;\n\n        case 4:\n          message.picks_Deprecated = reader.uint32();\n          break;\n\n        case 5:\n          if (!(message.teams && message.teams.length)) message.teams = [];\n          message.teams.push($root.CDataGCCStrike15_v2_TournamentGroupTeam.decode(reader, reader.uint32()));\n          break;\n\n        case 6:\n          if (!(message.stageIds && message.stageIds.length)) message.stageIds = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.stageIds.push(reader.int32());\n          } else message.stageIds.push(reader.int32());\n\n          break;\n\n        case 7:\n          message.picklockuntiltime = reader.uint32();\n          break;\n\n        case 8:\n          message.pickableteams = reader.uint32();\n          break;\n\n        case 9:\n          message.pointsPerPick = reader.uint32();\n          break;\n\n        case 10:\n          if (!(message.picks && message.picks.length)) message.picks = [];\n          message.picks.push($root.CDataGCCStrike15_v2_TournamentGroup.Picks.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CDataGCCStrike15_v2_TournamentGroup.Picks = function () {\n    /**\n     * Properties of a Picks.\n     * @memberof CDataGCCStrike15_v2_TournamentGroup\n     * @interface IPicks\n     * @property {Array.<number>|null} [pickids] Picks pickids\n     */\n\n    /**\n     * Constructs a new Picks.\n     * @memberof CDataGCCStrike15_v2_TournamentGroup\n     * @classdesc Represents a Picks.\n     * @implements IPicks\n     * @constructor\n     * @param {CDataGCCStrike15_v2_TournamentGroup.IPicks=} [properties] Properties to set\n     */\n    function Picks(properties) {\n      this.pickids = [];\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Picks pickids.\n     * @member {Array.<number>} pickids\n     * @memberof CDataGCCStrike15_v2_TournamentGroup.Picks\n     * @instance\n     */\n\n\n    Picks.prototype.pickids = $util.emptyArray;\n    /**\n     * Decodes a Picks message from the specified reader or buffer.\n     * @function decode\n     * @memberof CDataGCCStrike15_v2_TournamentGroup.Picks\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CDataGCCStrike15_v2_TournamentGroup.Picks} Picks\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    Picks.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CDataGCCStrike15_v2_TournamentGroup.Picks();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            if (!(message.pickids && message.pickids.length)) message.pickids = [];\n\n            if ((tag & 7) === 2) {\n              let end2 = reader.uint32() + reader.pos;\n\n              while (reader.pos < end2) message.pickids.push(reader.int32());\n            } else message.pickids.push(reader.int32());\n\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return Picks;\n  }();\n\n  return CDataGCCStrike15_v2_TournamentGroup;\n})();\n\nexports.CDataGCCStrike15_v2_TournamentSection = $root.CDataGCCStrike15_v2_TournamentSection = (() => {\n  /**\n   * Properties of a CDataGCCStrike15_v2_TournamentSection.\n   * @exports ICDataGCCStrike15_v2_TournamentSection\n   * @interface ICDataGCCStrike15_v2_TournamentSection\n   * @property {number|null} [sectionid] CDataGCCStrike15_v2_TournamentSection sectionid\n   * @property {string|null} [name] CDataGCCStrike15_v2_TournamentSection name\n   * @property {string|null} [desc] CDataGCCStrike15_v2_TournamentSection desc\n   * @property {Array.<ICDataGCCStrike15_v2_TournamentGroup>|null} [groups] CDataGCCStrike15_v2_TournamentSection groups\n   */\n\n  /**\n   * Constructs a new CDataGCCStrike15_v2_TournamentSection.\n   * @exports CDataGCCStrike15_v2_TournamentSection\n   * @classdesc Represents a CDataGCCStrike15_v2_TournamentSection.\n   * @implements ICDataGCCStrike15_v2_TournamentSection\n   * @constructor\n   * @param {ICDataGCCStrike15_v2_TournamentSection=} [properties] Properties to set\n   */\n  function CDataGCCStrike15_v2_TournamentSection(properties) {\n    this.groups = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CDataGCCStrike15_v2_TournamentSection sectionid.\n   * @member {number} sectionid\n   * @memberof CDataGCCStrike15_v2_TournamentSection\n   * @instance\n   */\n\n\n  CDataGCCStrike15_v2_TournamentSection.prototype.sectionid = 0;\n  /**\n   * CDataGCCStrike15_v2_TournamentSection name.\n   * @member {string} name\n   * @memberof CDataGCCStrike15_v2_TournamentSection\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_TournamentSection.prototype.name = \"\";\n  /**\n   * CDataGCCStrike15_v2_TournamentSection desc.\n   * @member {string} desc\n   * @memberof CDataGCCStrike15_v2_TournamentSection\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_TournamentSection.prototype.desc = \"\";\n  /**\n   * CDataGCCStrike15_v2_TournamentSection groups.\n   * @member {Array.<ICDataGCCStrike15_v2_TournamentGroup>} groups\n   * @memberof CDataGCCStrike15_v2_TournamentSection\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_TournamentSection.prototype.groups = $util.emptyArray;\n  /**\n   * Decodes a CDataGCCStrike15_v2_TournamentSection message from the specified reader or buffer.\n   * @function decode\n   * @memberof CDataGCCStrike15_v2_TournamentSection\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CDataGCCStrike15_v2_TournamentSection} CDataGCCStrike15_v2_TournamentSection\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CDataGCCStrike15_v2_TournamentSection.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CDataGCCStrike15_v2_TournamentSection();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.sectionid = reader.uint32();\n          break;\n\n        case 2:\n          message.name = reader.string();\n          break;\n\n        case 3:\n          message.desc = reader.string();\n          break;\n\n        case 4:\n          if (!(message.groups && message.groups.length)) message.groups = [];\n          message.groups.push($root.CDataGCCStrike15_v2_TournamentGroup.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CDataGCCStrike15_v2_TournamentSection;\n})();\n\nexports.CDataGCCStrike15_v2_TournamentInfo = $root.CDataGCCStrike15_v2_TournamentInfo = (() => {\n  /**\n   * Properties of a CDataGCCStrike15_v2_TournamentInfo.\n   * @exports ICDataGCCStrike15_v2_TournamentInfo\n   * @interface ICDataGCCStrike15_v2_TournamentInfo\n   * @property {Array.<ICDataGCCStrike15_v2_TournamentSection>|null} [sections] CDataGCCStrike15_v2_TournamentInfo sections\n   * @property {ITournamentEvent|null} [tournamentEvent] CDataGCCStrike15_v2_TournamentInfo tournamentEvent\n   * @property {Array.<ITournamentTeam>|null} [tournamentTeams] CDataGCCStrike15_v2_TournamentInfo tournamentTeams\n   */\n\n  /**\n   * Constructs a new CDataGCCStrike15_v2_TournamentInfo.\n   * @exports CDataGCCStrike15_v2_TournamentInfo\n   * @classdesc Represents a CDataGCCStrike15_v2_TournamentInfo.\n   * @implements ICDataGCCStrike15_v2_TournamentInfo\n   * @constructor\n   * @param {ICDataGCCStrike15_v2_TournamentInfo=} [properties] Properties to set\n   */\n  function CDataGCCStrike15_v2_TournamentInfo(properties) {\n    this.sections = [];\n    this.tournamentTeams = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CDataGCCStrike15_v2_TournamentInfo sections.\n   * @member {Array.<ICDataGCCStrike15_v2_TournamentSection>} sections\n   * @memberof CDataGCCStrike15_v2_TournamentInfo\n   * @instance\n   */\n\n\n  CDataGCCStrike15_v2_TournamentInfo.prototype.sections = $util.emptyArray;\n  /**\n   * CDataGCCStrike15_v2_TournamentInfo tournamentEvent.\n   * @member {ITournamentEvent|null|undefined} tournamentEvent\n   * @memberof CDataGCCStrike15_v2_TournamentInfo\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_TournamentInfo.prototype.tournamentEvent = null;\n  /**\n   * CDataGCCStrike15_v2_TournamentInfo tournamentTeams.\n   * @member {Array.<ITournamentTeam>} tournamentTeams\n   * @memberof CDataGCCStrike15_v2_TournamentInfo\n   * @instance\n   */\n\n  CDataGCCStrike15_v2_TournamentInfo.prototype.tournamentTeams = $util.emptyArray;\n  /**\n   * Decodes a CDataGCCStrike15_v2_TournamentInfo message from the specified reader or buffer.\n   * @function decode\n   * @memberof CDataGCCStrike15_v2_TournamentInfo\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CDataGCCStrike15_v2_TournamentInfo} CDataGCCStrike15_v2_TournamentInfo\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CDataGCCStrike15_v2_TournamentInfo.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CDataGCCStrike15_v2_TournamentInfo();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.sections && message.sections.length)) message.sections = [];\n          message.sections.push($root.CDataGCCStrike15_v2_TournamentSection.decode(reader, reader.uint32()));\n          break;\n\n        case 2:\n          message.tournamentEvent = $root.TournamentEvent.decode(reader, reader.uint32());\n          break;\n\n        case 3:\n          if (!(message.tournamentTeams && message.tournamentTeams.length)) message.tournamentTeams = [];\n          message.tournamentTeams.push($root.TournamentTeam.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CDataGCCStrike15_v2_TournamentInfo;\n})();\n\nexports.CMsgGCCStrike15_v2_MatchList = $root.CMsgGCCStrike15_v2_MatchList = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_MatchList.\n   * @exports ICMsgGCCStrike15_v2_MatchList\n   * @interface ICMsgGCCStrike15_v2_MatchList\n   * @property {number|null} [msgrequestid] CMsgGCCStrike15_v2_MatchList msgrequestid\n   * @property {number|null} [accountid] CMsgGCCStrike15_v2_MatchList accountid\n   * @property {number|null} [servertime] CMsgGCCStrike15_v2_MatchList servertime\n   * @property {Array.<ICDataGCCStrike15_v2_MatchInfo>|null} [matches] CMsgGCCStrike15_v2_MatchList matches\n   * @property {Array.<ITournamentTeam>|null} [streams] CMsgGCCStrike15_v2_MatchList streams\n   * @property {ICDataGCCStrike15_v2_TournamentInfo|null} [tournamentinfo] CMsgGCCStrike15_v2_MatchList tournamentinfo\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_MatchList.\n   * @exports CMsgGCCStrike15_v2_MatchList\n   * @classdesc Represents a CMsgGCCStrike15_v2_MatchList.\n   * @implements ICMsgGCCStrike15_v2_MatchList\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_MatchList=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_MatchList(properties) {\n    this.matches = [];\n    this.streams = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_MatchList msgrequestid.\n   * @member {number} msgrequestid\n   * @memberof CMsgGCCStrike15_v2_MatchList\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_MatchList.prototype.msgrequestid = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchList accountid.\n   * @member {number} accountid\n   * @memberof CMsgGCCStrike15_v2_MatchList\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchList.prototype.accountid = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchList servertime.\n   * @member {number} servertime\n   * @memberof CMsgGCCStrike15_v2_MatchList\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchList.prototype.servertime = 0;\n  /**\n   * CMsgGCCStrike15_v2_MatchList matches.\n   * @member {Array.<ICDataGCCStrike15_v2_MatchInfo>} matches\n   * @memberof CMsgGCCStrike15_v2_MatchList\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchList.prototype.matches = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchList streams.\n   * @member {Array.<ITournamentTeam>} streams\n   * @memberof CMsgGCCStrike15_v2_MatchList\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchList.prototype.streams = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_MatchList tournamentinfo.\n   * @member {ICDataGCCStrike15_v2_TournamentInfo|null|undefined} tournamentinfo\n   * @memberof CMsgGCCStrike15_v2_MatchList\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_MatchList.prototype.tournamentinfo = null;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_MatchList message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_MatchList\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_MatchList} CMsgGCCStrike15_v2_MatchList\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_MatchList.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_MatchList();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.msgrequestid = reader.uint32();\n          break;\n\n        case 2:\n          message.accountid = reader.uint32();\n          break;\n\n        case 3:\n          message.servertime = reader.uint32();\n          break;\n\n        case 4:\n          if (!(message.matches && message.matches.length)) message.matches = [];\n          message.matches.push($root.CDataGCCStrike15_v2_MatchInfo.decode(reader, reader.uint32()));\n          break;\n\n        case 5:\n          if (!(message.streams && message.streams.length)) message.streams = [];\n          message.streams.push($root.TournamentTeam.decode(reader, reader.uint32()));\n          break;\n\n        case 6:\n          message.tournamentinfo = $root.CDataGCCStrike15_v2_TournamentInfo.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_MatchList;\n})();\n\nexports.CMsgGCCStrike15_v2_Predictions = $root.CMsgGCCStrike15_v2_Predictions = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_Predictions.\n   * @exports ICMsgGCCStrike15_v2_Predictions\n   * @interface ICMsgGCCStrike15_v2_Predictions\n   * @property {number|null} [eventId] CMsgGCCStrike15_v2_Predictions eventId\n   * @property {Array.<CMsgGCCStrike15_v2_Predictions.IGroupMatchTeamPick>|null} [groupMatchTeamPicks] CMsgGCCStrike15_v2_Predictions groupMatchTeamPicks\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_Predictions.\n   * @exports CMsgGCCStrike15_v2_Predictions\n   * @classdesc Represents a CMsgGCCStrike15_v2_Predictions.\n   * @implements ICMsgGCCStrike15_v2_Predictions\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_Predictions=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_Predictions(properties) {\n    this.groupMatchTeamPicks = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_Predictions eventId.\n   * @member {number} eventId\n   * @memberof CMsgGCCStrike15_v2_Predictions\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_Predictions.prototype.eventId = 0;\n  /**\n   * CMsgGCCStrike15_v2_Predictions groupMatchTeamPicks.\n   * @member {Array.<CMsgGCCStrike15_v2_Predictions.IGroupMatchTeamPick>} groupMatchTeamPicks\n   * @memberof CMsgGCCStrike15_v2_Predictions\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_Predictions.prototype.groupMatchTeamPicks = $util.emptyArray;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_Predictions message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_Predictions\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_Predictions} CMsgGCCStrike15_v2_Predictions\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_Predictions.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_Predictions();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.eventId = reader.uint32();\n          break;\n\n        case 2:\n          if (!(message.groupMatchTeamPicks && message.groupMatchTeamPicks.length)) message.groupMatchTeamPicks = [];\n          message.groupMatchTeamPicks.push($root.CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick = function () {\n    /**\n     * Properties of a GroupMatchTeamPick.\n     * @memberof CMsgGCCStrike15_v2_Predictions\n     * @interface IGroupMatchTeamPick\n     * @property {number|null} [sectionid] GroupMatchTeamPick sectionid\n     * @property {number|null} [groupid] GroupMatchTeamPick groupid\n     * @property {number|null} [index] GroupMatchTeamPick index\n     * @property {number|null} [teamid] GroupMatchTeamPick teamid\n     * @property {number|Long|null} [itemid] GroupMatchTeamPick itemid\n     */\n\n    /**\n     * Constructs a new GroupMatchTeamPick.\n     * @memberof CMsgGCCStrike15_v2_Predictions\n     * @classdesc Represents a GroupMatchTeamPick.\n     * @implements IGroupMatchTeamPick\n     * @constructor\n     * @param {CMsgGCCStrike15_v2_Predictions.IGroupMatchTeamPick=} [properties] Properties to set\n     */\n    function GroupMatchTeamPick(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * GroupMatchTeamPick sectionid.\n     * @member {number} sectionid\n     * @memberof CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick\n     * @instance\n     */\n\n\n    GroupMatchTeamPick.prototype.sectionid = 0;\n    /**\n     * GroupMatchTeamPick groupid.\n     * @member {number} groupid\n     * @memberof CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick\n     * @instance\n     */\n\n    GroupMatchTeamPick.prototype.groupid = 0;\n    /**\n     * GroupMatchTeamPick index.\n     * @member {number} index\n     * @memberof CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick\n     * @instance\n     */\n\n    GroupMatchTeamPick.prototype.index = 0;\n    /**\n     * GroupMatchTeamPick teamid.\n     * @member {number} teamid\n     * @memberof CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick\n     * @instance\n     */\n\n    GroupMatchTeamPick.prototype.teamid = 0;\n    /**\n     * GroupMatchTeamPick itemid.\n     * @member {number|Long} itemid\n     * @memberof CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick\n     * @instance\n     */\n\n    GroupMatchTeamPick.prototype.itemid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n    /**\n     * Decodes a GroupMatchTeamPick message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick} GroupMatchTeamPick\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    GroupMatchTeamPick.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.sectionid = reader.int32();\n            break;\n\n          case 2:\n            message.groupid = reader.int32();\n            break;\n\n          case 3:\n            message.index = reader.int32();\n            break;\n\n          case 4:\n            message.teamid = reader.int32();\n            break;\n\n          case 5:\n            message.itemid = reader.uint64();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return GroupMatchTeamPick;\n  }();\n\n  return CMsgGCCStrike15_v2_Predictions;\n})();\n\nexports.CMsgGCCStrike15_v2_Fantasy = $root.CMsgGCCStrike15_v2_Fantasy = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_Fantasy.\n   * @exports ICMsgGCCStrike15_v2_Fantasy\n   * @interface ICMsgGCCStrike15_v2_Fantasy\n   * @property {number|null} [eventId] CMsgGCCStrike15_v2_Fantasy eventId\n   * @property {Array.<CMsgGCCStrike15_v2_Fantasy.IFantasyTeam>|null} [teams] CMsgGCCStrike15_v2_Fantasy teams\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_Fantasy.\n   * @exports CMsgGCCStrike15_v2_Fantasy\n   * @classdesc Represents a CMsgGCCStrike15_v2_Fantasy.\n   * @implements ICMsgGCCStrike15_v2_Fantasy\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_Fantasy=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_Fantasy(properties) {\n    this.teams = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_Fantasy eventId.\n   * @member {number} eventId\n   * @memberof CMsgGCCStrike15_v2_Fantasy\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_Fantasy.prototype.eventId = 0;\n  /**\n   * CMsgGCCStrike15_v2_Fantasy teams.\n   * @member {Array.<CMsgGCCStrike15_v2_Fantasy.IFantasyTeam>} teams\n   * @memberof CMsgGCCStrike15_v2_Fantasy\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_Fantasy.prototype.teams = $util.emptyArray;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_Fantasy message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_Fantasy\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_Fantasy} CMsgGCCStrike15_v2_Fantasy\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_Fantasy.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_Fantasy();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.eventId = reader.uint32();\n          break;\n\n        case 2:\n          if (!(message.teams && message.teams.length)) message.teams = [];\n          message.teams.push($root.CMsgGCCStrike15_v2_Fantasy.FantasyTeam.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CMsgGCCStrike15_v2_Fantasy.FantasySlot = function () {\n    /**\n     * Properties of a FantasySlot.\n     * @memberof CMsgGCCStrike15_v2_Fantasy\n     * @interface IFantasySlot\n     * @property {number|null} [type] FantasySlot type\n     * @property {number|null} [pick] FantasySlot pick\n     * @property {number|Long|null} [itemid] FantasySlot itemid\n     */\n\n    /**\n     * Constructs a new FantasySlot.\n     * @memberof CMsgGCCStrike15_v2_Fantasy\n     * @classdesc Represents a FantasySlot.\n     * @implements IFantasySlot\n     * @constructor\n     * @param {CMsgGCCStrike15_v2_Fantasy.IFantasySlot=} [properties] Properties to set\n     */\n    function FantasySlot(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * FantasySlot type.\n     * @member {number} type\n     * @memberof CMsgGCCStrike15_v2_Fantasy.FantasySlot\n     * @instance\n     */\n\n\n    FantasySlot.prototype.type = 0;\n    /**\n     * FantasySlot pick.\n     * @member {number} pick\n     * @memberof CMsgGCCStrike15_v2_Fantasy.FantasySlot\n     * @instance\n     */\n\n    FantasySlot.prototype.pick = 0;\n    /**\n     * FantasySlot itemid.\n     * @member {number|Long} itemid\n     * @memberof CMsgGCCStrike15_v2_Fantasy.FantasySlot\n     * @instance\n     */\n\n    FantasySlot.prototype.itemid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n    /**\n     * Decodes a FantasySlot message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_Fantasy.FantasySlot\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_Fantasy.FantasySlot} FantasySlot\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    FantasySlot.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CMsgGCCStrike15_v2_Fantasy.FantasySlot();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.type = reader.int32();\n            break;\n\n          case 2:\n            message.pick = reader.int32();\n            break;\n\n          case 3:\n            message.itemid = reader.uint64();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return FantasySlot;\n  }();\n\n  CMsgGCCStrike15_v2_Fantasy.FantasyTeam = function () {\n    /**\n     * Properties of a FantasyTeam.\n     * @memberof CMsgGCCStrike15_v2_Fantasy\n     * @interface IFantasyTeam\n     * @property {number|null} [sectionid] FantasyTeam sectionid\n     * @property {Array.<CMsgGCCStrike15_v2_Fantasy.IFantasySlot>|null} [slots] FantasyTeam slots\n     */\n\n    /**\n     * Constructs a new FantasyTeam.\n     * @memberof CMsgGCCStrike15_v2_Fantasy\n     * @classdesc Represents a FantasyTeam.\n     * @implements IFantasyTeam\n     * @constructor\n     * @param {CMsgGCCStrike15_v2_Fantasy.IFantasyTeam=} [properties] Properties to set\n     */\n    function FantasyTeam(properties) {\n      this.slots = [];\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * FantasyTeam sectionid.\n     * @member {number} sectionid\n     * @memberof CMsgGCCStrike15_v2_Fantasy.FantasyTeam\n     * @instance\n     */\n\n\n    FantasyTeam.prototype.sectionid = 0;\n    /**\n     * FantasyTeam slots.\n     * @member {Array.<CMsgGCCStrike15_v2_Fantasy.IFantasySlot>} slots\n     * @memberof CMsgGCCStrike15_v2_Fantasy.FantasyTeam\n     * @instance\n     */\n\n    FantasyTeam.prototype.slots = $util.emptyArray;\n    /**\n     * Decodes a FantasyTeam message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_Fantasy.FantasyTeam\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_Fantasy.FantasyTeam} FantasyTeam\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    FantasyTeam.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CMsgGCCStrike15_v2_Fantasy.FantasyTeam();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.sectionid = reader.int32();\n            break;\n\n          case 2:\n            if (!(message.slots && message.slots.length)) message.slots = [];\n            message.slots.push($root.CMsgGCCStrike15_v2_Fantasy.FantasySlot.decode(reader, reader.uint32()));\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return FantasyTeam;\n  }();\n\n  return CMsgGCCStrike15_v2_Fantasy;\n})();\n\nexports.CAttribute_String = $root.CAttribute_String = (() => {\n  /**\n   * Properties of a CAttribute_String.\n   * @exports ICAttribute_String\n   * @interface ICAttribute_String\n   * @property {string|null} [value] CAttribute_String value\n   */\n\n  /**\n   * Constructs a new CAttribute_String.\n   * @exports CAttribute_String\n   * @classdesc Represents a CAttribute_String.\n   * @implements ICAttribute_String\n   * @constructor\n   * @param {ICAttribute_String=} [properties] Properties to set\n   */\n  function CAttribute_String(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CAttribute_String value.\n   * @member {string} value\n   * @memberof CAttribute_String\n   * @instance\n   */\n\n\n  CAttribute_String.prototype.value = \"\";\n  /**\n   * Decodes a CAttribute_String message from the specified reader or buffer.\n   * @function decode\n   * @memberof CAttribute_String\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CAttribute_String} CAttribute_String\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CAttribute_String.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CAttribute_String();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.value = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CAttribute_String;\n})();\n\nexports.CMsgGCToGCReloadVersions = $root.CMsgGCToGCReloadVersions = (() => {\n  /**\n   * Properties of a CMsgGCToGCReloadVersions.\n   * @exports ICMsgGCToGCReloadVersions\n   * @interface ICMsgGCToGCReloadVersions\n   */\n\n  /**\n   * Constructs a new CMsgGCToGCReloadVersions.\n   * @exports CMsgGCToGCReloadVersions\n   * @classdesc Represents a CMsgGCToGCReloadVersions.\n   * @implements ICMsgGCToGCReloadVersions\n   * @constructor\n   * @param {ICMsgGCToGCReloadVersions=} [properties] Properties to set\n   */\n  function CMsgGCToGCReloadVersions(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * Decodes a CMsgGCToGCReloadVersions message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCToGCReloadVersions\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCToGCReloadVersions} CMsgGCToGCReloadVersions\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  CMsgGCToGCReloadVersions.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCToGCReloadVersions();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCToGCReloadVersions;\n})();\n\nexports.CMsgCStrike15Welcome = $root.CMsgCStrike15Welcome = (() => {\n  /**\n   * Properties of a CMsgCStrike15Welcome.\n   * @exports ICMsgCStrike15Welcome\n   * @interface ICMsgCStrike15Welcome\n   * @property {number|null} [storeItemHash] CMsgCStrike15Welcome storeItemHash\n   * @property {number|null} [timeplayedconsecutively] CMsgCStrike15Welcome timeplayedconsecutively\n   * @property {number|null} [timeFirstPlayed] CMsgCStrike15Welcome timeFirstPlayed\n   * @property {number|null} [lastTimePlayed] CMsgCStrike15Welcome lastTimePlayed\n   * @property {number|null} [lastIpAddress] CMsgCStrike15Welcome lastIpAddress\n   * @property {number|Long|null} [gscookieid] CMsgCStrike15Welcome gscookieid\n   * @property {number|Long|null} [uniqueid] CMsgCStrike15Welcome uniqueid\n   */\n\n  /**\n   * Constructs a new CMsgCStrike15Welcome.\n   * @exports CMsgCStrike15Welcome\n   * @classdesc Represents a CMsgCStrike15Welcome.\n   * @implements ICMsgCStrike15Welcome\n   * @constructor\n   * @param {ICMsgCStrike15Welcome=} [properties] Properties to set\n   */\n  function CMsgCStrike15Welcome(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgCStrike15Welcome storeItemHash.\n   * @member {number} storeItemHash\n   * @memberof CMsgCStrike15Welcome\n   * @instance\n   */\n\n\n  CMsgCStrike15Welcome.prototype.storeItemHash = 0;\n  /**\n   * CMsgCStrike15Welcome timeplayedconsecutively.\n   * @member {number} timeplayedconsecutively\n   * @memberof CMsgCStrike15Welcome\n   * @instance\n   */\n\n  CMsgCStrike15Welcome.prototype.timeplayedconsecutively = 0;\n  /**\n   * CMsgCStrike15Welcome timeFirstPlayed.\n   * @member {number} timeFirstPlayed\n   * @memberof CMsgCStrike15Welcome\n   * @instance\n   */\n\n  CMsgCStrike15Welcome.prototype.timeFirstPlayed = 0;\n  /**\n   * CMsgCStrike15Welcome lastTimePlayed.\n   * @member {number} lastTimePlayed\n   * @memberof CMsgCStrike15Welcome\n   * @instance\n   */\n\n  CMsgCStrike15Welcome.prototype.lastTimePlayed = 0;\n  /**\n   * CMsgCStrike15Welcome lastIpAddress.\n   * @member {number} lastIpAddress\n   * @memberof CMsgCStrike15Welcome\n   * @instance\n   */\n\n  CMsgCStrike15Welcome.prototype.lastIpAddress = 0;\n  /**\n   * CMsgCStrike15Welcome gscookieid.\n   * @member {number|Long} gscookieid\n   * @memberof CMsgCStrike15Welcome\n   * @instance\n   */\n\n  CMsgCStrike15Welcome.prototype.gscookieid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgCStrike15Welcome uniqueid.\n   * @member {number|Long} uniqueid\n   * @memberof CMsgCStrike15Welcome\n   * @instance\n   */\n\n  CMsgCStrike15Welcome.prototype.uniqueid = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * Decodes a CMsgCStrike15Welcome message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgCStrike15Welcome\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgCStrike15Welcome} CMsgCStrike15Welcome\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgCStrike15Welcome.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgCStrike15Welcome();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 5:\n          message.storeItemHash = reader.uint32();\n          break;\n\n        case 6:\n          message.timeplayedconsecutively = reader.uint32();\n          break;\n\n        case 10:\n          message.timeFirstPlayed = reader.uint32();\n          break;\n\n        case 12:\n          message.lastTimePlayed = reader.uint32();\n          break;\n\n        case 13:\n          message.lastIpAddress = reader.uint32();\n          break;\n\n        case 18:\n          message.gscookieid = reader.uint64();\n          break;\n\n        case 19:\n          message.uniqueid = reader.uint64();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgCStrike15Welcome;\n})();\n\nexports.CMsgGCCStrike15_v2_ClientVarValueNotificationInfo = $root.CMsgGCCStrike15_v2_ClientVarValueNotificationInfo = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.\n   * @exports ICMsgGCCStrike15_v2_ClientVarValueNotificationInfo\n   * @interface ICMsgGCCStrike15_v2_ClientVarValueNotificationInfo\n   * @property {string|null} [valueName] CMsgGCCStrike15_v2_ClientVarValueNotificationInfo valueName\n   * @property {number|null} [valueInt] CMsgGCCStrike15_v2_ClientVarValueNotificationInfo valueInt\n   * @property {number|null} [serverAddr] CMsgGCCStrike15_v2_ClientVarValueNotificationInfo serverAddr\n   * @property {number|null} [serverPort] CMsgGCCStrike15_v2_ClientVarValueNotificationInfo serverPort\n   * @property {Array.<string>|null} [chokedBlocks] CMsgGCCStrike15_v2_ClientVarValueNotificationInfo chokedBlocks\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.\n   * @exports CMsgGCCStrike15_v2_ClientVarValueNotificationInfo\n   * @classdesc Represents a CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.\n   * @implements ICMsgGCCStrike15_v2_ClientVarValueNotificationInfo\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_ClientVarValueNotificationInfo=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_ClientVarValueNotificationInfo(properties) {\n    this.chokedBlocks = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_ClientVarValueNotificationInfo valueName.\n   * @member {string} valueName\n   * @memberof CMsgGCCStrike15_v2_ClientVarValueNotificationInfo\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.prototype.valueName = \"\";\n  /**\n   * CMsgGCCStrike15_v2_ClientVarValueNotificationInfo valueInt.\n   * @member {number} valueInt\n   * @memberof CMsgGCCStrike15_v2_ClientVarValueNotificationInfo\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.prototype.valueInt = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientVarValueNotificationInfo serverAddr.\n   * @member {number} serverAddr\n   * @memberof CMsgGCCStrike15_v2_ClientVarValueNotificationInfo\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.prototype.serverAddr = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientVarValueNotificationInfo serverPort.\n   * @member {number} serverPort\n   * @memberof CMsgGCCStrike15_v2_ClientVarValueNotificationInfo\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.prototype.serverPort = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientVarValueNotificationInfo chokedBlocks.\n   * @member {Array.<string>} chokedBlocks\n   * @memberof CMsgGCCStrike15_v2_ClientVarValueNotificationInfo\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.prototype.chokedBlocks = $util.emptyArray;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_ClientVarValueNotificationInfo message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_ClientVarValueNotificationInfo\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_ClientVarValueNotificationInfo} CMsgGCCStrike15_v2_ClientVarValueNotificationInfo\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_ClientVarValueNotificationInfo();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.valueName = reader.string();\n          break;\n\n        case 2:\n          message.valueInt = reader.int32();\n          break;\n\n        case 3:\n          message.serverAddr = reader.uint32();\n          break;\n\n        case 4:\n          message.serverPort = reader.uint32();\n          break;\n\n        case 5:\n          if (!(message.chokedBlocks && message.chokedBlocks.length)) message.chokedBlocks = [];\n          message.chokedBlocks.push(reader.string());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_ClientVarValueNotificationInfo;\n})();\n\nexports.CMsgGCCStrike15_v2_ServerVarValueNotificationInfo = $root.CMsgGCCStrike15_v2_ServerVarValueNotificationInfo = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.\n   * @exports ICMsgGCCStrike15_v2_ServerVarValueNotificationInfo\n   * @interface ICMsgGCCStrike15_v2_ServerVarValueNotificationInfo\n   * @property {number|null} [accountid] CMsgGCCStrike15_v2_ServerVarValueNotificationInfo accountid\n   * @property {Array.<number>|null} [viewangles] CMsgGCCStrike15_v2_ServerVarValueNotificationInfo viewangles\n   * @property {number|null} [type] CMsgGCCStrike15_v2_ServerVarValueNotificationInfo type\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.\n   * @exports CMsgGCCStrike15_v2_ServerVarValueNotificationInfo\n   * @classdesc Represents a CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.\n   * @implements ICMsgGCCStrike15_v2_ServerVarValueNotificationInfo\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_ServerVarValueNotificationInfo=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_ServerVarValueNotificationInfo(properties) {\n    this.viewangles = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_ServerVarValueNotificationInfo accountid.\n   * @member {number} accountid\n   * @memberof CMsgGCCStrike15_v2_ServerVarValueNotificationInfo\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.prototype.accountid = 0;\n  /**\n   * CMsgGCCStrike15_v2_ServerVarValueNotificationInfo viewangles.\n   * @member {Array.<number>} viewangles\n   * @memberof CMsgGCCStrike15_v2_ServerVarValueNotificationInfo\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.prototype.viewangles = $util.emptyArray;\n  /**\n   * CMsgGCCStrike15_v2_ServerVarValueNotificationInfo type.\n   * @member {number} type\n   * @memberof CMsgGCCStrike15_v2_ServerVarValueNotificationInfo\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.prototype.type = 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_ServerVarValueNotificationInfo message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_ServerVarValueNotificationInfo\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_ServerVarValueNotificationInfo} CMsgGCCStrike15_v2_ServerVarValueNotificationInfo\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_ServerVarValueNotificationInfo();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.accountid = reader.uint32();\n          break;\n\n        case 2:\n          if (!(message.viewangles && message.viewangles.length)) message.viewangles = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.viewangles.push(reader.uint32());\n          } else message.viewangles.push(reader.uint32());\n\n          break;\n\n        case 3:\n          message.type = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_ServerVarValueNotificationInfo;\n})();\n\nexports.CMsgGCCStrike15_v2_GiftsLeaderboardRequest = $root.CMsgGCCStrike15_v2_GiftsLeaderboardRequest = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_GiftsLeaderboardRequest.\n   * @exports ICMsgGCCStrike15_v2_GiftsLeaderboardRequest\n   * @interface ICMsgGCCStrike15_v2_GiftsLeaderboardRequest\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_GiftsLeaderboardRequest.\n   * @exports CMsgGCCStrike15_v2_GiftsLeaderboardRequest\n   * @classdesc Represents a CMsgGCCStrike15_v2_GiftsLeaderboardRequest.\n   * @implements ICMsgGCCStrike15_v2_GiftsLeaderboardRequest\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_GiftsLeaderboardRequest=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_GiftsLeaderboardRequest(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * Decodes a CMsgGCCStrike15_v2_GiftsLeaderboardRequest message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardRequest\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_GiftsLeaderboardRequest} CMsgGCCStrike15_v2_GiftsLeaderboardRequest\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  CMsgGCCStrike15_v2_GiftsLeaderboardRequest.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_GiftsLeaderboardRequest();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_GiftsLeaderboardRequest;\n})();\n\nexports.CMsgGCCStrike15_v2_GiftsLeaderboardResponse = $root.CMsgGCCStrike15_v2_GiftsLeaderboardResponse = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_GiftsLeaderboardResponse.\n   * @exports ICMsgGCCStrike15_v2_GiftsLeaderboardResponse\n   * @interface ICMsgGCCStrike15_v2_GiftsLeaderboardResponse\n   * @property {number|null} [servertime] CMsgGCCStrike15_v2_GiftsLeaderboardResponse servertime\n   * @property {number|null} [timePeriodSeconds] CMsgGCCStrike15_v2_GiftsLeaderboardResponse timePeriodSeconds\n   * @property {number|null} [totalGiftsGiven] CMsgGCCStrike15_v2_GiftsLeaderboardResponse totalGiftsGiven\n   * @property {number|null} [totalGivers] CMsgGCCStrike15_v2_GiftsLeaderboardResponse totalGivers\n   * @property {Array.<CMsgGCCStrike15_v2_GiftsLeaderboardResponse.IGiftLeaderboardEntry>|null} [entries] CMsgGCCStrike15_v2_GiftsLeaderboardResponse entries\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_GiftsLeaderboardResponse.\n   * @exports CMsgGCCStrike15_v2_GiftsLeaderboardResponse\n   * @classdesc Represents a CMsgGCCStrike15_v2_GiftsLeaderboardResponse.\n   * @implements ICMsgGCCStrike15_v2_GiftsLeaderboardResponse\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_GiftsLeaderboardResponse=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_GiftsLeaderboardResponse(properties) {\n    this.entries = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_GiftsLeaderboardResponse servertime.\n   * @member {number} servertime\n   * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_GiftsLeaderboardResponse.prototype.servertime = 0;\n  /**\n   * CMsgGCCStrike15_v2_GiftsLeaderboardResponse timePeriodSeconds.\n   * @member {number} timePeriodSeconds\n   * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_GiftsLeaderboardResponse.prototype.timePeriodSeconds = 0;\n  /**\n   * CMsgGCCStrike15_v2_GiftsLeaderboardResponse totalGiftsGiven.\n   * @member {number} totalGiftsGiven\n   * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_GiftsLeaderboardResponse.prototype.totalGiftsGiven = 0;\n  /**\n   * CMsgGCCStrike15_v2_GiftsLeaderboardResponse totalGivers.\n   * @member {number} totalGivers\n   * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_GiftsLeaderboardResponse.prototype.totalGivers = 0;\n  /**\n   * CMsgGCCStrike15_v2_GiftsLeaderboardResponse entries.\n   * @member {Array.<CMsgGCCStrike15_v2_GiftsLeaderboardResponse.IGiftLeaderboardEntry>} entries\n   * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_GiftsLeaderboardResponse.prototype.entries = $util.emptyArray;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_GiftsLeaderboardResponse message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_GiftsLeaderboardResponse} CMsgGCCStrike15_v2_GiftsLeaderboardResponse\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_GiftsLeaderboardResponse.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_GiftsLeaderboardResponse();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.servertime = reader.uint32();\n          break;\n\n        case 2:\n          message.timePeriodSeconds = reader.uint32();\n          break;\n\n        case 3:\n          message.totalGiftsGiven = reader.uint32();\n          break;\n\n        case 4:\n          message.totalGivers = reader.uint32();\n          break;\n\n        case 5:\n          if (!(message.entries && message.entries.length)) message.entries = [];\n          message.entries.push($root.CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry = function () {\n    /**\n     * Properties of a GiftLeaderboardEntry.\n     * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse\n     * @interface IGiftLeaderboardEntry\n     * @property {number|null} [accountid] GiftLeaderboardEntry accountid\n     * @property {number|null} [gifts] GiftLeaderboardEntry gifts\n     */\n\n    /**\n     * Constructs a new GiftLeaderboardEntry.\n     * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse\n     * @classdesc Represents a GiftLeaderboardEntry.\n     * @implements IGiftLeaderboardEntry\n     * @constructor\n     * @param {CMsgGCCStrike15_v2_GiftsLeaderboardResponse.IGiftLeaderboardEntry=} [properties] Properties to set\n     */\n    function GiftLeaderboardEntry(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * GiftLeaderboardEntry accountid.\n     * @member {number} accountid\n     * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry\n     * @instance\n     */\n\n\n    GiftLeaderboardEntry.prototype.accountid = 0;\n    /**\n     * GiftLeaderboardEntry gifts.\n     * @member {number} gifts\n     * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry\n     * @instance\n     */\n\n    GiftLeaderboardEntry.prototype.gifts = 0;\n    /**\n     * Decodes a GiftLeaderboardEntry message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry} GiftLeaderboardEntry\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    GiftLeaderboardEntry.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.accountid = reader.uint32();\n            break;\n\n          case 2:\n            message.gifts = reader.uint32();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return GiftLeaderboardEntry;\n  }();\n\n  return CMsgGCCStrike15_v2_GiftsLeaderboardResponse;\n})();\n\nexports.CMsgGCCStrike15_v2_ClientSubmitSurveyVote = $root.CMsgGCCStrike15_v2_ClientSubmitSurveyVote = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_ClientSubmitSurveyVote.\n   * @exports ICMsgGCCStrike15_v2_ClientSubmitSurveyVote\n   * @interface ICMsgGCCStrike15_v2_ClientSubmitSurveyVote\n   * @property {number|null} [surveyId] CMsgGCCStrike15_v2_ClientSubmitSurveyVote surveyId\n   * @property {number|null} [vote] CMsgGCCStrike15_v2_ClientSubmitSurveyVote vote\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_ClientSubmitSurveyVote.\n   * @exports CMsgGCCStrike15_v2_ClientSubmitSurveyVote\n   * @classdesc Represents a CMsgGCCStrike15_v2_ClientSubmitSurveyVote.\n   * @implements ICMsgGCCStrike15_v2_ClientSubmitSurveyVote\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_ClientSubmitSurveyVote=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_ClientSubmitSurveyVote(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_ClientSubmitSurveyVote surveyId.\n   * @member {number} surveyId\n   * @memberof CMsgGCCStrike15_v2_ClientSubmitSurveyVote\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_ClientSubmitSurveyVote.prototype.surveyId = 0;\n  /**\n   * CMsgGCCStrike15_v2_ClientSubmitSurveyVote vote.\n   * @member {number} vote\n   * @memberof CMsgGCCStrike15_v2_ClientSubmitSurveyVote\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_ClientSubmitSurveyVote.prototype.vote = 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_ClientSubmitSurveyVote message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_ClientSubmitSurveyVote\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_ClientSubmitSurveyVote} CMsgGCCStrike15_v2_ClientSubmitSurveyVote\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_ClientSubmitSurveyVote.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_ClientSubmitSurveyVote();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.surveyId = reader.uint32();\n          break;\n\n        case 2:\n          message.vote = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_ClientSubmitSurveyVote;\n})();\n\nexports.CMsgGCCStrike15_v2_Server2GCClientValidate = $root.CMsgGCCStrike15_v2_Server2GCClientValidate = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_Server2GCClientValidate.\n   * @exports ICMsgGCCStrike15_v2_Server2GCClientValidate\n   * @interface ICMsgGCCStrike15_v2_Server2GCClientValidate\n   * @property {number|null} [accountid] CMsgGCCStrike15_v2_Server2GCClientValidate accountid\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_Server2GCClientValidate.\n   * @exports CMsgGCCStrike15_v2_Server2GCClientValidate\n   * @classdesc Represents a CMsgGCCStrike15_v2_Server2GCClientValidate.\n   * @implements ICMsgGCCStrike15_v2_Server2GCClientValidate\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_Server2GCClientValidate=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_Server2GCClientValidate(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_Server2GCClientValidate accountid.\n   * @member {number} accountid\n   * @memberof CMsgGCCStrike15_v2_Server2GCClientValidate\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_Server2GCClientValidate.prototype.accountid = 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_Server2GCClientValidate message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_Server2GCClientValidate\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_Server2GCClientValidate} CMsgGCCStrike15_v2_Server2GCClientValidate\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_Server2GCClientValidate.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_Server2GCClientValidate();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.accountid = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_Server2GCClientValidate;\n})();\n\nexports.CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure = $root.CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.\n   * @exports ICMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n   * @interface ICMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n   * @property {number|null} [accountid] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure accountid\n   * @property {string|null} [path] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure path\n   * @property {string|null} [file] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure file\n   * @property {number|null} [crc] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure crc\n   * @property {number|null} [hash] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure hash\n   * @property {number|null} [len] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure len\n   * @property {number|null} [packNumber] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure packNumber\n   * @property {number|null} [packFileId] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure packFileId\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.\n   * @exports CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n   * @classdesc Represents a CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.\n   * @implements ICMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_Server2GCPureServerValidationFailure=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure accountid.\n   * @member {number} accountid\n   * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.accountid = 0;\n  /**\n   * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure path.\n   * @member {string} path\n   * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.path = \"\";\n  /**\n   * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure file.\n   * @member {string} file\n   * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.file = \"\";\n  /**\n   * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure crc.\n   * @member {number} crc\n   * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.crc = 0;\n  /**\n   * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure hash.\n   * @member {number} hash\n   * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.hash = 0;\n  /**\n   * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure len.\n   * @member {number} len\n   * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.len = 0;\n  /**\n   * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure packNumber.\n   * @member {number} packNumber\n   * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.packNumber = 0;\n  /**\n   * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure packFileId.\n   * @member {number} packFileId\n   * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.packFileId = 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure} CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.accountid = reader.uint32();\n          break;\n\n        case 2:\n          message.path = reader.string();\n          break;\n\n        case 3:\n          message.file = reader.string();\n          break;\n\n        case 4:\n          message.crc = reader.uint32();\n          break;\n\n        case 5:\n          message.hash = reader.int32();\n          break;\n\n        case 6:\n          message.len = reader.int32();\n          break;\n\n        case 7:\n          message.packNumber = reader.int32();\n          break;\n\n        case 8:\n          message.packFileId = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure;\n})();\n\nexports.CMsgGCCStrike15_v2_GC2ClientTournamentInfo = $root.CMsgGCCStrike15_v2_GC2ClientTournamentInfo = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_GC2ClientTournamentInfo.\n   * @exports ICMsgGCCStrike15_v2_GC2ClientTournamentInfo\n   * @interface ICMsgGCCStrike15_v2_GC2ClientTournamentInfo\n   * @property {number|null} [eventid] CMsgGCCStrike15_v2_GC2ClientTournamentInfo eventid\n   * @property {number|null} [stageid] CMsgGCCStrike15_v2_GC2ClientTournamentInfo stageid\n   * @property {number|null} [gameType] CMsgGCCStrike15_v2_GC2ClientTournamentInfo gameType\n   * @property {Array.<number>|null} [teamids] CMsgGCCStrike15_v2_GC2ClientTournamentInfo teamids\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_GC2ClientTournamentInfo.\n   * @exports CMsgGCCStrike15_v2_GC2ClientTournamentInfo\n   * @classdesc Represents a CMsgGCCStrike15_v2_GC2ClientTournamentInfo.\n   * @implements ICMsgGCCStrike15_v2_GC2ClientTournamentInfo\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_GC2ClientTournamentInfo=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_GC2ClientTournamentInfo(properties) {\n    this.teamids = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_GC2ClientTournamentInfo eventid.\n   * @member {number} eventid\n   * @memberof CMsgGCCStrike15_v2_GC2ClientTournamentInfo\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_GC2ClientTournamentInfo.prototype.eventid = 0;\n  /**\n   * CMsgGCCStrike15_v2_GC2ClientTournamentInfo stageid.\n   * @member {number} stageid\n   * @memberof CMsgGCCStrike15_v2_GC2ClientTournamentInfo\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_GC2ClientTournamentInfo.prototype.stageid = 0;\n  /**\n   * CMsgGCCStrike15_v2_GC2ClientTournamentInfo gameType.\n   * @member {number} gameType\n   * @memberof CMsgGCCStrike15_v2_GC2ClientTournamentInfo\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_GC2ClientTournamentInfo.prototype.gameType = 0;\n  /**\n   * CMsgGCCStrike15_v2_GC2ClientTournamentInfo teamids.\n   * @member {Array.<number>} teamids\n   * @memberof CMsgGCCStrike15_v2_GC2ClientTournamentInfo\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_GC2ClientTournamentInfo.prototype.teamids = $util.emptyArray;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_GC2ClientTournamentInfo message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_GC2ClientTournamentInfo\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_GC2ClientTournamentInfo} CMsgGCCStrike15_v2_GC2ClientTournamentInfo\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_GC2ClientTournamentInfo.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_GC2ClientTournamentInfo();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.eventid = reader.uint32();\n          break;\n\n        case 2:\n          message.stageid = reader.uint32();\n          break;\n\n        case 3:\n          message.gameType = reader.uint32();\n          break;\n\n        case 4:\n          if (!(message.teamids && message.teamids.length)) message.teamids = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.teamids.push(reader.uint32());\n          } else message.teamids.push(reader.uint32());\n\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_GC2ClientTournamentInfo;\n})();\n\nexports.CSOEconCoupon = $root.CSOEconCoupon = (() => {\n  /**\n   * Properties of a CSOEconCoupon.\n   * @exports ICSOEconCoupon\n   * @interface ICSOEconCoupon\n   * @property {number|null} [entryid] CSOEconCoupon entryid\n   * @property {number|null} [defidx] CSOEconCoupon defidx\n   * @property {number|null} [expirationDate] CSOEconCoupon expirationDate\n   */\n\n  /**\n   * Constructs a new CSOEconCoupon.\n   * @exports CSOEconCoupon\n   * @classdesc Represents a CSOEconCoupon.\n   * @implements ICSOEconCoupon\n   * @constructor\n   * @param {ICSOEconCoupon=} [properties] Properties to set\n   */\n  function CSOEconCoupon(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSOEconCoupon entryid.\n   * @member {number} entryid\n   * @memberof CSOEconCoupon\n   * @instance\n   */\n\n\n  CSOEconCoupon.prototype.entryid = 0;\n  /**\n   * CSOEconCoupon defidx.\n   * @member {number} defidx\n   * @memberof CSOEconCoupon\n   * @instance\n   */\n\n  CSOEconCoupon.prototype.defidx = 0;\n  /**\n   * CSOEconCoupon expirationDate.\n   * @member {number} expirationDate\n   * @memberof CSOEconCoupon\n   * @instance\n   */\n\n  CSOEconCoupon.prototype.expirationDate = 0;\n  /**\n   * Decodes a CSOEconCoupon message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSOEconCoupon\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSOEconCoupon} CSOEconCoupon\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSOEconCoupon.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSOEconCoupon();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.entryid = reader.uint32();\n          break;\n\n        case 2:\n          message.defidx = reader.uint32();\n          break;\n\n        case 3:\n          message.expirationDate = reader.fixed32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CSOEconCoupon;\n})();\n\nexports.CSOQuestProgress = $root.CSOQuestProgress = (() => {\n  /**\n   * Properties of a CSOQuestProgress.\n   * @exports ICSOQuestProgress\n   * @interface ICSOQuestProgress\n   * @property {number|null} [questid] CSOQuestProgress questid\n   * @property {number|null} [pointsRemaining] CSOQuestProgress pointsRemaining\n   * @property {number|null} [bonusPoints] CSOQuestProgress bonusPoints\n   */\n\n  /**\n   * Constructs a new CSOQuestProgress.\n   * @exports CSOQuestProgress\n   * @classdesc Represents a CSOQuestProgress.\n   * @implements ICSOQuestProgress\n   * @constructor\n   * @param {ICSOQuestProgress=} [properties] Properties to set\n   */\n  function CSOQuestProgress(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSOQuestProgress questid.\n   * @member {number} questid\n   * @memberof CSOQuestProgress\n   * @instance\n   */\n\n\n  CSOQuestProgress.prototype.questid = 0;\n  /**\n   * CSOQuestProgress pointsRemaining.\n   * @member {number} pointsRemaining\n   * @memberof CSOQuestProgress\n   * @instance\n   */\n\n  CSOQuestProgress.prototype.pointsRemaining = 0;\n  /**\n   * CSOQuestProgress bonusPoints.\n   * @member {number} bonusPoints\n   * @memberof CSOQuestProgress\n   * @instance\n   */\n\n  CSOQuestProgress.prototype.bonusPoints = 0;\n  /**\n   * Decodes a CSOQuestProgress message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSOQuestProgress\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSOQuestProgress} CSOQuestProgress\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSOQuestProgress.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSOQuestProgress();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.questid = reader.uint32();\n          break;\n\n        case 2:\n          message.pointsRemaining = reader.uint32();\n          break;\n\n        case 3:\n          message.bonusPoints = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CSOQuestProgress;\n})();\n\nexports.CSOPersonaDataPublic = $root.CSOPersonaDataPublic = (() => {\n  /**\n   * Properties of a CSOPersonaDataPublic.\n   * @exports ICSOPersonaDataPublic\n   * @interface ICSOPersonaDataPublic\n   * @property {number|null} [playerLevel] CSOPersonaDataPublic playerLevel\n   * @property {IPlayerCommendationInfo|null} [commendation] CSOPersonaDataPublic commendation\n   */\n\n  /**\n   * Constructs a new CSOPersonaDataPublic.\n   * @exports CSOPersonaDataPublic\n   * @classdesc Represents a CSOPersonaDataPublic.\n   * @implements ICSOPersonaDataPublic\n   * @constructor\n   * @param {ICSOPersonaDataPublic=} [properties] Properties to set\n   */\n  function CSOPersonaDataPublic(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CSOPersonaDataPublic playerLevel.\n   * @member {number} playerLevel\n   * @memberof CSOPersonaDataPublic\n   * @instance\n   */\n\n\n  CSOPersonaDataPublic.prototype.playerLevel = 0;\n  /**\n   * CSOPersonaDataPublic commendation.\n   * @member {IPlayerCommendationInfo|null|undefined} commendation\n   * @memberof CSOPersonaDataPublic\n   * @instance\n   */\n\n  CSOPersonaDataPublic.prototype.commendation = null;\n  /**\n   * Decodes a CSOPersonaDataPublic message from the specified reader or buffer.\n   * @function decode\n   * @memberof CSOPersonaDataPublic\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CSOPersonaDataPublic} CSOPersonaDataPublic\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CSOPersonaDataPublic.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CSOPersonaDataPublic();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.playerLevel = reader.int32();\n          break;\n\n        case 2:\n          message.commendation = $root.PlayerCommendationInfo.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CSOPersonaDataPublic;\n})();\n\nexports.CMsgGC_GlobalGame_Subscribe = $root.CMsgGC_GlobalGame_Subscribe = (() => {\n  /**\n   * Properties of a CMsgGC_GlobalGame_Subscribe.\n   * @exports ICMsgGC_GlobalGame_Subscribe\n   * @interface ICMsgGC_GlobalGame_Subscribe\n   * @property {number|Long|null} [ticket] CMsgGC_GlobalGame_Subscribe ticket\n   */\n\n  /**\n   * Constructs a new CMsgGC_GlobalGame_Subscribe.\n   * @exports CMsgGC_GlobalGame_Subscribe\n   * @classdesc Represents a CMsgGC_GlobalGame_Subscribe.\n   * @implements ICMsgGC_GlobalGame_Subscribe\n   * @constructor\n   * @param {ICMsgGC_GlobalGame_Subscribe=} [properties] Properties to set\n   */\n  function CMsgGC_GlobalGame_Subscribe(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGC_GlobalGame_Subscribe ticket.\n   * @member {number|Long} ticket\n   * @memberof CMsgGC_GlobalGame_Subscribe\n   * @instance\n   */\n\n\n  CMsgGC_GlobalGame_Subscribe.prototype.ticket = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * Decodes a CMsgGC_GlobalGame_Subscribe message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGC_GlobalGame_Subscribe\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGC_GlobalGame_Subscribe} CMsgGC_GlobalGame_Subscribe\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGC_GlobalGame_Subscribe.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGC_GlobalGame_Subscribe();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.ticket = reader.uint64();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGC_GlobalGame_Subscribe;\n})();\n\nexports.CMsgGC_GlobalGame_Unsubscribe = $root.CMsgGC_GlobalGame_Unsubscribe = (() => {\n  /**\n   * Properties of a CMsgGC_GlobalGame_Unsubscribe.\n   * @exports ICMsgGC_GlobalGame_Unsubscribe\n   * @interface ICMsgGC_GlobalGame_Unsubscribe\n   * @property {number|null} [timeleft] CMsgGC_GlobalGame_Unsubscribe timeleft\n   */\n\n  /**\n   * Constructs a new CMsgGC_GlobalGame_Unsubscribe.\n   * @exports CMsgGC_GlobalGame_Unsubscribe\n   * @classdesc Represents a CMsgGC_GlobalGame_Unsubscribe.\n   * @implements ICMsgGC_GlobalGame_Unsubscribe\n   * @constructor\n   * @param {ICMsgGC_GlobalGame_Unsubscribe=} [properties] Properties to set\n   */\n  function CMsgGC_GlobalGame_Unsubscribe(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGC_GlobalGame_Unsubscribe timeleft.\n   * @member {number} timeleft\n   * @memberof CMsgGC_GlobalGame_Unsubscribe\n   * @instance\n   */\n\n\n  CMsgGC_GlobalGame_Unsubscribe.prototype.timeleft = 0;\n  /**\n   * Decodes a CMsgGC_GlobalGame_Unsubscribe message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGC_GlobalGame_Unsubscribe\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGC_GlobalGame_Unsubscribe} CMsgGC_GlobalGame_Unsubscribe\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGC_GlobalGame_Unsubscribe.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGC_GlobalGame_Unsubscribe();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.timeleft = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGC_GlobalGame_Unsubscribe;\n})();\n\nexports.CMsgGC_GlobalGame_Play = $root.CMsgGC_GlobalGame_Play = (() => {\n  /**\n   * Properties of a CMsgGC_GlobalGame_Play.\n   * @exports ICMsgGC_GlobalGame_Play\n   * @interface ICMsgGC_GlobalGame_Play\n   * @property {number|Long|null} [ticket] CMsgGC_GlobalGame_Play ticket\n   * @property {number|null} [gametimems] CMsgGC_GlobalGame_Play gametimems\n   * @property {number|null} [msperpoint] CMsgGC_GlobalGame_Play msperpoint\n   */\n\n  /**\n   * Constructs a new CMsgGC_GlobalGame_Play.\n   * @exports CMsgGC_GlobalGame_Play\n   * @classdesc Represents a CMsgGC_GlobalGame_Play.\n   * @implements ICMsgGC_GlobalGame_Play\n   * @constructor\n   * @param {ICMsgGC_GlobalGame_Play=} [properties] Properties to set\n   */\n  function CMsgGC_GlobalGame_Play(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGC_GlobalGame_Play ticket.\n   * @member {number|Long} ticket\n   * @memberof CMsgGC_GlobalGame_Play\n   * @instance\n   */\n\n\n  CMsgGC_GlobalGame_Play.prototype.ticket = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgGC_GlobalGame_Play gametimems.\n   * @member {number} gametimems\n   * @memberof CMsgGC_GlobalGame_Play\n   * @instance\n   */\n\n  CMsgGC_GlobalGame_Play.prototype.gametimems = 0;\n  /**\n   * CMsgGC_GlobalGame_Play msperpoint.\n   * @member {number} msperpoint\n   * @memberof CMsgGC_GlobalGame_Play\n   * @instance\n   */\n\n  CMsgGC_GlobalGame_Play.prototype.msperpoint = 0;\n  /**\n   * Decodes a CMsgGC_GlobalGame_Play message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGC_GlobalGame_Play\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGC_GlobalGame_Play} CMsgGC_GlobalGame_Play\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGC_GlobalGame_Play.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGC_GlobalGame_Play();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.ticket = reader.uint64();\n          break;\n\n        case 2:\n          message.gametimems = reader.uint32();\n          break;\n\n        case 3:\n          message.msperpoint = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGC_GlobalGame_Play;\n})();\n\nexports.CMsgGCCStrike15_v2_AcknowledgePenalty = $root.CMsgGCCStrike15_v2_AcknowledgePenalty = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_AcknowledgePenalty.\n   * @exports ICMsgGCCStrike15_v2_AcknowledgePenalty\n   * @interface ICMsgGCCStrike15_v2_AcknowledgePenalty\n   * @property {number|null} [acknowledged] CMsgGCCStrike15_v2_AcknowledgePenalty acknowledged\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_AcknowledgePenalty.\n   * @exports CMsgGCCStrike15_v2_AcknowledgePenalty\n   * @classdesc Represents a CMsgGCCStrike15_v2_AcknowledgePenalty.\n   * @implements ICMsgGCCStrike15_v2_AcknowledgePenalty\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_AcknowledgePenalty=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_AcknowledgePenalty(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_AcknowledgePenalty acknowledged.\n   * @member {number} acknowledged\n   * @memberof CMsgGCCStrike15_v2_AcknowledgePenalty\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_AcknowledgePenalty.prototype.acknowledged = 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_AcknowledgePenalty message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_AcknowledgePenalty\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_AcknowledgePenalty} CMsgGCCStrike15_v2_AcknowledgePenalty\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_AcknowledgePenalty.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_AcknowledgePenalty();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.acknowledged = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_AcknowledgePenalty;\n})();\n\nexports.CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin = $root.CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin.\n   * @exports ICMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin\n   * @interface ICMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin.\n   * @exports CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin\n   * @classdesc Represents a CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin.\n   * @implements ICMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * Decodes a CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin} CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin;\n})();\n\nexports.CMsgGCCStrike15_v2_Client2GCStreamUnlock = $root.CMsgGCCStrike15_v2_Client2GCStreamUnlock = (() => {\n  /**\n   * Properties of a CMsgGCCStrike15_v2_Client2GCStreamUnlock.\n   * @exports ICMsgGCCStrike15_v2_Client2GCStreamUnlock\n   * @interface ICMsgGCCStrike15_v2_Client2GCStreamUnlock\n   * @property {number|Long|null} [ticket] CMsgGCCStrike15_v2_Client2GCStreamUnlock ticket\n   * @property {number|null} [os] CMsgGCCStrike15_v2_Client2GCStreamUnlock os\n   */\n\n  /**\n   * Constructs a new CMsgGCCStrike15_v2_Client2GCStreamUnlock.\n   * @exports CMsgGCCStrike15_v2_Client2GCStreamUnlock\n   * @classdesc Represents a CMsgGCCStrike15_v2_Client2GCStreamUnlock.\n   * @implements ICMsgGCCStrike15_v2_Client2GCStreamUnlock\n   * @constructor\n   * @param {ICMsgGCCStrike15_v2_Client2GCStreamUnlock=} [properties] Properties to set\n   */\n  function CMsgGCCStrike15_v2_Client2GCStreamUnlock(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCStrike15_v2_Client2GCStreamUnlock ticket.\n   * @member {number|Long} ticket\n   * @memberof CMsgGCCStrike15_v2_Client2GCStreamUnlock\n   * @instance\n   */\n\n\n  CMsgGCCStrike15_v2_Client2GCStreamUnlock.prototype.ticket = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CMsgGCCStrike15_v2_Client2GCStreamUnlock os.\n   * @member {number} os\n   * @memberof CMsgGCCStrike15_v2_Client2GCStreamUnlock\n   * @instance\n   */\n\n  CMsgGCCStrike15_v2_Client2GCStreamUnlock.prototype.os = 0;\n  /**\n   * Decodes a CMsgGCCStrike15_v2_Client2GCStreamUnlock message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCStrike15_v2_Client2GCStreamUnlock\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCStrike15_v2_Client2GCStreamUnlock} CMsgGCCStrike15_v2_Client2GCStreamUnlock\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCStrike15_v2_Client2GCStreamUnlock.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCStrike15_v2_Client2GCStreamUnlock();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.ticket = reader.uint64();\n          break;\n\n        case 2:\n          message.os = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCStrike15_v2_Client2GCStreamUnlock;\n})();\n/**\n * GCProtoBufMsgSrc enum.\n * @exports GCProtoBufMsgSrc\n * @enum {string}\n * @property {number} GCProtoBufMsgSrc_Unspecified=0 GCProtoBufMsgSrc_Unspecified value\n * @property {number} GCProtoBufMsgSrc_FromSystem=1 GCProtoBufMsgSrc_FromSystem value\n * @property {number} GCProtoBufMsgSrc_FromSteamID=2 GCProtoBufMsgSrc_FromSteamID value\n * @property {number} GCProtoBufMsgSrc_FromGC=3 GCProtoBufMsgSrc_FromGC value\n * @property {number} GCProtoBufMsgSrc_ReplySystem=4 GCProtoBufMsgSrc_ReplySystem value\n */\n\n\n$root.GCProtoBufMsgSrc = function () {\n  const valuesById = {},\n        values = Object.create(valuesById);\n  values[valuesById[0] = \"GCProtoBufMsgSrc_Unspecified\"] = 0;\n  values[valuesById[1] = \"GCProtoBufMsgSrc_FromSystem\"] = 1;\n  values[valuesById[2] = \"GCProtoBufMsgSrc_FromSteamID\"] = 2;\n  values[valuesById[3] = \"GCProtoBufMsgSrc_FromGC\"] = 3;\n  values[valuesById[4] = \"GCProtoBufMsgSrc_ReplySystem\"] = 4;\n  return values;\n}();\n\nexports.CMsgProtoBufHeader = $root.CMsgProtoBufHeader = (() => {\n  /**\n   * Properties of a CMsgProtoBufHeader.\n   * @exports ICMsgProtoBufHeader\n   * @interface ICMsgProtoBufHeader\n   * @property {number|Long|null} [clientSteamId] CMsgProtoBufHeader clientSteamId\n   * @property {number|null} [clientSessionId] CMsgProtoBufHeader clientSessionId\n   * @property {number|null} [sourceAppId] CMsgProtoBufHeader sourceAppId\n   * @property {number|Long|null} [jobIdSource] CMsgProtoBufHeader jobIdSource\n   * @property {number|Long|null} [jobIdTarget] CMsgProtoBufHeader jobIdTarget\n   * @property {string|null} [targetJobName] CMsgProtoBufHeader targetJobName\n   * @property {number|null} [eresult] CMsgProtoBufHeader eresult\n   * @property {string|null} [errorMessage] CMsgProtoBufHeader errorMessage\n   * @property {GCProtoBufMsgSrc|null} [gcMsgSrc] CMsgProtoBufHeader gcMsgSrc\n   * @property {number|null} [gcDirIndexSource] CMsgProtoBufHeader gcDirIndexSource\n   */\n\n  /**\n   * Constructs a new CMsgProtoBufHeader.\n   * @exports CMsgProtoBufHeader\n   * @classdesc Represents a CMsgProtoBufHeader.\n   * @implements ICMsgProtoBufHeader\n   * @constructor\n   * @param {ICMsgProtoBufHeader=} [properties] Properties to set\n   */\n  function CMsgProtoBufHeader(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgProtoBufHeader clientSteamId.\n   * @member {number|Long} clientSteamId\n   * @memberof CMsgProtoBufHeader\n   * @instance\n   */\n\n\n  CMsgProtoBufHeader.prototype.clientSteamId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n  /**\n   * CMsgProtoBufHeader clientSessionId.\n   * @member {number} clientSessionId\n   * @memberof CMsgProtoBufHeader\n   * @instance\n   */\n\n  CMsgProtoBufHeader.prototype.clientSessionId = 0;\n  /**\n   * CMsgProtoBufHeader sourceAppId.\n   * @member {number} sourceAppId\n   * @memberof CMsgProtoBufHeader\n   * @instance\n   */\n\n  CMsgProtoBufHeader.prototype.sourceAppId = 0;\n  /**\n   * CMsgProtoBufHeader jobIdSource.\n   * @member {number|Long} jobIdSource\n   * @memberof CMsgProtoBufHeader\n   * @instance\n   */\n\n  CMsgProtoBufHeader.prototype.jobIdSource = $util.Long ? $util.Long.fromBits(-1, 2147483647, false) : 9223372036854776000;\n  /**\n   * CMsgProtoBufHeader jobIdTarget.\n   * @member {number|Long} jobIdTarget\n   * @memberof CMsgProtoBufHeader\n   * @instance\n   */\n\n  CMsgProtoBufHeader.prototype.jobIdTarget = $util.Long ? $util.Long.fromBits(-1, 2147483647, false) : 9223372036854776000;\n  /**\n   * CMsgProtoBufHeader targetJobName.\n   * @member {string} targetJobName\n   * @memberof CMsgProtoBufHeader\n   * @instance\n   */\n\n  CMsgProtoBufHeader.prototype.targetJobName = \"\";\n  /**\n   * CMsgProtoBufHeader eresult.\n   * @member {number} eresult\n   * @memberof CMsgProtoBufHeader\n   * @instance\n   */\n\n  CMsgProtoBufHeader.prototype.eresult = 2;\n  /**\n   * CMsgProtoBufHeader errorMessage.\n   * @member {string} errorMessage\n   * @memberof CMsgProtoBufHeader\n   * @instance\n   */\n\n  CMsgProtoBufHeader.prototype.errorMessage = \"\";\n  /**\n   * CMsgProtoBufHeader gcMsgSrc.\n   * @member {GCProtoBufMsgSrc} gcMsgSrc\n   * @memberof CMsgProtoBufHeader\n   * @instance\n   */\n\n  CMsgProtoBufHeader.prototype.gcMsgSrc = 0;\n  /**\n   * CMsgProtoBufHeader gcDirIndexSource.\n   * @member {number} gcDirIndexSource\n   * @memberof CMsgProtoBufHeader\n   * @instance\n   */\n\n  CMsgProtoBufHeader.prototype.gcDirIndexSource = 0;\n  /**\n   * Decodes a CMsgProtoBufHeader message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgProtoBufHeader\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgProtoBufHeader} CMsgProtoBufHeader\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgProtoBufHeader.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgProtoBufHeader();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.clientSteamId = reader.fixed64();\n          break;\n\n        case 2:\n          message.clientSessionId = reader.int32();\n          break;\n\n        case 3:\n          message.sourceAppId = reader.uint32();\n          break;\n\n        case 10:\n          message.jobIdSource = reader.fixed64();\n          break;\n\n        case 11:\n          message.jobIdTarget = reader.fixed64();\n          break;\n\n        case 12:\n          message.targetJobName = reader.string();\n          break;\n\n        case 13:\n          message.eresult = reader.int32();\n          break;\n\n        case 14:\n          message.errorMessage = reader.string();\n          break;\n\n        case 200:\n          message.gcMsgSrc = reader.int32();\n          break;\n\n        case 201:\n          message.gcDirIndexSource = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgProtoBufHeader;\n})();\n\nexports.CMsgWebAPIKey = $root.CMsgWebAPIKey = (() => {\n  /**\n   * Properties of a CMsgWebAPIKey.\n   * @exports ICMsgWebAPIKey\n   * @interface ICMsgWebAPIKey\n   * @property {number|null} [status] CMsgWebAPIKey status\n   * @property {number|null} [accountId] CMsgWebAPIKey accountId\n   * @property {number|null} [publisherGroupId] CMsgWebAPIKey publisherGroupId\n   * @property {number|null} [keyId] CMsgWebAPIKey keyId\n   * @property {string|null} [domain] CMsgWebAPIKey domain\n   */\n\n  /**\n   * Constructs a new CMsgWebAPIKey.\n   * @exports CMsgWebAPIKey\n   * @classdesc Represents a CMsgWebAPIKey.\n   * @implements ICMsgWebAPIKey\n   * @constructor\n   * @param {ICMsgWebAPIKey=} [properties] Properties to set\n   */\n  function CMsgWebAPIKey(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgWebAPIKey status.\n   * @member {number} status\n   * @memberof CMsgWebAPIKey\n   * @instance\n   */\n\n\n  CMsgWebAPIKey.prototype.status = 255;\n  /**\n   * CMsgWebAPIKey accountId.\n   * @member {number} accountId\n   * @memberof CMsgWebAPIKey\n   * @instance\n   */\n\n  CMsgWebAPIKey.prototype.accountId = 0;\n  /**\n   * CMsgWebAPIKey publisherGroupId.\n   * @member {number} publisherGroupId\n   * @memberof CMsgWebAPIKey\n   * @instance\n   */\n\n  CMsgWebAPIKey.prototype.publisherGroupId = 0;\n  /**\n   * CMsgWebAPIKey keyId.\n   * @member {number} keyId\n   * @memberof CMsgWebAPIKey\n   * @instance\n   */\n\n  CMsgWebAPIKey.prototype.keyId = 0;\n  /**\n   * CMsgWebAPIKey domain.\n   * @member {string} domain\n   * @memberof CMsgWebAPIKey\n   * @instance\n   */\n\n  CMsgWebAPIKey.prototype.domain = \"\";\n  /**\n   * Decodes a CMsgWebAPIKey message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgWebAPIKey\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgWebAPIKey} CMsgWebAPIKey\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgWebAPIKey.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgWebAPIKey();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.status = reader.uint32();\n          break;\n\n        case 2:\n          message.accountId = reader.uint32();\n          break;\n\n        case 3:\n          message.publisherGroupId = reader.uint32();\n          break;\n\n        case 4:\n          message.keyId = reader.uint32();\n          break;\n\n        case 5:\n          message.domain = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgWebAPIKey;\n})();\n\nexports.CMsgHttpRequest = $root.CMsgHttpRequest = (() => {\n  /**\n   * Properties of a CMsgHttpRequest.\n   * @exports ICMsgHttpRequest\n   * @interface ICMsgHttpRequest\n   * @property {number|null} [requestMethod] CMsgHttpRequest requestMethod\n   * @property {string|null} [hostname] CMsgHttpRequest hostname\n   * @property {string|null} [url] CMsgHttpRequest url\n   * @property {Array.<CMsgHttpRequest.IRequestHeader>|null} [headers] CMsgHttpRequest headers\n   * @property {Array.<CMsgHttpRequest.IQueryParam>|null} [getParams] CMsgHttpRequest getParams\n   * @property {Array.<CMsgHttpRequest.IQueryParam>|null} [postParams] CMsgHttpRequest postParams\n   * @property {Uint8Array|null} [body] CMsgHttpRequest body\n   * @property {number|null} [absoluteTimeout] CMsgHttpRequest absoluteTimeout\n   */\n\n  /**\n   * Constructs a new CMsgHttpRequest.\n   * @exports CMsgHttpRequest\n   * @classdesc Represents a CMsgHttpRequest.\n   * @implements ICMsgHttpRequest\n   * @constructor\n   * @param {ICMsgHttpRequest=} [properties] Properties to set\n   */\n  function CMsgHttpRequest(properties) {\n    this.headers = [];\n    this.getParams = [];\n    this.postParams = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgHttpRequest requestMethod.\n   * @member {number} requestMethod\n   * @memberof CMsgHttpRequest\n   * @instance\n   */\n\n\n  CMsgHttpRequest.prototype.requestMethod = 0;\n  /**\n   * CMsgHttpRequest hostname.\n   * @member {string} hostname\n   * @memberof CMsgHttpRequest\n   * @instance\n   */\n\n  CMsgHttpRequest.prototype.hostname = \"\";\n  /**\n   * CMsgHttpRequest url.\n   * @member {string} url\n   * @memberof CMsgHttpRequest\n   * @instance\n   */\n\n  CMsgHttpRequest.prototype.url = \"\";\n  /**\n   * CMsgHttpRequest headers.\n   * @member {Array.<CMsgHttpRequest.IRequestHeader>} headers\n   * @memberof CMsgHttpRequest\n   * @instance\n   */\n\n  CMsgHttpRequest.prototype.headers = $util.emptyArray;\n  /**\n   * CMsgHttpRequest getParams.\n   * @member {Array.<CMsgHttpRequest.IQueryParam>} getParams\n   * @memberof CMsgHttpRequest\n   * @instance\n   */\n\n  CMsgHttpRequest.prototype.getParams = $util.emptyArray;\n  /**\n   * CMsgHttpRequest postParams.\n   * @member {Array.<CMsgHttpRequest.IQueryParam>} postParams\n   * @memberof CMsgHttpRequest\n   * @instance\n   */\n\n  CMsgHttpRequest.prototype.postParams = $util.emptyArray;\n  /**\n   * CMsgHttpRequest body.\n   * @member {Uint8Array} body\n   * @memberof CMsgHttpRequest\n   * @instance\n   */\n\n  CMsgHttpRequest.prototype.body = $util.newBuffer([]);\n  /**\n   * CMsgHttpRequest absoluteTimeout.\n   * @member {number} absoluteTimeout\n   * @memberof CMsgHttpRequest\n   * @instance\n   */\n\n  CMsgHttpRequest.prototype.absoluteTimeout = 0;\n  /**\n   * Decodes a CMsgHttpRequest message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgHttpRequest\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgHttpRequest} CMsgHttpRequest\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgHttpRequest.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgHttpRequest();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.requestMethod = reader.uint32();\n          break;\n\n        case 2:\n          message.hostname = reader.string();\n          break;\n\n        case 3:\n          message.url = reader.string();\n          break;\n\n        case 4:\n          if (!(message.headers && message.headers.length)) message.headers = [];\n          message.headers.push($root.CMsgHttpRequest.RequestHeader.decode(reader, reader.uint32()));\n          break;\n\n        case 5:\n          if (!(message.getParams && message.getParams.length)) message.getParams = [];\n          message.getParams.push($root.CMsgHttpRequest.QueryParam.decode(reader, reader.uint32()));\n          break;\n\n        case 6:\n          if (!(message.postParams && message.postParams.length)) message.postParams = [];\n          message.postParams.push($root.CMsgHttpRequest.QueryParam.decode(reader, reader.uint32()));\n          break;\n\n        case 7:\n          message.body = reader.bytes();\n          break;\n\n        case 8:\n          message.absoluteTimeout = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CMsgHttpRequest.RequestHeader = function () {\n    /**\n     * Properties of a RequestHeader.\n     * @memberof CMsgHttpRequest\n     * @interface IRequestHeader\n     * @property {string|null} [name] RequestHeader name\n     * @property {string|null} [value] RequestHeader value\n     */\n\n    /**\n     * Constructs a new RequestHeader.\n     * @memberof CMsgHttpRequest\n     * @classdesc Represents a RequestHeader.\n     * @implements IRequestHeader\n     * @constructor\n     * @param {CMsgHttpRequest.IRequestHeader=} [properties] Properties to set\n     */\n    function RequestHeader(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * RequestHeader name.\n     * @member {string} name\n     * @memberof CMsgHttpRequest.RequestHeader\n     * @instance\n     */\n\n\n    RequestHeader.prototype.name = \"\";\n    /**\n     * RequestHeader value.\n     * @member {string} value\n     * @memberof CMsgHttpRequest.RequestHeader\n     * @instance\n     */\n\n    RequestHeader.prototype.value = \"\";\n    /**\n     * Decodes a RequestHeader message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgHttpRequest.RequestHeader\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgHttpRequest.RequestHeader} RequestHeader\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    RequestHeader.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CMsgHttpRequest.RequestHeader();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.name = reader.string();\n            break;\n\n          case 2:\n            message.value = reader.string();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return RequestHeader;\n  }();\n\n  CMsgHttpRequest.QueryParam = function () {\n    /**\n     * Properties of a QueryParam.\n     * @memberof CMsgHttpRequest\n     * @interface IQueryParam\n     * @property {string|null} [name] QueryParam name\n     * @property {Uint8Array|null} [value] QueryParam value\n     */\n\n    /**\n     * Constructs a new QueryParam.\n     * @memberof CMsgHttpRequest\n     * @classdesc Represents a QueryParam.\n     * @implements IQueryParam\n     * @constructor\n     * @param {CMsgHttpRequest.IQueryParam=} [properties] Properties to set\n     */\n    function QueryParam(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * QueryParam name.\n     * @member {string} name\n     * @memberof CMsgHttpRequest.QueryParam\n     * @instance\n     */\n\n\n    QueryParam.prototype.name = \"\";\n    /**\n     * QueryParam value.\n     * @member {Uint8Array} value\n     * @memberof CMsgHttpRequest.QueryParam\n     * @instance\n     */\n\n    QueryParam.prototype.value = $util.newBuffer([]);\n    /**\n     * Decodes a QueryParam message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgHttpRequest.QueryParam\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgHttpRequest.QueryParam} QueryParam\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    QueryParam.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CMsgHttpRequest.QueryParam();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.name = reader.string();\n            break;\n\n          case 2:\n            message.value = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return QueryParam;\n  }();\n\n  return CMsgHttpRequest;\n})();\n\nexports.CMsgWebAPIRequest = $root.CMsgWebAPIRequest = (() => {\n  /**\n   * Properties of a CMsgWebAPIRequest.\n   * @exports ICMsgWebAPIRequest\n   * @interface ICMsgWebAPIRequest\n   * @property {string|null} [UNUSEDJobName] CMsgWebAPIRequest UNUSEDJobName\n   * @property {string|null} [interfaceName] CMsgWebAPIRequest interfaceName\n   * @property {string|null} [methodName] CMsgWebAPIRequest methodName\n   * @property {number|null} [version] CMsgWebAPIRequest version\n   * @property {ICMsgWebAPIKey|null} [apiKey] CMsgWebAPIRequest apiKey\n   * @property {ICMsgHttpRequest|null} [request] CMsgWebAPIRequest request\n   * @property {number|null} [routingAppId] CMsgWebAPIRequest routingAppId\n   */\n\n  /**\n   * Constructs a new CMsgWebAPIRequest.\n   * @exports CMsgWebAPIRequest\n   * @classdesc Represents a CMsgWebAPIRequest.\n   * @implements ICMsgWebAPIRequest\n   * @constructor\n   * @param {ICMsgWebAPIRequest=} [properties] Properties to set\n   */\n  function CMsgWebAPIRequest(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgWebAPIRequest UNUSEDJobName.\n   * @member {string} UNUSEDJobName\n   * @memberof CMsgWebAPIRequest\n   * @instance\n   */\n\n\n  CMsgWebAPIRequest.prototype.UNUSEDJobName = \"\";\n  /**\n   * CMsgWebAPIRequest interfaceName.\n   * @member {string} interfaceName\n   * @memberof CMsgWebAPIRequest\n   * @instance\n   */\n\n  CMsgWebAPIRequest.prototype.interfaceName = \"\";\n  /**\n   * CMsgWebAPIRequest methodName.\n   * @member {string} methodName\n   * @memberof CMsgWebAPIRequest\n   * @instance\n   */\n\n  CMsgWebAPIRequest.prototype.methodName = \"\";\n  /**\n   * CMsgWebAPIRequest version.\n   * @member {number} version\n   * @memberof CMsgWebAPIRequest\n   * @instance\n   */\n\n  CMsgWebAPIRequest.prototype.version = 0;\n  /**\n   * CMsgWebAPIRequest apiKey.\n   * @member {ICMsgWebAPIKey|null|undefined} apiKey\n   * @memberof CMsgWebAPIRequest\n   * @instance\n   */\n\n  CMsgWebAPIRequest.prototype.apiKey = null;\n  /**\n   * CMsgWebAPIRequest request.\n   * @member {ICMsgHttpRequest|null|undefined} request\n   * @memberof CMsgWebAPIRequest\n   * @instance\n   */\n\n  CMsgWebAPIRequest.prototype.request = null;\n  /**\n   * CMsgWebAPIRequest routingAppId.\n   * @member {number} routingAppId\n   * @memberof CMsgWebAPIRequest\n   * @instance\n   */\n\n  CMsgWebAPIRequest.prototype.routingAppId = 0;\n  /**\n   * Decodes a CMsgWebAPIRequest message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgWebAPIRequest\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgWebAPIRequest} CMsgWebAPIRequest\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgWebAPIRequest.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgWebAPIRequest();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.UNUSEDJobName = reader.string();\n          break;\n\n        case 2:\n          message.interfaceName = reader.string();\n          break;\n\n        case 3:\n          message.methodName = reader.string();\n          break;\n\n        case 4:\n          message.version = reader.uint32();\n          break;\n\n        case 5:\n          message.apiKey = $root.CMsgWebAPIKey.decode(reader, reader.uint32());\n          break;\n\n        case 6:\n          message.request = $root.CMsgHttpRequest.decode(reader, reader.uint32());\n          break;\n\n        case 7:\n          message.routingAppId = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgWebAPIRequest;\n})();\n\nexports.CMsgHttpResponse = $root.CMsgHttpResponse = (() => {\n  /**\n   * Properties of a CMsgHttpResponse.\n   * @exports ICMsgHttpResponse\n   * @interface ICMsgHttpResponse\n   * @property {number|null} [statusCode] CMsgHttpResponse statusCode\n   * @property {Array.<CMsgHttpResponse.IResponseHeader>|null} [headers] CMsgHttpResponse headers\n   * @property {Uint8Array|null} [body] CMsgHttpResponse body\n   */\n\n  /**\n   * Constructs a new CMsgHttpResponse.\n   * @exports CMsgHttpResponse\n   * @classdesc Represents a CMsgHttpResponse.\n   * @implements ICMsgHttpResponse\n   * @constructor\n   * @param {ICMsgHttpResponse=} [properties] Properties to set\n   */\n  function CMsgHttpResponse(properties) {\n    this.headers = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgHttpResponse statusCode.\n   * @member {number} statusCode\n   * @memberof CMsgHttpResponse\n   * @instance\n   */\n\n\n  CMsgHttpResponse.prototype.statusCode = 0;\n  /**\n   * CMsgHttpResponse headers.\n   * @member {Array.<CMsgHttpResponse.IResponseHeader>} headers\n   * @memberof CMsgHttpResponse\n   * @instance\n   */\n\n  CMsgHttpResponse.prototype.headers = $util.emptyArray;\n  /**\n   * CMsgHttpResponse body.\n   * @member {Uint8Array} body\n   * @memberof CMsgHttpResponse\n   * @instance\n   */\n\n  CMsgHttpResponse.prototype.body = $util.newBuffer([]);\n  /**\n   * Decodes a CMsgHttpResponse message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgHttpResponse\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgHttpResponse} CMsgHttpResponse\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgHttpResponse.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgHttpResponse();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.statusCode = reader.uint32();\n          break;\n\n        case 2:\n          if (!(message.headers && message.headers.length)) message.headers = [];\n          message.headers.push($root.CMsgHttpResponse.ResponseHeader.decode(reader, reader.uint32()));\n          break;\n\n        case 3:\n          message.body = reader.bytes();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CMsgHttpResponse.ResponseHeader = function () {\n    /**\n     * Properties of a ResponseHeader.\n     * @memberof CMsgHttpResponse\n     * @interface IResponseHeader\n     * @property {string|null} [name] ResponseHeader name\n     * @property {string|null} [value] ResponseHeader value\n     */\n\n    /**\n     * Constructs a new ResponseHeader.\n     * @memberof CMsgHttpResponse\n     * @classdesc Represents a ResponseHeader.\n     * @implements IResponseHeader\n     * @constructor\n     * @param {CMsgHttpResponse.IResponseHeader=} [properties] Properties to set\n     */\n    function ResponseHeader(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * ResponseHeader name.\n     * @member {string} name\n     * @memberof CMsgHttpResponse.ResponseHeader\n     * @instance\n     */\n\n\n    ResponseHeader.prototype.name = \"\";\n    /**\n     * ResponseHeader value.\n     * @member {string} value\n     * @memberof CMsgHttpResponse.ResponseHeader\n     * @instance\n     */\n\n    ResponseHeader.prototype.value = \"\";\n    /**\n     * Decodes a ResponseHeader message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgHttpResponse.ResponseHeader\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgHttpResponse.ResponseHeader} ResponseHeader\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    ResponseHeader.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CMsgHttpResponse.ResponseHeader();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.name = reader.string();\n            break;\n\n          case 2:\n            message.value = reader.string();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return ResponseHeader;\n  }();\n\n  return CMsgHttpResponse;\n})();\n\nexports.CMsgAMFindAccounts = $root.CMsgAMFindAccounts = (() => {\n  /**\n   * Properties of a CMsgAMFindAccounts.\n   * @exports ICMsgAMFindAccounts\n   * @interface ICMsgAMFindAccounts\n   * @property {number|null} [searchType] CMsgAMFindAccounts searchType\n   * @property {string|null} [searchString] CMsgAMFindAccounts searchString\n   */\n\n  /**\n   * Constructs a new CMsgAMFindAccounts.\n   * @exports CMsgAMFindAccounts\n   * @classdesc Represents a CMsgAMFindAccounts.\n   * @implements ICMsgAMFindAccounts\n   * @constructor\n   * @param {ICMsgAMFindAccounts=} [properties] Properties to set\n   */\n  function CMsgAMFindAccounts(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgAMFindAccounts searchType.\n   * @member {number} searchType\n   * @memberof CMsgAMFindAccounts\n   * @instance\n   */\n\n\n  CMsgAMFindAccounts.prototype.searchType = 0;\n  /**\n   * CMsgAMFindAccounts searchString.\n   * @member {string} searchString\n   * @memberof CMsgAMFindAccounts\n   * @instance\n   */\n\n  CMsgAMFindAccounts.prototype.searchString = \"\";\n  /**\n   * Decodes a CMsgAMFindAccounts message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgAMFindAccounts\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgAMFindAccounts} CMsgAMFindAccounts\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgAMFindAccounts.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgAMFindAccounts();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.searchType = reader.uint32();\n          break;\n\n        case 2:\n          message.searchString = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgAMFindAccounts;\n})();\n\nexports.CMsgAMFindAccountsResponse = $root.CMsgAMFindAccountsResponse = (() => {\n  /**\n   * Properties of a CMsgAMFindAccountsResponse.\n   * @exports ICMsgAMFindAccountsResponse\n   * @interface ICMsgAMFindAccountsResponse\n   * @property {Array.<number|Long>|null} [steamId] CMsgAMFindAccountsResponse steamId\n   */\n\n  /**\n   * Constructs a new CMsgAMFindAccountsResponse.\n   * @exports CMsgAMFindAccountsResponse\n   * @classdesc Represents a CMsgAMFindAccountsResponse.\n   * @implements ICMsgAMFindAccountsResponse\n   * @constructor\n   * @param {ICMsgAMFindAccountsResponse=} [properties] Properties to set\n   */\n  function CMsgAMFindAccountsResponse(properties) {\n    this.steamId = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgAMFindAccountsResponse steamId.\n   * @member {Array.<number|Long>} steamId\n   * @memberof CMsgAMFindAccountsResponse\n   * @instance\n   */\n\n\n  CMsgAMFindAccountsResponse.prototype.steamId = $util.emptyArray;\n  /**\n   * Decodes a CMsgAMFindAccountsResponse message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgAMFindAccountsResponse\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgAMFindAccountsResponse} CMsgAMFindAccountsResponse\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgAMFindAccountsResponse.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgAMFindAccountsResponse();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.steamId && message.steamId.length)) message.steamId = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.steamId.push(reader.fixed64());\n          } else message.steamId.push(reader.fixed64());\n\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgAMFindAccountsResponse;\n})();\n\nexports.CMsgNotifyWatchdog = $root.CMsgNotifyWatchdog = (() => {\n  /**\n   * Properties of a CMsgNotifyWatchdog.\n   * @exports ICMsgNotifyWatchdog\n   * @interface ICMsgNotifyWatchdog\n   * @property {number|null} [source] CMsgNotifyWatchdog source\n   * @property {number|null} [alertType] CMsgNotifyWatchdog alertType\n   * @property {number|null} [alertDestination] CMsgNotifyWatchdog alertDestination\n   * @property {boolean|null} [critical] CMsgNotifyWatchdog critical\n   * @property {number|null} [time] CMsgNotifyWatchdog time\n   * @property {number|null} [appid] CMsgNotifyWatchdog appid\n   * @property {string|null} [text] CMsgNotifyWatchdog text\n   */\n\n  /**\n   * Constructs a new CMsgNotifyWatchdog.\n   * @exports CMsgNotifyWatchdog\n   * @classdesc Represents a CMsgNotifyWatchdog.\n   * @implements ICMsgNotifyWatchdog\n   * @constructor\n   * @param {ICMsgNotifyWatchdog=} [properties] Properties to set\n   */\n  function CMsgNotifyWatchdog(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgNotifyWatchdog source.\n   * @member {number} source\n   * @memberof CMsgNotifyWatchdog\n   * @instance\n   */\n\n\n  CMsgNotifyWatchdog.prototype.source = 0;\n  /**\n   * CMsgNotifyWatchdog alertType.\n   * @member {number} alertType\n   * @memberof CMsgNotifyWatchdog\n   * @instance\n   */\n\n  CMsgNotifyWatchdog.prototype.alertType = 0;\n  /**\n   * CMsgNotifyWatchdog alertDestination.\n   * @member {number} alertDestination\n   * @memberof CMsgNotifyWatchdog\n   * @instance\n   */\n\n  CMsgNotifyWatchdog.prototype.alertDestination = 0;\n  /**\n   * CMsgNotifyWatchdog critical.\n   * @member {boolean} critical\n   * @memberof CMsgNotifyWatchdog\n   * @instance\n   */\n\n  CMsgNotifyWatchdog.prototype.critical = false;\n  /**\n   * CMsgNotifyWatchdog time.\n   * @member {number} time\n   * @memberof CMsgNotifyWatchdog\n   * @instance\n   */\n\n  CMsgNotifyWatchdog.prototype.time = 0;\n  /**\n   * CMsgNotifyWatchdog appid.\n   * @member {number} appid\n   * @memberof CMsgNotifyWatchdog\n   * @instance\n   */\n\n  CMsgNotifyWatchdog.prototype.appid = 0;\n  /**\n   * CMsgNotifyWatchdog text.\n   * @member {string} text\n   * @memberof CMsgNotifyWatchdog\n   * @instance\n   */\n\n  CMsgNotifyWatchdog.prototype.text = \"\";\n  /**\n   * Decodes a CMsgNotifyWatchdog message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgNotifyWatchdog\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgNotifyWatchdog} CMsgNotifyWatchdog\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgNotifyWatchdog.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgNotifyWatchdog();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.source = reader.uint32();\n          break;\n\n        case 2:\n          message.alertType = reader.uint32();\n          break;\n\n        case 3:\n          message.alertDestination = reader.uint32();\n          break;\n\n        case 4:\n          message.critical = reader.bool();\n          break;\n\n        case 5:\n          message.time = reader.uint32();\n          break;\n\n        case 6:\n          message.appid = reader.uint32();\n          break;\n\n        case 7:\n          message.text = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgNotifyWatchdog;\n})();\n\nexports.CMsgAMGetLicenses = $root.CMsgAMGetLicenses = (() => {\n  /**\n   * Properties of a CMsgAMGetLicenses.\n   * @exports ICMsgAMGetLicenses\n   * @interface ICMsgAMGetLicenses\n   * @property {number|Long|null} [steamid] CMsgAMGetLicenses steamid\n   */\n\n  /**\n   * Constructs a new CMsgAMGetLicenses.\n   * @exports CMsgAMGetLicenses\n   * @classdesc Represents a CMsgAMGetLicenses.\n   * @implements ICMsgAMGetLicenses\n   * @constructor\n   * @param {ICMsgAMGetLicenses=} [properties] Properties to set\n   */\n  function CMsgAMGetLicenses(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgAMGetLicenses steamid.\n   * @member {number|Long} steamid\n   * @memberof CMsgAMGetLicenses\n   * @instance\n   */\n\n\n  CMsgAMGetLicenses.prototype.steamid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n  /**\n   * Decodes a CMsgAMGetLicenses message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgAMGetLicenses\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgAMGetLicenses} CMsgAMGetLicenses\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgAMGetLicenses.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgAMGetLicenses();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.steamid = reader.fixed64();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgAMGetLicenses;\n})();\n\nexports.CMsgPackageLicense = $root.CMsgPackageLicense = (() => {\n  /**\n   * Properties of a CMsgPackageLicense.\n   * @exports ICMsgPackageLicense\n   * @interface ICMsgPackageLicense\n   * @property {number|null} [packageId] CMsgPackageLicense packageId\n   * @property {number|null} [timeCreated] CMsgPackageLicense timeCreated\n   * @property {number|null} [ownerId] CMsgPackageLicense ownerId\n   */\n\n  /**\n   * Constructs a new CMsgPackageLicense.\n   * @exports CMsgPackageLicense\n   * @classdesc Represents a CMsgPackageLicense.\n   * @implements ICMsgPackageLicense\n   * @constructor\n   * @param {ICMsgPackageLicense=} [properties] Properties to set\n   */\n  function CMsgPackageLicense(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgPackageLicense packageId.\n   * @member {number} packageId\n   * @memberof CMsgPackageLicense\n   * @instance\n   */\n\n\n  CMsgPackageLicense.prototype.packageId = 0;\n  /**\n   * CMsgPackageLicense timeCreated.\n   * @member {number} timeCreated\n   * @memberof CMsgPackageLicense\n   * @instance\n   */\n\n  CMsgPackageLicense.prototype.timeCreated = 0;\n  /**\n   * CMsgPackageLicense ownerId.\n   * @member {number} ownerId\n   * @memberof CMsgPackageLicense\n   * @instance\n   */\n\n  CMsgPackageLicense.prototype.ownerId = 0;\n  /**\n   * Decodes a CMsgPackageLicense message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgPackageLicense\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgPackageLicense} CMsgPackageLicense\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgPackageLicense.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgPackageLicense();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.packageId = reader.uint32();\n          break;\n\n        case 2:\n          message.timeCreated = reader.uint32();\n          break;\n\n        case 3:\n          message.ownerId = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgPackageLicense;\n})();\n\nexports.CMsgAMGetLicensesResponse = $root.CMsgAMGetLicensesResponse = (() => {\n  /**\n   * Properties of a CMsgAMGetLicensesResponse.\n   * @exports ICMsgAMGetLicensesResponse\n   * @interface ICMsgAMGetLicensesResponse\n   * @property {Array.<ICMsgPackageLicense>|null} [license] CMsgAMGetLicensesResponse license\n   * @property {number|null} [result] CMsgAMGetLicensesResponse result\n   */\n\n  /**\n   * Constructs a new CMsgAMGetLicensesResponse.\n   * @exports CMsgAMGetLicensesResponse\n   * @classdesc Represents a CMsgAMGetLicensesResponse.\n   * @implements ICMsgAMGetLicensesResponse\n   * @constructor\n   * @param {ICMsgAMGetLicensesResponse=} [properties] Properties to set\n   */\n  function CMsgAMGetLicensesResponse(properties) {\n    this.license = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgAMGetLicensesResponse license.\n   * @member {Array.<ICMsgPackageLicense>} license\n   * @memberof CMsgAMGetLicensesResponse\n   * @instance\n   */\n\n\n  CMsgAMGetLicensesResponse.prototype.license = $util.emptyArray;\n  /**\n   * CMsgAMGetLicensesResponse result.\n   * @member {number} result\n   * @memberof CMsgAMGetLicensesResponse\n   * @instance\n   */\n\n  CMsgAMGetLicensesResponse.prototype.result = 0;\n  /**\n   * Decodes a CMsgAMGetLicensesResponse message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgAMGetLicensesResponse\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgAMGetLicensesResponse} CMsgAMGetLicensesResponse\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgAMGetLicensesResponse.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgAMGetLicensesResponse();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.license && message.license.length)) message.license = [];\n          message.license.push($root.CMsgPackageLicense.decode(reader, reader.uint32()));\n          break;\n\n        case 2:\n          message.result = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgAMGetLicensesResponse;\n})();\n\nexports.CMsgAMGetUserGameStats = $root.CMsgAMGetUserGameStats = (() => {\n  /**\n   * Properties of a CMsgAMGetUserGameStats.\n   * @exports ICMsgAMGetUserGameStats\n   * @interface ICMsgAMGetUserGameStats\n   * @property {number|Long|null} [steamId] CMsgAMGetUserGameStats steamId\n   * @property {number|Long|null} [gameId] CMsgAMGetUserGameStats gameId\n   * @property {Array.<number>|null} [stats] CMsgAMGetUserGameStats stats\n   */\n\n  /**\n   * Constructs a new CMsgAMGetUserGameStats.\n   * @exports CMsgAMGetUserGameStats\n   * @classdesc Represents a CMsgAMGetUserGameStats.\n   * @implements ICMsgAMGetUserGameStats\n   * @constructor\n   * @param {ICMsgAMGetUserGameStats=} [properties] Properties to set\n   */\n  function CMsgAMGetUserGameStats(properties) {\n    this.stats = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgAMGetUserGameStats steamId.\n   * @member {number|Long} steamId\n   * @memberof CMsgAMGetUserGameStats\n   * @instance\n   */\n\n\n  CMsgAMGetUserGameStats.prototype.steamId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n  /**\n   * CMsgAMGetUserGameStats gameId.\n   * @member {number|Long} gameId\n   * @memberof CMsgAMGetUserGameStats\n   * @instance\n   */\n\n  CMsgAMGetUserGameStats.prototype.gameId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n  /**\n   * CMsgAMGetUserGameStats stats.\n   * @member {Array.<number>} stats\n   * @memberof CMsgAMGetUserGameStats\n   * @instance\n   */\n\n  CMsgAMGetUserGameStats.prototype.stats = $util.emptyArray;\n  /**\n   * Decodes a CMsgAMGetUserGameStats message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgAMGetUserGameStats\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgAMGetUserGameStats} CMsgAMGetUserGameStats\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgAMGetUserGameStats.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgAMGetUserGameStats();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.steamId = reader.fixed64();\n          break;\n\n        case 2:\n          message.gameId = reader.fixed64();\n          break;\n\n        case 3:\n          if (!(message.stats && message.stats.length)) message.stats = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.stats.push(reader.uint32());\n          } else message.stats.push(reader.uint32());\n\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgAMGetUserGameStats;\n})();\n\nexports.CMsgAMGetUserGameStatsResponse = $root.CMsgAMGetUserGameStatsResponse = (() => {\n  /**\n   * Properties of a CMsgAMGetUserGameStatsResponse.\n   * @exports ICMsgAMGetUserGameStatsResponse\n   * @interface ICMsgAMGetUserGameStatsResponse\n   * @property {number|Long|null} [steamId] CMsgAMGetUserGameStatsResponse steamId\n   * @property {number|Long|null} [gameId] CMsgAMGetUserGameStatsResponse gameId\n   * @property {number|null} [eresult] CMsgAMGetUserGameStatsResponse eresult\n   * @property {Array.<CMsgAMGetUserGameStatsResponse.IStats>|null} [stats] CMsgAMGetUserGameStatsResponse stats\n   * @property {Array.<CMsgAMGetUserGameStatsResponse.IAchievement_Blocks>|null} [achievementBlocks] CMsgAMGetUserGameStatsResponse achievementBlocks\n   */\n\n  /**\n   * Constructs a new CMsgAMGetUserGameStatsResponse.\n   * @exports CMsgAMGetUserGameStatsResponse\n   * @classdesc Represents a CMsgAMGetUserGameStatsResponse.\n   * @implements ICMsgAMGetUserGameStatsResponse\n   * @constructor\n   * @param {ICMsgAMGetUserGameStatsResponse=} [properties] Properties to set\n   */\n  function CMsgAMGetUserGameStatsResponse(properties) {\n    this.stats = [];\n    this.achievementBlocks = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgAMGetUserGameStatsResponse steamId.\n   * @member {number|Long} steamId\n   * @memberof CMsgAMGetUserGameStatsResponse\n   * @instance\n   */\n\n\n  CMsgAMGetUserGameStatsResponse.prototype.steamId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n  /**\n   * CMsgAMGetUserGameStatsResponse gameId.\n   * @member {number|Long} gameId\n   * @memberof CMsgAMGetUserGameStatsResponse\n   * @instance\n   */\n\n  CMsgAMGetUserGameStatsResponse.prototype.gameId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n  /**\n   * CMsgAMGetUserGameStatsResponse eresult.\n   * @member {number} eresult\n   * @memberof CMsgAMGetUserGameStatsResponse\n   * @instance\n   */\n\n  CMsgAMGetUserGameStatsResponse.prototype.eresult = 2;\n  /**\n   * CMsgAMGetUserGameStatsResponse stats.\n   * @member {Array.<CMsgAMGetUserGameStatsResponse.IStats>} stats\n   * @memberof CMsgAMGetUserGameStatsResponse\n   * @instance\n   */\n\n  CMsgAMGetUserGameStatsResponse.prototype.stats = $util.emptyArray;\n  /**\n   * CMsgAMGetUserGameStatsResponse achievementBlocks.\n   * @member {Array.<CMsgAMGetUserGameStatsResponse.IAchievement_Blocks>} achievementBlocks\n   * @memberof CMsgAMGetUserGameStatsResponse\n   * @instance\n   */\n\n  CMsgAMGetUserGameStatsResponse.prototype.achievementBlocks = $util.emptyArray;\n  /**\n   * Decodes a CMsgAMGetUserGameStatsResponse message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgAMGetUserGameStatsResponse\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgAMGetUserGameStatsResponse} CMsgAMGetUserGameStatsResponse\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgAMGetUserGameStatsResponse.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgAMGetUserGameStatsResponse();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.steamId = reader.fixed64();\n          break;\n\n        case 2:\n          message.gameId = reader.fixed64();\n          break;\n\n        case 3:\n          message.eresult = reader.int32();\n          break;\n\n        case 4:\n          if (!(message.stats && message.stats.length)) message.stats = [];\n          message.stats.push($root.CMsgAMGetUserGameStatsResponse.Stats.decode(reader, reader.uint32()));\n          break;\n\n        case 5:\n          if (!(message.achievementBlocks && message.achievementBlocks.length)) message.achievementBlocks = [];\n          message.achievementBlocks.push($root.CMsgAMGetUserGameStatsResponse.Achievement_Blocks.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CMsgAMGetUserGameStatsResponse.Stats = function () {\n    /**\n     * Properties of a Stats.\n     * @memberof CMsgAMGetUserGameStatsResponse\n     * @interface IStats\n     * @property {number|null} [statId] Stats statId\n     * @property {number|null} [statValue] Stats statValue\n     */\n\n    /**\n     * Constructs a new Stats.\n     * @memberof CMsgAMGetUserGameStatsResponse\n     * @classdesc Represents a Stats.\n     * @implements IStats\n     * @constructor\n     * @param {CMsgAMGetUserGameStatsResponse.IStats=} [properties] Properties to set\n     */\n    function Stats(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Stats statId.\n     * @member {number} statId\n     * @memberof CMsgAMGetUserGameStatsResponse.Stats\n     * @instance\n     */\n\n\n    Stats.prototype.statId = 0;\n    /**\n     * Stats statValue.\n     * @member {number} statValue\n     * @memberof CMsgAMGetUserGameStatsResponse.Stats\n     * @instance\n     */\n\n    Stats.prototype.statValue = 0;\n    /**\n     * Decodes a Stats message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgAMGetUserGameStatsResponse.Stats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgAMGetUserGameStatsResponse.Stats} Stats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    Stats.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CMsgAMGetUserGameStatsResponse.Stats();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.statId = reader.uint32();\n            break;\n\n          case 2:\n            message.statValue = reader.uint32();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return Stats;\n  }();\n\n  CMsgAMGetUserGameStatsResponse.Achievement_Blocks = function () {\n    /**\n     * Properties of an Achievement_Blocks.\n     * @memberof CMsgAMGetUserGameStatsResponse\n     * @interface IAchievement_Blocks\n     * @property {number|null} [achievementId] Achievement_Blocks achievementId\n     * @property {number|null} [achievementBitId] Achievement_Blocks achievementBitId\n     * @property {number|null} [unlockTime] Achievement_Blocks unlockTime\n     */\n\n    /**\n     * Constructs a new Achievement_Blocks.\n     * @memberof CMsgAMGetUserGameStatsResponse\n     * @classdesc Represents an Achievement_Blocks.\n     * @implements IAchievement_Blocks\n     * @constructor\n     * @param {CMsgAMGetUserGameStatsResponse.IAchievement_Blocks=} [properties] Properties to set\n     */\n    function Achievement_Blocks(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Achievement_Blocks achievementId.\n     * @member {number} achievementId\n     * @memberof CMsgAMGetUserGameStatsResponse.Achievement_Blocks\n     * @instance\n     */\n\n\n    Achievement_Blocks.prototype.achievementId = 0;\n    /**\n     * Achievement_Blocks achievementBitId.\n     * @member {number} achievementBitId\n     * @memberof CMsgAMGetUserGameStatsResponse.Achievement_Blocks\n     * @instance\n     */\n\n    Achievement_Blocks.prototype.achievementBitId = 0;\n    /**\n     * Achievement_Blocks unlockTime.\n     * @member {number} unlockTime\n     * @memberof CMsgAMGetUserGameStatsResponse.Achievement_Blocks\n     * @instance\n     */\n\n    Achievement_Blocks.prototype.unlockTime = 0;\n    /**\n     * Decodes an Achievement_Blocks message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgAMGetUserGameStatsResponse.Achievement_Blocks\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgAMGetUserGameStatsResponse.Achievement_Blocks} Achievement_Blocks\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    Achievement_Blocks.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CMsgAMGetUserGameStatsResponse.Achievement_Blocks();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.achievementId = reader.uint32();\n            break;\n\n          case 2:\n            message.achievementBitId = reader.uint32();\n            break;\n\n          case 3:\n            message.unlockTime = reader.fixed32();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return Achievement_Blocks;\n  }();\n\n  return CMsgAMGetUserGameStatsResponse;\n})();\n\nexports.CMsgGCGetCommandList = $root.CMsgGCGetCommandList = (() => {\n  /**\n   * Properties of a CMsgGCGetCommandList.\n   * @exports ICMsgGCGetCommandList\n   * @interface ICMsgGCGetCommandList\n   * @property {number|null} [appId] CMsgGCGetCommandList appId\n   * @property {string|null} [commandPrefix] CMsgGCGetCommandList commandPrefix\n   */\n\n  /**\n   * Constructs a new CMsgGCGetCommandList.\n   * @exports CMsgGCGetCommandList\n   * @classdesc Represents a CMsgGCGetCommandList.\n   * @implements ICMsgGCGetCommandList\n   * @constructor\n   * @param {ICMsgGCGetCommandList=} [properties] Properties to set\n   */\n  function CMsgGCGetCommandList(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCGetCommandList appId.\n   * @member {number} appId\n   * @memberof CMsgGCGetCommandList\n   * @instance\n   */\n\n\n  CMsgGCGetCommandList.prototype.appId = 0;\n  /**\n   * CMsgGCGetCommandList commandPrefix.\n   * @member {string} commandPrefix\n   * @memberof CMsgGCGetCommandList\n   * @instance\n   */\n\n  CMsgGCGetCommandList.prototype.commandPrefix = \"\";\n  /**\n   * Decodes a CMsgGCGetCommandList message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCGetCommandList\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCGetCommandList} CMsgGCGetCommandList\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCGetCommandList.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCGetCommandList();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.appId = reader.uint32();\n          break;\n\n        case 2:\n          message.commandPrefix = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCGetCommandList;\n})();\n\nexports.CMsgGCGetCommandListResponse = $root.CMsgGCGetCommandListResponse = (() => {\n  /**\n   * Properties of a CMsgGCGetCommandListResponse.\n   * @exports ICMsgGCGetCommandListResponse\n   * @interface ICMsgGCGetCommandListResponse\n   * @property {Array.<string>|null} [commandName] CMsgGCGetCommandListResponse commandName\n   */\n\n  /**\n   * Constructs a new CMsgGCGetCommandListResponse.\n   * @exports CMsgGCGetCommandListResponse\n   * @classdesc Represents a CMsgGCGetCommandListResponse.\n   * @implements ICMsgGCGetCommandListResponse\n   * @constructor\n   * @param {ICMsgGCGetCommandListResponse=} [properties] Properties to set\n   */\n  function CMsgGCGetCommandListResponse(properties) {\n    this.commandName = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCGetCommandListResponse commandName.\n   * @member {Array.<string>} commandName\n   * @memberof CMsgGCGetCommandListResponse\n   * @instance\n   */\n\n\n  CMsgGCGetCommandListResponse.prototype.commandName = $util.emptyArray;\n  /**\n   * Decodes a CMsgGCGetCommandListResponse message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCGetCommandListResponse\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCGetCommandListResponse} CMsgGCGetCommandListResponse\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCGetCommandListResponse.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCGetCommandListResponse();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.commandName && message.commandName.length)) message.commandName = [];\n          message.commandName.push(reader.string());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCGetCommandListResponse;\n})();\n\nexports.CGCMsgMemCachedGet = $root.CGCMsgMemCachedGet = (() => {\n  /**\n   * Properties of a CGCMsgMemCachedGet.\n   * @exports ICGCMsgMemCachedGet\n   * @interface ICGCMsgMemCachedGet\n   * @property {Array.<string>|null} [keys] CGCMsgMemCachedGet keys\n   */\n\n  /**\n   * Constructs a new CGCMsgMemCachedGet.\n   * @exports CGCMsgMemCachedGet\n   * @classdesc Represents a CGCMsgMemCachedGet.\n   * @implements ICGCMsgMemCachedGet\n   * @constructor\n   * @param {ICGCMsgMemCachedGet=} [properties] Properties to set\n   */\n  function CGCMsgMemCachedGet(properties) {\n    this.keys = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CGCMsgMemCachedGet keys.\n   * @member {Array.<string>} keys\n   * @memberof CGCMsgMemCachedGet\n   * @instance\n   */\n\n\n  CGCMsgMemCachedGet.prototype.keys = $util.emptyArray;\n  /**\n   * Decodes a CGCMsgMemCachedGet message from the specified reader or buffer.\n   * @function decode\n   * @memberof CGCMsgMemCachedGet\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CGCMsgMemCachedGet} CGCMsgMemCachedGet\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CGCMsgMemCachedGet.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CGCMsgMemCachedGet();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.keys && message.keys.length)) message.keys = [];\n          message.keys.push(reader.string());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CGCMsgMemCachedGet;\n})();\n\nexports.CGCMsgMemCachedGetResponse = $root.CGCMsgMemCachedGetResponse = (() => {\n  /**\n   * Properties of a CGCMsgMemCachedGetResponse.\n   * @exports ICGCMsgMemCachedGetResponse\n   * @interface ICGCMsgMemCachedGetResponse\n   * @property {Array.<CGCMsgMemCachedGetResponse.IValueTag>|null} [values] CGCMsgMemCachedGetResponse values\n   */\n\n  /**\n   * Constructs a new CGCMsgMemCachedGetResponse.\n   * @exports CGCMsgMemCachedGetResponse\n   * @classdesc Represents a CGCMsgMemCachedGetResponse.\n   * @implements ICGCMsgMemCachedGetResponse\n   * @constructor\n   * @param {ICGCMsgMemCachedGetResponse=} [properties] Properties to set\n   */\n  function CGCMsgMemCachedGetResponse(properties) {\n    this.values = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CGCMsgMemCachedGetResponse values.\n   * @member {Array.<CGCMsgMemCachedGetResponse.IValueTag>} values\n   * @memberof CGCMsgMemCachedGetResponse\n   * @instance\n   */\n\n\n  CGCMsgMemCachedGetResponse.prototype.values = $util.emptyArray;\n  /**\n   * Decodes a CGCMsgMemCachedGetResponse message from the specified reader or buffer.\n   * @function decode\n   * @memberof CGCMsgMemCachedGetResponse\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CGCMsgMemCachedGetResponse} CGCMsgMemCachedGetResponse\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CGCMsgMemCachedGetResponse.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CGCMsgMemCachedGetResponse();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.values && message.values.length)) message.values = [];\n          message.values.push($root.CGCMsgMemCachedGetResponse.ValueTag.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CGCMsgMemCachedGetResponse.ValueTag = function () {\n    /**\n     * Properties of a ValueTag.\n     * @memberof CGCMsgMemCachedGetResponse\n     * @interface IValueTag\n     * @property {boolean|null} [found] ValueTag found\n     * @property {Uint8Array|null} [value] ValueTag value\n     */\n\n    /**\n     * Constructs a new ValueTag.\n     * @memberof CGCMsgMemCachedGetResponse\n     * @classdesc Represents a ValueTag.\n     * @implements IValueTag\n     * @constructor\n     * @param {CGCMsgMemCachedGetResponse.IValueTag=} [properties] Properties to set\n     */\n    function ValueTag(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * ValueTag found.\n     * @member {boolean} found\n     * @memberof CGCMsgMemCachedGetResponse.ValueTag\n     * @instance\n     */\n\n\n    ValueTag.prototype.found = false;\n    /**\n     * ValueTag value.\n     * @member {Uint8Array} value\n     * @memberof CGCMsgMemCachedGetResponse.ValueTag\n     * @instance\n     */\n\n    ValueTag.prototype.value = $util.newBuffer([]);\n    /**\n     * Decodes a ValueTag message from the specified reader or buffer.\n     * @function decode\n     * @memberof CGCMsgMemCachedGetResponse.ValueTag\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CGCMsgMemCachedGetResponse.ValueTag} ValueTag\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    ValueTag.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CGCMsgMemCachedGetResponse.ValueTag();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.found = reader.bool();\n            break;\n\n          case 2:\n            message.value = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return ValueTag;\n  }();\n\n  return CGCMsgMemCachedGetResponse;\n})();\n\nexports.CGCMsgMemCachedSet = $root.CGCMsgMemCachedSet = (() => {\n  /**\n   * Properties of a CGCMsgMemCachedSet.\n   * @exports ICGCMsgMemCachedSet\n   * @interface ICGCMsgMemCachedSet\n   * @property {Array.<CGCMsgMemCachedSet.IKeyPair>|null} [keys] CGCMsgMemCachedSet keys\n   */\n\n  /**\n   * Constructs a new CGCMsgMemCachedSet.\n   * @exports CGCMsgMemCachedSet\n   * @classdesc Represents a CGCMsgMemCachedSet.\n   * @implements ICGCMsgMemCachedSet\n   * @constructor\n   * @param {ICGCMsgMemCachedSet=} [properties] Properties to set\n   */\n  function CGCMsgMemCachedSet(properties) {\n    this.keys = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CGCMsgMemCachedSet keys.\n   * @member {Array.<CGCMsgMemCachedSet.IKeyPair>} keys\n   * @memberof CGCMsgMemCachedSet\n   * @instance\n   */\n\n\n  CGCMsgMemCachedSet.prototype.keys = $util.emptyArray;\n  /**\n   * Decodes a CGCMsgMemCachedSet message from the specified reader or buffer.\n   * @function decode\n   * @memberof CGCMsgMemCachedSet\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CGCMsgMemCachedSet} CGCMsgMemCachedSet\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CGCMsgMemCachedSet.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CGCMsgMemCachedSet();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.keys && message.keys.length)) message.keys = [];\n          message.keys.push($root.CGCMsgMemCachedSet.KeyPair.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CGCMsgMemCachedSet.KeyPair = function () {\n    /**\n     * Properties of a KeyPair.\n     * @memberof CGCMsgMemCachedSet\n     * @interface IKeyPair\n     * @property {string|null} [name] KeyPair name\n     * @property {Uint8Array|null} [value] KeyPair value\n     */\n\n    /**\n     * Constructs a new KeyPair.\n     * @memberof CGCMsgMemCachedSet\n     * @classdesc Represents a KeyPair.\n     * @implements IKeyPair\n     * @constructor\n     * @param {CGCMsgMemCachedSet.IKeyPair=} [properties] Properties to set\n     */\n    function KeyPair(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * KeyPair name.\n     * @member {string} name\n     * @memberof CGCMsgMemCachedSet.KeyPair\n     * @instance\n     */\n\n\n    KeyPair.prototype.name = \"\";\n    /**\n     * KeyPair value.\n     * @member {Uint8Array} value\n     * @memberof CGCMsgMemCachedSet.KeyPair\n     * @instance\n     */\n\n    KeyPair.prototype.value = $util.newBuffer([]);\n    /**\n     * Decodes a KeyPair message from the specified reader or buffer.\n     * @function decode\n     * @memberof CGCMsgMemCachedSet.KeyPair\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CGCMsgMemCachedSet.KeyPair} KeyPair\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    KeyPair.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CGCMsgMemCachedSet.KeyPair();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.name = reader.string();\n            break;\n\n          case 2:\n            message.value = reader.bytes();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return KeyPair;\n  }();\n\n  return CGCMsgMemCachedSet;\n})();\n\nexports.CGCMsgMemCachedDelete = $root.CGCMsgMemCachedDelete = (() => {\n  /**\n   * Properties of a CGCMsgMemCachedDelete.\n   * @exports ICGCMsgMemCachedDelete\n   * @interface ICGCMsgMemCachedDelete\n   * @property {Array.<string>|null} [keys] CGCMsgMemCachedDelete keys\n   */\n\n  /**\n   * Constructs a new CGCMsgMemCachedDelete.\n   * @exports CGCMsgMemCachedDelete\n   * @classdesc Represents a CGCMsgMemCachedDelete.\n   * @implements ICGCMsgMemCachedDelete\n   * @constructor\n   * @param {ICGCMsgMemCachedDelete=} [properties] Properties to set\n   */\n  function CGCMsgMemCachedDelete(properties) {\n    this.keys = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CGCMsgMemCachedDelete keys.\n   * @member {Array.<string>} keys\n   * @memberof CGCMsgMemCachedDelete\n   * @instance\n   */\n\n\n  CGCMsgMemCachedDelete.prototype.keys = $util.emptyArray;\n  /**\n   * Decodes a CGCMsgMemCachedDelete message from the specified reader or buffer.\n   * @function decode\n   * @memberof CGCMsgMemCachedDelete\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CGCMsgMemCachedDelete} CGCMsgMemCachedDelete\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CGCMsgMemCachedDelete.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CGCMsgMemCachedDelete();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.keys && message.keys.length)) message.keys = [];\n          message.keys.push(reader.string());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CGCMsgMemCachedDelete;\n})();\n\nexports.CGCMsgMemCachedStats = $root.CGCMsgMemCachedStats = (() => {\n  /**\n   * Properties of a CGCMsgMemCachedStats.\n   * @exports ICGCMsgMemCachedStats\n   * @interface ICGCMsgMemCachedStats\n   */\n\n  /**\n   * Constructs a new CGCMsgMemCachedStats.\n   * @exports CGCMsgMemCachedStats\n   * @classdesc Represents a CGCMsgMemCachedStats.\n   * @implements ICGCMsgMemCachedStats\n   * @constructor\n   * @param {ICGCMsgMemCachedStats=} [properties] Properties to set\n   */\n  function CGCMsgMemCachedStats(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * Decodes a CGCMsgMemCachedStats message from the specified reader or buffer.\n   * @function decode\n   * @memberof CGCMsgMemCachedStats\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CGCMsgMemCachedStats} CGCMsgMemCachedStats\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  CGCMsgMemCachedStats.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CGCMsgMemCachedStats();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CGCMsgMemCachedStats;\n})();\n\nexports.CGCMsgMemCachedStatsResponse = $root.CGCMsgMemCachedStatsResponse = (() => {\n  /**\n   * Properties of a CGCMsgMemCachedStatsResponse.\n   * @exports ICGCMsgMemCachedStatsResponse\n   * @interface ICGCMsgMemCachedStatsResponse\n   * @property {number|Long|null} [currConnections] CGCMsgMemCachedStatsResponse currConnections\n   * @property {number|Long|null} [cmdGet] CGCMsgMemCachedStatsResponse cmdGet\n   * @property {number|Long|null} [cmdSet] CGCMsgMemCachedStatsResponse cmdSet\n   * @property {number|Long|null} [cmdFlush] CGCMsgMemCachedStatsResponse cmdFlush\n   * @property {number|Long|null} [getHits] CGCMsgMemCachedStatsResponse getHits\n   * @property {number|Long|null} [getMisses] CGCMsgMemCachedStatsResponse getMisses\n   * @property {number|Long|null} [deleteHits] CGCMsgMemCachedStatsResponse deleteHits\n   * @property {number|Long|null} [deleteMisses] CGCMsgMemCachedStatsResponse deleteMisses\n   * @property {number|Long|null} [bytesRead] CGCMsgMemCachedStatsResponse bytesRead\n   * @property {number|Long|null} [bytesWritten] CGCMsgMemCachedStatsResponse bytesWritten\n   * @property {number|Long|null} [limitMaxbytes] CGCMsgMemCachedStatsResponse limitMaxbytes\n   * @property {number|Long|null} [currItems] CGCMsgMemCachedStatsResponse currItems\n   * @property {number|Long|null} [evictions] CGCMsgMemCachedStatsResponse evictions\n   * @property {number|Long|null} [bytes] CGCMsgMemCachedStatsResponse bytes\n   */\n\n  /**\n   * Constructs a new CGCMsgMemCachedStatsResponse.\n   * @exports CGCMsgMemCachedStatsResponse\n   * @classdesc Represents a CGCMsgMemCachedStatsResponse.\n   * @implements ICGCMsgMemCachedStatsResponse\n   * @constructor\n   * @param {ICGCMsgMemCachedStatsResponse=} [properties] Properties to set\n   */\n  function CGCMsgMemCachedStatsResponse(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CGCMsgMemCachedStatsResponse currConnections.\n   * @member {number|Long} currConnections\n   * @memberof CGCMsgMemCachedStatsResponse\n   * @instance\n   */\n\n\n  CGCMsgMemCachedStatsResponse.prototype.currConnections = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CGCMsgMemCachedStatsResponse cmdGet.\n   * @member {number|Long} cmdGet\n   * @memberof CGCMsgMemCachedStatsResponse\n   * @instance\n   */\n\n  CGCMsgMemCachedStatsResponse.prototype.cmdGet = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CGCMsgMemCachedStatsResponse cmdSet.\n   * @member {number|Long} cmdSet\n   * @memberof CGCMsgMemCachedStatsResponse\n   * @instance\n   */\n\n  CGCMsgMemCachedStatsResponse.prototype.cmdSet = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CGCMsgMemCachedStatsResponse cmdFlush.\n   * @member {number|Long} cmdFlush\n   * @memberof CGCMsgMemCachedStatsResponse\n   * @instance\n   */\n\n  CGCMsgMemCachedStatsResponse.prototype.cmdFlush = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CGCMsgMemCachedStatsResponse getHits.\n   * @member {number|Long} getHits\n   * @memberof CGCMsgMemCachedStatsResponse\n   * @instance\n   */\n\n  CGCMsgMemCachedStatsResponse.prototype.getHits = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CGCMsgMemCachedStatsResponse getMisses.\n   * @member {number|Long} getMisses\n   * @memberof CGCMsgMemCachedStatsResponse\n   * @instance\n   */\n\n  CGCMsgMemCachedStatsResponse.prototype.getMisses = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CGCMsgMemCachedStatsResponse deleteHits.\n   * @member {number|Long} deleteHits\n   * @memberof CGCMsgMemCachedStatsResponse\n   * @instance\n   */\n\n  CGCMsgMemCachedStatsResponse.prototype.deleteHits = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CGCMsgMemCachedStatsResponse deleteMisses.\n   * @member {number|Long} deleteMisses\n   * @memberof CGCMsgMemCachedStatsResponse\n   * @instance\n   */\n\n  CGCMsgMemCachedStatsResponse.prototype.deleteMisses = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CGCMsgMemCachedStatsResponse bytesRead.\n   * @member {number|Long} bytesRead\n   * @memberof CGCMsgMemCachedStatsResponse\n   * @instance\n   */\n\n  CGCMsgMemCachedStatsResponse.prototype.bytesRead = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CGCMsgMemCachedStatsResponse bytesWritten.\n   * @member {number|Long} bytesWritten\n   * @memberof CGCMsgMemCachedStatsResponse\n   * @instance\n   */\n\n  CGCMsgMemCachedStatsResponse.prototype.bytesWritten = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CGCMsgMemCachedStatsResponse limitMaxbytes.\n   * @member {number|Long} limitMaxbytes\n   * @memberof CGCMsgMemCachedStatsResponse\n   * @instance\n   */\n\n  CGCMsgMemCachedStatsResponse.prototype.limitMaxbytes = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CGCMsgMemCachedStatsResponse currItems.\n   * @member {number|Long} currItems\n   * @memberof CGCMsgMemCachedStatsResponse\n   * @instance\n   */\n\n  CGCMsgMemCachedStatsResponse.prototype.currItems = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CGCMsgMemCachedStatsResponse evictions.\n   * @member {number|Long} evictions\n   * @memberof CGCMsgMemCachedStatsResponse\n   * @instance\n   */\n\n  CGCMsgMemCachedStatsResponse.prototype.evictions = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * CGCMsgMemCachedStatsResponse bytes.\n   * @member {number|Long} bytes\n   * @memberof CGCMsgMemCachedStatsResponse\n   * @instance\n   */\n\n  CGCMsgMemCachedStatsResponse.prototype.bytes = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;\n  /**\n   * Decodes a CGCMsgMemCachedStatsResponse message from the specified reader or buffer.\n   * @function decode\n   * @memberof CGCMsgMemCachedStatsResponse\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CGCMsgMemCachedStatsResponse} CGCMsgMemCachedStatsResponse\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CGCMsgMemCachedStatsResponse.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CGCMsgMemCachedStatsResponse();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.currConnections = reader.uint64();\n          break;\n\n        case 2:\n          message.cmdGet = reader.uint64();\n          break;\n\n        case 3:\n          message.cmdSet = reader.uint64();\n          break;\n\n        case 4:\n          message.cmdFlush = reader.uint64();\n          break;\n\n        case 5:\n          message.getHits = reader.uint64();\n          break;\n\n        case 6:\n          message.getMisses = reader.uint64();\n          break;\n\n        case 7:\n          message.deleteHits = reader.uint64();\n          break;\n\n        case 8:\n          message.deleteMisses = reader.uint64();\n          break;\n\n        case 9:\n          message.bytesRead = reader.uint64();\n          break;\n\n        case 10:\n          message.bytesWritten = reader.uint64();\n          break;\n\n        case 11:\n          message.limitMaxbytes = reader.uint64();\n          break;\n\n        case 12:\n          message.currItems = reader.uint64();\n          break;\n\n        case 13:\n          message.evictions = reader.uint64();\n          break;\n\n        case 14:\n          message.bytes = reader.uint64();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CGCMsgMemCachedStatsResponse;\n})();\n\nexports.CGCMsgSQLStats = $root.CGCMsgSQLStats = (() => {\n  /**\n   * Properties of a CGCMsgSQLStats.\n   * @exports ICGCMsgSQLStats\n   * @interface ICGCMsgSQLStats\n   * @property {number|null} [schemaCatalog] CGCMsgSQLStats schemaCatalog\n   */\n\n  /**\n   * Constructs a new CGCMsgSQLStats.\n   * @exports CGCMsgSQLStats\n   * @classdesc Represents a CGCMsgSQLStats.\n   * @implements ICGCMsgSQLStats\n   * @constructor\n   * @param {ICGCMsgSQLStats=} [properties] Properties to set\n   */\n  function CGCMsgSQLStats(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CGCMsgSQLStats schemaCatalog.\n   * @member {number} schemaCatalog\n   * @memberof CGCMsgSQLStats\n   * @instance\n   */\n\n\n  CGCMsgSQLStats.prototype.schemaCatalog = 0;\n  /**\n   * Decodes a CGCMsgSQLStats message from the specified reader or buffer.\n   * @function decode\n   * @memberof CGCMsgSQLStats\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CGCMsgSQLStats} CGCMsgSQLStats\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CGCMsgSQLStats.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CGCMsgSQLStats();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.schemaCatalog = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CGCMsgSQLStats;\n})();\n\nexports.CGCMsgSQLStatsResponse = $root.CGCMsgSQLStatsResponse = (() => {\n  /**\n   * Properties of a CGCMsgSQLStatsResponse.\n   * @exports ICGCMsgSQLStatsResponse\n   * @interface ICGCMsgSQLStatsResponse\n   * @property {number|null} [threads] CGCMsgSQLStatsResponse threads\n   * @property {number|null} [threadsConnected] CGCMsgSQLStatsResponse threadsConnected\n   * @property {number|null} [threadsActive] CGCMsgSQLStatsResponse threadsActive\n   * @property {number|null} [operationsSubmitted] CGCMsgSQLStatsResponse operationsSubmitted\n   * @property {number|null} [preparedStatementsExecuted] CGCMsgSQLStatsResponse preparedStatementsExecuted\n   * @property {number|null} [nonPreparedStatementsExecuted] CGCMsgSQLStatsResponse nonPreparedStatementsExecuted\n   * @property {number|null} [deadlockRetries] CGCMsgSQLStatsResponse deadlockRetries\n   * @property {number|null} [operationsTimedOutInQueue] CGCMsgSQLStatsResponse operationsTimedOutInQueue\n   * @property {number|null} [errors] CGCMsgSQLStatsResponse errors\n   */\n\n  /**\n   * Constructs a new CGCMsgSQLStatsResponse.\n   * @exports CGCMsgSQLStatsResponse\n   * @classdesc Represents a CGCMsgSQLStatsResponse.\n   * @implements ICGCMsgSQLStatsResponse\n   * @constructor\n   * @param {ICGCMsgSQLStatsResponse=} [properties] Properties to set\n   */\n  function CGCMsgSQLStatsResponse(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CGCMsgSQLStatsResponse threads.\n   * @member {number} threads\n   * @memberof CGCMsgSQLStatsResponse\n   * @instance\n   */\n\n\n  CGCMsgSQLStatsResponse.prototype.threads = 0;\n  /**\n   * CGCMsgSQLStatsResponse threadsConnected.\n   * @member {number} threadsConnected\n   * @memberof CGCMsgSQLStatsResponse\n   * @instance\n   */\n\n  CGCMsgSQLStatsResponse.prototype.threadsConnected = 0;\n  /**\n   * CGCMsgSQLStatsResponse threadsActive.\n   * @member {number} threadsActive\n   * @memberof CGCMsgSQLStatsResponse\n   * @instance\n   */\n\n  CGCMsgSQLStatsResponse.prototype.threadsActive = 0;\n  /**\n   * CGCMsgSQLStatsResponse operationsSubmitted.\n   * @member {number} operationsSubmitted\n   * @memberof CGCMsgSQLStatsResponse\n   * @instance\n   */\n\n  CGCMsgSQLStatsResponse.prototype.operationsSubmitted = 0;\n  /**\n   * CGCMsgSQLStatsResponse preparedStatementsExecuted.\n   * @member {number} preparedStatementsExecuted\n   * @memberof CGCMsgSQLStatsResponse\n   * @instance\n   */\n\n  CGCMsgSQLStatsResponse.prototype.preparedStatementsExecuted = 0;\n  /**\n   * CGCMsgSQLStatsResponse nonPreparedStatementsExecuted.\n   * @member {number} nonPreparedStatementsExecuted\n   * @memberof CGCMsgSQLStatsResponse\n   * @instance\n   */\n\n  CGCMsgSQLStatsResponse.prototype.nonPreparedStatementsExecuted = 0;\n  /**\n   * CGCMsgSQLStatsResponse deadlockRetries.\n   * @member {number} deadlockRetries\n   * @memberof CGCMsgSQLStatsResponse\n   * @instance\n   */\n\n  CGCMsgSQLStatsResponse.prototype.deadlockRetries = 0;\n  /**\n   * CGCMsgSQLStatsResponse operationsTimedOutInQueue.\n   * @member {number} operationsTimedOutInQueue\n   * @memberof CGCMsgSQLStatsResponse\n   * @instance\n   */\n\n  CGCMsgSQLStatsResponse.prototype.operationsTimedOutInQueue = 0;\n  /**\n   * CGCMsgSQLStatsResponse errors.\n   * @member {number} errors\n   * @memberof CGCMsgSQLStatsResponse\n   * @instance\n   */\n\n  CGCMsgSQLStatsResponse.prototype.errors = 0;\n  /**\n   * Decodes a CGCMsgSQLStatsResponse message from the specified reader or buffer.\n   * @function decode\n   * @memberof CGCMsgSQLStatsResponse\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CGCMsgSQLStatsResponse} CGCMsgSQLStatsResponse\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CGCMsgSQLStatsResponse.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CGCMsgSQLStatsResponse();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.threads = reader.uint32();\n          break;\n\n        case 2:\n          message.threadsConnected = reader.uint32();\n          break;\n\n        case 3:\n          message.threadsActive = reader.uint32();\n          break;\n\n        case 4:\n          message.operationsSubmitted = reader.uint32();\n          break;\n\n        case 5:\n          message.preparedStatementsExecuted = reader.uint32();\n          break;\n\n        case 6:\n          message.nonPreparedStatementsExecuted = reader.uint32();\n          break;\n\n        case 7:\n          message.deadlockRetries = reader.uint32();\n          break;\n\n        case 8:\n          message.operationsTimedOutInQueue = reader.uint32();\n          break;\n\n        case 9:\n          message.errors = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CGCMsgSQLStatsResponse;\n})();\n\nexports.CMsgAMAddFreeLicense = $root.CMsgAMAddFreeLicense = (() => {\n  /**\n   * Properties of a CMsgAMAddFreeLicense.\n   * @exports ICMsgAMAddFreeLicense\n   * @interface ICMsgAMAddFreeLicense\n   * @property {number|Long|null} [steamid] CMsgAMAddFreeLicense steamid\n   * @property {number|null} [ipPublic] CMsgAMAddFreeLicense ipPublic\n   * @property {number|null} [packageid] CMsgAMAddFreeLicense packageid\n   * @property {string|null} [storeCountryCode] CMsgAMAddFreeLicense storeCountryCode\n   */\n\n  /**\n   * Constructs a new CMsgAMAddFreeLicense.\n   * @exports CMsgAMAddFreeLicense\n   * @classdesc Represents a CMsgAMAddFreeLicense.\n   * @implements ICMsgAMAddFreeLicense\n   * @constructor\n   * @param {ICMsgAMAddFreeLicense=} [properties] Properties to set\n   */\n  function CMsgAMAddFreeLicense(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgAMAddFreeLicense steamid.\n   * @member {number|Long} steamid\n   * @memberof CMsgAMAddFreeLicense\n   * @instance\n   */\n\n\n  CMsgAMAddFreeLicense.prototype.steamid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n  /**\n   * CMsgAMAddFreeLicense ipPublic.\n   * @member {number} ipPublic\n   * @memberof CMsgAMAddFreeLicense\n   * @instance\n   */\n\n  CMsgAMAddFreeLicense.prototype.ipPublic = 0;\n  /**\n   * CMsgAMAddFreeLicense packageid.\n   * @member {number} packageid\n   * @memberof CMsgAMAddFreeLicense\n   * @instance\n   */\n\n  CMsgAMAddFreeLicense.prototype.packageid = 0;\n  /**\n   * CMsgAMAddFreeLicense storeCountryCode.\n   * @member {string} storeCountryCode\n   * @memberof CMsgAMAddFreeLicense\n   * @instance\n   */\n\n  CMsgAMAddFreeLicense.prototype.storeCountryCode = \"\";\n  /**\n   * Decodes a CMsgAMAddFreeLicense message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgAMAddFreeLicense\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgAMAddFreeLicense} CMsgAMAddFreeLicense\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgAMAddFreeLicense.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgAMAddFreeLicense();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.steamid = reader.fixed64();\n          break;\n\n        case 2:\n          message.ipPublic = reader.uint32();\n          break;\n\n        case 3:\n          message.packageid = reader.uint32();\n          break;\n\n        case 4:\n          message.storeCountryCode = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgAMAddFreeLicense;\n})();\n\nexports.CMsgAMAddFreeLicenseResponse = $root.CMsgAMAddFreeLicenseResponse = (() => {\n  /**\n   * Properties of a CMsgAMAddFreeLicenseResponse.\n   * @exports ICMsgAMAddFreeLicenseResponse\n   * @interface ICMsgAMAddFreeLicenseResponse\n   * @property {number|null} [eresult] CMsgAMAddFreeLicenseResponse eresult\n   * @property {number|null} [purchaseResultDetail] CMsgAMAddFreeLicenseResponse purchaseResultDetail\n   * @property {number|Long|null} [transid] CMsgAMAddFreeLicenseResponse transid\n   */\n\n  /**\n   * Constructs a new CMsgAMAddFreeLicenseResponse.\n   * @exports CMsgAMAddFreeLicenseResponse\n   * @classdesc Represents a CMsgAMAddFreeLicenseResponse.\n   * @implements ICMsgAMAddFreeLicenseResponse\n   * @constructor\n   * @param {ICMsgAMAddFreeLicenseResponse=} [properties] Properties to set\n   */\n  function CMsgAMAddFreeLicenseResponse(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgAMAddFreeLicenseResponse eresult.\n   * @member {number} eresult\n   * @memberof CMsgAMAddFreeLicenseResponse\n   * @instance\n   */\n\n\n  CMsgAMAddFreeLicenseResponse.prototype.eresult = 2;\n  /**\n   * CMsgAMAddFreeLicenseResponse purchaseResultDetail.\n   * @member {number} purchaseResultDetail\n   * @memberof CMsgAMAddFreeLicenseResponse\n   * @instance\n   */\n\n  CMsgAMAddFreeLicenseResponse.prototype.purchaseResultDetail = 0;\n  /**\n   * CMsgAMAddFreeLicenseResponse transid.\n   * @member {number|Long} transid\n   * @memberof CMsgAMAddFreeLicenseResponse\n   * @instance\n   */\n\n  CMsgAMAddFreeLicenseResponse.prototype.transid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n  /**\n   * Decodes a CMsgAMAddFreeLicenseResponse message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgAMAddFreeLicenseResponse\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgAMAddFreeLicenseResponse} CMsgAMAddFreeLicenseResponse\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgAMAddFreeLicenseResponse.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgAMAddFreeLicenseResponse();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.eresult = reader.int32();\n          break;\n\n        case 2:\n          message.purchaseResultDetail = reader.int32();\n          break;\n\n        case 3:\n          message.transid = reader.fixed64();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgAMAddFreeLicenseResponse;\n})();\n\nexports.CGCMsgGetIPLocation = $root.CGCMsgGetIPLocation = (() => {\n  /**\n   * Properties of a CGCMsgGetIPLocation.\n   * @exports ICGCMsgGetIPLocation\n   * @interface ICGCMsgGetIPLocation\n   * @property {Array.<number>|null} [ips] CGCMsgGetIPLocation ips\n   */\n\n  /**\n   * Constructs a new CGCMsgGetIPLocation.\n   * @exports CGCMsgGetIPLocation\n   * @classdesc Represents a CGCMsgGetIPLocation.\n   * @implements ICGCMsgGetIPLocation\n   * @constructor\n   * @param {ICGCMsgGetIPLocation=} [properties] Properties to set\n   */\n  function CGCMsgGetIPLocation(properties) {\n    this.ips = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CGCMsgGetIPLocation ips.\n   * @member {Array.<number>} ips\n   * @memberof CGCMsgGetIPLocation\n   * @instance\n   */\n\n\n  CGCMsgGetIPLocation.prototype.ips = $util.emptyArray;\n  /**\n   * Decodes a CGCMsgGetIPLocation message from the specified reader or buffer.\n   * @function decode\n   * @memberof CGCMsgGetIPLocation\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CGCMsgGetIPLocation} CGCMsgGetIPLocation\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CGCMsgGetIPLocation.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CGCMsgGetIPLocation();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.ips && message.ips.length)) message.ips = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.ips.push(reader.fixed32());\n          } else message.ips.push(reader.fixed32());\n\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CGCMsgGetIPLocation;\n})();\n\nexports.CIPLocationInfo = $root.CIPLocationInfo = (() => {\n  /**\n   * Properties of a CIPLocationInfo.\n   * @exports ICIPLocationInfo\n   * @interface ICIPLocationInfo\n   * @property {number|null} [ip] CIPLocationInfo ip\n   * @property {number|null} [latitude] CIPLocationInfo latitude\n   * @property {number|null} [longitude] CIPLocationInfo longitude\n   * @property {string|null} [country] CIPLocationInfo country\n   * @property {string|null} [state] CIPLocationInfo state\n   * @property {string|null} [city] CIPLocationInfo city\n   */\n\n  /**\n   * Constructs a new CIPLocationInfo.\n   * @exports CIPLocationInfo\n   * @classdesc Represents a CIPLocationInfo.\n   * @implements ICIPLocationInfo\n   * @constructor\n   * @param {ICIPLocationInfo=} [properties] Properties to set\n   */\n  function CIPLocationInfo(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CIPLocationInfo ip.\n   * @member {number} ip\n   * @memberof CIPLocationInfo\n   * @instance\n   */\n\n\n  CIPLocationInfo.prototype.ip = 0;\n  /**\n   * CIPLocationInfo latitude.\n   * @member {number} latitude\n   * @memberof CIPLocationInfo\n   * @instance\n   */\n\n  CIPLocationInfo.prototype.latitude = 0;\n  /**\n   * CIPLocationInfo longitude.\n   * @member {number} longitude\n   * @memberof CIPLocationInfo\n   * @instance\n   */\n\n  CIPLocationInfo.prototype.longitude = 0;\n  /**\n   * CIPLocationInfo country.\n   * @member {string} country\n   * @memberof CIPLocationInfo\n   * @instance\n   */\n\n  CIPLocationInfo.prototype.country = \"\";\n  /**\n   * CIPLocationInfo state.\n   * @member {string} state\n   * @memberof CIPLocationInfo\n   * @instance\n   */\n\n  CIPLocationInfo.prototype.state = \"\";\n  /**\n   * CIPLocationInfo city.\n   * @member {string} city\n   * @memberof CIPLocationInfo\n   * @instance\n   */\n\n  CIPLocationInfo.prototype.city = \"\";\n  /**\n   * Decodes a CIPLocationInfo message from the specified reader or buffer.\n   * @function decode\n   * @memberof CIPLocationInfo\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CIPLocationInfo} CIPLocationInfo\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CIPLocationInfo.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CIPLocationInfo();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.ip = reader.uint32();\n          break;\n\n        case 2:\n          message.latitude = reader.float();\n          break;\n\n        case 3:\n          message.longitude = reader.float();\n          break;\n\n        case 4:\n          message.country = reader.string();\n          break;\n\n        case 5:\n          message.state = reader.string();\n          break;\n\n        case 6:\n          message.city = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CIPLocationInfo;\n})();\n\nexports.CGCMsgGetIPLocationResponse = $root.CGCMsgGetIPLocationResponse = (() => {\n  /**\n   * Properties of a CGCMsgGetIPLocationResponse.\n   * @exports ICGCMsgGetIPLocationResponse\n   * @interface ICGCMsgGetIPLocationResponse\n   * @property {Array.<ICIPLocationInfo>|null} [infos] CGCMsgGetIPLocationResponse infos\n   */\n\n  /**\n   * Constructs a new CGCMsgGetIPLocationResponse.\n   * @exports CGCMsgGetIPLocationResponse\n   * @classdesc Represents a CGCMsgGetIPLocationResponse.\n   * @implements ICGCMsgGetIPLocationResponse\n   * @constructor\n   * @param {ICGCMsgGetIPLocationResponse=} [properties] Properties to set\n   */\n  function CGCMsgGetIPLocationResponse(properties) {\n    this.infos = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CGCMsgGetIPLocationResponse infos.\n   * @member {Array.<ICIPLocationInfo>} infos\n   * @memberof CGCMsgGetIPLocationResponse\n   * @instance\n   */\n\n\n  CGCMsgGetIPLocationResponse.prototype.infos = $util.emptyArray;\n  /**\n   * Decodes a CGCMsgGetIPLocationResponse message from the specified reader or buffer.\n   * @function decode\n   * @memberof CGCMsgGetIPLocationResponse\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CGCMsgGetIPLocationResponse} CGCMsgGetIPLocationResponse\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CGCMsgGetIPLocationResponse.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CGCMsgGetIPLocationResponse();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.infos && message.infos.length)) message.infos = [];\n          message.infos.push($root.CIPLocationInfo.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CGCMsgGetIPLocationResponse;\n})();\n\nexports.CGCMsgSystemStatsSchema = $root.CGCMsgSystemStatsSchema = (() => {\n  /**\n   * Properties of a CGCMsgSystemStatsSchema.\n   * @exports ICGCMsgSystemStatsSchema\n   * @interface ICGCMsgSystemStatsSchema\n   * @property {number|null} [gcAppId] CGCMsgSystemStatsSchema gcAppId\n   * @property {Uint8Array|null} [schemaKv] CGCMsgSystemStatsSchema schemaKv\n   */\n\n  /**\n   * Constructs a new CGCMsgSystemStatsSchema.\n   * @exports CGCMsgSystemStatsSchema\n   * @classdesc Represents a CGCMsgSystemStatsSchema.\n   * @implements ICGCMsgSystemStatsSchema\n   * @constructor\n   * @param {ICGCMsgSystemStatsSchema=} [properties] Properties to set\n   */\n  function CGCMsgSystemStatsSchema(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CGCMsgSystemStatsSchema gcAppId.\n   * @member {number} gcAppId\n   * @memberof CGCMsgSystemStatsSchema\n   * @instance\n   */\n\n\n  CGCMsgSystemStatsSchema.prototype.gcAppId = 0;\n  /**\n   * CGCMsgSystemStatsSchema schemaKv.\n   * @member {Uint8Array} schemaKv\n   * @memberof CGCMsgSystemStatsSchema\n   * @instance\n   */\n\n  CGCMsgSystemStatsSchema.prototype.schemaKv = $util.newBuffer([]);\n  /**\n   * Decodes a CGCMsgSystemStatsSchema message from the specified reader or buffer.\n   * @function decode\n   * @memberof CGCMsgSystemStatsSchema\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CGCMsgSystemStatsSchema} CGCMsgSystemStatsSchema\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CGCMsgSystemStatsSchema.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CGCMsgSystemStatsSchema();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.gcAppId = reader.uint32();\n          break;\n\n        case 2:\n          message.schemaKv = reader.bytes();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CGCMsgSystemStatsSchema;\n})();\n\nexports.CGCMsgGetSystemStats = $root.CGCMsgGetSystemStats = (() => {\n  /**\n   * Properties of a CGCMsgGetSystemStats.\n   * @exports ICGCMsgGetSystemStats\n   * @interface ICGCMsgGetSystemStats\n   */\n\n  /**\n   * Constructs a new CGCMsgGetSystemStats.\n   * @exports CGCMsgGetSystemStats\n   * @classdesc Represents a CGCMsgGetSystemStats.\n   * @implements ICGCMsgGetSystemStats\n   * @constructor\n   * @param {ICGCMsgGetSystemStats=} [properties] Properties to set\n   */\n  function CGCMsgGetSystemStats(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * Decodes a CGCMsgGetSystemStats message from the specified reader or buffer.\n   * @function decode\n   * @memberof CGCMsgGetSystemStats\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CGCMsgGetSystemStats} CGCMsgGetSystemStats\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n\n  CGCMsgGetSystemStats.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CGCMsgGetSystemStats();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CGCMsgGetSystemStats;\n})();\n\nexports.CGCMsgGetSystemStatsResponse = $root.CGCMsgGetSystemStatsResponse = (() => {\n  /**\n   * Properties of a CGCMsgGetSystemStatsResponse.\n   * @exports ICGCMsgGetSystemStatsResponse\n   * @interface ICGCMsgGetSystemStatsResponse\n   * @property {number|null} [gcAppId] CGCMsgGetSystemStatsResponse gcAppId\n   * @property {Uint8Array|null} [statsKv] CGCMsgGetSystemStatsResponse statsKv\n   * @property {number|null} [activeJobs] CGCMsgGetSystemStatsResponse activeJobs\n   * @property {number|null} [yieldingJobs] CGCMsgGetSystemStatsResponse yieldingJobs\n   * @property {number|null} [userSessions] CGCMsgGetSystemStatsResponse userSessions\n   * @property {number|null} [gameServerSessions] CGCMsgGetSystemStatsResponse gameServerSessions\n   * @property {number|null} [socaches] CGCMsgGetSystemStatsResponse socaches\n   * @property {number|null} [socachesToUnload] CGCMsgGetSystemStatsResponse socachesToUnload\n   * @property {number|null} [socachesLoading] CGCMsgGetSystemStatsResponse socachesLoading\n   * @property {number|null} [writebackQueue] CGCMsgGetSystemStatsResponse writebackQueue\n   * @property {number|null} [steamidLocks] CGCMsgGetSystemStatsResponse steamidLocks\n   * @property {number|null} [logonQueue] CGCMsgGetSystemStatsResponse logonQueue\n   * @property {number|null} [logonJobs] CGCMsgGetSystemStatsResponse logonJobs\n   */\n\n  /**\n   * Constructs a new CGCMsgGetSystemStatsResponse.\n   * @exports CGCMsgGetSystemStatsResponse\n   * @classdesc Represents a CGCMsgGetSystemStatsResponse.\n   * @implements ICGCMsgGetSystemStatsResponse\n   * @constructor\n   * @param {ICGCMsgGetSystemStatsResponse=} [properties] Properties to set\n   */\n  function CGCMsgGetSystemStatsResponse(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CGCMsgGetSystemStatsResponse gcAppId.\n   * @member {number} gcAppId\n   * @memberof CGCMsgGetSystemStatsResponse\n   * @instance\n   */\n\n\n  CGCMsgGetSystemStatsResponse.prototype.gcAppId = 0;\n  /**\n   * CGCMsgGetSystemStatsResponse statsKv.\n   * @member {Uint8Array} statsKv\n   * @memberof CGCMsgGetSystemStatsResponse\n   * @instance\n   */\n\n  CGCMsgGetSystemStatsResponse.prototype.statsKv = $util.newBuffer([]);\n  /**\n   * CGCMsgGetSystemStatsResponse activeJobs.\n   * @member {number} activeJobs\n   * @memberof CGCMsgGetSystemStatsResponse\n   * @instance\n   */\n\n  CGCMsgGetSystemStatsResponse.prototype.activeJobs = 0;\n  /**\n   * CGCMsgGetSystemStatsResponse yieldingJobs.\n   * @member {number} yieldingJobs\n   * @memberof CGCMsgGetSystemStatsResponse\n   * @instance\n   */\n\n  CGCMsgGetSystemStatsResponse.prototype.yieldingJobs = 0;\n  /**\n   * CGCMsgGetSystemStatsResponse userSessions.\n   * @member {number} userSessions\n   * @memberof CGCMsgGetSystemStatsResponse\n   * @instance\n   */\n\n  CGCMsgGetSystemStatsResponse.prototype.userSessions = 0;\n  /**\n   * CGCMsgGetSystemStatsResponse gameServerSessions.\n   * @member {number} gameServerSessions\n   * @memberof CGCMsgGetSystemStatsResponse\n   * @instance\n   */\n\n  CGCMsgGetSystemStatsResponse.prototype.gameServerSessions = 0;\n  /**\n   * CGCMsgGetSystemStatsResponse socaches.\n   * @member {number} socaches\n   * @memberof CGCMsgGetSystemStatsResponse\n   * @instance\n   */\n\n  CGCMsgGetSystemStatsResponse.prototype.socaches = 0;\n  /**\n   * CGCMsgGetSystemStatsResponse socachesToUnload.\n   * @member {number} socachesToUnload\n   * @memberof CGCMsgGetSystemStatsResponse\n   * @instance\n   */\n\n  CGCMsgGetSystemStatsResponse.prototype.socachesToUnload = 0;\n  /**\n   * CGCMsgGetSystemStatsResponse socachesLoading.\n   * @member {number} socachesLoading\n   * @memberof CGCMsgGetSystemStatsResponse\n   * @instance\n   */\n\n  CGCMsgGetSystemStatsResponse.prototype.socachesLoading = 0;\n  /**\n   * CGCMsgGetSystemStatsResponse writebackQueue.\n   * @member {number} writebackQueue\n   * @memberof CGCMsgGetSystemStatsResponse\n   * @instance\n   */\n\n  CGCMsgGetSystemStatsResponse.prototype.writebackQueue = 0;\n  /**\n   * CGCMsgGetSystemStatsResponse steamidLocks.\n   * @member {number} steamidLocks\n   * @memberof CGCMsgGetSystemStatsResponse\n   * @instance\n   */\n\n  CGCMsgGetSystemStatsResponse.prototype.steamidLocks = 0;\n  /**\n   * CGCMsgGetSystemStatsResponse logonQueue.\n   * @member {number} logonQueue\n   * @memberof CGCMsgGetSystemStatsResponse\n   * @instance\n   */\n\n  CGCMsgGetSystemStatsResponse.prototype.logonQueue = 0;\n  /**\n   * CGCMsgGetSystemStatsResponse logonJobs.\n   * @member {number} logonJobs\n   * @memberof CGCMsgGetSystemStatsResponse\n   * @instance\n   */\n\n  CGCMsgGetSystemStatsResponse.prototype.logonJobs = 0;\n  /**\n   * Decodes a CGCMsgGetSystemStatsResponse message from the specified reader or buffer.\n   * @function decode\n   * @memberof CGCMsgGetSystemStatsResponse\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CGCMsgGetSystemStatsResponse} CGCMsgGetSystemStatsResponse\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CGCMsgGetSystemStatsResponse.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CGCMsgGetSystemStatsResponse();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.gcAppId = reader.uint32();\n          break;\n\n        case 2:\n          message.statsKv = reader.bytes();\n          break;\n\n        case 3:\n          message.activeJobs = reader.uint32();\n          break;\n\n        case 4:\n          message.yieldingJobs = reader.uint32();\n          break;\n\n        case 5:\n          message.userSessions = reader.uint32();\n          break;\n\n        case 6:\n          message.gameServerSessions = reader.uint32();\n          break;\n\n        case 7:\n          message.socaches = reader.uint32();\n          break;\n\n        case 8:\n          message.socachesToUnload = reader.uint32();\n          break;\n\n        case 9:\n          message.socachesLoading = reader.uint32();\n          break;\n\n        case 10:\n          message.writebackQueue = reader.uint32();\n          break;\n\n        case 11:\n          message.steamidLocks = reader.uint32();\n          break;\n\n        case 12:\n          message.logonQueue = reader.uint32();\n          break;\n\n        case 13:\n          message.logonJobs = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CGCMsgGetSystemStatsResponse;\n})();\n\nexports.CMsgAMSendEmail = $root.CMsgAMSendEmail = (() => {\n  /**\n   * Properties of a CMsgAMSendEmail.\n   * @exports ICMsgAMSendEmail\n   * @interface ICMsgAMSendEmail\n   * @property {number|Long|null} [steamid] CMsgAMSendEmail steamid\n   * @property {number|null} [emailMsgType] CMsgAMSendEmail emailMsgType\n   * @property {number|null} [emailFormat] CMsgAMSendEmail emailFormat\n   * @property {Array.<CMsgAMSendEmail.IPersonaNameReplacementToken>|null} [personaNameTokens] CMsgAMSendEmail personaNameTokens\n   * @property {number|null} [sourceGc] CMsgAMSendEmail sourceGc\n   * @property {Array.<CMsgAMSendEmail.IReplacementToken>|null} [tokens] CMsgAMSendEmail tokens\n   */\n\n  /**\n   * Constructs a new CMsgAMSendEmail.\n   * @exports CMsgAMSendEmail\n   * @classdesc Represents a CMsgAMSendEmail.\n   * @implements ICMsgAMSendEmail\n   * @constructor\n   * @param {ICMsgAMSendEmail=} [properties] Properties to set\n   */\n  function CMsgAMSendEmail(properties) {\n    this.personaNameTokens = [];\n    this.tokens = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgAMSendEmail steamid.\n   * @member {number|Long} steamid\n   * @memberof CMsgAMSendEmail\n   * @instance\n   */\n\n\n  CMsgAMSendEmail.prototype.steamid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n  /**\n   * CMsgAMSendEmail emailMsgType.\n   * @member {number} emailMsgType\n   * @memberof CMsgAMSendEmail\n   * @instance\n   */\n\n  CMsgAMSendEmail.prototype.emailMsgType = 0;\n  /**\n   * CMsgAMSendEmail emailFormat.\n   * @member {number} emailFormat\n   * @memberof CMsgAMSendEmail\n   * @instance\n   */\n\n  CMsgAMSendEmail.prototype.emailFormat = 0;\n  /**\n   * CMsgAMSendEmail personaNameTokens.\n   * @member {Array.<CMsgAMSendEmail.IPersonaNameReplacementToken>} personaNameTokens\n   * @memberof CMsgAMSendEmail\n   * @instance\n   */\n\n  CMsgAMSendEmail.prototype.personaNameTokens = $util.emptyArray;\n  /**\n   * CMsgAMSendEmail sourceGc.\n   * @member {number} sourceGc\n   * @memberof CMsgAMSendEmail\n   * @instance\n   */\n\n  CMsgAMSendEmail.prototype.sourceGc = 0;\n  /**\n   * CMsgAMSendEmail tokens.\n   * @member {Array.<CMsgAMSendEmail.IReplacementToken>} tokens\n   * @memberof CMsgAMSendEmail\n   * @instance\n   */\n\n  CMsgAMSendEmail.prototype.tokens = $util.emptyArray;\n  /**\n   * Decodes a CMsgAMSendEmail message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgAMSendEmail\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgAMSendEmail} CMsgAMSendEmail\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgAMSendEmail.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgAMSendEmail();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.steamid = reader.fixed64();\n          break;\n\n        case 2:\n          message.emailMsgType = reader.uint32();\n          break;\n\n        case 3:\n          message.emailFormat = reader.uint32();\n          break;\n\n        case 5:\n          if (!(message.personaNameTokens && message.personaNameTokens.length)) message.personaNameTokens = [];\n          message.personaNameTokens.push($root.CMsgAMSendEmail.PersonaNameReplacementToken.decode(reader, reader.uint32()));\n          break;\n\n        case 6:\n          message.sourceGc = reader.uint32();\n          break;\n\n        case 7:\n          if (!(message.tokens && message.tokens.length)) message.tokens = [];\n          message.tokens.push($root.CMsgAMSendEmail.ReplacementToken.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CMsgAMSendEmail.ReplacementToken = function () {\n    /**\n     * Properties of a ReplacementToken.\n     * @memberof CMsgAMSendEmail\n     * @interface IReplacementToken\n     * @property {string|null} [tokenName] ReplacementToken tokenName\n     * @property {string|null} [tokenValue] ReplacementToken tokenValue\n     */\n\n    /**\n     * Constructs a new ReplacementToken.\n     * @memberof CMsgAMSendEmail\n     * @classdesc Represents a ReplacementToken.\n     * @implements IReplacementToken\n     * @constructor\n     * @param {CMsgAMSendEmail.IReplacementToken=} [properties] Properties to set\n     */\n    function ReplacementToken(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * ReplacementToken tokenName.\n     * @member {string} tokenName\n     * @memberof CMsgAMSendEmail.ReplacementToken\n     * @instance\n     */\n\n\n    ReplacementToken.prototype.tokenName = \"\";\n    /**\n     * ReplacementToken tokenValue.\n     * @member {string} tokenValue\n     * @memberof CMsgAMSendEmail.ReplacementToken\n     * @instance\n     */\n\n    ReplacementToken.prototype.tokenValue = \"\";\n    /**\n     * Decodes a ReplacementToken message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgAMSendEmail.ReplacementToken\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgAMSendEmail.ReplacementToken} ReplacementToken\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    ReplacementToken.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CMsgAMSendEmail.ReplacementToken();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.tokenName = reader.string();\n            break;\n\n          case 2:\n            message.tokenValue = reader.string();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return ReplacementToken;\n  }();\n\n  CMsgAMSendEmail.PersonaNameReplacementToken = function () {\n    /**\n     * Properties of a PersonaNameReplacementToken.\n     * @memberof CMsgAMSendEmail\n     * @interface IPersonaNameReplacementToken\n     * @property {number|Long|null} [steamid] PersonaNameReplacementToken steamid\n     * @property {string|null} [tokenName] PersonaNameReplacementToken tokenName\n     */\n\n    /**\n     * Constructs a new PersonaNameReplacementToken.\n     * @memberof CMsgAMSendEmail\n     * @classdesc Represents a PersonaNameReplacementToken.\n     * @implements IPersonaNameReplacementToken\n     * @constructor\n     * @param {CMsgAMSendEmail.IPersonaNameReplacementToken=} [properties] Properties to set\n     */\n    function PersonaNameReplacementToken(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * PersonaNameReplacementToken steamid.\n     * @member {number|Long} steamid\n     * @memberof CMsgAMSendEmail.PersonaNameReplacementToken\n     * @instance\n     */\n\n\n    PersonaNameReplacementToken.prototype.steamid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n    /**\n     * PersonaNameReplacementToken tokenName.\n     * @member {string} tokenName\n     * @memberof CMsgAMSendEmail.PersonaNameReplacementToken\n     * @instance\n     */\n\n    PersonaNameReplacementToken.prototype.tokenName = \"\";\n    /**\n     * Decodes a PersonaNameReplacementToken message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgAMSendEmail.PersonaNameReplacementToken\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgAMSendEmail.PersonaNameReplacementToken} PersonaNameReplacementToken\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    PersonaNameReplacementToken.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CMsgAMSendEmail.PersonaNameReplacementToken();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.steamid = reader.fixed64();\n            break;\n\n          case 2:\n            message.tokenName = reader.string();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return PersonaNameReplacementToken;\n  }();\n\n  return CMsgAMSendEmail;\n})();\n\nexports.CMsgAMSendEmailResponse = $root.CMsgAMSendEmailResponse = (() => {\n  /**\n   * Properties of a CMsgAMSendEmailResponse.\n   * @exports ICMsgAMSendEmailResponse\n   * @interface ICMsgAMSendEmailResponse\n   * @property {number|null} [eresult] CMsgAMSendEmailResponse eresult\n   */\n\n  /**\n   * Constructs a new CMsgAMSendEmailResponse.\n   * @exports CMsgAMSendEmailResponse\n   * @classdesc Represents a CMsgAMSendEmailResponse.\n   * @implements ICMsgAMSendEmailResponse\n   * @constructor\n   * @param {ICMsgAMSendEmailResponse=} [properties] Properties to set\n   */\n  function CMsgAMSendEmailResponse(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgAMSendEmailResponse eresult.\n   * @member {number} eresult\n   * @memberof CMsgAMSendEmailResponse\n   * @instance\n   */\n\n\n  CMsgAMSendEmailResponse.prototype.eresult = 2;\n  /**\n   * Decodes a CMsgAMSendEmailResponse message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgAMSendEmailResponse\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgAMSendEmailResponse} CMsgAMSendEmailResponse\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgAMSendEmailResponse.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgAMSendEmailResponse();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.eresult = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgAMSendEmailResponse;\n})();\n\nexports.CMsgGCGetEmailTemplate = $root.CMsgGCGetEmailTemplate = (() => {\n  /**\n   * Properties of a CMsgGCGetEmailTemplate.\n   * @exports ICMsgGCGetEmailTemplate\n   * @interface ICMsgGCGetEmailTemplate\n   * @property {number|null} [appId] CMsgGCGetEmailTemplate appId\n   * @property {number|null} [emailMsgType] CMsgGCGetEmailTemplate emailMsgType\n   * @property {number|null} [emailLang] CMsgGCGetEmailTemplate emailLang\n   * @property {number|null} [emailFormat] CMsgGCGetEmailTemplate emailFormat\n   */\n\n  /**\n   * Constructs a new CMsgGCGetEmailTemplate.\n   * @exports CMsgGCGetEmailTemplate\n   * @classdesc Represents a CMsgGCGetEmailTemplate.\n   * @implements ICMsgGCGetEmailTemplate\n   * @constructor\n   * @param {ICMsgGCGetEmailTemplate=} [properties] Properties to set\n   */\n  function CMsgGCGetEmailTemplate(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCGetEmailTemplate appId.\n   * @member {number} appId\n   * @memberof CMsgGCGetEmailTemplate\n   * @instance\n   */\n\n\n  CMsgGCGetEmailTemplate.prototype.appId = 0;\n  /**\n   * CMsgGCGetEmailTemplate emailMsgType.\n   * @member {number} emailMsgType\n   * @memberof CMsgGCGetEmailTemplate\n   * @instance\n   */\n\n  CMsgGCGetEmailTemplate.prototype.emailMsgType = 0;\n  /**\n   * CMsgGCGetEmailTemplate emailLang.\n   * @member {number} emailLang\n   * @memberof CMsgGCGetEmailTemplate\n   * @instance\n   */\n\n  CMsgGCGetEmailTemplate.prototype.emailLang = 0;\n  /**\n   * CMsgGCGetEmailTemplate emailFormat.\n   * @member {number} emailFormat\n   * @memberof CMsgGCGetEmailTemplate\n   * @instance\n   */\n\n  CMsgGCGetEmailTemplate.prototype.emailFormat = 0;\n  /**\n   * Decodes a CMsgGCGetEmailTemplate message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCGetEmailTemplate\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCGetEmailTemplate} CMsgGCGetEmailTemplate\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCGetEmailTemplate.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCGetEmailTemplate();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.appId = reader.uint32();\n          break;\n\n        case 2:\n          message.emailMsgType = reader.uint32();\n          break;\n\n        case 3:\n          message.emailLang = reader.int32();\n          break;\n\n        case 4:\n          message.emailFormat = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCGetEmailTemplate;\n})();\n\nexports.CMsgGCGetEmailTemplateResponse = $root.CMsgGCGetEmailTemplateResponse = (() => {\n  /**\n   * Properties of a CMsgGCGetEmailTemplateResponse.\n   * @exports ICMsgGCGetEmailTemplateResponse\n   * @interface ICMsgGCGetEmailTemplateResponse\n   * @property {number|null} [eresult] CMsgGCGetEmailTemplateResponse eresult\n   * @property {boolean|null} [templateExists] CMsgGCGetEmailTemplateResponse templateExists\n   * @property {string|null} [template] CMsgGCGetEmailTemplateResponse template\n   */\n\n  /**\n   * Constructs a new CMsgGCGetEmailTemplateResponse.\n   * @exports CMsgGCGetEmailTemplateResponse\n   * @classdesc Represents a CMsgGCGetEmailTemplateResponse.\n   * @implements ICMsgGCGetEmailTemplateResponse\n   * @constructor\n   * @param {ICMsgGCGetEmailTemplateResponse=} [properties] Properties to set\n   */\n  function CMsgGCGetEmailTemplateResponse(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCGetEmailTemplateResponse eresult.\n   * @member {number} eresult\n   * @memberof CMsgGCGetEmailTemplateResponse\n   * @instance\n   */\n\n\n  CMsgGCGetEmailTemplateResponse.prototype.eresult = 2;\n  /**\n   * CMsgGCGetEmailTemplateResponse templateExists.\n   * @member {boolean} templateExists\n   * @memberof CMsgGCGetEmailTemplateResponse\n   * @instance\n   */\n\n  CMsgGCGetEmailTemplateResponse.prototype.templateExists = false;\n  /**\n   * CMsgGCGetEmailTemplateResponse template.\n   * @member {string} template\n   * @memberof CMsgGCGetEmailTemplateResponse\n   * @instance\n   */\n\n  CMsgGCGetEmailTemplateResponse.prototype.template = \"\";\n  /**\n   * Decodes a CMsgGCGetEmailTemplateResponse message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCGetEmailTemplateResponse\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCGetEmailTemplateResponse} CMsgGCGetEmailTemplateResponse\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCGetEmailTemplateResponse.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCGetEmailTemplateResponse();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.eresult = reader.uint32();\n          break;\n\n        case 2:\n          message.templateExists = reader.bool();\n          break;\n\n        case 3:\n          message.template = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCGetEmailTemplateResponse;\n})();\n\nexports.CMsgAMGrantGuestPasses2 = $root.CMsgAMGrantGuestPasses2 = (() => {\n  /**\n   * Properties of a CMsgAMGrantGuestPasses2.\n   * @exports ICMsgAMGrantGuestPasses2\n   * @interface ICMsgAMGrantGuestPasses2\n   * @property {number|Long|null} [steamId] CMsgAMGrantGuestPasses2 steamId\n   * @property {number|null} [packageId] CMsgAMGrantGuestPasses2 packageId\n   * @property {number|null} [passesToGrant] CMsgAMGrantGuestPasses2 passesToGrant\n   * @property {number|null} [daysToExpiration] CMsgAMGrantGuestPasses2 daysToExpiration\n   * @property {number|null} [action] CMsgAMGrantGuestPasses2 action\n   */\n\n  /**\n   * Constructs a new CMsgAMGrantGuestPasses2.\n   * @exports CMsgAMGrantGuestPasses2\n   * @classdesc Represents a CMsgAMGrantGuestPasses2.\n   * @implements ICMsgAMGrantGuestPasses2\n   * @constructor\n   * @param {ICMsgAMGrantGuestPasses2=} [properties] Properties to set\n   */\n  function CMsgAMGrantGuestPasses2(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgAMGrantGuestPasses2 steamId.\n   * @member {number|Long} steamId\n   * @memberof CMsgAMGrantGuestPasses2\n   * @instance\n   */\n\n\n  CMsgAMGrantGuestPasses2.prototype.steamId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n  /**\n   * CMsgAMGrantGuestPasses2 packageId.\n   * @member {number} packageId\n   * @memberof CMsgAMGrantGuestPasses2\n   * @instance\n   */\n\n  CMsgAMGrantGuestPasses2.prototype.packageId = 0;\n  /**\n   * CMsgAMGrantGuestPasses2 passesToGrant.\n   * @member {number} passesToGrant\n   * @memberof CMsgAMGrantGuestPasses2\n   * @instance\n   */\n\n  CMsgAMGrantGuestPasses2.prototype.passesToGrant = 0;\n  /**\n   * CMsgAMGrantGuestPasses2 daysToExpiration.\n   * @member {number} daysToExpiration\n   * @memberof CMsgAMGrantGuestPasses2\n   * @instance\n   */\n\n  CMsgAMGrantGuestPasses2.prototype.daysToExpiration = 0;\n  /**\n   * CMsgAMGrantGuestPasses2 action.\n   * @member {number} action\n   * @memberof CMsgAMGrantGuestPasses2\n   * @instance\n   */\n\n  CMsgAMGrantGuestPasses2.prototype.action = 0;\n  /**\n   * Decodes a CMsgAMGrantGuestPasses2 message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgAMGrantGuestPasses2\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgAMGrantGuestPasses2} CMsgAMGrantGuestPasses2\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgAMGrantGuestPasses2.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgAMGrantGuestPasses2();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.steamId = reader.fixed64();\n          break;\n\n        case 2:\n          message.packageId = reader.uint32();\n          break;\n\n        case 3:\n          message.passesToGrant = reader.int32();\n          break;\n\n        case 4:\n          message.daysToExpiration = reader.int32();\n          break;\n\n        case 5:\n          message.action = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgAMGrantGuestPasses2;\n})();\n\nexports.CMsgAMGrantGuestPasses2Response = $root.CMsgAMGrantGuestPasses2Response = (() => {\n  /**\n   * Properties of a CMsgAMGrantGuestPasses2Response.\n   * @exports ICMsgAMGrantGuestPasses2Response\n   * @interface ICMsgAMGrantGuestPasses2Response\n   * @property {number|null} [eresult] CMsgAMGrantGuestPasses2Response eresult\n   * @property {number|null} [passesGranted] CMsgAMGrantGuestPasses2Response passesGranted\n   */\n\n  /**\n   * Constructs a new CMsgAMGrantGuestPasses2Response.\n   * @exports CMsgAMGrantGuestPasses2Response\n   * @classdesc Represents a CMsgAMGrantGuestPasses2Response.\n   * @implements ICMsgAMGrantGuestPasses2Response\n   * @constructor\n   * @param {ICMsgAMGrantGuestPasses2Response=} [properties] Properties to set\n   */\n  function CMsgAMGrantGuestPasses2Response(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgAMGrantGuestPasses2Response eresult.\n   * @member {number} eresult\n   * @memberof CMsgAMGrantGuestPasses2Response\n   * @instance\n   */\n\n\n  CMsgAMGrantGuestPasses2Response.prototype.eresult = 2;\n  /**\n   * CMsgAMGrantGuestPasses2Response passesGranted.\n   * @member {number} passesGranted\n   * @memberof CMsgAMGrantGuestPasses2Response\n   * @instance\n   */\n\n  CMsgAMGrantGuestPasses2Response.prototype.passesGranted = 0;\n  /**\n   * Decodes a CMsgAMGrantGuestPasses2Response message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgAMGrantGuestPasses2Response\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgAMGrantGuestPasses2Response} CMsgAMGrantGuestPasses2Response\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgAMGrantGuestPasses2Response.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgAMGrantGuestPasses2Response();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.eresult = reader.int32();\n          break;\n\n        case 2:\n          message.passesGranted = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgAMGrantGuestPasses2Response;\n})();\n\nexports.CGCSystemMsg_GetAccountDetails = $root.CGCSystemMsg_GetAccountDetails = (() => {\n  /**\n   * Properties of a CGCSystemMsg_GetAccountDetails.\n   * @exports ICGCSystemMsg_GetAccountDetails\n   * @interface ICGCSystemMsg_GetAccountDetails\n   * @property {number|Long|null} [steamid] CGCSystemMsg_GetAccountDetails steamid\n   * @property {number|null} [appid] CGCSystemMsg_GetAccountDetails appid\n   */\n\n  /**\n   * Constructs a new CGCSystemMsg_GetAccountDetails.\n   * @exports CGCSystemMsg_GetAccountDetails\n   * @classdesc Represents a CGCSystemMsg_GetAccountDetails.\n   * @implements ICGCSystemMsg_GetAccountDetails\n   * @constructor\n   * @param {ICGCSystemMsg_GetAccountDetails=} [properties] Properties to set\n   */\n  function CGCSystemMsg_GetAccountDetails(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CGCSystemMsg_GetAccountDetails steamid.\n   * @member {number|Long} steamid\n   * @memberof CGCSystemMsg_GetAccountDetails\n   * @instance\n   */\n\n\n  CGCSystemMsg_GetAccountDetails.prototype.steamid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n  /**\n   * CGCSystemMsg_GetAccountDetails appid.\n   * @member {number} appid\n   * @memberof CGCSystemMsg_GetAccountDetails\n   * @instance\n   */\n\n  CGCSystemMsg_GetAccountDetails.prototype.appid = 0;\n  /**\n   * Decodes a CGCSystemMsg_GetAccountDetails message from the specified reader or buffer.\n   * @function decode\n   * @memberof CGCSystemMsg_GetAccountDetails\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CGCSystemMsg_GetAccountDetails} CGCSystemMsg_GetAccountDetails\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CGCSystemMsg_GetAccountDetails.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CGCSystemMsg_GetAccountDetails();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.steamid = reader.fixed64();\n          break;\n\n        case 2:\n          message.appid = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CGCSystemMsg_GetAccountDetails;\n})();\n\nexports.CGCSystemMsg_GetAccountDetails_Response = $root.CGCSystemMsg_GetAccountDetails_Response = (() => {\n  /**\n   * Properties of a CGCSystemMsg_GetAccountDetails_Response.\n   * @exports ICGCSystemMsg_GetAccountDetails_Response\n   * @interface ICGCSystemMsg_GetAccountDetails_Response\n   * @property {number|null} [eresultDeprecated] CGCSystemMsg_GetAccountDetails_Response eresultDeprecated\n   * @property {string|null} [accountName] CGCSystemMsg_GetAccountDetails_Response accountName\n   * @property {string|null} [personaName] CGCSystemMsg_GetAccountDetails_Response personaName\n   * @property {boolean|null} [isProfilePublic] CGCSystemMsg_GetAccountDetails_Response isProfilePublic\n   * @property {boolean|null} [isInventoryPublic] CGCSystemMsg_GetAccountDetails_Response isInventoryPublic\n   * @property {boolean|null} [isVacBanned] CGCSystemMsg_GetAccountDetails_Response isVacBanned\n   * @property {boolean|null} [isCyberCafe] CGCSystemMsg_GetAccountDetails_Response isCyberCafe\n   * @property {boolean|null} [isSchoolAccount] CGCSystemMsg_GetAccountDetails_Response isSchoolAccount\n   * @property {boolean|null} [isLimited] CGCSystemMsg_GetAccountDetails_Response isLimited\n   * @property {boolean|null} [isSubscribed] CGCSystemMsg_GetAccountDetails_Response isSubscribed\n   * @property {number|null} [\"package\"] CGCSystemMsg_GetAccountDetails_Response package\n   * @property {boolean|null} [isFreeTrialAccount] CGCSystemMsg_GetAccountDetails_Response isFreeTrialAccount\n   * @property {number|null} [freeTrialExpiration] CGCSystemMsg_GetAccountDetails_Response freeTrialExpiration\n   * @property {boolean|null} [isLowViolence] CGCSystemMsg_GetAccountDetails_Response isLowViolence\n   * @property {boolean|null} [isAccountLockedDown] CGCSystemMsg_GetAccountDetails_Response isAccountLockedDown\n   * @property {boolean|null} [isCommunityBanned] CGCSystemMsg_GetAccountDetails_Response isCommunityBanned\n   * @property {boolean|null} [isTradeBanned] CGCSystemMsg_GetAccountDetails_Response isTradeBanned\n   * @property {number|null} [tradeBanExpiration] CGCSystemMsg_GetAccountDetails_Response tradeBanExpiration\n   * @property {number|null} [accountid] CGCSystemMsg_GetAccountDetails_Response accountid\n   * @property {number|null} [suspensionEndTime] CGCSystemMsg_GetAccountDetails_Response suspensionEndTime\n   * @property {string|null} [currency] CGCSystemMsg_GetAccountDetails_Response currency\n   * @property {number|null} [steamLevel] CGCSystemMsg_GetAccountDetails_Response steamLevel\n   */\n\n  /**\n   * Constructs a new CGCSystemMsg_GetAccountDetails_Response.\n   * @exports CGCSystemMsg_GetAccountDetails_Response\n   * @classdesc Represents a CGCSystemMsg_GetAccountDetails_Response.\n   * @implements ICGCSystemMsg_GetAccountDetails_Response\n   * @constructor\n   * @param {ICGCSystemMsg_GetAccountDetails_Response=} [properties] Properties to set\n   */\n  function CGCSystemMsg_GetAccountDetails_Response(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CGCSystemMsg_GetAccountDetails_Response eresultDeprecated.\n   * @member {number} eresultDeprecated\n   * @memberof CGCSystemMsg_GetAccountDetails_Response\n   * @instance\n   */\n\n\n  CGCSystemMsg_GetAccountDetails_Response.prototype.eresultDeprecated = 2;\n  /**\n   * CGCSystemMsg_GetAccountDetails_Response accountName.\n   * @member {string} accountName\n   * @memberof CGCSystemMsg_GetAccountDetails_Response\n   * @instance\n   */\n\n  CGCSystemMsg_GetAccountDetails_Response.prototype.accountName = \"\";\n  /**\n   * CGCSystemMsg_GetAccountDetails_Response personaName.\n   * @member {string} personaName\n   * @memberof CGCSystemMsg_GetAccountDetails_Response\n   * @instance\n   */\n\n  CGCSystemMsg_GetAccountDetails_Response.prototype.personaName = \"\";\n  /**\n   * CGCSystemMsg_GetAccountDetails_Response isProfilePublic.\n   * @member {boolean} isProfilePublic\n   * @memberof CGCSystemMsg_GetAccountDetails_Response\n   * @instance\n   */\n\n  CGCSystemMsg_GetAccountDetails_Response.prototype.isProfilePublic = false;\n  /**\n   * CGCSystemMsg_GetAccountDetails_Response isInventoryPublic.\n   * @member {boolean} isInventoryPublic\n   * @memberof CGCSystemMsg_GetAccountDetails_Response\n   * @instance\n   */\n\n  CGCSystemMsg_GetAccountDetails_Response.prototype.isInventoryPublic = false;\n  /**\n   * CGCSystemMsg_GetAccountDetails_Response isVacBanned.\n   * @member {boolean} isVacBanned\n   * @memberof CGCSystemMsg_GetAccountDetails_Response\n   * @instance\n   */\n\n  CGCSystemMsg_GetAccountDetails_Response.prototype.isVacBanned = false;\n  /**\n   * CGCSystemMsg_GetAccountDetails_Response isCyberCafe.\n   * @member {boolean} isCyberCafe\n   * @memberof CGCSystemMsg_GetAccountDetails_Response\n   * @instance\n   */\n\n  CGCSystemMsg_GetAccountDetails_Response.prototype.isCyberCafe = false;\n  /**\n   * CGCSystemMsg_GetAccountDetails_Response isSchoolAccount.\n   * @member {boolean} isSchoolAccount\n   * @memberof CGCSystemMsg_GetAccountDetails_Response\n   * @instance\n   */\n\n  CGCSystemMsg_GetAccountDetails_Response.prototype.isSchoolAccount = false;\n  /**\n   * CGCSystemMsg_GetAccountDetails_Response isLimited.\n   * @member {boolean} isLimited\n   * @memberof CGCSystemMsg_GetAccountDetails_Response\n   * @instance\n   */\n\n  CGCSystemMsg_GetAccountDetails_Response.prototype.isLimited = false;\n  /**\n   * CGCSystemMsg_GetAccountDetails_Response isSubscribed.\n   * @member {boolean} isSubscribed\n   * @memberof CGCSystemMsg_GetAccountDetails_Response\n   * @instance\n   */\n\n  CGCSystemMsg_GetAccountDetails_Response.prototype.isSubscribed = false;\n  /**\n   * CGCSystemMsg_GetAccountDetails_Response package.\n   * @member {number} package\n   * @memberof CGCSystemMsg_GetAccountDetails_Response\n   * @instance\n   */\n\n  CGCSystemMsg_GetAccountDetails_Response.prototype[\"package\"] = 0;\n  /**\n   * CGCSystemMsg_GetAccountDetails_Response isFreeTrialAccount.\n   * @member {boolean} isFreeTrialAccount\n   * @memberof CGCSystemMsg_GetAccountDetails_Response\n   * @instance\n   */\n\n  CGCSystemMsg_GetAccountDetails_Response.prototype.isFreeTrialAccount = false;\n  /**\n   * CGCSystemMsg_GetAccountDetails_Response freeTrialExpiration.\n   * @member {number} freeTrialExpiration\n   * @memberof CGCSystemMsg_GetAccountDetails_Response\n   * @instance\n   */\n\n  CGCSystemMsg_GetAccountDetails_Response.prototype.freeTrialExpiration = 0;\n  /**\n   * CGCSystemMsg_GetAccountDetails_Response isLowViolence.\n   * @member {boolean} isLowViolence\n   * @memberof CGCSystemMsg_GetAccountDetails_Response\n   * @instance\n   */\n\n  CGCSystemMsg_GetAccountDetails_Response.prototype.isLowViolence = false;\n  /**\n   * CGCSystemMsg_GetAccountDetails_Response isAccountLockedDown.\n   * @member {boolean} isAccountLockedDown\n   * @memberof CGCSystemMsg_GetAccountDetails_Response\n   * @instance\n   */\n\n  CGCSystemMsg_GetAccountDetails_Response.prototype.isAccountLockedDown = false;\n  /**\n   * CGCSystemMsg_GetAccountDetails_Response isCommunityBanned.\n   * @member {boolean} isCommunityBanned\n   * @memberof CGCSystemMsg_GetAccountDetails_Response\n   * @instance\n   */\n\n  CGCSystemMsg_GetAccountDetails_Response.prototype.isCommunityBanned = false;\n  /**\n   * CGCSystemMsg_GetAccountDetails_Response isTradeBanned.\n   * @member {boolean} isTradeBanned\n   * @memberof CGCSystemMsg_GetAccountDetails_Response\n   * @instance\n   */\n\n  CGCSystemMsg_GetAccountDetails_Response.prototype.isTradeBanned = false;\n  /**\n   * CGCSystemMsg_GetAccountDetails_Response tradeBanExpiration.\n   * @member {number} tradeBanExpiration\n   * @memberof CGCSystemMsg_GetAccountDetails_Response\n   * @instance\n   */\n\n  CGCSystemMsg_GetAccountDetails_Response.prototype.tradeBanExpiration = 0;\n  /**\n   * CGCSystemMsg_GetAccountDetails_Response accountid.\n   * @member {number} accountid\n   * @memberof CGCSystemMsg_GetAccountDetails_Response\n   * @instance\n   */\n\n  CGCSystemMsg_GetAccountDetails_Response.prototype.accountid = 0;\n  /**\n   * CGCSystemMsg_GetAccountDetails_Response suspensionEndTime.\n   * @member {number} suspensionEndTime\n   * @memberof CGCSystemMsg_GetAccountDetails_Response\n   * @instance\n   */\n\n  CGCSystemMsg_GetAccountDetails_Response.prototype.suspensionEndTime = 0;\n  /**\n   * CGCSystemMsg_GetAccountDetails_Response currency.\n   * @member {string} currency\n   * @memberof CGCSystemMsg_GetAccountDetails_Response\n   * @instance\n   */\n\n  CGCSystemMsg_GetAccountDetails_Response.prototype.currency = \"\";\n  /**\n   * CGCSystemMsg_GetAccountDetails_Response steamLevel.\n   * @member {number} steamLevel\n   * @memberof CGCSystemMsg_GetAccountDetails_Response\n   * @instance\n   */\n\n  CGCSystemMsg_GetAccountDetails_Response.prototype.steamLevel = 0;\n  /**\n   * Decodes a CGCSystemMsg_GetAccountDetails_Response message from the specified reader or buffer.\n   * @function decode\n   * @memberof CGCSystemMsg_GetAccountDetails_Response\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CGCSystemMsg_GetAccountDetails_Response} CGCSystemMsg_GetAccountDetails_Response\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CGCSystemMsg_GetAccountDetails_Response.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CGCSystemMsg_GetAccountDetails_Response();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.eresultDeprecated = reader.uint32();\n          break;\n\n        case 2:\n          message.accountName = reader.string();\n          break;\n\n        case 3:\n          message.personaName = reader.string();\n          break;\n\n        case 4:\n          message.isProfilePublic = reader.bool();\n          break;\n\n        case 5:\n          message.isInventoryPublic = reader.bool();\n          break;\n\n        case 7:\n          message.isVacBanned = reader.bool();\n          break;\n\n        case 8:\n          message.isCyberCafe = reader.bool();\n          break;\n\n        case 9:\n          message.isSchoolAccount = reader.bool();\n          break;\n\n        case 10:\n          message.isLimited = reader.bool();\n          break;\n\n        case 11:\n          message.isSubscribed = reader.bool();\n          break;\n\n        case 12:\n          message[\"package\"] = reader.uint32();\n          break;\n\n        case 13:\n          message.isFreeTrialAccount = reader.bool();\n          break;\n\n        case 14:\n          message.freeTrialExpiration = reader.uint32();\n          break;\n\n        case 15:\n          message.isLowViolence = reader.bool();\n          break;\n\n        case 16:\n          message.isAccountLockedDown = reader.bool();\n          break;\n\n        case 17:\n          message.isCommunityBanned = reader.bool();\n          break;\n\n        case 18:\n          message.isTradeBanned = reader.bool();\n          break;\n\n        case 19:\n          message.tradeBanExpiration = reader.uint32();\n          break;\n\n        case 20:\n          message.accountid = reader.uint32();\n          break;\n\n        case 21:\n          message.suspensionEndTime = reader.uint32();\n          break;\n\n        case 22:\n          message.currency = reader.string();\n          break;\n\n        case 23:\n          message.steamLevel = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CGCSystemMsg_GetAccountDetails_Response;\n})();\n\nexports.CMsgGCGetPersonaNames = $root.CMsgGCGetPersonaNames = (() => {\n  /**\n   * Properties of a CMsgGCGetPersonaNames.\n   * @exports ICMsgGCGetPersonaNames\n   * @interface ICMsgGCGetPersonaNames\n   * @property {Array.<number|Long>|null} [steamids] CMsgGCGetPersonaNames steamids\n   */\n\n  /**\n   * Constructs a new CMsgGCGetPersonaNames.\n   * @exports CMsgGCGetPersonaNames\n   * @classdesc Represents a CMsgGCGetPersonaNames.\n   * @implements ICMsgGCGetPersonaNames\n   * @constructor\n   * @param {ICMsgGCGetPersonaNames=} [properties] Properties to set\n   */\n  function CMsgGCGetPersonaNames(properties) {\n    this.steamids = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCGetPersonaNames steamids.\n   * @member {Array.<number|Long>} steamids\n   * @memberof CMsgGCGetPersonaNames\n   * @instance\n   */\n\n\n  CMsgGCGetPersonaNames.prototype.steamids = $util.emptyArray;\n  /**\n   * Decodes a CMsgGCGetPersonaNames message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCGetPersonaNames\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCGetPersonaNames} CMsgGCGetPersonaNames\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCGetPersonaNames.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCGetPersonaNames();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.steamids && message.steamids.length)) message.steamids = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.steamids.push(reader.fixed64());\n          } else message.steamids.push(reader.fixed64());\n\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCGetPersonaNames;\n})();\n\nexports.CMsgGCGetPersonaNames_Response = $root.CMsgGCGetPersonaNames_Response = (() => {\n  /**\n   * Properties of a CMsgGCGetPersonaNames_Response.\n   * @exports ICMsgGCGetPersonaNames_Response\n   * @interface ICMsgGCGetPersonaNames_Response\n   * @property {Array.<CMsgGCGetPersonaNames_Response.IPersonaName>|null} [succeededLookups] CMsgGCGetPersonaNames_Response succeededLookups\n   * @property {Array.<number|Long>|null} [failedLookupSteamids] CMsgGCGetPersonaNames_Response failedLookupSteamids\n   */\n\n  /**\n   * Constructs a new CMsgGCGetPersonaNames_Response.\n   * @exports CMsgGCGetPersonaNames_Response\n   * @classdesc Represents a CMsgGCGetPersonaNames_Response.\n   * @implements ICMsgGCGetPersonaNames_Response\n   * @constructor\n   * @param {ICMsgGCGetPersonaNames_Response=} [properties] Properties to set\n   */\n  function CMsgGCGetPersonaNames_Response(properties) {\n    this.succeededLookups = [];\n    this.failedLookupSteamids = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCGetPersonaNames_Response succeededLookups.\n   * @member {Array.<CMsgGCGetPersonaNames_Response.IPersonaName>} succeededLookups\n   * @memberof CMsgGCGetPersonaNames_Response\n   * @instance\n   */\n\n\n  CMsgGCGetPersonaNames_Response.prototype.succeededLookups = $util.emptyArray;\n  /**\n   * CMsgGCGetPersonaNames_Response failedLookupSteamids.\n   * @member {Array.<number|Long>} failedLookupSteamids\n   * @memberof CMsgGCGetPersonaNames_Response\n   * @instance\n   */\n\n  CMsgGCGetPersonaNames_Response.prototype.failedLookupSteamids = $util.emptyArray;\n  /**\n   * Decodes a CMsgGCGetPersonaNames_Response message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCGetPersonaNames_Response\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCGetPersonaNames_Response} CMsgGCGetPersonaNames_Response\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCGetPersonaNames_Response.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCGetPersonaNames_Response();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.succeededLookups && message.succeededLookups.length)) message.succeededLookups = [];\n          message.succeededLookups.push($root.CMsgGCGetPersonaNames_Response.PersonaName.decode(reader, reader.uint32()));\n          break;\n\n        case 2:\n          if (!(message.failedLookupSteamids && message.failedLookupSteamids.length)) message.failedLookupSteamids = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.failedLookupSteamids.push(reader.fixed64());\n          } else message.failedLookupSteamids.push(reader.fixed64());\n\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CMsgGCGetPersonaNames_Response.PersonaName = function () {\n    /**\n     * Properties of a PersonaName.\n     * @memberof CMsgGCGetPersonaNames_Response\n     * @interface IPersonaName\n     * @property {number|Long|null} [steamid] PersonaName steamid\n     * @property {string|null} [personaName] PersonaName personaName\n     */\n\n    /**\n     * Constructs a new PersonaName.\n     * @memberof CMsgGCGetPersonaNames_Response\n     * @classdesc Represents a PersonaName.\n     * @implements IPersonaName\n     * @constructor\n     * @param {CMsgGCGetPersonaNames_Response.IPersonaName=} [properties] Properties to set\n     */\n    function PersonaName(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * PersonaName steamid.\n     * @member {number|Long} steamid\n     * @memberof CMsgGCGetPersonaNames_Response.PersonaName\n     * @instance\n     */\n\n\n    PersonaName.prototype.steamid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n    /**\n     * PersonaName personaName.\n     * @member {string} personaName\n     * @memberof CMsgGCGetPersonaNames_Response.PersonaName\n     * @instance\n     */\n\n    PersonaName.prototype.personaName = \"\";\n    /**\n     * Decodes a PersonaName message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCGetPersonaNames_Response.PersonaName\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCGetPersonaNames_Response.PersonaName} PersonaName\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    PersonaName.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CMsgGCGetPersonaNames_Response.PersonaName();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.steamid = reader.fixed64();\n            break;\n\n          case 2:\n            message.personaName = reader.string();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return PersonaName;\n  }();\n\n  return CMsgGCGetPersonaNames_Response;\n})();\n\nexports.CMsgGCCheckFriendship = $root.CMsgGCCheckFriendship = (() => {\n  /**\n   * Properties of a CMsgGCCheckFriendship.\n   * @exports ICMsgGCCheckFriendship\n   * @interface ICMsgGCCheckFriendship\n   * @property {number|Long|null} [steamidLeft] CMsgGCCheckFriendship steamidLeft\n   * @property {number|Long|null} [steamidRight] CMsgGCCheckFriendship steamidRight\n   */\n\n  /**\n   * Constructs a new CMsgGCCheckFriendship.\n   * @exports CMsgGCCheckFriendship\n   * @classdesc Represents a CMsgGCCheckFriendship.\n   * @implements ICMsgGCCheckFriendship\n   * @constructor\n   * @param {ICMsgGCCheckFriendship=} [properties] Properties to set\n   */\n  function CMsgGCCheckFriendship(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCheckFriendship steamidLeft.\n   * @member {number|Long} steamidLeft\n   * @memberof CMsgGCCheckFriendship\n   * @instance\n   */\n\n\n  CMsgGCCheckFriendship.prototype.steamidLeft = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n  /**\n   * CMsgGCCheckFriendship steamidRight.\n   * @member {number|Long} steamidRight\n   * @memberof CMsgGCCheckFriendship\n   * @instance\n   */\n\n  CMsgGCCheckFriendship.prototype.steamidRight = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n  /**\n   * Decodes a CMsgGCCheckFriendship message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCheckFriendship\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCheckFriendship} CMsgGCCheckFriendship\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCheckFriendship.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCheckFriendship();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.steamidLeft = reader.fixed64();\n          break;\n\n        case 2:\n          message.steamidRight = reader.fixed64();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCheckFriendship;\n})();\n\nexports.CMsgGCCheckFriendship_Response = $root.CMsgGCCheckFriendship_Response = (() => {\n  /**\n   * Properties of a CMsgGCCheckFriendship_Response.\n   * @exports ICMsgGCCheckFriendship_Response\n   * @interface ICMsgGCCheckFriendship_Response\n   * @property {boolean|null} [success] CMsgGCCheckFriendship_Response success\n   * @property {boolean|null} [foundFriendship] CMsgGCCheckFriendship_Response foundFriendship\n   */\n\n  /**\n   * Constructs a new CMsgGCCheckFriendship_Response.\n   * @exports CMsgGCCheckFriendship_Response\n   * @classdesc Represents a CMsgGCCheckFriendship_Response.\n   * @implements ICMsgGCCheckFriendship_Response\n   * @constructor\n   * @param {ICMsgGCCheckFriendship_Response=} [properties] Properties to set\n   */\n  function CMsgGCCheckFriendship_Response(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCCheckFriendship_Response success.\n   * @member {boolean} success\n   * @memberof CMsgGCCheckFriendship_Response\n   * @instance\n   */\n\n\n  CMsgGCCheckFriendship_Response.prototype.success = false;\n  /**\n   * CMsgGCCheckFriendship_Response foundFriendship.\n   * @member {boolean} foundFriendship\n   * @memberof CMsgGCCheckFriendship_Response\n   * @instance\n   */\n\n  CMsgGCCheckFriendship_Response.prototype.foundFriendship = false;\n  /**\n   * Decodes a CMsgGCCheckFriendship_Response message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCCheckFriendship_Response\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCCheckFriendship_Response} CMsgGCCheckFriendship_Response\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCCheckFriendship_Response.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCCheckFriendship_Response();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.success = reader.bool();\n          break;\n\n        case 2:\n          message.foundFriendship = reader.bool();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCCheckFriendship_Response;\n})();\n\nexports.CMsgGCMsgMasterSetDirectory = $root.CMsgGCMsgMasterSetDirectory = (() => {\n  /**\n   * Properties of a CMsgGCMsgMasterSetDirectory.\n   * @exports ICMsgGCMsgMasterSetDirectory\n   * @interface ICMsgGCMsgMasterSetDirectory\n   * @property {number|null} [masterDirIndex] CMsgGCMsgMasterSetDirectory masterDirIndex\n   * @property {Array.<CMsgGCMsgMasterSetDirectory.ISubGC>|null} [dir] CMsgGCMsgMasterSetDirectory dir\n   */\n\n  /**\n   * Constructs a new CMsgGCMsgMasterSetDirectory.\n   * @exports CMsgGCMsgMasterSetDirectory\n   * @classdesc Represents a CMsgGCMsgMasterSetDirectory.\n   * @implements ICMsgGCMsgMasterSetDirectory\n   * @constructor\n   * @param {ICMsgGCMsgMasterSetDirectory=} [properties] Properties to set\n   */\n  function CMsgGCMsgMasterSetDirectory(properties) {\n    this.dir = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCMsgMasterSetDirectory masterDirIndex.\n   * @member {number} masterDirIndex\n   * @memberof CMsgGCMsgMasterSetDirectory\n   * @instance\n   */\n\n\n  CMsgGCMsgMasterSetDirectory.prototype.masterDirIndex = 0;\n  /**\n   * CMsgGCMsgMasterSetDirectory dir.\n   * @member {Array.<CMsgGCMsgMasterSetDirectory.ISubGC>} dir\n   * @memberof CMsgGCMsgMasterSetDirectory\n   * @instance\n   */\n\n  CMsgGCMsgMasterSetDirectory.prototype.dir = $util.emptyArray;\n  /**\n   * Decodes a CMsgGCMsgMasterSetDirectory message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCMsgMasterSetDirectory\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCMsgMasterSetDirectory} CMsgGCMsgMasterSetDirectory\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCMsgMasterSetDirectory.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCMsgMasterSetDirectory();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.masterDirIndex = reader.uint32();\n          break;\n\n        case 2:\n          if (!(message.dir && message.dir.length)) message.dir = [];\n          message.dir.push($root.CMsgGCMsgMasterSetDirectory.SubGC.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CMsgGCMsgMasterSetDirectory.SubGC = function () {\n    /**\n     * Properties of a SubGC.\n     * @memberof CMsgGCMsgMasterSetDirectory\n     * @interface ISubGC\n     * @property {number|null} [dirIndex] SubGC dirIndex\n     * @property {string|null} [name] SubGC name\n     * @property {string|null} [box] SubGC box\n     * @property {string|null} [commandLine] SubGC commandLine\n     * @property {string|null} [gcBinary] SubGC gcBinary\n     */\n\n    /**\n     * Constructs a new SubGC.\n     * @memberof CMsgGCMsgMasterSetDirectory\n     * @classdesc Represents a SubGC.\n     * @implements ISubGC\n     * @constructor\n     * @param {CMsgGCMsgMasterSetDirectory.ISubGC=} [properties] Properties to set\n     */\n    function SubGC(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * SubGC dirIndex.\n     * @member {number} dirIndex\n     * @memberof CMsgGCMsgMasterSetDirectory.SubGC\n     * @instance\n     */\n\n\n    SubGC.prototype.dirIndex = 0;\n    /**\n     * SubGC name.\n     * @member {string} name\n     * @memberof CMsgGCMsgMasterSetDirectory.SubGC\n     * @instance\n     */\n\n    SubGC.prototype.name = \"\";\n    /**\n     * SubGC box.\n     * @member {string} box\n     * @memberof CMsgGCMsgMasterSetDirectory.SubGC\n     * @instance\n     */\n\n    SubGC.prototype.box = \"\";\n    /**\n     * SubGC commandLine.\n     * @member {string} commandLine\n     * @memberof CMsgGCMsgMasterSetDirectory.SubGC\n     * @instance\n     */\n\n    SubGC.prototype.commandLine = \"\";\n    /**\n     * SubGC gcBinary.\n     * @member {string} gcBinary\n     * @memberof CMsgGCMsgMasterSetDirectory.SubGC\n     * @instance\n     */\n\n    SubGC.prototype.gcBinary = \"\";\n    /**\n     * Decodes a SubGC message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCMsgMasterSetDirectory.SubGC\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCMsgMasterSetDirectory.SubGC} SubGC\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    SubGC.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CMsgGCMsgMasterSetDirectory.SubGC();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.dirIndex = reader.uint32();\n            break;\n\n          case 2:\n            message.name = reader.string();\n            break;\n\n          case 3:\n            message.box = reader.string();\n            break;\n\n          case 4:\n            message.commandLine = reader.string();\n            break;\n\n          case 5:\n            message.gcBinary = reader.string();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return SubGC;\n  }();\n\n  return CMsgGCMsgMasterSetDirectory;\n})();\n\nexports.CMsgGCMsgMasterSetDirectory_Response = $root.CMsgGCMsgMasterSetDirectory_Response = (() => {\n  /**\n   * Properties of a CMsgGCMsgMasterSetDirectory_Response.\n   * @exports ICMsgGCMsgMasterSetDirectory_Response\n   * @interface ICMsgGCMsgMasterSetDirectory_Response\n   * @property {number|null} [eresult] CMsgGCMsgMasterSetDirectory_Response eresult\n   */\n\n  /**\n   * Constructs a new CMsgGCMsgMasterSetDirectory_Response.\n   * @exports CMsgGCMsgMasterSetDirectory_Response\n   * @classdesc Represents a CMsgGCMsgMasterSetDirectory_Response.\n   * @implements ICMsgGCMsgMasterSetDirectory_Response\n   * @constructor\n   * @param {ICMsgGCMsgMasterSetDirectory_Response=} [properties] Properties to set\n   */\n  function CMsgGCMsgMasterSetDirectory_Response(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCMsgMasterSetDirectory_Response eresult.\n   * @member {number} eresult\n   * @memberof CMsgGCMsgMasterSetDirectory_Response\n   * @instance\n   */\n\n\n  CMsgGCMsgMasterSetDirectory_Response.prototype.eresult = 2;\n  /**\n   * Decodes a CMsgGCMsgMasterSetDirectory_Response message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCMsgMasterSetDirectory_Response\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCMsgMasterSetDirectory_Response} CMsgGCMsgMasterSetDirectory_Response\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCMsgMasterSetDirectory_Response.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCMsgMasterSetDirectory_Response();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.eresult = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCMsgMasterSetDirectory_Response;\n})();\n\nexports.CMsgGCMsgWebAPIJobRequestForwardResponse = $root.CMsgGCMsgWebAPIJobRequestForwardResponse = (() => {\n  /**\n   * Properties of a CMsgGCMsgWebAPIJobRequestForwardResponse.\n   * @exports ICMsgGCMsgWebAPIJobRequestForwardResponse\n   * @interface ICMsgGCMsgWebAPIJobRequestForwardResponse\n   * @property {number|null} [dirIndex] CMsgGCMsgWebAPIJobRequestForwardResponse dirIndex\n   */\n\n  /**\n   * Constructs a new CMsgGCMsgWebAPIJobRequestForwardResponse.\n   * @exports CMsgGCMsgWebAPIJobRequestForwardResponse\n   * @classdesc Represents a CMsgGCMsgWebAPIJobRequestForwardResponse.\n   * @implements ICMsgGCMsgWebAPIJobRequestForwardResponse\n   * @constructor\n   * @param {ICMsgGCMsgWebAPIJobRequestForwardResponse=} [properties] Properties to set\n   */\n  function CMsgGCMsgWebAPIJobRequestForwardResponse(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCMsgWebAPIJobRequestForwardResponse dirIndex.\n   * @member {number} dirIndex\n   * @memberof CMsgGCMsgWebAPIJobRequestForwardResponse\n   * @instance\n   */\n\n\n  CMsgGCMsgWebAPIJobRequestForwardResponse.prototype.dirIndex = 0;\n  /**\n   * Decodes a CMsgGCMsgWebAPIJobRequestForwardResponse message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCMsgWebAPIJobRequestForwardResponse\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCMsgWebAPIJobRequestForwardResponse} CMsgGCMsgWebAPIJobRequestForwardResponse\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCMsgWebAPIJobRequestForwardResponse.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCMsgWebAPIJobRequestForwardResponse();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.dirIndex = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCMsgWebAPIJobRequestForwardResponse;\n})();\n\nexports.CGCSystemMsg_GetPurchaseTrust_Request = $root.CGCSystemMsg_GetPurchaseTrust_Request = (() => {\n  /**\n   * Properties of a CGCSystemMsg_GetPurchaseTrust_Request.\n   * @exports ICGCSystemMsg_GetPurchaseTrust_Request\n   * @interface ICGCSystemMsg_GetPurchaseTrust_Request\n   * @property {number|Long|null} [steamid] CGCSystemMsg_GetPurchaseTrust_Request steamid\n   */\n\n  /**\n   * Constructs a new CGCSystemMsg_GetPurchaseTrust_Request.\n   * @exports CGCSystemMsg_GetPurchaseTrust_Request\n   * @classdesc Represents a CGCSystemMsg_GetPurchaseTrust_Request.\n   * @implements ICGCSystemMsg_GetPurchaseTrust_Request\n   * @constructor\n   * @param {ICGCSystemMsg_GetPurchaseTrust_Request=} [properties] Properties to set\n   */\n  function CGCSystemMsg_GetPurchaseTrust_Request(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CGCSystemMsg_GetPurchaseTrust_Request steamid.\n   * @member {number|Long} steamid\n   * @memberof CGCSystemMsg_GetPurchaseTrust_Request\n   * @instance\n   */\n\n\n  CGCSystemMsg_GetPurchaseTrust_Request.prototype.steamid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n  /**\n   * Decodes a CGCSystemMsg_GetPurchaseTrust_Request message from the specified reader or buffer.\n   * @function decode\n   * @memberof CGCSystemMsg_GetPurchaseTrust_Request\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CGCSystemMsg_GetPurchaseTrust_Request} CGCSystemMsg_GetPurchaseTrust_Request\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CGCSystemMsg_GetPurchaseTrust_Request.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CGCSystemMsg_GetPurchaseTrust_Request();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.steamid = reader.fixed64();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CGCSystemMsg_GetPurchaseTrust_Request;\n})();\n\nexports.CGCSystemMsg_GetPurchaseTrust_Response = $root.CGCSystemMsg_GetPurchaseTrust_Response = (() => {\n  /**\n   * Properties of a CGCSystemMsg_GetPurchaseTrust_Response.\n   * @exports ICGCSystemMsg_GetPurchaseTrust_Response\n   * @interface ICGCSystemMsg_GetPurchaseTrust_Response\n   * @property {boolean|null} [hasPriorPurchaseHistory] CGCSystemMsg_GetPurchaseTrust_Response hasPriorPurchaseHistory\n   * @property {boolean|null} [hasNoRecentPasswordResets] CGCSystemMsg_GetPurchaseTrust_Response hasNoRecentPasswordResets\n   * @property {boolean|null} [isWalletCashTrusted] CGCSystemMsg_GetPurchaseTrust_Response isWalletCashTrusted\n   * @property {number|null} [timeAllTrusted] CGCSystemMsg_GetPurchaseTrust_Response timeAllTrusted\n   */\n\n  /**\n   * Constructs a new CGCSystemMsg_GetPurchaseTrust_Response.\n   * @exports CGCSystemMsg_GetPurchaseTrust_Response\n   * @classdesc Represents a CGCSystemMsg_GetPurchaseTrust_Response.\n   * @implements ICGCSystemMsg_GetPurchaseTrust_Response\n   * @constructor\n   * @param {ICGCSystemMsg_GetPurchaseTrust_Response=} [properties] Properties to set\n   */\n  function CGCSystemMsg_GetPurchaseTrust_Response(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CGCSystemMsg_GetPurchaseTrust_Response hasPriorPurchaseHistory.\n   * @member {boolean} hasPriorPurchaseHistory\n   * @memberof CGCSystemMsg_GetPurchaseTrust_Response\n   * @instance\n   */\n\n\n  CGCSystemMsg_GetPurchaseTrust_Response.prototype.hasPriorPurchaseHistory = false;\n  /**\n   * CGCSystemMsg_GetPurchaseTrust_Response hasNoRecentPasswordResets.\n   * @member {boolean} hasNoRecentPasswordResets\n   * @memberof CGCSystemMsg_GetPurchaseTrust_Response\n   * @instance\n   */\n\n  CGCSystemMsg_GetPurchaseTrust_Response.prototype.hasNoRecentPasswordResets = false;\n  /**\n   * CGCSystemMsg_GetPurchaseTrust_Response isWalletCashTrusted.\n   * @member {boolean} isWalletCashTrusted\n   * @memberof CGCSystemMsg_GetPurchaseTrust_Response\n   * @instance\n   */\n\n  CGCSystemMsg_GetPurchaseTrust_Response.prototype.isWalletCashTrusted = false;\n  /**\n   * CGCSystemMsg_GetPurchaseTrust_Response timeAllTrusted.\n   * @member {number} timeAllTrusted\n   * @memberof CGCSystemMsg_GetPurchaseTrust_Response\n   * @instance\n   */\n\n  CGCSystemMsg_GetPurchaseTrust_Response.prototype.timeAllTrusted = 0;\n  /**\n   * Decodes a CGCSystemMsg_GetPurchaseTrust_Response message from the specified reader or buffer.\n   * @function decode\n   * @memberof CGCSystemMsg_GetPurchaseTrust_Response\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CGCSystemMsg_GetPurchaseTrust_Response} CGCSystemMsg_GetPurchaseTrust_Response\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CGCSystemMsg_GetPurchaseTrust_Response.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CGCSystemMsg_GetPurchaseTrust_Response();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.hasPriorPurchaseHistory = reader.bool();\n          break;\n\n        case 2:\n          message.hasNoRecentPasswordResets = reader.bool();\n          break;\n\n        case 3:\n          message.isWalletCashTrusted = reader.bool();\n          break;\n\n        case 4:\n          message.timeAllTrusted = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CGCSystemMsg_GetPurchaseTrust_Response;\n})();\n\nexports.CMsgGCHAccountVacStatusChange = $root.CMsgGCHAccountVacStatusChange = (() => {\n  /**\n   * Properties of a CMsgGCHAccountVacStatusChange.\n   * @exports ICMsgGCHAccountVacStatusChange\n   * @interface ICMsgGCHAccountVacStatusChange\n   * @property {number|Long|null} [steamId] CMsgGCHAccountVacStatusChange steamId\n   * @property {number|null} [appId] CMsgGCHAccountVacStatusChange appId\n   * @property {number|null} [rtimeVacbanStarts] CMsgGCHAccountVacStatusChange rtimeVacbanStarts\n   * @property {boolean|null} [isBannedNow] CMsgGCHAccountVacStatusChange isBannedNow\n   * @property {boolean|null} [isBannedFuture] CMsgGCHAccountVacStatusChange isBannedFuture\n   */\n\n  /**\n   * Constructs a new CMsgGCHAccountVacStatusChange.\n   * @exports CMsgGCHAccountVacStatusChange\n   * @classdesc Represents a CMsgGCHAccountVacStatusChange.\n   * @implements ICMsgGCHAccountVacStatusChange\n   * @constructor\n   * @param {ICMsgGCHAccountVacStatusChange=} [properties] Properties to set\n   */\n  function CMsgGCHAccountVacStatusChange(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCHAccountVacStatusChange steamId.\n   * @member {number|Long} steamId\n   * @memberof CMsgGCHAccountVacStatusChange\n   * @instance\n   */\n\n\n  CMsgGCHAccountVacStatusChange.prototype.steamId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n  /**\n   * CMsgGCHAccountVacStatusChange appId.\n   * @member {number} appId\n   * @memberof CMsgGCHAccountVacStatusChange\n   * @instance\n   */\n\n  CMsgGCHAccountVacStatusChange.prototype.appId = 0;\n  /**\n   * CMsgGCHAccountVacStatusChange rtimeVacbanStarts.\n   * @member {number} rtimeVacbanStarts\n   * @memberof CMsgGCHAccountVacStatusChange\n   * @instance\n   */\n\n  CMsgGCHAccountVacStatusChange.prototype.rtimeVacbanStarts = 0;\n  /**\n   * CMsgGCHAccountVacStatusChange isBannedNow.\n   * @member {boolean} isBannedNow\n   * @memberof CMsgGCHAccountVacStatusChange\n   * @instance\n   */\n\n  CMsgGCHAccountVacStatusChange.prototype.isBannedNow = false;\n  /**\n   * CMsgGCHAccountVacStatusChange isBannedFuture.\n   * @member {boolean} isBannedFuture\n   * @memberof CMsgGCHAccountVacStatusChange\n   * @instance\n   */\n\n  CMsgGCHAccountVacStatusChange.prototype.isBannedFuture = false;\n  /**\n   * Decodes a CMsgGCHAccountVacStatusChange message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCHAccountVacStatusChange\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCHAccountVacStatusChange} CMsgGCHAccountVacStatusChange\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCHAccountVacStatusChange.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCHAccountVacStatusChange();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.steamId = reader.fixed64();\n          break;\n\n        case 2:\n          message.appId = reader.uint32();\n          break;\n\n        case 3:\n          message.rtimeVacbanStarts = reader.uint32();\n          break;\n\n        case 4:\n          message.isBannedNow = reader.bool();\n          break;\n\n        case 5:\n          message.isBannedFuture = reader.bool();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCHAccountVacStatusChange;\n})();\n\nexports.CMsgGCGetPartnerAccountLink = $root.CMsgGCGetPartnerAccountLink = (() => {\n  /**\n   * Properties of a CMsgGCGetPartnerAccountLink.\n   * @exports ICMsgGCGetPartnerAccountLink\n   * @interface ICMsgGCGetPartnerAccountLink\n   * @property {number|Long|null} [steamid] CMsgGCGetPartnerAccountLink steamid\n   */\n\n  /**\n   * Constructs a new CMsgGCGetPartnerAccountLink.\n   * @exports CMsgGCGetPartnerAccountLink\n   * @classdesc Represents a CMsgGCGetPartnerAccountLink.\n   * @implements ICMsgGCGetPartnerAccountLink\n   * @constructor\n   * @param {ICMsgGCGetPartnerAccountLink=} [properties] Properties to set\n   */\n  function CMsgGCGetPartnerAccountLink(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCGetPartnerAccountLink steamid.\n   * @member {number|Long} steamid\n   * @memberof CMsgGCGetPartnerAccountLink\n   * @instance\n   */\n\n\n  CMsgGCGetPartnerAccountLink.prototype.steamid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n  /**\n   * Decodes a CMsgGCGetPartnerAccountLink message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCGetPartnerAccountLink\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCGetPartnerAccountLink} CMsgGCGetPartnerAccountLink\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCGetPartnerAccountLink.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCGetPartnerAccountLink();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.steamid = reader.fixed64();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCGetPartnerAccountLink;\n})();\n\nexports.CMsgGCGetPartnerAccountLink_Response = $root.CMsgGCGetPartnerAccountLink_Response = (() => {\n  /**\n   * Properties of a CMsgGCGetPartnerAccountLink_Response.\n   * @exports ICMsgGCGetPartnerAccountLink_Response\n   * @interface ICMsgGCGetPartnerAccountLink_Response\n   * @property {number|null} [pwid] CMsgGCGetPartnerAccountLink_Response pwid\n   * @property {number|null} [nexonid] CMsgGCGetPartnerAccountLink_Response nexonid\n   */\n\n  /**\n   * Constructs a new CMsgGCGetPartnerAccountLink_Response.\n   * @exports CMsgGCGetPartnerAccountLink_Response\n   * @classdesc Represents a CMsgGCGetPartnerAccountLink_Response.\n   * @implements ICMsgGCGetPartnerAccountLink_Response\n   * @constructor\n   * @param {ICMsgGCGetPartnerAccountLink_Response=} [properties] Properties to set\n   */\n  function CMsgGCGetPartnerAccountLink_Response(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCGetPartnerAccountLink_Response pwid.\n   * @member {number} pwid\n   * @memberof CMsgGCGetPartnerAccountLink_Response\n   * @instance\n   */\n\n\n  CMsgGCGetPartnerAccountLink_Response.prototype.pwid = 0;\n  /**\n   * CMsgGCGetPartnerAccountLink_Response nexonid.\n   * @member {number} nexonid\n   * @memberof CMsgGCGetPartnerAccountLink_Response\n   * @instance\n   */\n\n  CMsgGCGetPartnerAccountLink_Response.prototype.nexonid = 0;\n  /**\n   * Decodes a CMsgGCGetPartnerAccountLink_Response message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCGetPartnerAccountLink_Response\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCGetPartnerAccountLink_Response} CMsgGCGetPartnerAccountLink_Response\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCGetPartnerAccountLink_Response.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCGetPartnerAccountLink_Response();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.pwid = reader.uint32();\n          break;\n\n        case 2:\n          message.nexonid = reader.uint32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCGetPartnerAccountLink_Response;\n})();\n\nexports.CMsgGCRoutingInfo = $root.CMsgGCRoutingInfo = (() => {\n  /**\n   * Properties of a CMsgGCRoutingInfo.\n   * @exports ICMsgGCRoutingInfo\n   * @interface ICMsgGCRoutingInfo\n   * @property {Array.<number>|null} [dirIndex] CMsgGCRoutingInfo dirIndex\n   * @property {CMsgGCRoutingInfo.RoutingMethod|null} [method] CMsgGCRoutingInfo method\n   * @property {CMsgGCRoutingInfo.RoutingMethod|null} [fallback] CMsgGCRoutingInfo fallback\n   * @property {number|null} [protobufField] CMsgGCRoutingInfo protobufField\n   * @property {string|null} [webapiParam] CMsgGCRoutingInfo webapiParam\n   */\n\n  /**\n   * Constructs a new CMsgGCRoutingInfo.\n   * @exports CMsgGCRoutingInfo\n   * @classdesc Represents a CMsgGCRoutingInfo.\n   * @implements ICMsgGCRoutingInfo\n   * @constructor\n   * @param {ICMsgGCRoutingInfo=} [properties] Properties to set\n   */\n  function CMsgGCRoutingInfo(properties) {\n    this.dirIndex = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCRoutingInfo dirIndex.\n   * @member {Array.<number>} dirIndex\n   * @memberof CMsgGCRoutingInfo\n   * @instance\n   */\n\n\n  CMsgGCRoutingInfo.prototype.dirIndex = $util.emptyArray;\n  /**\n   * CMsgGCRoutingInfo method.\n   * @member {CMsgGCRoutingInfo.RoutingMethod} method\n   * @memberof CMsgGCRoutingInfo\n   * @instance\n   */\n\n  CMsgGCRoutingInfo.prototype.method = 0;\n  /**\n   * CMsgGCRoutingInfo fallback.\n   * @member {CMsgGCRoutingInfo.RoutingMethod} fallback\n   * @memberof CMsgGCRoutingInfo\n   * @instance\n   */\n\n  CMsgGCRoutingInfo.prototype.fallback = 1;\n  /**\n   * CMsgGCRoutingInfo protobufField.\n   * @member {number} protobufField\n   * @memberof CMsgGCRoutingInfo\n   * @instance\n   */\n\n  CMsgGCRoutingInfo.prototype.protobufField = 0;\n  /**\n   * CMsgGCRoutingInfo webapiParam.\n   * @member {string} webapiParam\n   * @memberof CMsgGCRoutingInfo\n   * @instance\n   */\n\n  CMsgGCRoutingInfo.prototype.webapiParam = \"\";\n  /**\n   * Decodes a CMsgGCRoutingInfo message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCRoutingInfo\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCRoutingInfo} CMsgGCRoutingInfo\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCRoutingInfo.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCRoutingInfo();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.dirIndex && message.dirIndex.length)) message.dirIndex = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.dirIndex.push(reader.uint32());\n          } else message.dirIndex.push(reader.uint32());\n\n          break;\n\n        case 2:\n          message.method = reader.int32();\n          break;\n\n        case 3:\n          message.fallback = reader.int32();\n          break;\n\n        case 4:\n          message.protobufField = reader.uint32();\n          break;\n\n        case 5:\n          message.webapiParam = reader.string();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n  /**\n   * RoutingMethod enum.\n   * @name CMsgGCRoutingInfo.RoutingMethod\n   * @enum {string}\n   * @property {number} RANDOM=0 RANDOM value\n   * @property {number} DISCARD=1 DISCARD value\n   * @property {number} CLIENT_STEAMID=2 CLIENT_STEAMID value\n   * @property {number} PROTOBUF_FIELD_UINT64=3 PROTOBUF_FIELD_UINT64 value\n   * @property {number} WEBAPI_PARAM_UINT64=4 WEBAPI_PARAM_UINT64 value\n   */\n\n\n  CMsgGCRoutingInfo.RoutingMethod = function () {\n    const valuesById = {},\n          values = Object.create(valuesById);\n    values[valuesById[0] = \"RANDOM\"] = 0;\n    values[valuesById[1] = \"DISCARD\"] = 1;\n    values[valuesById[2] = \"CLIENT_STEAMID\"] = 2;\n    values[valuesById[3] = \"PROTOBUF_FIELD_UINT64\"] = 3;\n    values[valuesById[4] = \"WEBAPI_PARAM_UINT64\"] = 4;\n    return values;\n  }();\n\n  return CMsgGCRoutingInfo;\n})();\n\nexports.CMsgGCMsgMasterSetWebAPIRouting = $root.CMsgGCMsgMasterSetWebAPIRouting = (() => {\n  /**\n   * Properties of a CMsgGCMsgMasterSetWebAPIRouting.\n   * @exports ICMsgGCMsgMasterSetWebAPIRouting\n   * @interface ICMsgGCMsgMasterSetWebAPIRouting\n   * @property {Array.<CMsgGCMsgMasterSetWebAPIRouting.IEntry>|null} [entries] CMsgGCMsgMasterSetWebAPIRouting entries\n   */\n\n  /**\n   * Constructs a new CMsgGCMsgMasterSetWebAPIRouting.\n   * @exports CMsgGCMsgMasterSetWebAPIRouting\n   * @classdesc Represents a CMsgGCMsgMasterSetWebAPIRouting.\n   * @implements ICMsgGCMsgMasterSetWebAPIRouting\n   * @constructor\n   * @param {ICMsgGCMsgMasterSetWebAPIRouting=} [properties] Properties to set\n   */\n  function CMsgGCMsgMasterSetWebAPIRouting(properties) {\n    this.entries = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCMsgMasterSetWebAPIRouting entries.\n   * @member {Array.<CMsgGCMsgMasterSetWebAPIRouting.IEntry>} entries\n   * @memberof CMsgGCMsgMasterSetWebAPIRouting\n   * @instance\n   */\n\n\n  CMsgGCMsgMasterSetWebAPIRouting.prototype.entries = $util.emptyArray;\n  /**\n   * Decodes a CMsgGCMsgMasterSetWebAPIRouting message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCMsgMasterSetWebAPIRouting\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCMsgMasterSetWebAPIRouting} CMsgGCMsgMasterSetWebAPIRouting\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCMsgMasterSetWebAPIRouting.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCMsgMasterSetWebAPIRouting();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.entries && message.entries.length)) message.entries = [];\n          message.entries.push($root.CMsgGCMsgMasterSetWebAPIRouting.Entry.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CMsgGCMsgMasterSetWebAPIRouting.Entry = function () {\n    /**\n     * Properties of an Entry.\n     * @memberof CMsgGCMsgMasterSetWebAPIRouting\n     * @interface IEntry\n     * @property {string|null} [interfaceName] Entry interfaceName\n     * @property {string|null} [methodName] Entry methodName\n     * @property {ICMsgGCRoutingInfo|null} [routing] Entry routing\n     */\n\n    /**\n     * Constructs a new Entry.\n     * @memberof CMsgGCMsgMasterSetWebAPIRouting\n     * @classdesc Represents an Entry.\n     * @implements IEntry\n     * @constructor\n     * @param {CMsgGCMsgMasterSetWebAPIRouting.IEntry=} [properties] Properties to set\n     */\n    function Entry(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Entry interfaceName.\n     * @member {string} interfaceName\n     * @memberof CMsgGCMsgMasterSetWebAPIRouting.Entry\n     * @instance\n     */\n\n\n    Entry.prototype.interfaceName = \"\";\n    /**\n     * Entry methodName.\n     * @member {string} methodName\n     * @memberof CMsgGCMsgMasterSetWebAPIRouting.Entry\n     * @instance\n     */\n\n    Entry.prototype.methodName = \"\";\n    /**\n     * Entry routing.\n     * @member {ICMsgGCRoutingInfo|null|undefined} routing\n     * @memberof CMsgGCMsgMasterSetWebAPIRouting.Entry\n     * @instance\n     */\n\n    Entry.prototype.routing = null;\n    /**\n     * Decodes an Entry message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCMsgMasterSetWebAPIRouting.Entry\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCMsgMasterSetWebAPIRouting.Entry} Entry\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    Entry.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CMsgGCMsgMasterSetWebAPIRouting.Entry();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.interfaceName = reader.string();\n            break;\n\n          case 2:\n            message.methodName = reader.string();\n            break;\n\n          case 3:\n            message.routing = $root.CMsgGCRoutingInfo.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return Entry;\n  }();\n\n  return CMsgGCMsgMasterSetWebAPIRouting;\n})();\n\nexports.CMsgGCMsgMasterSetClientMsgRouting = $root.CMsgGCMsgMasterSetClientMsgRouting = (() => {\n  /**\n   * Properties of a CMsgGCMsgMasterSetClientMsgRouting.\n   * @exports ICMsgGCMsgMasterSetClientMsgRouting\n   * @interface ICMsgGCMsgMasterSetClientMsgRouting\n   * @property {Array.<CMsgGCMsgMasterSetClientMsgRouting.IEntry>|null} [entries] CMsgGCMsgMasterSetClientMsgRouting entries\n   */\n\n  /**\n   * Constructs a new CMsgGCMsgMasterSetClientMsgRouting.\n   * @exports CMsgGCMsgMasterSetClientMsgRouting\n   * @classdesc Represents a CMsgGCMsgMasterSetClientMsgRouting.\n   * @implements ICMsgGCMsgMasterSetClientMsgRouting\n   * @constructor\n   * @param {ICMsgGCMsgMasterSetClientMsgRouting=} [properties] Properties to set\n   */\n  function CMsgGCMsgMasterSetClientMsgRouting(properties) {\n    this.entries = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCMsgMasterSetClientMsgRouting entries.\n   * @member {Array.<CMsgGCMsgMasterSetClientMsgRouting.IEntry>} entries\n   * @memberof CMsgGCMsgMasterSetClientMsgRouting\n   * @instance\n   */\n\n\n  CMsgGCMsgMasterSetClientMsgRouting.prototype.entries = $util.emptyArray;\n  /**\n   * Decodes a CMsgGCMsgMasterSetClientMsgRouting message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCMsgMasterSetClientMsgRouting\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCMsgMasterSetClientMsgRouting} CMsgGCMsgMasterSetClientMsgRouting\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCMsgMasterSetClientMsgRouting.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCMsgMasterSetClientMsgRouting();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.entries && message.entries.length)) message.entries = [];\n          message.entries.push($root.CMsgGCMsgMasterSetClientMsgRouting.Entry.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CMsgGCMsgMasterSetClientMsgRouting.Entry = function () {\n    /**\n     * Properties of an Entry.\n     * @memberof CMsgGCMsgMasterSetClientMsgRouting\n     * @interface IEntry\n     * @property {number|null} [msgType] Entry msgType\n     * @property {ICMsgGCRoutingInfo|null} [routing] Entry routing\n     */\n\n    /**\n     * Constructs a new Entry.\n     * @memberof CMsgGCMsgMasterSetClientMsgRouting\n     * @classdesc Represents an Entry.\n     * @implements IEntry\n     * @constructor\n     * @param {CMsgGCMsgMasterSetClientMsgRouting.IEntry=} [properties] Properties to set\n     */\n    function Entry(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Entry msgType.\n     * @member {number} msgType\n     * @memberof CMsgGCMsgMasterSetClientMsgRouting.Entry\n     * @instance\n     */\n\n\n    Entry.prototype.msgType = 0;\n    /**\n     * Entry routing.\n     * @member {ICMsgGCRoutingInfo|null|undefined} routing\n     * @memberof CMsgGCMsgMasterSetClientMsgRouting.Entry\n     * @instance\n     */\n\n    Entry.prototype.routing = null;\n    /**\n     * Decodes an Entry message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCMsgMasterSetClientMsgRouting.Entry\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCMsgMasterSetClientMsgRouting.Entry} Entry\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    Entry.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CMsgGCMsgMasterSetClientMsgRouting.Entry();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.msgType = reader.uint32();\n            break;\n\n          case 2:\n            message.routing = $root.CMsgGCRoutingInfo.decode(reader, reader.uint32());\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return Entry;\n  }();\n\n  return CMsgGCMsgMasterSetClientMsgRouting;\n})();\n\nexports.CMsgGCMsgMasterSetWebAPIRouting_Response = $root.CMsgGCMsgMasterSetWebAPIRouting_Response = (() => {\n  /**\n   * Properties of a CMsgGCMsgMasterSetWebAPIRouting_Response.\n   * @exports ICMsgGCMsgMasterSetWebAPIRouting_Response\n   * @interface ICMsgGCMsgMasterSetWebAPIRouting_Response\n   * @property {number|null} [eresult] CMsgGCMsgMasterSetWebAPIRouting_Response eresult\n   */\n\n  /**\n   * Constructs a new CMsgGCMsgMasterSetWebAPIRouting_Response.\n   * @exports CMsgGCMsgMasterSetWebAPIRouting_Response\n   * @classdesc Represents a CMsgGCMsgMasterSetWebAPIRouting_Response.\n   * @implements ICMsgGCMsgMasterSetWebAPIRouting_Response\n   * @constructor\n   * @param {ICMsgGCMsgMasterSetWebAPIRouting_Response=} [properties] Properties to set\n   */\n  function CMsgGCMsgMasterSetWebAPIRouting_Response(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCMsgMasterSetWebAPIRouting_Response eresult.\n   * @member {number} eresult\n   * @memberof CMsgGCMsgMasterSetWebAPIRouting_Response\n   * @instance\n   */\n\n\n  CMsgGCMsgMasterSetWebAPIRouting_Response.prototype.eresult = 2;\n  /**\n   * Decodes a CMsgGCMsgMasterSetWebAPIRouting_Response message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCMsgMasterSetWebAPIRouting_Response\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCMsgMasterSetWebAPIRouting_Response} CMsgGCMsgMasterSetWebAPIRouting_Response\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCMsgMasterSetWebAPIRouting_Response.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCMsgMasterSetWebAPIRouting_Response();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.eresult = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCMsgMasterSetWebAPIRouting_Response;\n})();\n\nexports.CMsgGCMsgMasterSetClientMsgRouting_Response = $root.CMsgGCMsgMasterSetClientMsgRouting_Response = (() => {\n  /**\n   * Properties of a CMsgGCMsgMasterSetClientMsgRouting_Response.\n   * @exports ICMsgGCMsgMasterSetClientMsgRouting_Response\n   * @interface ICMsgGCMsgMasterSetClientMsgRouting_Response\n   * @property {number|null} [eresult] CMsgGCMsgMasterSetClientMsgRouting_Response eresult\n   */\n\n  /**\n   * Constructs a new CMsgGCMsgMasterSetClientMsgRouting_Response.\n   * @exports CMsgGCMsgMasterSetClientMsgRouting_Response\n   * @classdesc Represents a CMsgGCMsgMasterSetClientMsgRouting_Response.\n   * @implements ICMsgGCMsgMasterSetClientMsgRouting_Response\n   * @constructor\n   * @param {ICMsgGCMsgMasterSetClientMsgRouting_Response=} [properties] Properties to set\n   */\n  function CMsgGCMsgMasterSetClientMsgRouting_Response(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCMsgMasterSetClientMsgRouting_Response eresult.\n   * @member {number} eresult\n   * @memberof CMsgGCMsgMasterSetClientMsgRouting_Response\n   * @instance\n   */\n\n\n  CMsgGCMsgMasterSetClientMsgRouting_Response.prototype.eresult = 2;\n  /**\n   * Decodes a CMsgGCMsgMasterSetClientMsgRouting_Response message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCMsgMasterSetClientMsgRouting_Response\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCMsgMasterSetClientMsgRouting_Response} CMsgGCMsgMasterSetClientMsgRouting_Response\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCMsgMasterSetClientMsgRouting_Response.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCMsgMasterSetClientMsgRouting_Response();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.eresult = reader.int32();\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  return CMsgGCMsgMasterSetClientMsgRouting_Response;\n})();\n\nexports.CMsgGCMsgSetOptions = $root.CMsgGCMsgSetOptions = (() => {\n  /**\n   * Properties of a CMsgGCMsgSetOptions.\n   * @exports ICMsgGCMsgSetOptions\n   * @interface ICMsgGCMsgSetOptions\n   * @property {Array.<CMsgGCMsgSetOptions.Option>|null} [options] CMsgGCMsgSetOptions options\n   * @property {Array.<CMsgGCMsgSetOptions.IMessageRange>|null} [clientMsgRanges] CMsgGCMsgSetOptions clientMsgRanges\n   */\n\n  /**\n   * Constructs a new CMsgGCMsgSetOptions.\n   * @exports CMsgGCMsgSetOptions\n   * @classdesc Represents a CMsgGCMsgSetOptions.\n   * @implements ICMsgGCMsgSetOptions\n   * @constructor\n   * @param {ICMsgGCMsgSetOptions=} [properties] Properties to set\n   */\n  function CMsgGCMsgSetOptions(properties) {\n    this.options = [];\n    this.clientMsgRanges = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCMsgSetOptions options.\n   * @member {Array.<CMsgGCMsgSetOptions.Option>} options\n   * @memberof CMsgGCMsgSetOptions\n   * @instance\n   */\n\n\n  CMsgGCMsgSetOptions.prototype.options = $util.emptyArray;\n  /**\n   * CMsgGCMsgSetOptions clientMsgRanges.\n   * @member {Array.<CMsgGCMsgSetOptions.IMessageRange>} clientMsgRanges\n   * @memberof CMsgGCMsgSetOptions\n   * @instance\n   */\n\n  CMsgGCMsgSetOptions.prototype.clientMsgRanges = $util.emptyArray;\n  /**\n   * Decodes a CMsgGCMsgSetOptions message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCMsgSetOptions\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCMsgSetOptions} CMsgGCMsgSetOptions\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCMsgSetOptions.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCMsgSetOptions();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          if (!(message.options && message.options.length)) message.options = [];\n\n          if ((tag & 7) === 2) {\n            let end2 = reader.uint32() + reader.pos;\n\n            while (reader.pos < end2) message.options.push(reader.int32());\n          } else message.options.push(reader.int32());\n\n          break;\n\n        case 2:\n          if (!(message.clientMsgRanges && message.clientMsgRanges.length)) message.clientMsgRanges = [];\n          message.clientMsgRanges.push($root.CMsgGCMsgSetOptions.MessageRange.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CMsgGCMsgSetOptions.MessageRange = function () {\n    /**\n     * Properties of a MessageRange.\n     * @memberof CMsgGCMsgSetOptions\n     * @interface IMessageRange\n     * @property {number} low MessageRange low\n     * @property {number} high MessageRange high\n     */\n\n    /**\n     * Constructs a new MessageRange.\n     * @memberof CMsgGCMsgSetOptions\n     * @classdesc Represents a MessageRange.\n     * @implements IMessageRange\n     * @constructor\n     * @param {CMsgGCMsgSetOptions.IMessageRange=} [properties] Properties to set\n     */\n    function MessageRange(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * MessageRange low.\n     * @member {number} low\n     * @memberof CMsgGCMsgSetOptions.MessageRange\n     * @instance\n     */\n\n\n    MessageRange.prototype.low = 0;\n    /**\n     * MessageRange high.\n     * @member {number} high\n     * @memberof CMsgGCMsgSetOptions.MessageRange\n     * @instance\n     */\n\n    MessageRange.prototype.high = 0;\n    /**\n     * Decodes a MessageRange message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCMsgSetOptions.MessageRange\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCMsgSetOptions.MessageRange} MessageRange\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    MessageRange.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CMsgGCMsgSetOptions.MessageRange();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.low = reader.uint32();\n            break;\n\n          case 2:\n            message.high = reader.uint32();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      if (!message.hasOwnProperty(\"low\")) throw $util.ProtocolError(\"missing required 'low'\", {\n        instance: message\n      });\n      if (!message.hasOwnProperty(\"high\")) throw $util.ProtocolError(\"missing required 'high'\", {\n        instance: message\n      });\n      return message;\n    };\n\n    return MessageRange;\n  }();\n  /**\n   * Option enum.\n   * @name CMsgGCMsgSetOptions.Option\n   * @enum {string}\n   * @property {number} NOTIFY_USER_SESSIONS=0 NOTIFY_USER_SESSIONS value\n   * @property {number} NOTIFY_SERVER_SESSIONS=1 NOTIFY_SERVER_SESSIONS value\n   * @property {number} NOTIFY_ACHIEVEMENTS=2 NOTIFY_ACHIEVEMENTS value\n   * @property {number} NOTIFY_VAC_ACTION=3 NOTIFY_VAC_ACTION value\n   */\n\n\n  CMsgGCMsgSetOptions.Option = function () {\n    const valuesById = {},\n          values = Object.create(valuesById);\n    values[valuesById[0] = \"NOTIFY_USER_SESSIONS\"] = 0;\n    values[valuesById[1] = \"NOTIFY_SERVER_SESSIONS\"] = 1;\n    values[valuesById[2] = \"NOTIFY_ACHIEVEMENTS\"] = 2;\n    values[valuesById[3] = \"NOTIFY_VAC_ACTION\"] = 3;\n    return values;\n  }();\n\n  return CMsgGCMsgSetOptions;\n})();\n\nexports.CMsgGCHUpdateSession = $root.CMsgGCHUpdateSession = (() => {\n  /**\n   * Properties of a CMsgGCHUpdateSession.\n   * @exports ICMsgGCHUpdateSession\n   * @interface ICMsgGCHUpdateSession\n   * @property {number|Long|null} [steamId] CMsgGCHUpdateSession steamId\n   * @property {number|null} [appId] CMsgGCHUpdateSession appId\n   * @property {boolean|null} [online] CMsgGCHUpdateSession online\n   * @property {number|Long|null} [serverSteamId] CMsgGCHUpdateSession serverSteamId\n   * @property {number|null} [serverAddr] CMsgGCHUpdateSession serverAddr\n   * @property {number|null} [serverPort] CMsgGCHUpdateSession serverPort\n   * @property {number|null} [osType] CMsgGCHUpdateSession osType\n   * @property {number|null} [clientAddr] CMsgGCHUpdateSession clientAddr\n   * @property {Array.<CMsgGCHUpdateSession.IExtraField>|null} [extraFields] CMsgGCHUpdateSession extraFields\n   */\n\n  /**\n   * Constructs a new CMsgGCHUpdateSession.\n   * @exports CMsgGCHUpdateSession\n   * @classdesc Represents a CMsgGCHUpdateSession.\n   * @implements ICMsgGCHUpdateSession\n   * @constructor\n   * @param {ICMsgGCHUpdateSession=} [properties] Properties to set\n   */\n  function CMsgGCHUpdateSession(properties) {\n    this.extraFields = [];\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgGCHUpdateSession steamId.\n   * @member {number|Long} steamId\n   * @memberof CMsgGCHUpdateSession\n   * @instance\n   */\n\n\n  CMsgGCHUpdateSession.prototype.steamId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n  /**\n   * CMsgGCHUpdateSession appId.\n   * @member {number} appId\n   * @memberof CMsgGCHUpdateSession\n   * @instance\n   */\n\n  CMsgGCHUpdateSession.prototype.appId = 0;\n  /**\n   * CMsgGCHUpdateSession online.\n   * @member {boolean} online\n   * @memberof CMsgGCHUpdateSession\n   * @instance\n   */\n\n  CMsgGCHUpdateSession.prototype.online = false;\n  /**\n   * CMsgGCHUpdateSession serverSteamId.\n   * @member {number|Long} serverSteamId\n   * @memberof CMsgGCHUpdateSession\n   * @instance\n   */\n\n  CMsgGCHUpdateSession.prototype.serverSteamId = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n  /**\n   * CMsgGCHUpdateSession serverAddr.\n   * @member {number} serverAddr\n   * @memberof CMsgGCHUpdateSession\n   * @instance\n   */\n\n  CMsgGCHUpdateSession.prototype.serverAddr = 0;\n  /**\n   * CMsgGCHUpdateSession serverPort.\n   * @member {number} serverPort\n   * @memberof CMsgGCHUpdateSession\n   * @instance\n   */\n\n  CMsgGCHUpdateSession.prototype.serverPort = 0;\n  /**\n   * CMsgGCHUpdateSession osType.\n   * @member {number} osType\n   * @memberof CMsgGCHUpdateSession\n   * @instance\n   */\n\n  CMsgGCHUpdateSession.prototype.osType = 0;\n  /**\n   * CMsgGCHUpdateSession clientAddr.\n   * @member {number} clientAddr\n   * @memberof CMsgGCHUpdateSession\n   * @instance\n   */\n\n  CMsgGCHUpdateSession.prototype.clientAddr = 0;\n  /**\n   * CMsgGCHUpdateSession extraFields.\n   * @member {Array.<CMsgGCHUpdateSession.IExtraField>} extraFields\n   * @memberof CMsgGCHUpdateSession\n   * @instance\n   */\n\n  CMsgGCHUpdateSession.prototype.extraFields = $util.emptyArray;\n  /**\n   * Decodes a CMsgGCHUpdateSession message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgGCHUpdateSession\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgGCHUpdateSession} CMsgGCHUpdateSession\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgGCHUpdateSession.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgGCHUpdateSession();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.steamId = reader.fixed64();\n          break;\n\n        case 2:\n          message.appId = reader.uint32();\n          break;\n\n        case 3:\n          message.online = reader.bool();\n          break;\n\n        case 4:\n          message.serverSteamId = reader.fixed64();\n          break;\n\n        case 5:\n          message.serverAddr = reader.uint32();\n          break;\n\n        case 6:\n          message.serverPort = reader.uint32();\n          break;\n\n        case 7:\n          message.osType = reader.uint32();\n          break;\n\n        case 8:\n          message.clientAddr = reader.uint32();\n          break;\n\n        case 9:\n          if (!(message.extraFields && message.extraFields.length)) message.extraFields = [];\n          message.extraFields.push($root.CMsgGCHUpdateSession.ExtraField.decode(reader, reader.uint32()));\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CMsgGCHUpdateSession.ExtraField = function () {\n    /**\n     * Properties of an ExtraField.\n     * @memberof CMsgGCHUpdateSession\n     * @interface IExtraField\n     * @property {string|null} [name] ExtraField name\n     * @property {string|null} [value] ExtraField value\n     */\n\n    /**\n     * Constructs a new ExtraField.\n     * @memberof CMsgGCHUpdateSession\n     * @classdesc Represents an ExtraField.\n     * @implements IExtraField\n     * @constructor\n     * @param {CMsgGCHUpdateSession.IExtraField=} [properties] Properties to set\n     */\n    function ExtraField(properties) {\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * ExtraField name.\n     * @member {string} name\n     * @memberof CMsgGCHUpdateSession.ExtraField\n     * @instance\n     */\n\n\n    ExtraField.prototype.name = \"\";\n    /**\n     * ExtraField value.\n     * @member {string} value\n     * @memberof CMsgGCHUpdateSession.ExtraField\n     * @instance\n     */\n\n    ExtraField.prototype.value = \"\";\n    /**\n     * Decodes an ExtraField message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCHUpdateSession.ExtraField\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCHUpdateSession.ExtraField} ExtraField\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    ExtraField.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CMsgGCHUpdateSession.ExtraField();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.name = reader.string();\n            break;\n\n          case 2:\n            message.value = reader.string();\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return ExtraField;\n  }();\n\n  return CMsgGCHUpdateSession;\n})();\n\nexports.CMsgNotificationOfSuspiciousActivity = $root.CMsgNotificationOfSuspiciousActivity = (() => {\n  /**\n   * Properties of a CMsgNotificationOfSuspiciousActivity.\n   * @exports ICMsgNotificationOfSuspiciousActivity\n   * @interface ICMsgNotificationOfSuspiciousActivity\n   * @property {number|Long|null} [steamid] CMsgNotificationOfSuspiciousActivity steamid\n   * @property {number|null} [appid] CMsgNotificationOfSuspiciousActivity appid\n   * @property {CMsgNotificationOfSuspiciousActivity.IMultipleGameInstances|null} [multipleInstances] CMsgNotificationOfSuspiciousActivity multipleInstances\n   */\n\n  /**\n   * Constructs a new CMsgNotificationOfSuspiciousActivity.\n   * @exports CMsgNotificationOfSuspiciousActivity\n   * @classdesc Represents a CMsgNotificationOfSuspiciousActivity.\n   * @implements ICMsgNotificationOfSuspiciousActivity\n   * @constructor\n   * @param {ICMsgNotificationOfSuspiciousActivity=} [properties] Properties to set\n   */\n  function CMsgNotificationOfSuspiciousActivity(properties) {\n    if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n  }\n  /**\n   * CMsgNotificationOfSuspiciousActivity steamid.\n   * @member {number|Long} steamid\n   * @memberof CMsgNotificationOfSuspiciousActivity\n   * @instance\n   */\n\n\n  CMsgNotificationOfSuspiciousActivity.prototype.steamid = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;\n  /**\n   * CMsgNotificationOfSuspiciousActivity appid.\n   * @member {number} appid\n   * @memberof CMsgNotificationOfSuspiciousActivity\n   * @instance\n   */\n\n  CMsgNotificationOfSuspiciousActivity.prototype.appid = 0;\n  /**\n   * CMsgNotificationOfSuspiciousActivity multipleInstances.\n   * @member {CMsgNotificationOfSuspiciousActivity.IMultipleGameInstances|null|undefined} multipleInstances\n   * @memberof CMsgNotificationOfSuspiciousActivity\n   * @instance\n   */\n\n  CMsgNotificationOfSuspiciousActivity.prototype.multipleInstances = null;\n  /**\n   * Decodes a CMsgNotificationOfSuspiciousActivity message from the specified reader or buffer.\n   * @function decode\n   * @memberof CMsgNotificationOfSuspiciousActivity\n   * @static\n   * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n   * @param {number} [length] Message length if known beforehand\n   * @returns {CMsgNotificationOfSuspiciousActivity} CMsgNotificationOfSuspiciousActivity\n   * @throws {Error} If the payload is not a reader or valid buffer\n   * @throws {$protobuf.util.ProtocolError} If required fields are missing\n   */\n\n  CMsgNotificationOfSuspiciousActivity.decode = function decode(reader, length) {\n    if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n    let end = length === undefined ? reader.len : reader.pos + length,\n        message = new $root.CMsgNotificationOfSuspiciousActivity();\n\n    while (reader.pos < end) {\n      let tag = reader.uint32();\n\n      switch (tag >>> 3) {\n        case 1:\n          message.steamid = reader.fixed64();\n          break;\n\n        case 2:\n          message.appid = reader.uint32();\n          break;\n\n        case 3:\n          message.multipleInstances = $root.CMsgNotificationOfSuspiciousActivity.MultipleGameInstances.decode(reader, reader.uint32());\n          break;\n\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n\n    return message;\n  };\n\n  CMsgNotificationOfSuspiciousActivity.MultipleGameInstances = function () {\n    /**\n     * Properties of a MultipleGameInstances.\n     * @memberof CMsgNotificationOfSuspiciousActivity\n     * @interface IMultipleGameInstances\n     * @property {number|null} [appInstanceCount] MultipleGameInstances appInstanceCount\n     * @property {Array.<number|Long>|null} [otherSteamids] MultipleGameInstances otherSteamids\n     */\n\n    /**\n     * Constructs a new MultipleGameInstances.\n     * @memberof CMsgNotificationOfSuspiciousActivity\n     * @classdesc Represents a MultipleGameInstances.\n     * @implements IMultipleGameInstances\n     * @constructor\n     * @param {CMsgNotificationOfSuspiciousActivity.IMultipleGameInstances=} [properties] Properties to set\n     */\n    function MultipleGameInstances(properties) {\n      this.otherSteamids = [];\n      if (properties) for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i) if (properties[keys[i]] != null) this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * MultipleGameInstances appInstanceCount.\n     * @member {number} appInstanceCount\n     * @memberof CMsgNotificationOfSuspiciousActivity.MultipleGameInstances\n     * @instance\n     */\n\n\n    MultipleGameInstances.prototype.appInstanceCount = 0;\n    /**\n     * MultipleGameInstances otherSteamids.\n     * @member {Array.<number|Long>} otherSteamids\n     * @memberof CMsgNotificationOfSuspiciousActivity.MultipleGameInstances\n     * @instance\n     */\n\n    MultipleGameInstances.prototype.otherSteamids = $util.emptyArray;\n    /**\n     * Decodes a MultipleGameInstances message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgNotificationOfSuspiciousActivity.MultipleGameInstances\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgNotificationOfSuspiciousActivity.MultipleGameInstances} MultipleGameInstances\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n\n    MultipleGameInstances.decode = function decode(reader, length) {\n      if (!(reader instanceof $Reader)) reader = $Reader.create(reader);\n      let end = length === undefined ? reader.len : reader.pos + length,\n          message = new $root.CMsgNotificationOfSuspiciousActivity.MultipleGameInstances();\n\n      while (reader.pos < end) {\n        let tag = reader.uint32();\n\n        switch (tag >>> 3) {\n          case 1:\n            message.appInstanceCount = reader.uint32();\n            break;\n\n          case 2:\n            if (!(message.otherSteamids && message.otherSteamids.length)) message.otherSteamids = [];\n\n            if ((tag & 7) === 2) {\n              let end2 = reader.uint32() + reader.pos;\n\n              while (reader.pos < end2) message.otherSteamids.push(reader.fixed64());\n            } else message.otherSteamids.push(reader.fixed64());\n\n            break;\n\n          default:\n            reader.skipType(tag & 7);\n            break;\n        }\n      }\n\n      return message;\n    };\n\n    return MultipleGameInstances;\n  }();\n\n  return CMsgNotificationOfSuspiciousActivity;\n})();","map":{"version":3,"sources":["../../src/protobufs/cstrike15_usermessages.js"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = exports.CMsgNotificationOfSuspiciousActivity = exports.CMsgGCHUpdateSession = exports.CMsgGCMsgSetOptions = exports.CMsgGCMsgMasterSetClientMsgRouting_Response = exports.CMsgGCMsgMasterSetWebAPIRouting_Response = exports.CMsgGCMsgMasterSetClientMsgRouting = exports.CMsgGCMsgMasterSetWebAPIRouting = exports.CMsgGCRoutingInfo = exports.CMsgGCGetPartnerAccountLink_Response = exports.CMsgGCGetPartnerAccountLink = exports.CMsgGCHAccountVacStatusChange = exports.CGCSystemMsg_GetPurchaseTrust_Response = exports.CGCSystemMsg_GetPurchaseTrust_Request = exports.CMsgGCMsgWebAPIJobRequestForwardResponse = exports.CMsgGCMsgMasterSetDirectory_Response = exports.CMsgGCMsgMasterSetDirectory = exports.CMsgGCCheckFriendship_Response = exports.CMsgGCCheckFriendship = exports.CMsgGCGetPersonaNames_Response = exports.CMsgGCGetPersonaNames = exports.CGCSystemMsg_GetAccountDetails_Response = exports.CGCSystemMsg_GetAccountDetails = exports.CMsgAMGrantGuestPasses2Response = exports.CMsgAMGrantGuestPasses2 = exports.CMsgGCGetEmailTemplateResponse = exports.CMsgGCGetEmailTemplate = exports.CMsgAMSendEmailResponse = exports.CMsgAMSendEmail = exports.CGCMsgGetSystemStatsResponse = exports.CGCMsgGetSystemStats = exports.CGCMsgSystemStatsSchema = exports.CGCMsgGetIPLocationResponse = exports.CIPLocationInfo = exports.CGCMsgGetIPLocation = exports.CMsgAMAddFreeLicenseResponse = exports.CMsgAMAddFreeLicense = exports.CGCMsgSQLStatsResponse = exports.CGCMsgSQLStats = exports.CGCMsgMemCachedStatsResponse = exports.CGCMsgMemCachedStats = exports.CGCMsgMemCachedDelete = exports.CGCMsgMemCachedSet = exports.CGCMsgMemCachedGetResponse = exports.CGCMsgMemCachedGet = exports.CMsgGCGetCommandListResponse = exports.CMsgGCGetCommandList = exports.CMsgAMGetUserGameStatsResponse = exports.CMsgAMGetUserGameStats = exports.CMsgAMGetLicensesResponse = exports.CMsgPackageLicense = exports.CMsgAMGetLicenses = exports.CMsgNotifyWatchdog = exports.CMsgAMFindAccountsResponse = exports.CMsgAMFindAccounts = exports.CMsgHttpResponse = exports.CMsgWebAPIRequest = exports.CMsgHttpRequest = exports.CMsgWebAPIKey = exports.CMsgProtoBufHeader = exports.CMsgGCCStrike15_v2_Client2GCStreamUnlock = exports.CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin = exports.CMsgGCCStrike15_v2_AcknowledgePenalty = exports.CMsgGC_GlobalGame_Play = exports.CMsgGC_GlobalGame_Unsubscribe = exports.CMsgGC_GlobalGame_Subscribe = exports.CSOPersonaDataPublic = exports.CSOQuestProgress = exports.CSOEconCoupon = exports.CMsgGCCStrike15_v2_GC2ClientTournamentInfo = exports.CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure = exports.CMsgGCCStrike15_v2_Server2GCClientValidate = exports.CMsgGCCStrike15_v2_ClientSubmitSurveyVote = exports.CMsgGCCStrike15_v2_GiftsLeaderboardResponse = exports.CMsgGCCStrike15_v2_GiftsLeaderboardRequest = exports.CMsgGCCStrike15_v2_ServerVarValueNotificationInfo = exports.CMsgGCCStrike15_v2_ClientVarValueNotificationInfo = exports.CMsgCStrike15Welcome = exports.CMsgGCToGCReloadVersions = exports.CAttribute_String = exports.CMsgGCCStrike15_v2_Fantasy = exports.CMsgGCCStrike15_v2_Predictions = exports.CMsgGCCStrike15_v2_MatchList = exports.CDataGCCStrike15_v2_TournamentInfo = exports.CDataGCCStrike15_v2_TournamentSection = exports.CDataGCCStrike15_v2_TournamentGroup = exports.CDataGCCStrike15_v2_TournamentGroupTeam = exports.CDataGCCStrike15_v2_MatchInfo = exports.CMsgGCCStrike15_v2_MatchListRequestFullGameInfo = exports.CMsgGCCStrike15_v2_MatchListRequestTournamentGames = exports.CMsgGCCStrike15_v2_MatchListRequestRecentUserGames = exports.CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser = exports.CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames = exports.CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification = exports.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse = exports.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest = exports.CMsgItemAcknowledged = exports.CMsgGCCStrike15_v2_MatchEndRewardDropsNotification = exports.CEconItemPreviewDataBlock = exports.CMsgGCCStrike15_v2_MatchEndRunRewardDrops = exports.CMsgGCCStrike15_v2_Client2GCTextMsg = exports.CMsgGCCStrike15_v2_GC2ClientTextMsg = exports.CClientHeaderOverwatchEvidence = exports.CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus = exports.CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment = exports.CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate = exports.CMsgGCCStrike15_v2_PlayersProfile = exports.CMsgGCCStrike15_v2_ClientRequestPlayersProfile = exports.CMsgGCCStrike15_v2_WatchInfoUsers = exports.CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded = exports.CMsgGCCstrike15_v2_ClientRequestNewMission = exports.CMsgGCCStrike15_v2_ClientRequestJoinServerData = exports.CMsgGCCStrike15_v2_ClientRequestJoinFriendData = exports.WatchableMatchInfo = exports.CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends = exports.CMsgGCCStrike15_v2_ClientReportResponse = exports.CMsgGCCStrike15_v2_ClientReportServer = exports.CMsgGCCStrike15_v2_ClientCommendPlayer = exports.CMsgGCCStrike15_v2_ClientReportPlayer = exports.CMsgGCCStrike15_v2_ServerNotificationForUserPenalty = exports.CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate = exports.CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate = exports.CMsgGCCStrike15_v2_MatchmakingServer2GCKick = exports.CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon = exports.CMsgGCCStrike15_v2_AccountPrivacySettings = exports.CMsgGCCStrike15_v2_MatchmakingGC2ClientHello = exports.CMsgGCCStrike15_v2_MatchmakingClient2GCHello = exports.CMsgGCCStrike15_v2_MatchmakingServerMatchEnd = exports.CMsgGCCStrike15_v2_MatchmakingServerRoundStats = exports.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve = exports.CMsgGCCStrike15_v2_MatchmakingServerReservationResponse = exports.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve = exports.CPreMatchInfoData = exports.CDataGCCStrike15_v2_TournamentMatchDraft = exports.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate = exports.CMsgGCCStrike15_v2_MatchmakingClient2ServerPing = exports.CMsgGCCStrike15_v2_MatchmakingStop = exports.CMsgGCCStrike15_v2_MatchmakingStart = exports.CMsgGCCStrike15_v2_GC2ServerReservationUpdate = exports.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm = exports.CMsgGCCStrike15_v2_MatchmakingGCOperationalStats = exports.CMsgGC_ServerQuestUpdateData = exports.PlayerQuestData = exports.MatchEndItemUpdates = exports.XpProgressData = exports.IpAddressMask = exports.ServerHltvInfo = exports.TournamentMatchSetup = exports.AccountActivity = exports.PlayerMedalsInfo = exports.PlayerCommendationInfo = exports.PlayerRankingInfo = exports.OperationalStatisticsPacket = exports.OperationalStatisticElement = exports.OperationalStatisticDescription = exports.GlobalStatistics = exports.TournamentEvent = exports.TournamentTeam = exports.TournamentPlayer = exports.DetailedSearchStatistic = exports.GameServerPing = exports.CCLCMsg_HltvReplay = exports.CSVCMsg_HltvReplay = exports.CSVCMsg_EncryptedData = exports.CSVCMsg_CmdKeyValues = exports.CSVCMsg_EntityMsg = exports.CSVCMsg_Sounds = exports.CSVCMsg_PacketEntities = exports.CSVCMsg_TempEntities = exports.CSVCMsg_GameEventList = exports.CSVCMsg_GameEvent = exports.CSVCMsg_PaintmapData = exports.CSVCMsg_UserMessage = exports.CSVCMsg_Menu = exports.CSVCMsg_GetCvarValue = exports.CSVCMsg_SplitScreen = exports.CSVCMsg_BSPDecal = exports.CSVCMsg_Prefetch = exports.CSVCMsg_CrosshairAngle = exports.CSVCMsg_FixAngle = exports.CSVCMsg_VoiceData = exports.CSVCMsg_VoiceInit = exports.CSVCMsg_UpdateStringTable = exports.CSVCMsg_CreateStringTable = exports.CSVCMsg_SetView = exports.CSVCMsg_SetPause = exports.CSVCMsg_Print = exports.CSVCMsg_SendTable = exports.CSVCMsg_ClassInfo = exports.CSVCMsg_ServerInfo = exports.CCLCMsg_CmdKeyValues = exports.CCLCMsg_SplitPlayerConnect = exports.CCLCMsg_LoadingProgress = exports.CCLCMsg_FileCRCCheck = exports.CCLCMsg_RespondCvarValue = exports.CCLCMsg_ListenEvents = exports.CCLCMsg_BaselineAck = exports.CCLCMsg_VoiceData = exports.CCLCMsg_Move = exports.CCLCMsg_ClientInfo = exports.CNETMsg_PlayerAvatarData = exports.CNETMsg_SplitScreenUser = exports.CNETMsg_File = exports.CNETMsg_Disconnect = exports.CNETMsg_NOP = exports.CNETMsg_SetConVar = exports.CMsg_CVars = exports.CNETMsg_SignonState = exports.CNETMsg_StringCmd = exports.CNETMsg_Tick = exports.CMsgRGBA = exports.CMsgQAngle = exports.CMsgVector2D = exports.CMsgVector = exports.google = exports.CCSUsrMsg_ServerRankRevealAll = exports.CCSUsrMsg_ClientInfo = exports.CCSUsrMsg_WarmupHasEnded = exports.CCSUsrMsg_DisconnectToLobby = exports.CCSUsrMsg_StopSpectatorMode = exports.CCSUsrMsg_RequestState = exports.CCSUsrMsg_GameTitle = exports.CCSUsrMsg_ResetHud = exports.CCSUsrMsg_RoundBackupFilenames = exports.CCSUsrMsg_GlowPropTurnOff = exports.CCSUsrMsg_ItemDrop = exports.CCSUsrMsg_MatchStatsUpdate = exports.CCSUsrMsg_MarkAchievement = exports.CCSUsrMsg_AmmoDenied = exports.CCSUsrMsg_BarTime = exports.CCSUsrMsg_ShowMenu = exports.CCSUsrMsg_ItemPickup = exports.CCSUsrMsg_XpUpdate = exports.CCSUsrMsg_ServerRankUpdate = exports.CCSUsrMsg_SendLastKillerDamageToClient = exports.CCSUsrMsg_VoteSetup = exports.CCSUsrMsg_VoteFailed = exports.CCSUsrMsg_VotePass = exports.CCSUsrMsg_VoteStart = exports.CCSUsrMsg_CallVoteFailed = exports.CCSUsrMsg_XRankUpd = exports.CCSUsrMsg_XRankGet = exports.CCSUsrMsg_QuestProgress = exports.CCSUsrMsg_DisplayInventory = exports.CCSUsrMsg_PlayerStatsUpdate = exports.CCSUsrMsg_MatchEndConditions = exports.CCSUsrMsg_AchievementEvent = exports.CCSUsrMsg_CurrentTimescale = exports.CCSUsrMsg_DesiredTimescale = exports.CCSUsrMsg_KillCam = exports.CCSUsrMsg_ReportHit = exports.CCSUsrMsg_AdjustMoney = exports.CCSUsrMsg_ReloadEffect = exports.CCSUsrMsg_SendPlayerItemFound = exports.CCSUsrMsg_SendPlayerItemDrops = exports.CCSUsrMsg_ProcessSpottedEntityUpdate = exports.CCSUsrMsg_KeyHintText = exports.CCSUsrMsg_HintText = exports.CCSUsrMsg_RadioText = exports.CCSUsrMsg_Damage = exports.CCSUsrMsg_VoiceMask = exports.CCSUsrMsg_RawAudio = exports.CCSUsrMsg_SendAudio = exports.CCSUsrMsg_CloseCaptionDirect = exports.CCSUsrMsg_CloseCaption = exports.CCSUsrMsg_Rumble = exports.CCSUsrMsg_Fade = exports.CCSUsrMsg_Shake = exports.CCSUsrMsg_HudMsg = exports.CCSUsrMsg_TextMsg = exports.CCSUsrMsg_SayText2 = exports.CCSUsrMsg_SayText = exports.CCSUsrMsg_HudText = exports.CCSUsrMsg_Train = exports.CCSUsrMsg_Geiger = exports.CCSUsrMsg_VGUIMenu = exports.ECstrike15UserMessages = void 0;\n/* tslint:disable */\nconst $protobuf = require(\"protobufjs/minimal\");\n// Common aliases\nconst $Reader = $protobuf.Reader, $util = $protobuf.util;\n// Exported root namespace\nconst $root = $protobuf.roots[\"default\"] || ($protobuf.roots[\"default\"] = {});\nexports.default = $root;\n/**\n * ECstrike15UserMessages enum.\n * @exports ECstrike15UserMessages\n * @enum {string}\n * @property {number} CS_UM_VGUIMenu=1 CS_UM_VGUIMenu value\n * @property {number} CS_UM_Geiger=2 CS_UM_Geiger value\n * @property {number} CS_UM_Train=3 CS_UM_Train value\n * @property {number} CS_UM_HudText=4 CS_UM_HudText value\n * @property {number} CS_UM_SayText=5 CS_UM_SayText value\n * @property {number} CS_UM_SayText2=6 CS_UM_SayText2 value\n * @property {number} CS_UM_TextMsg=7 CS_UM_TextMsg value\n * @property {number} CS_UM_HudMsg=8 CS_UM_HudMsg value\n * @property {number} CS_UM_ResetHud=9 CS_UM_ResetHud value\n * @property {number} CS_UM_GameTitle=10 CS_UM_GameTitle value\n * @property {number} CS_UM_Shake=12 CS_UM_Shake value\n * @property {number} CS_UM_Fade=13 CS_UM_Fade value\n * @property {number} CS_UM_Rumble=14 CS_UM_Rumble value\n * @property {number} CS_UM_CloseCaption=15 CS_UM_CloseCaption value\n * @property {number} CS_UM_CloseCaptionDirect=16 CS_UM_CloseCaptionDirect value\n * @property {number} CS_UM_SendAudio=17 CS_UM_SendAudio value\n * @property {number} CS_UM_RawAudio=18 CS_UM_RawAudio value\n * @property {number} CS_UM_VoiceMask=19 CS_UM_VoiceMask value\n * @property {number} CS_UM_RequestState=20 CS_UM_RequestState value\n * @property {number} CS_UM_Damage=21 CS_UM_Damage value\n * @property {number} CS_UM_RadioText=22 CS_UM_RadioText value\n * @property {number} CS_UM_HintText=23 CS_UM_HintText value\n * @property {number} CS_UM_KeyHintText=24 CS_UM_KeyHintText value\n * @property {number} CS_UM_ProcessSpottedEntityUpdate=25 CS_UM_ProcessSpottedEntityUpdate value\n * @property {number} CS_UM_ReloadEffect=26 CS_UM_ReloadEffect value\n * @property {number} CS_UM_AdjustMoney=27 CS_UM_AdjustMoney value\n * @property {number} CS_UM_UpdateTeamMoney=28 CS_UM_UpdateTeamMoney value\n * @property {number} CS_UM_StopSpectatorMode=29 CS_UM_StopSpectatorMode value\n * @property {number} CS_UM_KillCam=30 CS_UM_KillCam value\n * @property {number} CS_UM_DesiredTimescale=31 CS_UM_DesiredTimescale value\n * @property {number} CS_UM_CurrentTimescale=32 CS_UM_CurrentTimescale value\n * @property {number} CS_UM_AchievementEvent=33 CS_UM_AchievementEvent value\n * @property {number} CS_UM_MatchEndConditions=34 CS_UM_MatchEndConditions value\n * @property {number} CS_UM_DisconnectToLobby=35 CS_UM_DisconnectToLobby value\n * @property {number} CS_UM_PlayerStatsUpdate=36 CS_UM_PlayerStatsUpdate value\n * @property {number} CS_UM_DisplayInventory=37 CS_UM_DisplayInventory value\n * @property {number} CS_UM_WarmupHasEnded=38 CS_UM_WarmupHasEnded value\n * @property {number} CS_UM_ClientInfo=39 CS_UM_ClientInfo value\n * @property {number} CS_UM_XRankGet=40 CS_UM_XRankGet value\n * @property {number} CS_UM_XRankUpd=41 CS_UM_XRankUpd value\n * @property {number} CS_UM_CallVoteFailed=45 CS_UM_CallVoteFailed value\n * @property {number} CS_UM_VoteStart=46 CS_UM_VoteStart value\n * @property {number} CS_UM_VotePass=47 CS_UM_VotePass value\n * @property {number} CS_UM_VoteFailed=48 CS_UM_VoteFailed value\n * @property {number} CS_UM_VoteSetup=49 CS_UM_VoteSetup value\n * @property {number} CS_UM_ServerRankRevealAll=50 CS_UM_ServerRankRevealAll value\n * @property {number} CS_UM_SendLastKillerDamageToClient=51 CS_UM_SendLastKillerDamageToClient value\n * @property {number} CS_UM_ServerRankUpdate=52 CS_UM_ServerRankUpdate value\n * @property {number} CS_UM_ItemPickup=53 CS_UM_ItemPickup value\n * @property {number} CS_UM_ShowMenu=54 CS_UM_ShowMenu value\n * @property {number} CS_UM_BarTime=55 CS_UM_BarTime value\n * @property {number} CS_UM_AmmoDenied=56 CS_UM_AmmoDenied value\n * @property {number} CS_UM_MarkAchievement=57 CS_UM_MarkAchievement value\n * @property {number} CS_UM_MatchStatsUpdate=58 CS_UM_MatchStatsUpdate value\n * @property {number} CS_UM_ItemDrop=59 CS_UM_ItemDrop value\n * @property {number} CS_UM_GlowPropTurnOff=60 CS_UM_GlowPropTurnOff value\n * @property {number} CS_UM_SendPlayerItemDrops=61 CS_UM_SendPlayerItemDrops value\n * @property {number} CS_UM_RoundBackupFilenames=62 CS_UM_RoundBackupFilenames value\n * @property {number} CS_UM_SendPlayerItemFound=63 CS_UM_SendPlayerItemFound value\n * @property {number} CS_UM_ReportHit=64 CS_UM_ReportHit value\n * @property {number} CS_UM_XpUpdate=65 CS_UM_XpUpdate value\n * @property {number} CS_UM_QuestProgress=66 CS_UM_QuestProgress value\n */\nexports.ECstrike15UserMessages = ($root.ECstrike15UserMessages = (function () {\n    const valuesById = {}, values = Object.create(valuesById);\n    values[(valuesById[1] = \"CS_UM_VGUIMenu\")] = 1;\n    values[(valuesById[2] = \"CS_UM_Geiger\")] = 2;\n    values[(valuesById[3] = \"CS_UM_Train\")] = 3;\n    values[(valuesById[4] = \"CS_UM_HudText\")] = 4;\n    values[(valuesById[5] = \"CS_UM_SayText\")] = 5;\n    values[(valuesById[6] = \"CS_UM_SayText2\")] = 6;\n    values[(valuesById[7] = \"CS_UM_TextMsg\")] = 7;\n    values[(valuesById[8] = \"CS_UM_HudMsg\")] = 8;\n    values[(valuesById[9] = \"CS_UM_ResetHud\")] = 9;\n    values[(valuesById[10] = \"CS_UM_GameTitle\")] = 10;\n    values[(valuesById[12] = \"CS_UM_Shake\")] = 12;\n    values[(valuesById[13] = \"CS_UM_Fade\")] = 13;\n    values[(valuesById[14] = \"CS_UM_Rumble\")] = 14;\n    values[(valuesById[15] = \"CS_UM_CloseCaption\")] = 15;\n    values[(valuesById[16] = \"CS_UM_CloseCaptionDirect\")] = 16;\n    values[(valuesById[17] = \"CS_UM_SendAudio\")] = 17;\n    values[(valuesById[18] = \"CS_UM_RawAudio\")] = 18;\n    values[(valuesById[19] = \"CS_UM_VoiceMask\")] = 19;\n    values[(valuesById[20] = \"CS_UM_RequestState\")] = 20;\n    values[(valuesById[21] = \"CS_UM_Damage\")] = 21;\n    values[(valuesById[22] = \"CS_UM_RadioText\")] = 22;\n    values[(valuesById[23] = \"CS_UM_HintText\")] = 23;\n    values[(valuesById[24] = \"CS_UM_KeyHintText\")] = 24;\n    values[(valuesById[25] = \"CS_UM_ProcessSpottedEntityUpdate\")] = 25;\n    values[(valuesById[26] = \"CS_UM_ReloadEffect\")] = 26;\n    values[(valuesById[27] = \"CS_UM_AdjustMoney\")] = 27;\n    values[(valuesById[28] = \"CS_UM_UpdateTeamMoney\")] = 28;\n    values[(valuesById[29] = \"CS_UM_StopSpectatorMode\")] = 29;\n    values[(valuesById[30] = \"CS_UM_KillCam\")] = 30;\n    values[(valuesById[31] = \"CS_UM_DesiredTimescale\")] = 31;\n    values[(valuesById[32] = \"CS_UM_CurrentTimescale\")] = 32;\n    values[(valuesById[33] = \"CS_UM_AchievementEvent\")] = 33;\n    values[(valuesById[34] = \"CS_UM_MatchEndConditions\")] = 34;\n    values[(valuesById[35] = \"CS_UM_DisconnectToLobby\")] = 35;\n    values[(valuesById[36] = \"CS_UM_PlayerStatsUpdate\")] = 36;\n    values[(valuesById[37] = \"CS_UM_DisplayInventory\")] = 37;\n    values[(valuesById[38] = \"CS_UM_WarmupHasEnded\")] = 38;\n    values[(valuesById[39] = \"CS_UM_ClientInfo\")] = 39;\n    values[(valuesById[40] = \"CS_UM_XRankGet\")] = 40;\n    values[(valuesById[41] = \"CS_UM_XRankUpd\")] = 41;\n    values[(valuesById[45] = \"CS_UM_CallVoteFailed\")] = 45;\n    values[(valuesById[46] = \"CS_UM_VoteStart\")] = 46;\n    values[(valuesById[47] = \"CS_UM_VotePass\")] = 47;\n    values[(valuesById[48] = \"CS_UM_VoteFailed\")] = 48;\n    values[(valuesById[49] = \"CS_UM_VoteSetup\")] = 49;\n    values[(valuesById[50] = \"CS_UM_ServerRankRevealAll\")] = 50;\n    values[(valuesById[51] = \"CS_UM_SendLastKillerDamageToClient\")] = 51;\n    values[(valuesById[52] = \"CS_UM_ServerRankUpdate\")] = 52;\n    values[(valuesById[53] = \"CS_UM_ItemPickup\")] = 53;\n    values[(valuesById[54] = \"CS_UM_ShowMenu\")] = 54;\n    values[(valuesById[55] = \"CS_UM_BarTime\")] = 55;\n    values[(valuesById[56] = \"CS_UM_AmmoDenied\")] = 56;\n    values[(valuesById[57] = \"CS_UM_MarkAchievement\")] = 57;\n    values[(valuesById[58] = \"CS_UM_MatchStatsUpdate\")] = 58;\n    values[(valuesById[59] = \"CS_UM_ItemDrop\")] = 59;\n    values[(valuesById[60] = \"CS_UM_GlowPropTurnOff\")] = 60;\n    values[(valuesById[61] = \"CS_UM_SendPlayerItemDrops\")] = 61;\n    values[(valuesById[62] = \"CS_UM_RoundBackupFilenames\")] = 62;\n    values[(valuesById[63] = \"CS_UM_SendPlayerItemFound\")] = 63;\n    values[(valuesById[64] = \"CS_UM_ReportHit\")] = 64;\n    values[(valuesById[65] = \"CS_UM_XpUpdate\")] = 65;\n    values[(valuesById[66] = \"CS_UM_QuestProgress\")] = 66;\n    return values;\n})());\nexports.CCSUsrMsg_VGUIMenu = ($root.CCSUsrMsg_VGUIMenu = (() => {\n    /**\n     * Properties of a CCSUsrMsg_VGUIMenu.\n     * @exports ICCSUsrMsg_VGUIMenu\n     * @interface ICCSUsrMsg_VGUIMenu\n     * @property {string|null} [name] CCSUsrMsg_VGUIMenu name\n     * @property {boolean|null} [show] CCSUsrMsg_VGUIMenu show\n     * @property {Array.<CCSUsrMsg_VGUIMenu.ISubkey>|null} [subkeys] CCSUsrMsg_VGUIMenu subkeys\n     */\n    /**\n     * Constructs a new CCSUsrMsg_VGUIMenu.\n     * @exports CCSUsrMsg_VGUIMenu\n     * @classdesc Represents a CCSUsrMsg_VGUIMenu.\n     * @implements ICCSUsrMsg_VGUIMenu\n     * @constructor\n     * @param {ICCSUsrMsg_VGUIMenu=} [properties] Properties to set\n     */\n    function CCSUsrMsg_VGUIMenu(properties) {\n        this.subkeys = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_VGUIMenu name.\n     * @member {string} name\n     * @memberof CCSUsrMsg_VGUIMenu\n     * @instance\n     */\n    CCSUsrMsg_VGUIMenu.prototype.name = \"\";\n    /**\n     * CCSUsrMsg_VGUIMenu show.\n     * @member {boolean} show\n     * @memberof CCSUsrMsg_VGUIMenu\n     * @instance\n     */\n    CCSUsrMsg_VGUIMenu.prototype.show = false;\n    /**\n     * CCSUsrMsg_VGUIMenu subkeys.\n     * @member {Array.<CCSUsrMsg_VGUIMenu.ISubkey>} subkeys\n     * @memberof CCSUsrMsg_VGUIMenu\n     * @instance\n     */\n    CCSUsrMsg_VGUIMenu.prototype.subkeys = $util.emptyArray;\n    /**\n     * Decodes a CCSUsrMsg_VGUIMenu message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_VGUIMenu\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_VGUIMenu} CCSUsrMsg_VGUIMenu\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_VGUIMenu.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_VGUIMenu();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 2:\n                    message.show = reader.bool();\n                    break;\n                case 3:\n                    if (!(message.subkeys && message.subkeys.length))\n                        message.subkeys = [];\n                    message.subkeys.push($root.CCSUsrMsg_VGUIMenu.Subkey.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CCSUsrMsg_VGUIMenu.Subkey = (function () {\n        /**\n         * Properties of a Subkey.\n         * @memberof CCSUsrMsg_VGUIMenu\n         * @interface ISubkey\n         * @property {string|null} [name] Subkey name\n         * @property {string|null} [str] Subkey str\n         */\n        /**\n         * Constructs a new Subkey.\n         * @memberof CCSUsrMsg_VGUIMenu\n         * @classdesc Represents a Subkey.\n         * @implements ISubkey\n         * @constructor\n         * @param {CCSUsrMsg_VGUIMenu.ISubkey=} [properties] Properties to set\n         */\n        function Subkey(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * Subkey name.\n         * @member {string} name\n         * @memberof CCSUsrMsg_VGUIMenu.Subkey\n         * @instance\n         */\n        Subkey.prototype.name = \"\";\n        /**\n         * Subkey str.\n         * @member {string} str\n         * @memberof CCSUsrMsg_VGUIMenu.Subkey\n         * @instance\n         */\n        Subkey.prototype.str = \"\";\n        /**\n         * Decodes a Subkey message from the specified reader or buffer.\n         * @function decode\n         * @memberof CCSUsrMsg_VGUIMenu.Subkey\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CCSUsrMsg_VGUIMenu.Subkey} Subkey\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Subkey.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_VGUIMenu.Subkey();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.name = reader.string();\n                        break;\n                    case 2:\n                        message.str = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return Subkey;\n    })();\n    return CCSUsrMsg_VGUIMenu;\n})());\nexports.CCSUsrMsg_Geiger = ($root.CCSUsrMsg_Geiger = (() => {\n    /**\n     * Properties of a CCSUsrMsg_Geiger.\n     * @exports ICCSUsrMsg_Geiger\n     * @interface ICCSUsrMsg_Geiger\n     * @property {number|null} [range] CCSUsrMsg_Geiger range\n     */\n    /**\n     * Constructs a new CCSUsrMsg_Geiger.\n     * @exports CCSUsrMsg_Geiger\n     * @classdesc Represents a CCSUsrMsg_Geiger.\n     * @implements ICCSUsrMsg_Geiger\n     * @constructor\n     * @param {ICCSUsrMsg_Geiger=} [properties] Properties to set\n     */\n    function CCSUsrMsg_Geiger(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_Geiger range.\n     * @member {number} range\n     * @memberof CCSUsrMsg_Geiger\n     * @instance\n     */\n    CCSUsrMsg_Geiger.prototype.range = 0;\n    /**\n     * Decodes a CCSUsrMsg_Geiger message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_Geiger\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_Geiger} CCSUsrMsg_Geiger\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_Geiger.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_Geiger();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.range = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_Geiger;\n})());\nexports.CCSUsrMsg_Train = ($root.CCSUsrMsg_Train = (() => {\n    /**\n     * Properties of a CCSUsrMsg_Train.\n     * @exports ICCSUsrMsg_Train\n     * @interface ICCSUsrMsg_Train\n     * @property {number|null} [train] CCSUsrMsg_Train train\n     */\n    /**\n     * Constructs a new CCSUsrMsg_Train.\n     * @exports CCSUsrMsg_Train\n     * @classdesc Represents a CCSUsrMsg_Train.\n     * @implements ICCSUsrMsg_Train\n     * @constructor\n     * @param {ICCSUsrMsg_Train=} [properties] Properties to set\n     */\n    function CCSUsrMsg_Train(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_Train train.\n     * @member {number} train\n     * @memberof CCSUsrMsg_Train\n     * @instance\n     */\n    CCSUsrMsg_Train.prototype.train = 0;\n    /**\n     * Decodes a CCSUsrMsg_Train message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_Train\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_Train} CCSUsrMsg_Train\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_Train.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_Train();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.train = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_Train;\n})());\nexports.CCSUsrMsg_HudText = ($root.CCSUsrMsg_HudText = (() => {\n    /**\n     * Properties of a CCSUsrMsg_HudText.\n     * @exports ICCSUsrMsg_HudText\n     * @interface ICCSUsrMsg_HudText\n     * @property {string|null} [text] CCSUsrMsg_HudText text\n     */\n    /**\n     * Constructs a new CCSUsrMsg_HudText.\n     * @exports CCSUsrMsg_HudText\n     * @classdesc Represents a CCSUsrMsg_HudText.\n     * @implements ICCSUsrMsg_HudText\n     * @constructor\n     * @param {ICCSUsrMsg_HudText=} [properties] Properties to set\n     */\n    function CCSUsrMsg_HudText(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_HudText text.\n     * @member {string} text\n     * @memberof CCSUsrMsg_HudText\n     * @instance\n     */\n    CCSUsrMsg_HudText.prototype.text = \"\";\n    /**\n     * Decodes a CCSUsrMsg_HudText message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_HudText\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_HudText} CCSUsrMsg_HudText\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_HudText.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_HudText();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.text = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_HudText;\n})());\nexports.CCSUsrMsg_SayText = ($root.CCSUsrMsg_SayText = (() => {\n    /**\n     * Properties of a CCSUsrMsg_SayText.\n     * @exports ICCSUsrMsg_SayText\n     * @interface ICCSUsrMsg_SayText\n     * @property {number|null} [entIdx] CCSUsrMsg_SayText entIdx\n     * @property {string|null} [text] CCSUsrMsg_SayText text\n     * @property {boolean|null} [chat] CCSUsrMsg_SayText chat\n     * @property {boolean|null} [textallchat] CCSUsrMsg_SayText textallchat\n     */\n    /**\n     * Constructs a new CCSUsrMsg_SayText.\n     * @exports CCSUsrMsg_SayText\n     * @classdesc Represents a CCSUsrMsg_SayText.\n     * @implements ICCSUsrMsg_SayText\n     * @constructor\n     * @param {ICCSUsrMsg_SayText=} [properties] Properties to set\n     */\n    function CCSUsrMsg_SayText(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_SayText entIdx.\n     * @member {number} entIdx\n     * @memberof CCSUsrMsg_SayText\n     * @instance\n     */\n    CCSUsrMsg_SayText.prototype.entIdx = 0;\n    /**\n     * CCSUsrMsg_SayText text.\n     * @member {string} text\n     * @memberof CCSUsrMsg_SayText\n     * @instance\n     */\n    CCSUsrMsg_SayText.prototype.text = \"\";\n    /**\n     * CCSUsrMsg_SayText chat.\n     * @member {boolean} chat\n     * @memberof CCSUsrMsg_SayText\n     * @instance\n     */\n    CCSUsrMsg_SayText.prototype.chat = false;\n    /**\n     * CCSUsrMsg_SayText textallchat.\n     * @member {boolean} textallchat\n     * @memberof CCSUsrMsg_SayText\n     * @instance\n     */\n    CCSUsrMsg_SayText.prototype.textallchat = false;\n    /**\n     * Decodes a CCSUsrMsg_SayText message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_SayText\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_SayText} CCSUsrMsg_SayText\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_SayText.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_SayText();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.entIdx = reader.int32();\n                    break;\n                case 2:\n                    message.text = reader.string();\n                    break;\n                case 3:\n                    message.chat = reader.bool();\n                    break;\n                case 4:\n                    message.textallchat = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_SayText;\n})());\nexports.CCSUsrMsg_SayText2 = ($root.CCSUsrMsg_SayText2 = (() => {\n    /**\n     * Properties of a CCSUsrMsg_SayText2.\n     * @exports ICCSUsrMsg_SayText2\n     * @interface ICCSUsrMsg_SayText2\n     * @property {number|null} [entIdx] CCSUsrMsg_SayText2 entIdx\n     * @property {boolean|null} [chat] CCSUsrMsg_SayText2 chat\n     * @property {string|null} [msgName] CCSUsrMsg_SayText2 msgName\n     * @property {Array.<string>|null} [params] CCSUsrMsg_SayText2 params\n     * @property {boolean|null} [textallchat] CCSUsrMsg_SayText2 textallchat\n     */\n    /**\n     * Constructs a new CCSUsrMsg_SayText2.\n     * @exports CCSUsrMsg_SayText2\n     * @classdesc Represents a CCSUsrMsg_SayText2.\n     * @implements ICCSUsrMsg_SayText2\n     * @constructor\n     * @param {ICCSUsrMsg_SayText2=} [properties] Properties to set\n     */\n    function CCSUsrMsg_SayText2(properties) {\n        this.params = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_SayText2 entIdx.\n     * @member {number} entIdx\n     * @memberof CCSUsrMsg_SayText2\n     * @instance\n     */\n    CCSUsrMsg_SayText2.prototype.entIdx = 0;\n    /**\n     * CCSUsrMsg_SayText2 chat.\n     * @member {boolean} chat\n     * @memberof CCSUsrMsg_SayText2\n     * @instance\n     */\n    CCSUsrMsg_SayText2.prototype.chat = false;\n    /**\n     * CCSUsrMsg_SayText2 msgName.\n     * @member {string} msgName\n     * @memberof CCSUsrMsg_SayText2\n     * @instance\n     */\n    CCSUsrMsg_SayText2.prototype.msgName = \"\";\n    /**\n     * CCSUsrMsg_SayText2 params.\n     * @member {Array.<string>} params\n     * @memberof CCSUsrMsg_SayText2\n     * @instance\n     */\n    CCSUsrMsg_SayText2.prototype.params = $util.emptyArray;\n    /**\n     * CCSUsrMsg_SayText2 textallchat.\n     * @member {boolean} textallchat\n     * @memberof CCSUsrMsg_SayText2\n     * @instance\n     */\n    CCSUsrMsg_SayText2.prototype.textallchat = false;\n    /**\n     * Decodes a CCSUsrMsg_SayText2 message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_SayText2\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_SayText2} CCSUsrMsg_SayText2\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_SayText2.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_SayText2();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.entIdx = reader.int32();\n                    break;\n                case 2:\n                    message.chat = reader.bool();\n                    break;\n                case 3:\n                    message.msgName = reader.string();\n                    break;\n                case 4:\n                    if (!(message.params && message.params.length))\n                        message.params = [];\n                    message.params.push(reader.string());\n                    break;\n                case 5:\n                    message.textallchat = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_SayText2;\n})());\nexports.CCSUsrMsg_TextMsg = ($root.CCSUsrMsg_TextMsg = (() => {\n    /**\n     * Properties of a CCSUsrMsg_TextMsg.\n     * @exports ICCSUsrMsg_TextMsg\n     * @interface ICCSUsrMsg_TextMsg\n     * @property {number|null} [msgDst] CCSUsrMsg_TextMsg msgDst\n     * @property {Array.<string>|null} [params] CCSUsrMsg_TextMsg params\n     */\n    /**\n     * Constructs a new CCSUsrMsg_TextMsg.\n     * @exports CCSUsrMsg_TextMsg\n     * @classdesc Represents a CCSUsrMsg_TextMsg.\n     * @implements ICCSUsrMsg_TextMsg\n     * @constructor\n     * @param {ICCSUsrMsg_TextMsg=} [properties] Properties to set\n     */\n    function CCSUsrMsg_TextMsg(properties) {\n        this.params = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_TextMsg msgDst.\n     * @member {number} msgDst\n     * @memberof CCSUsrMsg_TextMsg\n     * @instance\n     */\n    CCSUsrMsg_TextMsg.prototype.msgDst = 0;\n    /**\n     * CCSUsrMsg_TextMsg params.\n     * @member {Array.<string>} params\n     * @memberof CCSUsrMsg_TextMsg\n     * @instance\n     */\n    CCSUsrMsg_TextMsg.prototype.params = $util.emptyArray;\n    /**\n     * Decodes a CCSUsrMsg_TextMsg message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_TextMsg\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_TextMsg} CCSUsrMsg_TextMsg\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_TextMsg.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_TextMsg();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.msgDst = reader.int32();\n                    break;\n                case 3:\n                    if (!(message.params && message.params.length))\n                        message.params = [];\n                    message.params.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_TextMsg;\n})());\nexports.CCSUsrMsg_HudMsg = ($root.CCSUsrMsg_HudMsg = (() => {\n    /**\n     * Properties of a CCSUsrMsg_HudMsg.\n     * @exports ICCSUsrMsg_HudMsg\n     * @interface ICCSUsrMsg_HudMsg\n     * @property {number|null} [channel] CCSUsrMsg_HudMsg channel\n     * @property {ICMsgVector2D|null} [pos] CCSUsrMsg_HudMsg pos\n     * @property {ICMsgRGBA|null} [clr1] CCSUsrMsg_HudMsg clr1\n     * @property {ICMsgRGBA|null} [clr2] CCSUsrMsg_HudMsg clr2\n     * @property {number|null} [effect] CCSUsrMsg_HudMsg effect\n     * @property {number|null} [fadeInTime] CCSUsrMsg_HudMsg fadeInTime\n     * @property {number|null} [fadeOutTime] CCSUsrMsg_HudMsg fadeOutTime\n     * @property {number|null} [holdTime] CCSUsrMsg_HudMsg holdTime\n     * @property {number|null} [fxTime] CCSUsrMsg_HudMsg fxTime\n     * @property {string|null} [text] CCSUsrMsg_HudMsg text\n     */\n    /**\n     * Constructs a new CCSUsrMsg_HudMsg.\n     * @exports CCSUsrMsg_HudMsg\n     * @classdesc Represents a CCSUsrMsg_HudMsg.\n     * @implements ICCSUsrMsg_HudMsg\n     * @constructor\n     * @param {ICCSUsrMsg_HudMsg=} [properties] Properties to set\n     */\n    function CCSUsrMsg_HudMsg(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_HudMsg channel.\n     * @member {number} channel\n     * @memberof CCSUsrMsg_HudMsg\n     * @instance\n     */\n    CCSUsrMsg_HudMsg.prototype.channel = 0;\n    /**\n     * CCSUsrMsg_HudMsg pos.\n     * @member {ICMsgVector2D|null|undefined} pos\n     * @memberof CCSUsrMsg_HudMsg\n     * @instance\n     */\n    CCSUsrMsg_HudMsg.prototype.pos = null;\n    /**\n     * CCSUsrMsg_HudMsg clr1.\n     * @member {ICMsgRGBA|null|undefined} clr1\n     * @memberof CCSUsrMsg_HudMsg\n     * @instance\n     */\n    CCSUsrMsg_HudMsg.prototype.clr1 = null;\n    /**\n     * CCSUsrMsg_HudMsg clr2.\n     * @member {ICMsgRGBA|null|undefined} clr2\n     * @memberof CCSUsrMsg_HudMsg\n     * @instance\n     */\n    CCSUsrMsg_HudMsg.prototype.clr2 = null;\n    /**\n     * CCSUsrMsg_HudMsg effect.\n     * @member {number} effect\n     * @memberof CCSUsrMsg_HudMsg\n     * @instance\n     */\n    CCSUsrMsg_HudMsg.prototype.effect = 0;\n    /**\n     * CCSUsrMsg_HudMsg fadeInTime.\n     * @member {number} fadeInTime\n     * @memberof CCSUsrMsg_HudMsg\n     * @instance\n     */\n    CCSUsrMsg_HudMsg.prototype.fadeInTime = 0;\n    /**\n     * CCSUsrMsg_HudMsg fadeOutTime.\n     * @member {number} fadeOutTime\n     * @memberof CCSUsrMsg_HudMsg\n     * @instance\n     */\n    CCSUsrMsg_HudMsg.prototype.fadeOutTime = 0;\n    /**\n     * CCSUsrMsg_HudMsg holdTime.\n     * @member {number} holdTime\n     * @memberof CCSUsrMsg_HudMsg\n     * @instance\n     */\n    CCSUsrMsg_HudMsg.prototype.holdTime = 0;\n    /**\n     * CCSUsrMsg_HudMsg fxTime.\n     * @member {number} fxTime\n     * @memberof CCSUsrMsg_HudMsg\n     * @instance\n     */\n    CCSUsrMsg_HudMsg.prototype.fxTime = 0;\n    /**\n     * CCSUsrMsg_HudMsg text.\n     * @member {string} text\n     * @memberof CCSUsrMsg_HudMsg\n     * @instance\n     */\n    CCSUsrMsg_HudMsg.prototype.text = \"\";\n    /**\n     * Decodes a CCSUsrMsg_HudMsg message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_HudMsg\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_HudMsg} CCSUsrMsg_HudMsg\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_HudMsg.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_HudMsg();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.channel = reader.int32();\n                    break;\n                case 2:\n                    message.pos = $root.CMsgVector2D.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.clr1 = $root.CMsgRGBA.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.clr2 = $root.CMsgRGBA.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.effect = reader.int32();\n                    break;\n                case 6:\n                    message.fadeInTime = reader.float();\n                    break;\n                case 7:\n                    message.fadeOutTime = reader.float();\n                    break;\n                case 9:\n                    message.holdTime = reader.float();\n                    break;\n                case 10:\n                    message.fxTime = reader.float();\n                    break;\n                case 11:\n                    message.text = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_HudMsg;\n})());\nexports.CCSUsrMsg_Shake = ($root.CCSUsrMsg_Shake = (() => {\n    /**\n     * Properties of a CCSUsrMsg_Shake.\n     * @exports ICCSUsrMsg_Shake\n     * @interface ICCSUsrMsg_Shake\n     * @property {number|null} [command] CCSUsrMsg_Shake command\n     * @property {number|null} [localAmplitude] CCSUsrMsg_Shake localAmplitude\n     * @property {number|null} [frequency] CCSUsrMsg_Shake frequency\n     * @property {number|null} [duration] CCSUsrMsg_Shake duration\n     */\n    /**\n     * Constructs a new CCSUsrMsg_Shake.\n     * @exports CCSUsrMsg_Shake\n     * @classdesc Represents a CCSUsrMsg_Shake.\n     * @implements ICCSUsrMsg_Shake\n     * @constructor\n     * @param {ICCSUsrMsg_Shake=} [properties] Properties to set\n     */\n    function CCSUsrMsg_Shake(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_Shake command.\n     * @member {number} command\n     * @memberof CCSUsrMsg_Shake\n     * @instance\n     */\n    CCSUsrMsg_Shake.prototype.command = 0;\n    /**\n     * CCSUsrMsg_Shake localAmplitude.\n     * @member {number} localAmplitude\n     * @memberof CCSUsrMsg_Shake\n     * @instance\n     */\n    CCSUsrMsg_Shake.prototype.localAmplitude = 0;\n    /**\n     * CCSUsrMsg_Shake frequency.\n     * @member {number} frequency\n     * @memberof CCSUsrMsg_Shake\n     * @instance\n     */\n    CCSUsrMsg_Shake.prototype.frequency = 0;\n    /**\n     * CCSUsrMsg_Shake duration.\n     * @member {number} duration\n     * @memberof CCSUsrMsg_Shake\n     * @instance\n     */\n    CCSUsrMsg_Shake.prototype.duration = 0;\n    /**\n     * Decodes a CCSUsrMsg_Shake message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_Shake\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_Shake} CCSUsrMsg_Shake\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_Shake.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_Shake();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.command = reader.int32();\n                    break;\n                case 2:\n                    message.localAmplitude = reader.float();\n                    break;\n                case 3:\n                    message.frequency = reader.float();\n                    break;\n                case 4:\n                    message.duration = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_Shake;\n})());\nexports.CCSUsrMsg_Fade = ($root.CCSUsrMsg_Fade = (() => {\n    /**\n     * Properties of a CCSUsrMsg_Fade.\n     * @exports ICCSUsrMsg_Fade\n     * @interface ICCSUsrMsg_Fade\n     * @property {number|null} [duration] CCSUsrMsg_Fade duration\n     * @property {number|null} [holdTime] CCSUsrMsg_Fade holdTime\n     * @property {number|null} [flags] CCSUsrMsg_Fade flags\n     * @property {ICMsgRGBA|null} [clr] CCSUsrMsg_Fade clr\n     */\n    /**\n     * Constructs a new CCSUsrMsg_Fade.\n     * @exports CCSUsrMsg_Fade\n     * @classdesc Represents a CCSUsrMsg_Fade.\n     * @implements ICCSUsrMsg_Fade\n     * @constructor\n     * @param {ICCSUsrMsg_Fade=} [properties] Properties to set\n     */\n    function CCSUsrMsg_Fade(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_Fade duration.\n     * @member {number} duration\n     * @memberof CCSUsrMsg_Fade\n     * @instance\n     */\n    CCSUsrMsg_Fade.prototype.duration = 0;\n    /**\n     * CCSUsrMsg_Fade holdTime.\n     * @member {number} holdTime\n     * @memberof CCSUsrMsg_Fade\n     * @instance\n     */\n    CCSUsrMsg_Fade.prototype.holdTime = 0;\n    /**\n     * CCSUsrMsg_Fade flags.\n     * @member {number} flags\n     * @memberof CCSUsrMsg_Fade\n     * @instance\n     */\n    CCSUsrMsg_Fade.prototype.flags = 0;\n    /**\n     * CCSUsrMsg_Fade clr.\n     * @member {ICMsgRGBA|null|undefined} clr\n     * @memberof CCSUsrMsg_Fade\n     * @instance\n     */\n    CCSUsrMsg_Fade.prototype.clr = null;\n    /**\n     * Decodes a CCSUsrMsg_Fade message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_Fade\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_Fade} CCSUsrMsg_Fade\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_Fade.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_Fade();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.duration = reader.int32();\n                    break;\n                case 2:\n                    message.holdTime = reader.int32();\n                    break;\n                case 3:\n                    message.flags = reader.int32();\n                    break;\n                case 4:\n                    message.clr = $root.CMsgRGBA.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_Fade;\n})());\nexports.CCSUsrMsg_Rumble = ($root.CCSUsrMsg_Rumble = (() => {\n    /**\n     * Properties of a CCSUsrMsg_Rumble.\n     * @exports ICCSUsrMsg_Rumble\n     * @interface ICCSUsrMsg_Rumble\n     * @property {number|null} [index] CCSUsrMsg_Rumble index\n     * @property {number|null} [data] CCSUsrMsg_Rumble data\n     * @property {number|null} [flags] CCSUsrMsg_Rumble flags\n     */\n    /**\n     * Constructs a new CCSUsrMsg_Rumble.\n     * @exports CCSUsrMsg_Rumble\n     * @classdesc Represents a CCSUsrMsg_Rumble.\n     * @implements ICCSUsrMsg_Rumble\n     * @constructor\n     * @param {ICCSUsrMsg_Rumble=} [properties] Properties to set\n     */\n    function CCSUsrMsg_Rumble(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_Rumble index.\n     * @member {number} index\n     * @memberof CCSUsrMsg_Rumble\n     * @instance\n     */\n    CCSUsrMsg_Rumble.prototype.index = 0;\n    /**\n     * CCSUsrMsg_Rumble data.\n     * @member {number} data\n     * @memberof CCSUsrMsg_Rumble\n     * @instance\n     */\n    CCSUsrMsg_Rumble.prototype.data = 0;\n    /**\n     * CCSUsrMsg_Rumble flags.\n     * @member {number} flags\n     * @memberof CCSUsrMsg_Rumble\n     * @instance\n     */\n    CCSUsrMsg_Rumble.prototype.flags = 0;\n    /**\n     * Decodes a CCSUsrMsg_Rumble message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_Rumble\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_Rumble} CCSUsrMsg_Rumble\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_Rumble.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_Rumble();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.index = reader.int32();\n                    break;\n                case 2:\n                    message.data = reader.int32();\n                    break;\n                case 3:\n                    message.flags = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_Rumble;\n})());\nexports.CCSUsrMsg_CloseCaption = ($root.CCSUsrMsg_CloseCaption = (() => {\n    /**\n     * Properties of a CCSUsrMsg_CloseCaption.\n     * @exports ICCSUsrMsg_CloseCaption\n     * @interface ICCSUsrMsg_CloseCaption\n     * @property {number|null} [hash] CCSUsrMsg_CloseCaption hash\n     * @property {number|null} [duration] CCSUsrMsg_CloseCaption duration\n     * @property {boolean|null} [fromPlayer] CCSUsrMsg_CloseCaption fromPlayer\n     */\n    /**\n     * Constructs a new CCSUsrMsg_CloseCaption.\n     * @exports CCSUsrMsg_CloseCaption\n     * @classdesc Represents a CCSUsrMsg_CloseCaption.\n     * @implements ICCSUsrMsg_CloseCaption\n     * @constructor\n     * @param {ICCSUsrMsg_CloseCaption=} [properties] Properties to set\n     */\n    function CCSUsrMsg_CloseCaption(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_CloseCaption hash.\n     * @member {number} hash\n     * @memberof CCSUsrMsg_CloseCaption\n     * @instance\n     */\n    CCSUsrMsg_CloseCaption.prototype.hash = 0;\n    /**\n     * CCSUsrMsg_CloseCaption duration.\n     * @member {number} duration\n     * @memberof CCSUsrMsg_CloseCaption\n     * @instance\n     */\n    CCSUsrMsg_CloseCaption.prototype.duration = 0;\n    /**\n     * CCSUsrMsg_CloseCaption fromPlayer.\n     * @member {boolean} fromPlayer\n     * @memberof CCSUsrMsg_CloseCaption\n     * @instance\n     */\n    CCSUsrMsg_CloseCaption.prototype.fromPlayer = false;\n    /**\n     * Decodes a CCSUsrMsg_CloseCaption message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_CloseCaption\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_CloseCaption} CCSUsrMsg_CloseCaption\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_CloseCaption.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_CloseCaption();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.hash = reader.uint32();\n                    break;\n                case 2:\n                    message.duration = reader.int32();\n                    break;\n                case 3:\n                    message.fromPlayer = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_CloseCaption;\n})());\nexports.CCSUsrMsg_CloseCaptionDirect = ($root.CCSUsrMsg_CloseCaptionDirect = (() => {\n    /**\n     * Properties of a CCSUsrMsg_CloseCaptionDirect.\n     * @exports ICCSUsrMsg_CloseCaptionDirect\n     * @interface ICCSUsrMsg_CloseCaptionDirect\n     * @property {number|null} [hash] CCSUsrMsg_CloseCaptionDirect hash\n     * @property {number|null} [duration] CCSUsrMsg_CloseCaptionDirect duration\n     * @property {boolean|null} [fromPlayer] CCSUsrMsg_CloseCaptionDirect fromPlayer\n     */\n    /**\n     * Constructs a new CCSUsrMsg_CloseCaptionDirect.\n     * @exports CCSUsrMsg_CloseCaptionDirect\n     * @classdesc Represents a CCSUsrMsg_CloseCaptionDirect.\n     * @implements ICCSUsrMsg_CloseCaptionDirect\n     * @constructor\n     * @param {ICCSUsrMsg_CloseCaptionDirect=} [properties] Properties to set\n     */\n    function CCSUsrMsg_CloseCaptionDirect(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_CloseCaptionDirect hash.\n     * @member {number} hash\n     * @memberof CCSUsrMsg_CloseCaptionDirect\n     * @instance\n     */\n    CCSUsrMsg_CloseCaptionDirect.prototype.hash = 0;\n    /**\n     * CCSUsrMsg_CloseCaptionDirect duration.\n     * @member {number} duration\n     * @memberof CCSUsrMsg_CloseCaptionDirect\n     * @instance\n     */\n    CCSUsrMsg_CloseCaptionDirect.prototype.duration = 0;\n    /**\n     * CCSUsrMsg_CloseCaptionDirect fromPlayer.\n     * @member {boolean} fromPlayer\n     * @memberof CCSUsrMsg_CloseCaptionDirect\n     * @instance\n     */\n    CCSUsrMsg_CloseCaptionDirect.prototype.fromPlayer = false;\n    /**\n     * Decodes a CCSUsrMsg_CloseCaptionDirect message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_CloseCaptionDirect\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_CloseCaptionDirect} CCSUsrMsg_CloseCaptionDirect\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_CloseCaptionDirect.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_CloseCaptionDirect();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.hash = reader.uint32();\n                    break;\n                case 2:\n                    message.duration = reader.int32();\n                    break;\n                case 3:\n                    message.fromPlayer = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_CloseCaptionDirect;\n})());\nexports.CCSUsrMsg_SendAudio = ($root.CCSUsrMsg_SendAudio = (() => {\n    /**\n     * Properties of a CCSUsrMsg_SendAudio.\n     * @exports ICCSUsrMsg_SendAudio\n     * @interface ICCSUsrMsg_SendAudio\n     * @property {string|null} [radioSound] CCSUsrMsg_SendAudio radioSound\n     */\n    /**\n     * Constructs a new CCSUsrMsg_SendAudio.\n     * @exports CCSUsrMsg_SendAudio\n     * @classdesc Represents a CCSUsrMsg_SendAudio.\n     * @implements ICCSUsrMsg_SendAudio\n     * @constructor\n     * @param {ICCSUsrMsg_SendAudio=} [properties] Properties to set\n     */\n    function CCSUsrMsg_SendAudio(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_SendAudio radioSound.\n     * @member {string} radioSound\n     * @memberof CCSUsrMsg_SendAudio\n     * @instance\n     */\n    CCSUsrMsg_SendAudio.prototype.radioSound = \"\";\n    /**\n     * Decodes a CCSUsrMsg_SendAudio message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_SendAudio\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_SendAudio} CCSUsrMsg_SendAudio\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_SendAudio.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_SendAudio();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.radioSound = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_SendAudio;\n})());\nexports.CCSUsrMsg_RawAudio = ($root.CCSUsrMsg_RawAudio = (() => {\n    /**\n     * Properties of a CCSUsrMsg_RawAudio.\n     * @exports ICCSUsrMsg_RawAudio\n     * @interface ICCSUsrMsg_RawAudio\n     * @property {number|null} [pitch] CCSUsrMsg_RawAudio pitch\n     * @property {number|null} [entidx] CCSUsrMsg_RawAudio entidx\n     * @property {number|null} [duration] CCSUsrMsg_RawAudio duration\n     * @property {string|null} [voiceFilename] CCSUsrMsg_RawAudio voiceFilename\n     */\n    /**\n     * Constructs a new CCSUsrMsg_RawAudio.\n     * @exports CCSUsrMsg_RawAudio\n     * @classdesc Represents a CCSUsrMsg_RawAudio.\n     * @implements ICCSUsrMsg_RawAudio\n     * @constructor\n     * @param {ICCSUsrMsg_RawAudio=} [properties] Properties to set\n     */\n    function CCSUsrMsg_RawAudio(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_RawAudio pitch.\n     * @member {number} pitch\n     * @memberof CCSUsrMsg_RawAudio\n     * @instance\n     */\n    CCSUsrMsg_RawAudio.prototype.pitch = 0;\n    /**\n     * CCSUsrMsg_RawAudio entidx.\n     * @member {number} entidx\n     * @memberof CCSUsrMsg_RawAudio\n     * @instance\n     */\n    CCSUsrMsg_RawAudio.prototype.entidx = 0;\n    /**\n     * CCSUsrMsg_RawAudio duration.\n     * @member {number} duration\n     * @memberof CCSUsrMsg_RawAudio\n     * @instance\n     */\n    CCSUsrMsg_RawAudio.prototype.duration = 0;\n    /**\n     * CCSUsrMsg_RawAudio voiceFilename.\n     * @member {string} voiceFilename\n     * @memberof CCSUsrMsg_RawAudio\n     * @instance\n     */\n    CCSUsrMsg_RawAudio.prototype.voiceFilename = \"\";\n    /**\n     * Decodes a CCSUsrMsg_RawAudio message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_RawAudio\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_RawAudio} CCSUsrMsg_RawAudio\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_RawAudio.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_RawAudio();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.pitch = reader.int32();\n                    break;\n                case 2:\n                    message.entidx = reader.int32();\n                    break;\n                case 3:\n                    message.duration = reader.float();\n                    break;\n                case 4:\n                    message.voiceFilename = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_RawAudio;\n})());\nexports.CCSUsrMsg_VoiceMask = ($root.CCSUsrMsg_VoiceMask = (() => {\n    /**\n     * Properties of a CCSUsrMsg_VoiceMask.\n     * @exports ICCSUsrMsg_VoiceMask\n     * @interface ICCSUsrMsg_VoiceMask\n     * @property {Array.<CCSUsrMsg_VoiceMask.IPlayerMask>|null} [playerMasks] CCSUsrMsg_VoiceMask playerMasks\n     * @property {boolean|null} [playerModEnable] CCSUsrMsg_VoiceMask playerModEnable\n     */\n    /**\n     * Constructs a new CCSUsrMsg_VoiceMask.\n     * @exports CCSUsrMsg_VoiceMask\n     * @classdesc Represents a CCSUsrMsg_VoiceMask.\n     * @implements ICCSUsrMsg_VoiceMask\n     * @constructor\n     * @param {ICCSUsrMsg_VoiceMask=} [properties] Properties to set\n     */\n    function CCSUsrMsg_VoiceMask(properties) {\n        this.playerMasks = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_VoiceMask playerMasks.\n     * @member {Array.<CCSUsrMsg_VoiceMask.IPlayerMask>} playerMasks\n     * @memberof CCSUsrMsg_VoiceMask\n     * @instance\n     */\n    CCSUsrMsg_VoiceMask.prototype.playerMasks = $util.emptyArray;\n    /**\n     * CCSUsrMsg_VoiceMask playerModEnable.\n     * @member {boolean} playerModEnable\n     * @memberof CCSUsrMsg_VoiceMask\n     * @instance\n     */\n    CCSUsrMsg_VoiceMask.prototype.playerModEnable = false;\n    /**\n     * Decodes a CCSUsrMsg_VoiceMask message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_VoiceMask\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_VoiceMask} CCSUsrMsg_VoiceMask\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_VoiceMask.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_VoiceMask();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.playerMasks && message.playerMasks.length))\n                        message.playerMasks = [];\n                    message.playerMasks.push($root.CCSUsrMsg_VoiceMask.PlayerMask.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.playerModEnable = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CCSUsrMsg_VoiceMask.PlayerMask = (function () {\n        /**\n         * Properties of a PlayerMask.\n         * @memberof CCSUsrMsg_VoiceMask\n         * @interface IPlayerMask\n         * @property {number|null} [gameRulesMask] PlayerMask gameRulesMask\n         * @property {number|null} [banMasks] PlayerMask banMasks\n         */\n        /**\n         * Constructs a new PlayerMask.\n         * @memberof CCSUsrMsg_VoiceMask\n         * @classdesc Represents a PlayerMask.\n         * @implements IPlayerMask\n         * @constructor\n         * @param {CCSUsrMsg_VoiceMask.IPlayerMask=} [properties] Properties to set\n         */\n        function PlayerMask(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * PlayerMask gameRulesMask.\n         * @member {number} gameRulesMask\n         * @memberof CCSUsrMsg_VoiceMask.PlayerMask\n         * @instance\n         */\n        PlayerMask.prototype.gameRulesMask = 0;\n        /**\n         * PlayerMask banMasks.\n         * @member {number} banMasks\n         * @memberof CCSUsrMsg_VoiceMask.PlayerMask\n         * @instance\n         */\n        PlayerMask.prototype.banMasks = 0;\n        /**\n         * Decodes a PlayerMask message from the specified reader or buffer.\n         * @function decode\n         * @memberof CCSUsrMsg_VoiceMask.PlayerMask\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CCSUsrMsg_VoiceMask.PlayerMask} PlayerMask\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        PlayerMask.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_VoiceMask.PlayerMask();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.gameRulesMask = reader.int32();\n                        break;\n                    case 2:\n                        message.banMasks = reader.int32();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return PlayerMask;\n    })();\n    return CCSUsrMsg_VoiceMask;\n})());\nexports.CCSUsrMsg_Damage = ($root.CCSUsrMsg_Damage = (() => {\n    /**\n     * Properties of a CCSUsrMsg_Damage.\n     * @exports ICCSUsrMsg_Damage\n     * @interface ICCSUsrMsg_Damage\n     * @property {number|null} [amount] CCSUsrMsg_Damage amount\n     * @property {ICMsgVector|null} [inflictorWorldPos] CCSUsrMsg_Damage inflictorWorldPos\n     * @property {number|null} [victimEntindex] CCSUsrMsg_Damage victimEntindex\n     */\n    /**\n     * Constructs a new CCSUsrMsg_Damage.\n     * @exports CCSUsrMsg_Damage\n     * @classdesc Represents a CCSUsrMsg_Damage.\n     * @implements ICCSUsrMsg_Damage\n     * @constructor\n     * @param {ICCSUsrMsg_Damage=} [properties] Properties to set\n     */\n    function CCSUsrMsg_Damage(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_Damage amount.\n     * @member {number} amount\n     * @memberof CCSUsrMsg_Damage\n     * @instance\n     */\n    CCSUsrMsg_Damage.prototype.amount = 0;\n    /**\n     * CCSUsrMsg_Damage inflictorWorldPos.\n     * @member {ICMsgVector|null|undefined} inflictorWorldPos\n     * @memberof CCSUsrMsg_Damage\n     * @instance\n     */\n    CCSUsrMsg_Damage.prototype.inflictorWorldPos = null;\n    /**\n     * CCSUsrMsg_Damage victimEntindex.\n     * @member {number} victimEntindex\n     * @memberof CCSUsrMsg_Damage\n     * @instance\n     */\n    CCSUsrMsg_Damage.prototype.victimEntindex = 0;\n    /**\n     * Decodes a CCSUsrMsg_Damage message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_Damage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_Damage} CCSUsrMsg_Damage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_Damage.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_Damage();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.amount = reader.int32();\n                    break;\n                case 2:\n                    message.inflictorWorldPos = $root.CMsgVector.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.victimEntindex = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_Damage;\n})());\nexports.CCSUsrMsg_RadioText = ($root.CCSUsrMsg_RadioText = (() => {\n    /**\n     * Properties of a CCSUsrMsg_RadioText.\n     * @exports ICCSUsrMsg_RadioText\n     * @interface ICCSUsrMsg_RadioText\n     * @property {number|null} [msgDst] CCSUsrMsg_RadioText msgDst\n     * @property {number|null} [client] CCSUsrMsg_RadioText client\n     * @property {string|null} [msgName] CCSUsrMsg_RadioText msgName\n     * @property {Array.<string>|null} [params] CCSUsrMsg_RadioText params\n     */\n    /**\n     * Constructs a new CCSUsrMsg_RadioText.\n     * @exports CCSUsrMsg_RadioText\n     * @classdesc Represents a CCSUsrMsg_RadioText.\n     * @implements ICCSUsrMsg_RadioText\n     * @constructor\n     * @param {ICCSUsrMsg_RadioText=} [properties] Properties to set\n     */\n    function CCSUsrMsg_RadioText(properties) {\n        this.params = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_RadioText msgDst.\n     * @member {number} msgDst\n     * @memberof CCSUsrMsg_RadioText\n     * @instance\n     */\n    CCSUsrMsg_RadioText.prototype.msgDst = 0;\n    /**\n     * CCSUsrMsg_RadioText client.\n     * @member {number} client\n     * @memberof CCSUsrMsg_RadioText\n     * @instance\n     */\n    CCSUsrMsg_RadioText.prototype.client = 0;\n    /**\n     * CCSUsrMsg_RadioText msgName.\n     * @member {string} msgName\n     * @memberof CCSUsrMsg_RadioText\n     * @instance\n     */\n    CCSUsrMsg_RadioText.prototype.msgName = \"\";\n    /**\n     * CCSUsrMsg_RadioText params.\n     * @member {Array.<string>} params\n     * @memberof CCSUsrMsg_RadioText\n     * @instance\n     */\n    CCSUsrMsg_RadioText.prototype.params = $util.emptyArray;\n    /**\n     * Decodes a CCSUsrMsg_RadioText message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_RadioText\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_RadioText} CCSUsrMsg_RadioText\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_RadioText.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_RadioText();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.msgDst = reader.int32();\n                    break;\n                case 2:\n                    message.client = reader.int32();\n                    break;\n                case 3:\n                    message.msgName = reader.string();\n                    break;\n                case 4:\n                    if (!(message.params && message.params.length))\n                        message.params = [];\n                    message.params.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_RadioText;\n})());\nexports.CCSUsrMsg_HintText = ($root.CCSUsrMsg_HintText = (() => {\n    /**\n     * Properties of a CCSUsrMsg_HintText.\n     * @exports ICCSUsrMsg_HintText\n     * @interface ICCSUsrMsg_HintText\n     * @property {string|null} [text] CCSUsrMsg_HintText text\n     */\n    /**\n     * Constructs a new CCSUsrMsg_HintText.\n     * @exports CCSUsrMsg_HintText\n     * @classdesc Represents a CCSUsrMsg_HintText.\n     * @implements ICCSUsrMsg_HintText\n     * @constructor\n     * @param {ICCSUsrMsg_HintText=} [properties] Properties to set\n     */\n    function CCSUsrMsg_HintText(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_HintText text.\n     * @member {string} text\n     * @memberof CCSUsrMsg_HintText\n     * @instance\n     */\n    CCSUsrMsg_HintText.prototype.text = \"\";\n    /**\n     * Decodes a CCSUsrMsg_HintText message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_HintText\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_HintText} CCSUsrMsg_HintText\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_HintText.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_HintText();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.text = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_HintText;\n})());\nexports.CCSUsrMsg_KeyHintText = ($root.CCSUsrMsg_KeyHintText = (() => {\n    /**\n     * Properties of a CCSUsrMsg_KeyHintText.\n     * @exports ICCSUsrMsg_KeyHintText\n     * @interface ICCSUsrMsg_KeyHintText\n     * @property {Array.<string>|null} [hints] CCSUsrMsg_KeyHintText hints\n     */\n    /**\n     * Constructs a new CCSUsrMsg_KeyHintText.\n     * @exports CCSUsrMsg_KeyHintText\n     * @classdesc Represents a CCSUsrMsg_KeyHintText.\n     * @implements ICCSUsrMsg_KeyHintText\n     * @constructor\n     * @param {ICCSUsrMsg_KeyHintText=} [properties] Properties to set\n     */\n    function CCSUsrMsg_KeyHintText(properties) {\n        this.hints = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_KeyHintText hints.\n     * @member {Array.<string>} hints\n     * @memberof CCSUsrMsg_KeyHintText\n     * @instance\n     */\n    CCSUsrMsg_KeyHintText.prototype.hints = $util.emptyArray;\n    /**\n     * Decodes a CCSUsrMsg_KeyHintText message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_KeyHintText\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_KeyHintText} CCSUsrMsg_KeyHintText\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_KeyHintText.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_KeyHintText();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.hints && message.hints.length))\n                        message.hints = [];\n                    message.hints.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_KeyHintText;\n})());\nexports.CCSUsrMsg_ProcessSpottedEntityUpdate = ($root.CCSUsrMsg_ProcessSpottedEntityUpdate = (() => {\n    /**\n     * Properties of a CCSUsrMsg_ProcessSpottedEntityUpdate.\n     * @exports ICCSUsrMsg_ProcessSpottedEntityUpdate\n     * @interface ICCSUsrMsg_ProcessSpottedEntityUpdate\n     * @property {boolean|null} [newUpdate] CCSUsrMsg_ProcessSpottedEntityUpdate newUpdate\n     * @property {Array.<CCSUsrMsg_ProcessSpottedEntityUpdate.ISpottedEntityUpdate>|null} [entityUpdates] CCSUsrMsg_ProcessSpottedEntityUpdate entityUpdates\n     */\n    /**\n     * Constructs a new CCSUsrMsg_ProcessSpottedEntityUpdate.\n     * @exports CCSUsrMsg_ProcessSpottedEntityUpdate\n     * @classdesc Represents a CCSUsrMsg_ProcessSpottedEntityUpdate.\n     * @implements ICCSUsrMsg_ProcessSpottedEntityUpdate\n     * @constructor\n     * @param {ICCSUsrMsg_ProcessSpottedEntityUpdate=} [properties] Properties to set\n     */\n    function CCSUsrMsg_ProcessSpottedEntityUpdate(properties) {\n        this.entityUpdates = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_ProcessSpottedEntityUpdate newUpdate.\n     * @member {boolean} newUpdate\n     * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate\n     * @instance\n     */\n    CCSUsrMsg_ProcessSpottedEntityUpdate.prototype.newUpdate = false;\n    /**\n     * CCSUsrMsg_ProcessSpottedEntityUpdate entityUpdates.\n     * @member {Array.<CCSUsrMsg_ProcessSpottedEntityUpdate.ISpottedEntityUpdate>} entityUpdates\n     * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate\n     * @instance\n     */\n    CCSUsrMsg_ProcessSpottedEntityUpdate.prototype.entityUpdates =\n        $util.emptyArray;\n    /**\n     * Decodes a CCSUsrMsg_ProcessSpottedEntityUpdate message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_ProcessSpottedEntityUpdate} CCSUsrMsg_ProcessSpottedEntityUpdate\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_ProcessSpottedEntityUpdate.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ProcessSpottedEntityUpdate();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.newUpdate = reader.bool();\n                    break;\n                case 2:\n                    if (!(message.entityUpdates && message.entityUpdates.length))\n                        message.entityUpdates = [];\n                    message.entityUpdates.push($root.CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate = (function () {\n        /**\n         * Properties of a SpottedEntityUpdate.\n         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate\n         * @interface ISpottedEntityUpdate\n         * @property {number|null} [entityIdx] SpottedEntityUpdate entityIdx\n         * @property {number|null} [classId] SpottedEntityUpdate classId\n         * @property {number|null} [originX] SpottedEntityUpdate originX\n         * @property {number|null} [originY] SpottedEntityUpdate originY\n         * @property {number|null} [originZ] SpottedEntityUpdate originZ\n         * @property {number|null} [angleY] SpottedEntityUpdate angleY\n         * @property {boolean|null} [defuser] SpottedEntityUpdate defuser\n         * @property {boolean|null} [playerHasDefuser] SpottedEntityUpdate playerHasDefuser\n         * @property {boolean|null} [playerHasC4] SpottedEntityUpdate playerHasC4\n         */\n        /**\n         * Constructs a new SpottedEntityUpdate.\n         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate\n         * @classdesc Represents a SpottedEntityUpdate.\n         * @implements ISpottedEntityUpdate\n         * @constructor\n         * @param {CCSUsrMsg_ProcessSpottedEntityUpdate.ISpottedEntityUpdate=} [properties] Properties to set\n         */\n        function SpottedEntityUpdate(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * SpottedEntityUpdate entityIdx.\n         * @member {number} entityIdx\n         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate\n         * @instance\n         */\n        SpottedEntityUpdate.prototype.entityIdx = 0;\n        /**\n         * SpottedEntityUpdate classId.\n         * @member {number} classId\n         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate\n         * @instance\n         */\n        SpottedEntityUpdate.prototype.classId = 0;\n        /**\n         * SpottedEntityUpdate originX.\n         * @member {number} originX\n         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate\n         * @instance\n         */\n        SpottedEntityUpdate.prototype.originX = 0;\n        /**\n         * SpottedEntityUpdate originY.\n         * @member {number} originY\n         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate\n         * @instance\n         */\n        SpottedEntityUpdate.prototype.originY = 0;\n        /**\n         * SpottedEntityUpdate originZ.\n         * @member {number} originZ\n         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate\n         * @instance\n         */\n        SpottedEntityUpdate.prototype.originZ = 0;\n        /**\n         * SpottedEntityUpdate angleY.\n         * @member {number} angleY\n         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate\n         * @instance\n         */\n        SpottedEntityUpdate.prototype.angleY = 0;\n        /**\n         * SpottedEntityUpdate defuser.\n         * @member {boolean} defuser\n         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate\n         * @instance\n         */\n        SpottedEntityUpdate.prototype.defuser = false;\n        /**\n         * SpottedEntityUpdate playerHasDefuser.\n         * @member {boolean} playerHasDefuser\n         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate\n         * @instance\n         */\n        SpottedEntityUpdate.prototype.playerHasDefuser = false;\n        /**\n         * SpottedEntityUpdate playerHasC4.\n         * @member {boolean} playerHasC4\n         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate\n         * @instance\n         */\n        SpottedEntityUpdate.prototype.playerHasC4 = false;\n        /**\n         * Decodes a SpottedEntityUpdate message from the specified reader or buffer.\n         * @function decode\n         * @memberof CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate} SpottedEntityUpdate\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        SpottedEntityUpdate.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ProcessSpottedEntityUpdate.SpottedEntityUpdate();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.entityIdx = reader.int32();\n                        break;\n                    case 2:\n                        message.classId = reader.int32();\n                        break;\n                    case 3:\n                        message.originX = reader.int32();\n                        break;\n                    case 4:\n                        message.originY = reader.int32();\n                        break;\n                    case 5:\n                        message.originZ = reader.int32();\n                        break;\n                    case 6:\n                        message.angleY = reader.int32();\n                        break;\n                    case 7:\n                        message.defuser = reader.bool();\n                        break;\n                    case 8:\n                        message.playerHasDefuser = reader.bool();\n                        break;\n                    case 9:\n                        message.playerHasC4 = reader.bool();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return SpottedEntityUpdate;\n    })();\n    return CCSUsrMsg_ProcessSpottedEntityUpdate;\n})());\nexports.CCSUsrMsg_SendPlayerItemDrops = ($root.CCSUsrMsg_SendPlayerItemDrops = (() => {\n    /**\n     * Properties of a CCSUsrMsg_SendPlayerItemDrops.\n     * @exports ICCSUsrMsg_SendPlayerItemDrops\n     * @interface ICCSUsrMsg_SendPlayerItemDrops\n     * @property {Array.<ICEconItemPreviewDataBlock>|null} [entityUpdates] CCSUsrMsg_SendPlayerItemDrops entityUpdates\n     */\n    /**\n     * Constructs a new CCSUsrMsg_SendPlayerItemDrops.\n     * @exports CCSUsrMsg_SendPlayerItemDrops\n     * @classdesc Represents a CCSUsrMsg_SendPlayerItemDrops.\n     * @implements ICCSUsrMsg_SendPlayerItemDrops\n     * @constructor\n     * @param {ICCSUsrMsg_SendPlayerItemDrops=} [properties] Properties to set\n     */\n    function CCSUsrMsg_SendPlayerItemDrops(properties) {\n        this.entityUpdates = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_SendPlayerItemDrops entityUpdates.\n     * @member {Array.<ICEconItemPreviewDataBlock>} entityUpdates\n     * @memberof CCSUsrMsg_SendPlayerItemDrops\n     * @instance\n     */\n    CCSUsrMsg_SendPlayerItemDrops.prototype.entityUpdates = $util.emptyArray;\n    /**\n     * Decodes a CCSUsrMsg_SendPlayerItemDrops message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_SendPlayerItemDrops\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_SendPlayerItemDrops} CCSUsrMsg_SendPlayerItemDrops\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_SendPlayerItemDrops.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_SendPlayerItemDrops();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.entityUpdates && message.entityUpdates.length))\n                        message.entityUpdates = [];\n                    message.entityUpdates.push($root.CEconItemPreviewDataBlock.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_SendPlayerItemDrops;\n})());\nexports.CCSUsrMsg_SendPlayerItemFound = ($root.CCSUsrMsg_SendPlayerItemFound = (() => {\n    /**\n     * Properties of a CCSUsrMsg_SendPlayerItemFound.\n     * @exports ICCSUsrMsg_SendPlayerItemFound\n     * @interface ICCSUsrMsg_SendPlayerItemFound\n     * @property {ICEconItemPreviewDataBlock|null} [iteminfo] CCSUsrMsg_SendPlayerItemFound iteminfo\n     * @property {number|null} [entindex] CCSUsrMsg_SendPlayerItemFound entindex\n     */\n    /**\n     * Constructs a new CCSUsrMsg_SendPlayerItemFound.\n     * @exports CCSUsrMsg_SendPlayerItemFound\n     * @classdesc Represents a CCSUsrMsg_SendPlayerItemFound.\n     * @implements ICCSUsrMsg_SendPlayerItemFound\n     * @constructor\n     * @param {ICCSUsrMsg_SendPlayerItemFound=} [properties] Properties to set\n     */\n    function CCSUsrMsg_SendPlayerItemFound(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_SendPlayerItemFound iteminfo.\n     * @member {ICEconItemPreviewDataBlock|null|undefined} iteminfo\n     * @memberof CCSUsrMsg_SendPlayerItemFound\n     * @instance\n     */\n    CCSUsrMsg_SendPlayerItemFound.prototype.iteminfo = null;\n    /**\n     * CCSUsrMsg_SendPlayerItemFound entindex.\n     * @member {number} entindex\n     * @memberof CCSUsrMsg_SendPlayerItemFound\n     * @instance\n     */\n    CCSUsrMsg_SendPlayerItemFound.prototype.entindex = 0;\n    /**\n     * Decodes a CCSUsrMsg_SendPlayerItemFound message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_SendPlayerItemFound\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_SendPlayerItemFound} CCSUsrMsg_SendPlayerItemFound\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_SendPlayerItemFound.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_SendPlayerItemFound();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.iteminfo = $root.CEconItemPreviewDataBlock.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.entindex = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_SendPlayerItemFound;\n})());\nexports.CCSUsrMsg_ReloadEffect = ($root.CCSUsrMsg_ReloadEffect = (() => {\n    /**\n     * Properties of a CCSUsrMsg_ReloadEffect.\n     * @exports ICCSUsrMsg_ReloadEffect\n     * @interface ICCSUsrMsg_ReloadEffect\n     * @property {number|null} [entidx] CCSUsrMsg_ReloadEffect entidx\n     * @property {number|null} [actanim] CCSUsrMsg_ReloadEffect actanim\n     * @property {number|null} [originX] CCSUsrMsg_ReloadEffect originX\n     * @property {number|null} [originY] CCSUsrMsg_ReloadEffect originY\n     * @property {number|null} [originZ] CCSUsrMsg_ReloadEffect originZ\n     */\n    /**\n     * Constructs a new CCSUsrMsg_ReloadEffect.\n     * @exports CCSUsrMsg_ReloadEffect\n     * @classdesc Represents a CCSUsrMsg_ReloadEffect.\n     * @implements ICCSUsrMsg_ReloadEffect\n     * @constructor\n     * @param {ICCSUsrMsg_ReloadEffect=} [properties] Properties to set\n     */\n    function CCSUsrMsg_ReloadEffect(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_ReloadEffect entidx.\n     * @member {number} entidx\n     * @memberof CCSUsrMsg_ReloadEffect\n     * @instance\n     */\n    CCSUsrMsg_ReloadEffect.prototype.entidx = 0;\n    /**\n     * CCSUsrMsg_ReloadEffect actanim.\n     * @member {number} actanim\n     * @memberof CCSUsrMsg_ReloadEffect\n     * @instance\n     */\n    CCSUsrMsg_ReloadEffect.prototype.actanim = 0;\n    /**\n     * CCSUsrMsg_ReloadEffect originX.\n     * @member {number} originX\n     * @memberof CCSUsrMsg_ReloadEffect\n     * @instance\n     */\n    CCSUsrMsg_ReloadEffect.prototype.originX = 0;\n    /**\n     * CCSUsrMsg_ReloadEffect originY.\n     * @member {number} originY\n     * @memberof CCSUsrMsg_ReloadEffect\n     * @instance\n     */\n    CCSUsrMsg_ReloadEffect.prototype.originY = 0;\n    /**\n     * CCSUsrMsg_ReloadEffect originZ.\n     * @member {number} originZ\n     * @memberof CCSUsrMsg_ReloadEffect\n     * @instance\n     */\n    CCSUsrMsg_ReloadEffect.prototype.originZ = 0;\n    /**\n     * Decodes a CCSUsrMsg_ReloadEffect message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_ReloadEffect\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_ReloadEffect} CCSUsrMsg_ReloadEffect\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_ReloadEffect.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ReloadEffect();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.entidx = reader.int32();\n                    break;\n                case 2:\n                    message.actanim = reader.int32();\n                    break;\n                case 3:\n                    message.originX = reader.float();\n                    break;\n                case 4:\n                    message.originY = reader.float();\n                    break;\n                case 5:\n                    message.originZ = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_ReloadEffect;\n})());\nexports.CCSUsrMsg_AdjustMoney = ($root.CCSUsrMsg_AdjustMoney = (() => {\n    /**\n     * Properties of a CCSUsrMsg_AdjustMoney.\n     * @exports ICCSUsrMsg_AdjustMoney\n     * @interface ICCSUsrMsg_AdjustMoney\n     * @property {number|null} [amount] CCSUsrMsg_AdjustMoney amount\n     */\n    /**\n     * Constructs a new CCSUsrMsg_AdjustMoney.\n     * @exports CCSUsrMsg_AdjustMoney\n     * @classdesc Represents a CCSUsrMsg_AdjustMoney.\n     * @implements ICCSUsrMsg_AdjustMoney\n     * @constructor\n     * @param {ICCSUsrMsg_AdjustMoney=} [properties] Properties to set\n     */\n    function CCSUsrMsg_AdjustMoney(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_AdjustMoney amount.\n     * @member {number} amount\n     * @memberof CCSUsrMsg_AdjustMoney\n     * @instance\n     */\n    CCSUsrMsg_AdjustMoney.prototype.amount = 0;\n    /**\n     * Decodes a CCSUsrMsg_AdjustMoney message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_AdjustMoney\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_AdjustMoney} CCSUsrMsg_AdjustMoney\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_AdjustMoney.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_AdjustMoney();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.amount = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_AdjustMoney;\n})());\nexports.CCSUsrMsg_ReportHit = ($root.CCSUsrMsg_ReportHit = (() => {\n    /**\n     * Properties of a CCSUsrMsg_ReportHit.\n     * @exports ICCSUsrMsg_ReportHit\n     * @interface ICCSUsrMsg_ReportHit\n     * @property {number|null} [posX] CCSUsrMsg_ReportHit posX\n     * @property {number|null} [posY] CCSUsrMsg_ReportHit posY\n     * @property {number|null} [timestamp] CCSUsrMsg_ReportHit timestamp\n     * @property {number|null} [posZ] CCSUsrMsg_ReportHit posZ\n     */\n    /**\n     * Constructs a new CCSUsrMsg_ReportHit.\n     * @exports CCSUsrMsg_ReportHit\n     * @classdesc Represents a CCSUsrMsg_ReportHit.\n     * @implements ICCSUsrMsg_ReportHit\n     * @constructor\n     * @param {ICCSUsrMsg_ReportHit=} [properties] Properties to set\n     */\n    function CCSUsrMsg_ReportHit(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_ReportHit posX.\n     * @member {number} posX\n     * @memberof CCSUsrMsg_ReportHit\n     * @instance\n     */\n    CCSUsrMsg_ReportHit.prototype.posX = 0;\n    /**\n     * CCSUsrMsg_ReportHit posY.\n     * @member {number} posY\n     * @memberof CCSUsrMsg_ReportHit\n     * @instance\n     */\n    CCSUsrMsg_ReportHit.prototype.posY = 0;\n    /**\n     * CCSUsrMsg_ReportHit timestamp.\n     * @member {number} timestamp\n     * @memberof CCSUsrMsg_ReportHit\n     * @instance\n     */\n    CCSUsrMsg_ReportHit.prototype.timestamp = 0;\n    /**\n     * CCSUsrMsg_ReportHit posZ.\n     * @member {number} posZ\n     * @memberof CCSUsrMsg_ReportHit\n     * @instance\n     */\n    CCSUsrMsg_ReportHit.prototype.posZ = 0;\n    /**\n     * Decodes a CCSUsrMsg_ReportHit message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_ReportHit\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_ReportHit} CCSUsrMsg_ReportHit\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_ReportHit.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ReportHit();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.posX = reader.float();\n                    break;\n                case 2:\n                    message.posY = reader.float();\n                    break;\n                case 4:\n                    message.timestamp = reader.float();\n                    break;\n                case 3:\n                    message.posZ = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_ReportHit;\n})());\nexports.CCSUsrMsg_KillCam = ($root.CCSUsrMsg_KillCam = (() => {\n    /**\n     * Properties of a CCSUsrMsg_KillCam.\n     * @exports ICCSUsrMsg_KillCam\n     * @interface ICCSUsrMsg_KillCam\n     * @property {number|null} [obsMode] CCSUsrMsg_KillCam obsMode\n     * @property {number|null} [firstTarget] CCSUsrMsg_KillCam firstTarget\n     * @property {number|null} [secondTarget] CCSUsrMsg_KillCam secondTarget\n     */\n    /**\n     * Constructs a new CCSUsrMsg_KillCam.\n     * @exports CCSUsrMsg_KillCam\n     * @classdesc Represents a CCSUsrMsg_KillCam.\n     * @implements ICCSUsrMsg_KillCam\n     * @constructor\n     * @param {ICCSUsrMsg_KillCam=} [properties] Properties to set\n     */\n    function CCSUsrMsg_KillCam(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_KillCam obsMode.\n     * @member {number} obsMode\n     * @memberof CCSUsrMsg_KillCam\n     * @instance\n     */\n    CCSUsrMsg_KillCam.prototype.obsMode = 0;\n    /**\n     * CCSUsrMsg_KillCam firstTarget.\n     * @member {number} firstTarget\n     * @memberof CCSUsrMsg_KillCam\n     * @instance\n     */\n    CCSUsrMsg_KillCam.prototype.firstTarget = 0;\n    /**\n     * CCSUsrMsg_KillCam secondTarget.\n     * @member {number} secondTarget\n     * @memberof CCSUsrMsg_KillCam\n     * @instance\n     */\n    CCSUsrMsg_KillCam.prototype.secondTarget = 0;\n    /**\n     * Decodes a CCSUsrMsg_KillCam message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_KillCam\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_KillCam} CCSUsrMsg_KillCam\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_KillCam.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_KillCam();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.obsMode = reader.int32();\n                    break;\n                case 2:\n                    message.firstTarget = reader.int32();\n                    break;\n                case 3:\n                    message.secondTarget = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_KillCam;\n})());\nexports.CCSUsrMsg_DesiredTimescale = ($root.CCSUsrMsg_DesiredTimescale = (() => {\n    /**\n     * Properties of a CCSUsrMsg_DesiredTimescale.\n     * @exports ICCSUsrMsg_DesiredTimescale\n     * @interface ICCSUsrMsg_DesiredTimescale\n     * @property {number|null} [desiredTimescale] CCSUsrMsg_DesiredTimescale desiredTimescale\n     * @property {number|null} [durationRealtimeSec] CCSUsrMsg_DesiredTimescale durationRealtimeSec\n     * @property {number|null} [interpolatorType] CCSUsrMsg_DesiredTimescale interpolatorType\n     * @property {number|null} [startBlendTime] CCSUsrMsg_DesiredTimescale startBlendTime\n     */\n    /**\n     * Constructs a new CCSUsrMsg_DesiredTimescale.\n     * @exports CCSUsrMsg_DesiredTimescale\n     * @classdesc Represents a CCSUsrMsg_DesiredTimescale.\n     * @implements ICCSUsrMsg_DesiredTimescale\n     * @constructor\n     * @param {ICCSUsrMsg_DesiredTimescale=} [properties] Properties to set\n     */\n    function CCSUsrMsg_DesiredTimescale(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_DesiredTimescale desiredTimescale.\n     * @member {number} desiredTimescale\n     * @memberof CCSUsrMsg_DesiredTimescale\n     * @instance\n     */\n    CCSUsrMsg_DesiredTimescale.prototype.desiredTimescale = 0;\n    /**\n     * CCSUsrMsg_DesiredTimescale durationRealtimeSec.\n     * @member {number} durationRealtimeSec\n     * @memberof CCSUsrMsg_DesiredTimescale\n     * @instance\n     */\n    CCSUsrMsg_DesiredTimescale.prototype.durationRealtimeSec = 0;\n    /**\n     * CCSUsrMsg_DesiredTimescale interpolatorType.\n     * @member {number} interpolatorType\n     * @memberof CCSUsrMsg_DesiredTimescale\n     * @instance\n     */\n    CCSUsrMsg_DesiredTimescale.prototype.interpolatorType = 0;\n    /**\n     * CCSUsrMsg_DesiredTimescale startBlendTime.\n     * @member {number} startBlendTime\n     * @memberof CCSUsrMsg_DesiredTimescale\n     * @instance\n     */\n    CCSUsrMsg_DesiredTimescale.prototype.startBlendTime = 0;\n    /**\n     * Decodes a CCSUsrMsg_DesiredTimescale message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_DesiredTimescale\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_DesiredTimescale} CCSUsrMsg_DesiredTimescale\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_DesiredTimescale.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_DesiredTimescale();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.desiredTimescale = reader.float();\n                    break;\n                case 2:\n                    message.durationRealtimeSec = reader.float();\n                    break;\n                case 3:\n                    message.interpolatorType = reader.int32();\n                    break;\n                case 4:\n                    message.startBlendTime = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_DesiredTimescale;\n})());\nexports.CCSUsrMsg_CurrentTimescale = ($root.CCSUsrMsg_CurrentTimescale = (() => {\n    /**\n     * Properties of a CCSUsrMsg_CurrentTimescale.\n     * @exports ICCSUsrMsg_CurrentTimescale\n     * @interface ICCSUsrMsg_CurrentTimescale\n     * @property {number|null} [curTimescale] CCSUsrMsg_CurrentTimescale curTimescale\n     */\n    /**\n     * Constructs a new CCSUsrMsg_CurrentTimescale.\n     * @exports CCSUsrMsg_CurrentTimescale\n     * @classdesc Represents a CCSUsrMsg_CurrentTimescale.\n     * @implements ICCSUsrMsg_CurrentTimescale\n     * @constructor\n     * @param {ICCSUsrMsg_CurrentTimescale=} [properties] Properties to set\n     */\n    function CCSUsrMsg_CurrentTimescale(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_CurrentTimescale curTimescale.\n     * @member {number} curTimescale\n     * @memberof CCSUsrMsg_CurrentTimescale\n     * @instance\n     */\n    CCSUsrMsg_CurrentTimescale.prototype.curTimescale = 0;\n    /**\n     * Decodes a CCSUsrMsg_CurrentTimescale message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_CurrentTimescale\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_CurrentTimescale} CCSUsrMsg_CurrentTimescale\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_CurrentTimescale.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_CurrentTimescale();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.curTimescale = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_CurrentTimescale;\n})());\nexports.CCSUsrMsg_AchievementEvent = ($root.CCSUsrMsg_AchievementEvent = (() => {\n    /**\n     * Properties of a CCSUsrMsg_AchievementEvent.\n     * @exports ICCSUsrMsg_AchievementEvent\n     * @interface ICCSUsrMsg_AchievementEvent\n     * @property {number|null} [achievement] CCSUsrMsg_AchievementEvent achievement\n     * @property {number|null} [count] CCSUsrMsg_AchievementEvent count\n     * @property {number|null} [userId] CCSUsrMsg_AchievementEvent userId\n     */\n    /**\n     * Constructs a new CCSUsrMsg_AchievementEvent.\n     * @exports CCSUsrMsg_AchievementEvent\n     * @classdesc Represents a CCSUsrMsg_AchievementEvent.\n     * @implements ICCSUsrMsg_AchievementEvent\n     * @constructor\n     * @param {ICCSUsrMsg_AchievementEvent=} [properties] Properties to set\n     */\n    function CCSUsrMsg_AchievementEvent(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_AchievementEvent achievement.\n     * @member {number} achievement\n     * @memberof CCSUsrMsg_AchievementEvent\n     * @instance\n     */\n    CCSUsrMsg_AchievementEvent.prototype.achievement = 0;\n    /**\n     * CCSUsrMsg_AchievementEvent count.\n     * @member {number} count\n     * @memberof CCSUsrMsg_AchievementEvent\n     * @instance\n     */\n    CCSUsrMsg_AchievementEvent.prototype.count = 0;\n    /**\n     * CCSUsrMsg_AchievementEvent userId.\n     * @member {number} userId\n     * @memberof CCSUsrMsg_AchievementEvent\n     * @instance\n     */\n    CCSUsrMsg_AchievementEvent.prototype.userId = 0;\n    /**\n     * Decodes a CCSUsrMsg_AchievementEvent message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_AchievementEvent\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_AchievementEvent} CCSUsrMsg_AchievementEvent\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_AchievementEvent.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_AchievementEvent();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.achievement = reader.int32();\n                    break;\n                case 2:\n                    message.count = reader.int32();\n                    break;\n                case 3:\n                    message.userId = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_AchievementEvent;\n})());\nexports.CCSUsrMsg_MatchEndConditions = ($root.CCSUsrMsg_MatchEndConditions = (() => {\n    /**\n     * Properties of a CCSUsrMsg_MatchEndConditions.\n     * @exports ICCSUsrMsg_MatchEndConditions\n     * @interface ICCSUsrMsg_MatchEndConditions\n     * @property {number|null} [fraglimit] CCSUsrMsg_MatchEndConditions fraglimit\n     * @property {number|null} [mpMaxrounds] CCSUsrMsg_MatchEndConditions mpMaxrounds\n     * @property {number|null} [mpWinlimit] CCSUsrMsg_MatchEndConditions mpWinlimit\n     * @property {number|null} [mpTimelimit] CCSUsrMsg_MatchEndConditions mpTimelimit\n     */\n    /**\n     * Constructs a new CCSUsrMsg_MatchEndConditions.\n     * @exports CCSUsrMsg_MatchEndConditions\n     * @classdesc Represents a CCSUsrMsg_MatchEndConditions.\n     * @implements ICCSUsrMsg_MatchEndConditions\n     * @constructor\n     * @param {ICCSUsrMsg_MatchEndConditions=} [properties] Properties to set\n     */\n    function CCSUsrMsg_MatchEndConditions(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_MatchEndConditions fraglimit.\n     * @member {number} fraglimit\n     * @memberof CCSUsrMsg_MatchEndConditions\n     * @instance\n     */\n    CCSUsrMsg_MatchEndConditions.prototype.fraglimit = 0;\n    /**\n     * CCSUsrMsg_MatchEndConditions mpMaxrounds.\n     * @member {number} mpMaxrounds\n     * @memberof CCSUsrMsg_MatchEndConditions\n     * @instance\n     */\n    CCSUsrMsg_MatchEndConditions.prototype.mpMaxrounds = 0;\n    /**\n     * CCSUsrMsg_MatchEndConditions mpWinlimit.\n     * @member {number} mpWinlimit\n     * @memberof CCSUsrMsg_MatchEndConditions\n     * @instance\n     */\n    CCSUsrMsg_MatchEndConditions.prototype.mpWinlimit = 0;\n    /**\n     * CCSUsrMsg_MatchEndConditions mpTimelimit.\n     * @member {number} mpTimelimit\n     * @memberof CCSUsrMsg_MatchEndConditions\n     * @instance\n     */\n    CCSUsrMsg_MatchEndConditions.prototype.mpTimelimit = 0;\n    /**\n     * Decodes a CCSUsrMsg_MatchEndConditions message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_MatchEndConditions\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_MatchEndConditions} CCSUsrMsg_MatchEndConditions\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_MatchEndConditions.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_MatchEndConditions();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.fraglimit = reader.int32();\n                    break;\n                case 2:\n                    message.mpMaxrounds = reader.int32();\n                    break;\n                case 3:\n                    message.mpWinlimit = reader.int32();\n                    break;\n                case 4:\n                    message.mpTimelimit = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_MatchEndConditions;\n})());\nexports.CCSUsrMsg_PlayerStatsUpdate = ($root.CCSUsrMsg_PlayerStatsUpdate = (() => {\n    /**\n     * Properties of a CCSUsrMsg_PlayerStatsUpdate.\n     * @exports ICCSUsrMsg_PlayerStatsUpdate\n     * @interface ICCSUsrMsg_PlayerStatsUpdate\n     * @property {number|null} [version] CCSUsrMsg_PlayerStatsUpdate version\n     * @property {Array.<CCSUsrMsg_PlayerStatsUpdate.IStat>|null} [stats] CCSUsrMsg_PlayerStatsUpdate stats\n     * @property {number|null} [userId] CCSUsrMsg_PlayerStatsUpdate userId\n     * @property {number|null} [crc] CCSUsrMsg_PlayerStatsUpdate crc\n     */\n    /**\n     * Constructs a new CCSUsrMsg_PlayerStatsUpdate.\n     * @exports CCSUsrMsg_PlayerStatsUpdate\n     * @classdesc Represents a CCSUsrMsg_PlayerStatsUpdate.\n     * @implements ICCSUsrMsg_PlayerStatsUpdate\n     * @constructor\n     * @param {ICCSUsrMsg_PlayerStatsUpdate=} [properties] Properties to set\n     */\n    function CCSUsrMsg_PlayerStatsUpdate(properties) {\n        this.stats = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_PlayerStatsUpdate version.\n     * @member {number} version\n     * @memberof CCSUsrMsg_PlayerStatsUpdate\n     * @instance\n     */\n    CCSUsrMsg_PlayerStatsUpdate.prototype.version = 0;\n    /**\n     * CCSUsrMsg_PlayerStatsUpdate stats.\n     * @member {Array.<CCSUsrMsg_PlayerStatsUpdate.IStat>} stats\n     * @memberof CCSUsrMsg_PlayerStatsUpdate\n     * @instance\n     */\n    CCSUsrMsg_PlayerStatsUpdate.prototype.stats = $util.emptyArray;\n    /**\n     * CCSUsrMsg_PlayerStatsUpdate userId.\n     * @member {number} userId\n     * @memberof CCSUsrMsg_PlayerStatsUpdate\n     * @instance\n     */\n    CCSUsrMsg_PlayerStatsUpdate.prototype.userId = 0;\n    /**\n     * CCSUsrMsg_PlayerStatsUpdate crc.\n     * @member {number} crc\n     * @memberof CCSUsrMsg_PlayerStatsUpdate\n     * @instance\n     */\n    CCSUsrMsg_PlayerStatsUpdate.prototype.crc = 0;\n    /**\n     * Decodes a CCSUsrMsg_PlayerStatsUpdate message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_PlayerStatsUpdate\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_PlayerStatsUpdate} CCSUsrMsg_PlayerStatsUpdate\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_PlayerStatsUpdate.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_PlayerStatsUpdate();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.version = reader.int32();\n                    break;\n                case 4:\n                    if (!(message.stats && message.stats.length))\n                        message.stats = [];\n                    message.stats.push($root.CCSUsrMsg_PlayerStatsUpdate.Stat.decode(reader, reader.uint32()));\n                    break;\n                case 5:\n                    message.userId = reader.int32();\n                    break;\n                case 6:\n                    message.crc = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CCSUsrMsg_PlayerStatsUpdate.Stat = (function () {\n        /**\n         * Properties of a Stat.\n         * @memberof CCSUsrMsg_PlayerStatsUpdate\n         * @interface IStat\n         * @property {number|null} [idx] Stat idx\n         * @property {number|null} [delta] Stat delta\n         */\n        /**\n         * Constructs a new Stat.\n         * @memberof CCSUsrMsg_PlayerStatsUpdate\n         * @classdesc Represents a Stat.\n         * @implements IStat\n         * @constructor\n         * @param {CCSUsrMsg_PlayerStatsUpdate.IStat=} [properties] Properties to set\n         */\n        function Stat(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * Stat idx.\n         * @member {number} idx\n         * @memberof CCSUsrMsg_PlayerStatsUpdate.Stat\n         * @instance\n         */\n        Stat.prototype.idx = 0;\n        /**\n         * Stat delta.\n         * @member {number} delta\n         * @memberof CCSUsrMsg_PlayerStatsUpdate.Stat\n         * @instance\n         */\n        Stat.prototype.delta = 0;\n        /**\n         * Decodes a Stat message from the specified reader or buffer.\n         * @function decode\n         * @memberof CCSUsrMsg_PlayerStatsUpdate.Stat\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CCSUsrMsg_PlayerStatsUpdate.Stat} Stat\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Stat.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_PlayerStatsUpdate.Stat();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.idx = reader.int32();\n                        break;\n                    case 2:\n                        message.delta = reader.int32();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return Stat;\n    })();\n    return CCSUsrMsg_PlayerStatsUpdate;\n})());\nexports.CCSUsrMsg_DisplayInventory = ($root.CCSUsrMsg_DisplayInventory = (() => {\n    /**\n     * Properties of a CCSUsrMsg_DisplayInventory.\n     * @exports ICCSUsrMsg_DisplayInventory\n     * @interface ICCSUsrMsg_DisplayInventory\n     * @property {boolean|null} [display] CCSUsrMsg_DisplayInventory display\n     * @property {number|null} [userId] CCSUsrMsg_DisplayInventory userId\n     */\n    /**\n     * Constructs a new CCSUsrMsg_DisplayInventory.\n     * @exports CCSUsrMsg_DisplayInventory\n     * @classdesc Represents a CCSUsrMsg_DisplayInventory.\n     * @implements ICCSUsrMsg_DisplayInventory\n     * @constructor\n     * @param {ICCSUsrMsg_DisplayInventory=} [properties] Properties to set\n     */\n    function CCSUsrMsg_DisplayInventory(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_DisplayInventory display.\n     * @member {boolean} display\n     * @memberof CCSUsrMsg_DisplayInventory\n     * @instance\n     */\n    CCSUsrMsg_DisplayInventory.prototype.display = false;\n    /**\n     * CCSUsrMsg_DisplayInventory userId.\n     * @member {number} userId\n     * @memberof CCSUsrMsg_DisplayInventory\n     * @instance\n     */\n    CCSUsrMsg_DisplayInventory.prototype.userId = 0;\n    /**\n     * Decodes a CCSUsrMsg_DisplayInventory message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_DisplayInventory\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_DisplayInventory} CCSUsrMsg_DisplayInventory\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_DisplayInventory.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_DisplayInventory();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.display = reader.bool();\n                    break;\n                case 2:\n                    message.userId = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_DisplayInventory;\n})());\nexports.CCSUsrMsg_QuestProgress = ($root.CCSUsrMsg_QuestProgress = (() => {\n    /**\n     * Properties of a CCSUsrMsg_QuestProgress.\n     * @exports ICCSUsrMsg_QuestProgress\n     * @interface ICCSUsrMsg_QuestProgress\n     * @property {number|null} [questId] CCSUsrMsg_QuestProgress questId\n     * @property {number|null} [normalPoints] CCSUsrMsg_QuestProgress normalPoints\n     * @property {number|null} [bonusPoints] CCSUsrMsg_QuestProgress bonusPoints\n     */\n    /**\n     * Constructs a new CCSUsrMsg_QuestProgress.\n     * @exports CCSUsrMsg_QuestProgress\n     * @classdesc Represents a CCSUsrMsg_QuestProgress.\n     * @implements ICCSUsrMsg_QuestProgress\n     * @constructor\n     * @param {ICCSUsrMsg_QuestProgress=} [properties] Properties to set\n     */\n    function CCSUsrMsg_QuestProgress(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_QuestProgress questId.\n     * @member {number} questId\n     * @memberof CCSUsrMsg_QuestProgress\n     * @instance\n     */\n    CCSUsrMsg_QuestProgress.prototype.questId = 0;\n    /**\n     * CCSUsrMsg_QuestProgress normalPoints.\n     * @member {number} normalPoints\n     * @memberof CCSUsrMsg_QuestProgress\n     * @instance\n     */\n    CCSUsrMsg_QuestProgress.prototype.normalPoints = 0;\n    /**\n     * CCSUsrMsg_QuestProgress bonusPoints.\n     * @member {number} bonusPoints\n     * @memberof CCSUsrMsg_QuestProgress\n     * @instance\n     */\n    CCSUsrMsg_QuestProgress.prototype.bonusPoints = 0;\n    /**\n     * Decodes a CCSUsrMsg_QuestProgress message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_QuestProgress\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_QuestProgress} CCSUsrMsg_QuestProgress\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_QuestProgress.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_QuestProgress();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.questId = reader.uint32();\n                    break;\n                case 2:\n                    message.normalPoints = reader.uint32();\n                    break;\n                case 3:\n                    message.bonusPoints = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_QuestProgress;\n})());\nexports.CCSUsrMsg_XRankGet = ($root.CCSUsrMsg_XRankGet = (() => {\n    /**\n     * Properties of a CCSUsrMsg_XRankGet.\n     * @exports ICCSUsrMsg_XRankGet\n     * @interface ICCSUsrMsg_XRankGet\n     * @property {number|null} [modeIdx] CCSUsrMsg_XRankGet modeIdx\n     * @property {number|null} [controller] CCSUsrMsg_XRankGet controller\n     */\n    /**\n     * Constructs a new CCSUsrMsg_XRankGet.\n     * @exports CCSUsrMsg_XRankGet\n     * @classdesc Represents a CCSUsrMsg_XRankGet.\n     * @implements ICCSUsrMsg_XRankGet\n     * @constructor\n     * @param {ICCSUsrMsg_XRankGet=} [properties] Properties to set\n     */\n    function CCSUsrMsg_XRankGet(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_XRankGet modeIdx.\n     * @member {number} modeIdx\n     * @memberof CCSUsrMsg_XRankGet\n     * @instance\n     */\n    CCSUsrMsg_XRankGet.prototype.modeIdx = 0;\n    /**\n     * CCSUsrMsg_XRankGet controller.\n     * @member {number} controller\n     * @memberof CCSUsrMsg_XRankGet\n     * @instance\n     */\n    CCSUsrMsg_XRankGet.prototype.controller = 0;\n    /**\n     * Decodes a CCSUsrMsg_XRankGet message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_XRankGet\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_XRankGet} CCSUsrMsg_XRankGet\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_XRankGet.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_XRankGet();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.modeIdx = reader.int32();\n                    break;\n                case 2:\n                    message.controller = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_XRankGet;\n})());\nexports.CCSUsrMsg_XRankUpd = ($root.CCSUsrMsg_XRankUpd = (() => {\n    /**\n     * Properties of a CCSUsrMsg_XRankUpd.\n     * @exports ICCSUsrMsg_XRankUpd\n     * @interface ICCSUsrMsg_XRankUpd\n     * @property {number|null} [modeIdx] CCSUsrMsg_XRankUpd modeIdx\n     * @property {number|null} [controller] CCSUsrMsg_XRankUpd controller\n     * @property {number|null} [ranking] CCSUsrMsg_XRankUpd ranking\n     */\n    /**\n     * Constructs a new CCSUsrMsg_XRankUpd.\n     * @exports CCSUsrMsg_XRankUpd\n     * @classdesc Represents a CCSUsrMsg_XRankUpd.\n     * @implements ICCSUsrMsg_XRankUpd\n     * @constructor\n     * @param {ICCSUsrMsg_XRankUpd=} [properties] Properties to set\n     */\n    function CCSUsrMsg_XRankUpd(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_XRankUpd modeIdx.\n     * @member {number} modeIdx\n     * @memberof CCSUsrMsg_XRankUpd\n     * @instance\n     */\n    CCSUsrMsg_XRankUpd.prototype.modeIdx = 0;\n    /**\n     * CCSUsrMsg_XRankUpd controller.\n     * @member {number} controller\n     * @memberof CCSUsrMsg_XRankUpd\n     * @instance\n     */\n    CCSUsrMsg_XRankUpd.prototype.controller = 0;\n    /**\n     * CCSUsrMsg_XRankUpd ranking.\n     * @member {number} ranking\n     * @memberof CCSUsrMsg_XRankUpd\n     * @instance\n     */\n    CCSUsrMsg_XRankUpd.prototype.ranking = 0;\n    /**\n     * Decodes a CCSUsrMsg_XRankUpd message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_XRankUpd\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_XRankUpd} CCSUsrMsg_XRankUpd\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_XRankUpd.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_XRankUpd();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.modeIdx = reader.int32();\n                    break;\n                case 2:\n                    message.controller = reader.int32();\n                    break;\n                case 3:\n                    message.ranking = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_XRankUpd;\n})());\nexports.CCSUsrMsg_CallVoteFailed = ($root.CCSUsrMsg_CallVoteFailed = (() => {\n    /**\n     * Properties of a CCSUsrMsg_CallVoteFailed.\n     * @exports ICCSUsrMsg_CallVoteFailed\n     * @interface ICCSUsrMsg_CallVoteFailed\n     * @property {number|null} [reason] CCSUsrMsg_CallVoteFailed reason\n     * @property {number|null} [time] CCSUsrMsg_CallVoteFailed time\n     */\n    /**\n     * Constructs a new CCSUsrMsg_CallVoteFailed.\n     * @exports CCSUsrMsg_CallVoteFailed\n     * @classdesc Represents a CCSUsrMsg_CallVoteFailed.\n     * @implements ICCSUsrMsg_CallVoteFailed\n     * @constructor\n     * @param {ICCSUsrMsg_CallVoteFailed=} [properties] Properties to set\n     */\n    function CCSUsrMsg_CallVoteFailed(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_CallVoteFailed reason.\n     * @member {number} reason\n     * @memberof CCSUsrMsg_CallVoteFailed\n     * @instance\n     */\n    CCSUsrMsg_CallVoteFailed.prototype.reason = 0;\n    /**\n     * CCSUsrMsg_CallVoteFailed time.\n     * @member {number} time\n     * @memberof CCSUsrMsg_CallVoteFailed\n     * @instance\n     */\n    CCSUsrMsg_CallVoteFailed.prototype.time = 0;\n    /**\n     * Decodes a CCSUsrMsg_CallVoteFailed message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_CallVoteFailed\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_CallVoteFailed} CCSUsrMsg_CallVoteFailed\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_CallVoteFailed.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_CallVoteFailed();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.reason = reader.int32();\n                    break;\n                case 2:\n                    message.time = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_CallVoteFailed;\n})());\nexports.CCSUsrMsg_VoteStart = ($root.CCSUsrMsg_VoteStart = (() => {\n    /**\n     * Properties of a CCSUsrMsg_VoteStart.\n     * @exports ICCSUsrMsg_VoteStart\n     * @interface ICCSUsrMsg_VoteStart\n     * @property {number|null} [team] CCSUsrMsg_VoteStart team\n     * @property {number|null} [entIdx] CCSUsrMsg_VoteStart entIdx\n     * @property {number|null} [voteType] CCSUsrMsg_VoteStart voteType\n     * @property {string|null} [dispStr] CCSUsrMsg_VoteStart dispStr\n     * @property {string|null} [detailsStr] CCSUsrMsg_VoteStart detailsStr\n     * @property {string|null} [otherTeamStr] CCSUsrMsg_VoteStart otherTeamStr\n     * @property {boolean|null} [isYesNoVote] CCSUsrMsg_VoteStart isYesNoVote\n     */\n    /**\n     * Constructs a new CCSUsrMsg_VoteStart.\n     * @exports CCSUsrMsg_VoteStart\n     * @classdesc Represents a CCSUsrMsg_VoteStart.\n     * @implements ICCSUsrMsg_VoteStart\n     * @constructor\n     * @param {ICCSUsrMsg_VoteStart=} [properties] Properties to set\n     */\n    function CCSUsrMsg_VoteStart(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_VoteStart team.\n     * @member {number} team\n     * @memberof CCSUsrMsg_VoteStart\n     * @instance\n     */\n    CCSUsrMsg_VoteStart.prototype.team = 0;\n    /**\n     * CCSUsrMsg_VoteStart entIdx.\n     * @member {number} entIdx\n     * @memberof CCSUsrMsg_VoteStart\n     * @instance\n     */\n    CCSUsrMsg_VoteStart.prototype.entIdx = 0;\n    /**\n     * CCSUsrMsg_VoteStart voteType.\n     * @member {number} voteType\n     * @memberof CCSUsrMsg_VoteStart\n     * @instance\n     */\n    CCSUsrMsg_VoteStart.prototype.voteType = 0;\n    /**\n     * CCSUsrMsg_VoteStart dispStr.\n     * @member {string} dispStr\n     * @memberof CCSUsrMsg_VoteStart\n     * @instance\n     */\n    CCSUsrMsg_VoteStart.prototype.dispStr = \"\";\n    /**\n     * CCSUsrMsg_VoteStart detailsStr.\n     * @member {string} detailsStr\n     * @memberof CCSUsrMsg_VoteStart\n     * @instance\n     */\n    CCSUsrMsg_VoteStart.prototype.detailsStr = \"\";\n    /**\n     * CCSUsrMsg_VoteStart otherTeamStr.\n     * @member {string} otherTeamStr\n     * @memberof CCSUsrMsg_VoteStart\n     * @instance\n     */\n    CCSUsrMsg_VoteStart.prototype.otherTeamStr = \"\";\n    /**\n     * CCSUsrMsg_VoteStart isYesNoVote.\n     * @member {boolean} isYesNoVote\n     * @memberof CCSUsrMsg_VoteStart\n     * @instance\n     */\n    CCSUsrMsg_VoteStart.prototype.isYesNoVote = false;\n    /**\n     * Decodes a CCSUsrMsg_VoteStart message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_VoteStart\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_VoteStart} CCSUsrMsg_VoteStart\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_VoteStart.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_VoteStart();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.team = reader.int32();\n                    break;\n                case 2:\n                    message.entIdx = reader.int32();\n                    break;\n                case 3:\n                    message.voteType = reader.int32();\n                    break;\n                case 4:\n                    message.dispStr = reader.string();\n                    break;\n                case 5:\n                    message.detailsStr = reader.string();\n                    break;\n                case 6:\n                    message.otherTeamStr = reader.string();\n                    break;\n                case 7:\n                    message.isYesNoVote = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_VoteStart;\n})());\nexports.CCSUsrMsg_VotePass = ($root.CCSUsrMsg_VotePass = (() => {\n    /**\n     * Properties of a CCSUsrMsg_VotePass.\n     * @exports ICCSUsrMsg_VotePass\n     * @interface ICCSUsrMsg_VotePass\n     * @property {number|null} [team] CCSUsrMsg_VotePass team\n     * @property {number|null} [voteType] CCSUsrMsg_VotePass voteType\n     * @property {string|null} [dispStr] CCSUsrMsg_VotePass dispStr\n     * @property {string|null} [detailsStr] CCSUsrMsg_VotePass detailsStr\n     */\n    /**\n     * Constructs a new CCSUsrMsg_VotePass.\n     * @exports CCSUsrMsg_VotePass\n     * @classdesc Represents a CCSUsrMsg_VotePass.\n     * @implements ICCSUsrMsg_VotePass\n     * @constructor\n     * @param {ICCSUsrMsg_VotePass=} [properties] Properties to set\n     */\n    function CCSUsrMsg_VotePass(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_VotePass team.\n     * @member {number} team\n     * @memberof CCSUsrMsg_VotePass\n     * @instance\n     */\n    CCSUsrMsg_VotePass.prototype.team = 0;\n    /**\n     * CCSUsrMsg_VotePass voteType.\n     * @member {number} voteType\n     * @memberof CCSUsrMsg_VotePass\n     * @instance\n     */\n    CCSUsrMsg_VotePass.prototype.voteType = 0;\n    /**\n     * CCSUsrMsg_VotePass dispStr.\n     * @member {string} dispStr\n     * @memberof CCSUsrMsg_VotePass\n     * @instance\n     */\n    CCSUsrMsg_VotePass.prototype.dispStr = \"\";\n    /**\n     * CCSUsrMsg_VotePass detailsStr.\n     * @member {string} detailsStr\n     * @memberof CCSUsrMsg_VotePass\n     * @instance\n     */\n    CCSUsrMsg_VotePass.prototype.detailsStr = \"\";\n    /**\n     * Decodes a CCSUsrMsg_VotePass message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_VotePass\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_VotePass} CCSUsrMsg_VotePass\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_VotePass.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_VotePass();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.team = reader.int32();\n                    break;\n                case 2:\n                    message.voteType = reader.int32();\n                    break;\n                case 3:\n                    message.dispStr = reader.string();\n                    break;\n                case 4:\n                    message.detailsStr = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_VotePass;\n})());\nexports.CCSUsrMsg_VoteFailed = ($root.CCSUsrMsg_VoteFailed = (() => {\n    /**\n     * Properties of a CCSUsrMsg_VoteFailed.\n     * @exports ICCSUsrMsg_VoteFailed\n     * @interface ICCSUsrMsg_VoteFailed\n     * @property {number|null} [team] CCSUsrMsg_VoteFailed team\n     * @property {number|null} [reason] CCSUsrMsg_VoteFailed reason\n     */\n    /**\n     * Constructs a new CCSUsrMsg_VoteFailed.\n     * @exports CCSUsrMsg_VoteFailed\n     * @classdesc Represents a CCSUsrMsg_VoteFailed.\n     * @implements ICCSUsrMsg_VoteFailed\n     * @constructor\n     * @param {ICCSUsrMsg_VoteFailed=} [properties] Properties to set\n     */\n    function CCSUsrMsg_VoteFailed(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_VoteFailed team.\n     * @member {number} team\n     * @memberof CCSUsrMsg_VoteFailed\n     * @instance\n     */\n    CCSUsrMsg_VoteFailed.prototype.team = 0;\n    /**\n     * CCSUsrMsg_VoteFailed reason.\n     * @member {number} reason\n     * @memberof CCSUsrMsg_VoteFailed\n     * @instance\n     */\n    CCSUsrMsg_VoteFailed.prototype.reason = 0;\n    /**\n     * Decodes a CCSUsrMsg_VoteFailed message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_VoteFailed\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_VoteFailed} CCSUsrMsg_VoteFailed\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_VoteFailed.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_VoteFailed();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.team = reader.int32();\n                    break;\n                case 2:\n                    message.reason = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_VoteFailed;\n})());\nexports.CCSUsrMsg_VoteSetup = ($root.CCSUsrMsg_VoteSetup = (() => {\n    /**\n     * Properties of a CCSUsrMsg_VoteSetup.\n     * @exports ICCSUsrMsg_VoteSetup\n     * @interface ICCSUsrMsg_VoteSetup\n     * @property {Array.<string>|null} [potentialIssues] CCSUsrMsg_VoteSetup potentialIssues\n     */\n    /**\n     * Constructs a new CCSUsrMsg_VoteSetup.\n     * @exports CCSUsrMsg_VoteSetup\n     * @classdesc Represents a CCSUsrMsg_VoteSetup.\n     * @implements ICCSUsrMsg_VoteSetup\n     * @constructor\n     * @param {ICCSUsrMsg_VoteSetup=} [properties] Properties to set\n     */\n    function CCSUsrMsg_VoteSetup(properties) {\n        this.potentialIssues = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_VoteSetup potentialIssues.\n     * @member {Array.<string>} potentialIssues\n     * @memberof CCSUsrMsg_VoteSetup\n     * @instance\n     */\n    CCSUsrMsg_VoteSetup.prototype.potentialIssues = $util.emptyArray;\n    /**\n     * Decodes a CCSUsrMsg_VoteSetup message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_VoteSetup\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_VoteSetup} CCSUsrMsg_VoteSetup\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_VoteSetup.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_VoteSetup();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.potentialIssues && message.potentialIssues.length))\n                        message.potentialIssues = [];\n                    message.potentialIssues.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_VoteSetup;\n})());\nexports.CCSUsrMsg_SendLastKillerDamageToClient = ($root.CCSUsrMsg_SendLastKillerDamageToClient = (() => {\n    /**\n     * Properties of a CCSUsrMsg_SendLastKillerDamageToClient.\n     * @exports ICCSUsrMsg_SendLastKillerDamageToClient\n     * @interface ICCSUsrMsg_SendLastKillerDamageToClient\n     * @property {number|null} [numHitsGiven] CCSUsrMsg_SendLastKillerDamageToClient numHitsGiven\n     * @property {number|null} [damageGiven] CCSUsrMsg_SendLastKillerDamageToClient damageGiven\n     * @property {number|null} [numHitsTaken] CCSUsrMsg_SendLastKillerDamageToClient numHitsTaken\n     * @property {number|null} [damageTaken] CCSUsrMsg_SendLastKillerDamageToClient damageTaken\n     */\n    /**\n     * Constructs a new CCSUsrMsg_SendLastKillerDamageToClient.\n     * @exports CCSUsrMsg_SendLastKillerDamageToClient\n     * @classdesc Represents a CCSUsrMsg_SendLastKillerDamageToClient.\n     * @implements ICCSUsrMsg_SendLastKillerDamageToClient\n     * @constructor\n     * @param {ICCSUsrMsg_SendLastKillerDamageToClient=} [properties] Properties to set\n     */\n    function CCSUsrMsg_SendLastKillerDamageToClient(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_SendLastKillerDamageToClient numHitsGiven.\n     * @member {number} numHitsGiven\n     * @memberof CCSUsrMsg_SendLastKillerDamageToClient\n     * @instance\n     */\n    CCSUsrMsg_SendLastKillerDamageToClient.prototype.numHitsGiven = 0;\n    /**\n     * CCSUsrMsg_SendLastKillerDamageToClient damageGiven.\n     * @member {number} damageGiven\n     * @memberof CCSUsrMsg_SendLastKillerDamageToClient\n     * @instance\n     */\n    CCSUsrMsg_SendLastKillerDamageToClient.prototype.damageGiven = 0;\n    /**\n     * CCSUsrMsg_SendLastKillerDamageToClient numHitsTaken.\n     * @member {number} numHitsTaken\n     * @memberof CCSUsrMsg_SendLastKillerDamageToClient\n     * @instance\n     */\n    CCSUsrMsg_SendLastKillerDamageToClient.prototype.numHitsTaken = 0;\n    /**\n     * CCSUsrMsg_SendLastKillerDamageToClient damageTaken.\n     * @member {number} damageTaken\n     * @memberof CCSUsrMsg_SendLastKillerDamageToClient\n     * @instance\n     */\n    CCSUsrMsg_SendLastKillerDamageToClient.prototype.damageTaken = 0;\n    /**\n     * Decodes a CCSUsrMsg_SendLastKillerDamageToClient message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_SendLastKillerDamageToClient\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_SendLastKillerDamageToClient} CCSUsrMsg_SendLastKillerDamageToClient\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_SendLastKillerDamageToClient.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_SendLastKillerDamageToClient();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.numHitsGiven = reader.int32();\n                    break;\n                case 2:\n                    message.damageGiven = reader.int32();\n                    break;\n                case 3:\n                    message.numHitsTaken = reader.int32();\n                    break;\n                case 4:\n                    message.damageTaken = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_SendLastKillerDamageToClient;\n})());\nexports.CCSUsrMsg_ServerRankUpdate = ($root.CCSUsrMsg_ServerRankUpdate = (() => {\n    /**\n     * Properties of a CCSUsrMsg_ServerRankUpdate.\n     * @exports ICCSUsrMsg_ServerRankUpdate\n     * @interface ICCSUsrMsg_ServerRankUpdate\n     * @property {Array.<CCSUsrMsg_ServerRankUpdate.IRankUpdate>|null} [rankUpdate] CCSUsrMsg_ServerRankUpdate rankUpdate\n     */\n    /**\n     * Constructs a new CCSUsrMsg_ServerRankUpdate.\n     * @exports CCSUsrMsg_ServerRankUpdate\n     * @classdesc Represents a CCSUsrMsg_ServerRankUpdate.\n     * @implements ICCSUsrMsg_ServerRankUpdate\n     * @constructor\n     * @param {ICCSUsrMsg_ServerRankUpdate=} [properties] Properties to set\n     */\n    function CCSUsrMsg_ServerRankUpdate(properties) {\n        this.rankUpdate = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_ServerRankUpdate rankUpdate.\n     * @member {Array.<CCSUsrMsg_ServerRankUpdate.IRankUpdate>} rankUpdate\n     * @memberof CCSUsrMsg_ServerRankUpdate\n     * @instance\n     */\n    CCSUsrMsg_ServerRankUpdate.prototype.rankUpdate = $util.emptyArray;\n    /**\n     * Decodes a CCSUsrMsg_ServerRankUpdate message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_ServerRankUpdate\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_ServerRankUpdate} CCSUsrMsg_ServerRankUpdate\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_ServerRankUpdate.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ServerRankUpdate();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.rankUpdate && message.rankUpdate.length))\n                        message.rankUpdate = [];\n                    message.rankUpdate.push($root.CCSUsrMsg_ServerRankUpdate.RankUpdate.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CCSUsrMsg_ServerRankUpdate.RankUpdate = (function () {\n        /**\n         * Properties of a RankUpdate.\n         * @memberof CCSUsrMsg_ServerRankUpdate\n         * @interface IRankUpdate\n         * @property {number|null} [accountId] RankUpdate accountId\n         * @property {number|null} [rankOld] RankUpdate rankOld\n         * @property {number|null} [rankNew] RankUpdate rankNew\n         * @property {number|null} [numWins] RankUpdate numWins\n         * @property {number|null} [rankChange] RankUpdate rankChange\n         */\n        /**\n         * Constructs a new RankUpdate.\n         * @memberof CCSUsrMsg_ServerRankUpdate\n         * @classdesc Represents a RankUpdate.\n         * @implements IRankUpdate\n         * @constructor\n         * @param {CCSUsrMsg_ServerRankUpdate.IRankUpdate=} [properties] Properties to set\n         */\n        function RankUpdate(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * RankUpdate accountId.\n         * @member {number} accountId\n         * @memberof CCSUsrMsg_ServerRankUpdate.RankUpdate\n         * @instance\n         */\n        RankUpdate.prototype.accountId = 0;\n        /**\n         * RankUpdate rankOld.\n         * @member {number} rankOld\n         * @memberof CCSUsrMsg_ServerRankUpdate.RankUpdate\n         * @instance\n         */\n        RankUpdate.prototype.rankOld = 0;\n        /**\n         * RankUpdate rankNew.\n         * @member {number} rankNew\n         * @memberof CCSUsrMsg_ServerRankUpdate.RankUpdate\n         * @instance\n         */\n        RankUpdate.prototype.rankNew = 0;\n        /**\n         * RankUpdate numWins.\n         * @member {number} numWins\n         * @memberof CCSUsrMsg_ServerRankUpdate.RankUpdate\n         * @instance\n         */\n        RankUpdate.prototype.numWins = 0;\n        /**\n         * RankUpdate rankChange.\n         * @member {number} rankChange\n         * @memberof CCSUsrMsg_ServerRankUpdate.RankUpdate\n         * @instance\n         */\n        RankUpdate.prototype.rankChange = 0;\n        /**\n         * Decodes a RankUpdate message from the specified reader or buffer.\n         * @function decode\n         * @memberof CCSUsrMsg_ServerRankUpdate.RankUpdate\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CCSUsrMsg_ServerRankUpdate.RankUpdate} RankUpdate\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        RankUpdate.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ServerRankUpdate.RankUpdate();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.accountId = reader.int32();\n                        break;\n                    case 2:\n                        message.rankOld = reader.int32();\n                        break;\n                    case 3:\n                        message.rankNew = reader.int32();\n                        break;\n                    case 4:\n                        message.numWins = reader.int32();\n                        break;\n                    case 5:\n                        message.rankChange = reader.float();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return RankUpdate;\n    })();\n    return CCSUsrMsg_ServerRankUpdate;\n})());\nexports.CCSUsrMsg_XpUpdate = ($root.CCSUsrMsg_XpUpdate = (() => {\n    /**\n     * Properties of a CCSUsrMsg_XpUpdate.\n     * @exports ICCSUsrMsg_XpUpdate\n     * @interface ICCSUsrMsg_XpUpdate\n     * @property {ICMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded|null} [data] CCSUsrMsg_XpUpdate data\n     */\n    /**\n     * Constructs a new CCSUsrMsg_XpUpdate.\n     * @exports CCSUsrMsg_XpUpdate\n     * @classdesc Represents a CCSUsrMsg_XpUpdate.\n     * @implements ICCSUsrMsg_XpUpdate\n     * @constructor\n     * @param {ICCSUsrMsg_XpUpdate=} [properties] Properties to set\n     */\n    function CCSUsrMsg_XpUpdate(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_XpUpdate data.\n     * @member {ICMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded|null|undefined} data\n     * @memberof CCSUsrMsg_XpUpdate\n     * @instance\n     */\n    CCSUsrMsg_XpUpdate.prototype.data = null;\n    /**\n     * Decodes a CCSUsrMsg_XpUpdate message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_XpUpdate\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_XpUpdate} CCSUsrMsg_XpUpdate\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_XpUpdate.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_XpUpdate();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.data = $root.CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_XpUpdate;\n})());\nexports.CCSUsrMsg_ItemPickup = ($root.CCSUsrMsg_ItemPickup = (() => {\n    /**\n     * Properties of a CCSUsrMsg_ItemPickup.\n     * @exports ICCSUsrMsg_ItemPickup\n     * @interface ICCSUsrMsg_ItemPickup\n     * @property {string|null} [item] CCSUsrMsg_ItemPickup item\n     */\n    /**\n     * Constructs a new CCSUsrMsg_ItemPickup.\n     * @exports CCSUsrMsg_ItemPickup\n     * @classdesc Represents a CCSUsrMsg_ItemPickup.\n     * @implements ICCSUsrMsg_ItemPickup\n     * @constructor\n     * @param {ICCSUsrMsg_ItemPickup=} [properties] Properties to set\n     */\n    function CCSUsrMsg_ItemPickup(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_ItemPickup item.\n     * @member {string} item\n     * @memberof CCSUsrMsg_ItemPickup\n     * @instance\n     */\n    CCSUsrMsg_ItemPickup.prototype.item = \"\";\n    /**\n     * Decodes a CCSUsrMsg_ItemPickup message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_ItemPickup\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_ItemPickup} CCSUsrMsg_ItemPickup\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_ItemPickup.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ItemPickup();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.item = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_ItemPickup;\n})());\nexports.CCSUsrMsg_ShowMenu = ($root.CCSUsrMsg_ShowMenu = (() => {\n    /**\n     * Properties of a CCSUsrMsg_ShowMenu.\n     * @exports ICCSUsrMsg_ShowMenu\n     * @interface ICCSUsrMsg_ShowMenu\n     * @property {number|null} [bitsValidSlots] CCSUsrMsg_ShowMenu bitsValidSlots\n     * @property {number|null} [displayTime] CCSUsrMsg_ShowMenu displayTime\n     * @property {string|null} [menuString] CCSUsrMsg_ShowMenu menuString\n     */\n    /**\n     * Constructs a new CCSUsrMsg_ShowMenu.\n     * @exports CCSUsrMsg_ShowMenu\n     * @classdesc Represents a CCSUsrMsg_ShowMenu.\n     * @implements ICCSUsrMsg_ShowMenu\n     * @constructor\n     * @param {ICCSUsrMsg_ShowMenu=} [properties] Properties to set\n     */\n    function CCSUsrMsg_ShowMenu(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_ShowMenu bitsValidSlots.\n     * @member {number} bitsValidSlots\n     * @memberof CCSUsrMsg_ShowMenu\n     * @instance\n     */\n    CCSUsrMsg_ShowMenu.prototype.bitsValidSlots = 0;\n    /**\n     * CCSUsrMsg_ShowMenu displayTime.\n     * @member {number} displayTime\n     * @memberof CCSUsrMsg_ShowMenu\n     * @instance\n     */\n    CCSUsrMsg_ShowMenu.prototype.displayTime = 0;\n    /**\n     * CCSUsrMsg_ShowMenu menuString.\n     * @member {string} menuString\n     * @memberof CCSUsrMsg_ShowMenu\n     * @instance\n     */\n    CCSUsrMsg_ShowMenu.prototype.menuString = \"\";\n    /**\n     * Decodes a CCSUsrMsg_ShowMenu message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_ShowMenu\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_ShowMenu} CCSUsrMsg_ShowMenu\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_ShowMenu.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ShowMenu();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bitsValidSlots = reader.int32();\n                    break;\n                case 2:\n                    message.displayTime = reader.int32();\n                    break;\n                case 3:\n                    message.menuString = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_ShowMenu;\n})());\nexports.CCSUsrMsg_BarTime = ($root.CCSUsrMsg_BarTime = (() => {\n    /**\n     * Properties of a CCSUsrMsg_BarTime.\n     * @exports ICCSUsrMsg_BarTime\n     * @interface ICCSUsrMsg_BarTime\n     * @property {string|null} [time] CCSUsrMsg_BarTime time\n     */\n    /**\n     * Constructs a new CCSUsrMsg_BarTime.\n     * @exports CCSUsrMsg_BarTime\n     * @classdesc Represents a CCSUsrMsg_BarTime.\n     * @implements ICCSUsrMsg_BarTime\n     * @constructor\n     * @param {ICCSUsrMsg_BarTime=} [properties] Properties to set\n     */\n    function CCSUsrMsg_BarTime(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_BarTime time.\n     * @member {string} time\n     * @memberof CCSUsrMsg_BarTime\n     * @instance\n     */\n    CCSUsrMsg_BarTime.prototype.time = \"\";\n    /**\n     * Decodes a CCSUsrMsg_BarTime message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_BarTime\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_BarTime} CCSUsrMsg_BarTime\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_BarTime.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_BarTime();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.time = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_BarTime;\n})());\nexports.CCSUsrMsg_AmmoDenied = ($root.CCSUsrMsg_AmmoDenied = (() => {\n    /**\n     * Properties of a CCSUsrMsg_AmmoDenied.\n     * @exports ICCSUsrMsg_AmmoDenied\n     * @interface ICCSUsrMsg_AmmoDenied\n     * @property {number|null} [ammoIdx] CCSUsrMsg_AmmoDenied ammoIdx\n     */\n    /**\n     * Constructs a new CCSUsrMsg_AmmoDenied.\n     * @exports CCSUsrMsg_AmmoDenied\n     * @classdesc Represents a CCSUsrMsg_AmmoDenied.\n     * @implements ICCSUsrMsg_AmmoDenied\n     * @constructor\n     * @param {ICCSUsrMsg_AmmoDenied=} [properties] Properties to set\n     */\n    function CCSUsrMsg_AmmoDenied(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_AmmoDenied ammoIdx.\n     * @member {number} ammoIdx\n     * @memberof CCSUsrMsg_AmmoDenied\n     * @instance\n     */\n    CCSUsrMsg_AmmoDenied.prototype.ammoIdx = 0;\n    /**\n     * Decodes a CCSUsrMsg_AmmoDenied message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_AmmoDenied\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_AmmoDenied} CCSUsrMsg_AmmoDenied\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_AmmoDenied.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_AmmoDenied();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.ammoIdx = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_AmmoDenied;\n})());\nexports.CCSUsrMsg_MarkAchievement = ($root.CCSUsrMsg_MarkAchievement = (() => {\n    /**\n     * Properties of a CCSUsrMsg_MarkAchievement.\n     * @exports ICCSUsrMsg_MarkAchievement\n     * @interface ICCSUsrMsg_MarkAchievement\n     * @property {string|null} [achievement] CCSUsrMsg_MarkAchievement achievement\n     */\n    /**\n     * Constructs a new CCSUsrMsg_MarkAchievement.\n     * @exports CCSUsrMsg_MarkAchievement\n     * @classdesc Represents a CCSUsrMsg_MarkAchievement.\n     * @implements ICCSUsrMsg_MarkAchievement\n     * @constructor\n     * @param {ICCSUsrMsg_MarkAchievement=} [properties] Properties to set\n     */\n    function CCSUsrMsg_MarkAchievement(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_MarkAchievement achievement.\n     * @member {string} achievement\n     * @memberof CCSUsrMsg_MarkAchievement\n     * @instance\n     */\n    CCSUsrMsg_MarkAchievement.prototype.achievement = \"\";\n    /**\n     * Decodes a CCSUsrMsg_MarkAchievement message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_MarkAchievement\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_MarkAchievement} CCSUsrMsg_MarkAchievement\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_MarkAchievement.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_MarkAchievement();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.achievement = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_MarkAchievement;\n})());\nexports.CCSUsrMsg_MatchStatsUpdate = ($root.CCSUsrMsg_MatchStatsUpdate = (() => {\n    /**\n     * Properties of a CCSUsrMsg_MatchStatsUpdate.\n     * @exports ICCSUsrMsg_MatchStatsUpdate\n     * @interface ICCSUsrMsg_MatchStatsUpdate\n     * @property {string|null} [update] CCSUsrMsg_MatchStatsUpdate update\n     */\n    /**\n     * Constructs a new CCSUsrMsg_MatchStatsUpdate.\n     * @exports CCSUsrMsg_MatchStatsUpdate\n     * @classdesc Represents a CCSUsrMsg_MatchStatsUpdate.\n     * @implements ICCSUsrMsg_MatchStatsUpdate\n     * @constructor\n     * @param {ICCSUsrMsg_MatchStatsUpdate=} [properties] Properties to set\n     */\n    function CCSUsrMsg_MatchStatsUpdate(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_MatchStatsUpdate update.\n     * @member {string} update\n     * @memberof CCSUsrMsg_MatchStatsUpdate\n     * @instance\n     */\n    CCSUsrMsg_MatchStatsUpdate.prototype.update = \"\";\n    /**\n     * Decodes a CCSUsrMsg_MatchStatsUpdate message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_MatchStatsUpdate\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_MatchStatsUpdate} CCSUsrMsg_MatchStatsUpdate\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_MatchStatsUpdate.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_MatchStatsUpdate();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.update = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_MatchStatsUpdate;\n})());\nexports.CCSUsrMsg_ItemDrop = ($root.CCSUsrMsg_ItemDrop = (() => {\n    /**\n     * Properties of a CCSUsrMsg_ItemDrop.\n     * @exports ICCSUsrMsg_ItemDrop\n     * @interface ICCSUsrMsg_ItemDrop\n     * @property {number|Long|null} [itemid] CCSUsrMsg_ItemDrop itemid\n     * @property {boolean|null} [death] CCSUsrMsg_ItemDrop death\n     */\n    /**\n     * Constructs a new CCSUsrMsg_ItemDrop.\n     * @exports CCSUsrMsg_ItemDrop\n     * @classdesc Represents a CCSUsrMsg_ItemDrop.\n     * @implements ICCSUsrMsg_ItemDrop\n     * @constructor\n     * @param {ICCSUsrMsg_ItemDrop=} [properties] Properties to set\n     */\n    function CCSUsrMsg_ItemDrop(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_ItemDrop itemid.\n     * @member {number|Long} itemid\n     * @memberof CCSUsrMsg_ItemDrop\n     * @instance\n     */\n    CCSUsrMsg_ItemDrop.prototype.itemid = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0;\n    /**\n     * CCSUsrMsg_ItemDrop death.\n     * @member {boolean} death\n     * @memberof CCSUsrMsg_ItemDrop\n     * @instance\n     */\n    CCSUsrMsg_ItemDrop.prototype.death = false;\n    /**\n     * Decodes a CCSUsrMsg_ItemDrop message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_ItemDrop\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_ItemDrop} CCSUsrMsg_ItemDrop\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_ItemDrop.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ItemDrop();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.itemid = reader.int64();\n                    break;\n                case 2:\n                    message.death = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_ItemDrop;\n})());\nexports.CCSUsrMsg_GlowPropTurnOff = ($root.CCSUsrMsg_GlowPropTurnOff = (() => {\n    /**\n     * Properties of a CCSUsrMsg_GlowPropTurnOff.\n     * @exports ICCSUsrMsg_GlowPropTurnOff\n     * @interface ICCSUsrMsg_GlowPropTurnOff\n     * @property {number|null} [entidx] CCSUsrMsg_GlowPropTurnOff entidx\n     */\n    /**\n     * Constructs a new CCSUsrMsg_GlowPropTurnOff.\n     * @exports CCSUsrMsg_GlowPropTurnOff\n     * @classdesc Represents a CCSUsrMsg_GlowPropTurnOff.\n     * @implements ICCSUsrMsg_GlowPropTurnOff\n     * @constructor\n     * @param {ICCSUsrMsg_GlowPropTurnOff=} [properties] Properties to set\n     */\n    function CCSUsrMsg_GlowPropTurnOff(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_GlowPropTurnOff entidx.\n     * @member {number} entidx\n     * @memberof CCSUsrMsg_GlowPropTurnOff\n     * @instance\n     */\n    CCSUsrMsg_GlowPropTurnOff.prototype.entidx = 0;\n    /**\n     * Decodes a CCSUsrMsg_GlowPropTurnOff message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_GlowPropTurnOff\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_GlowPropTurnOff} CCSUsrMsg_GlowPropTurnOff\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_GlowPropTurnOff.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_GlowPropTurnOff();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.entidx = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_GlowPropTurnOff;\n})());\nexports.CCSUsrMsg_RoundBackupFilenames = ($root.CCSUsrMsg_RoundBackupFilenames = (() => {\n    /**\n     * Properties of a CCSUsrMsg_RoundBackupFilenames.\n     * @exports ICCSUsrMsg_RoundBackupFilenames\n     * @interface ICCSUsrMsg_RoundBackupFilenames\n     * @property {number|null} [count] CCSUsrMsg_RoundBackupFilenames count\n     * @property {number|null} [index] CCSUsrMsg_RoundBackupFilenames index\n     * @property {string|null} [filename] CCSUsrMsg_RoundBackupFilenames filename\n     * @property {string|null} [nicename] CCSUsrMsg_RoundBackupFilenames nicename\n     */\n    /**\n     * Constructs a new CCSUsrMsg_RoundBackupFilenames.\n     * @exports CCSUsrMsg_RoundBackupFilenames\n     * @classdesc Represents a CCSUsrMsg_RoundBackupFilenames.\n     * @implements ICCSUsrMsg_RoundBackupFilenames\n     * @constructor\n     * @param {ICCSUsrMsg_RoundBackupFilenames=} [properties] Properties to set\n     */\n    function CCSUsrMsg_RoundBackupFilenames(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_RoundBackupFilenames count.\n     * @member {number} count\n     * @memberof CCSUsrMsg_RoundBackupFilenames\n     * @instance\n     */\n    CCSUsrMsg_RoundBackupFilenames.prototype.count = 0;\n    /**\n     * CCSUsrMsg_RoundBackupFilenames index.\n     * @member {number} index\n     * @memberof CCSUsrMsg_RoundBackupFilenames\n     * @instance\n     */\n    CCSUsrMsg_RoundBackupFilenames.prototype.index = 0;\n    /**\n     * CCSUsrMsg_RoundBackupFilenames filename.\n     * @member {string} filename\n     * @memberof CCSUsrMsg_RoundBackupFilenames\n     * @instance\n     */\n    CCSUsrMsg_RoundBackupFilenames.prototype.filename = \"\";\n    /**\n     * CCSUsrMsg_RoundBackupFilenames nicename.\n     * @member {string} nicename\n     * @memberof CCSUsrMsg_RoundBackupFilenames\n     * @instance\n     */\n    CCSUsrMsg_RoundBackupFilenames.prototype.nicename = \"\";\n    /**\n     * Decodes a CCSUsrMsg_RoundBackupFilenames message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_RoundBackupFilenames\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_RoundBackupFilenames} CCSUsrMsg_RoundBackupFilenames\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_RoundBackupFilenames.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_RoundBackupFilenames();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.count = reader.int32();\n                    break;\n                case 2:\n                    message.index = reader.int32();\n                    break;\n                case 3:\n                    message.filename = reader.string();\n                    break;\n                case 4:\n                    message.nicename = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_RoundBackupFilenames;\n})());\nexports.CCSUsrMsg_ResetHud = ($root.CCSUsrMsg_ResetHud = (() => {\n    /**\n     * Properties of a CCSUsrMsg_ResetHud.\n     * @exports ICCSUsrMsg_ResetHud\n     * @interface ICCSUsrMsg_ResetHud\n     * @property {boolean|null} [reset] CCSUsrMsg_ResetHud reset\n     */\n    /**\n     * Constructs a new CCSUsrMsg_ResetHud.\n     * @exports CCSUsrMsg_ResetHud\n     * @classdesc Represents a CCSUsrMsg_ResetHud.\n     * @implements ICCSUsrMsg_ResetHud\n     * @constructor\n     * @param {ICCSUsrMsg_ResetHud=} [properties] Properties to set\n     */\n    function CCSUsrMsg_ResetHud(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_ResetHud reset.\n     * @member {boolean} reset\n     * @memberof CCSUsrMsg_ResetHud\n     * @instance\n     */\n    CCSUsrMsg_ResetHud.prototype.reset = false;\n    /**\n     * Decodes a CCSUsrMsg_ResetHud message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_ResetHud\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_ResetHud} CCSUsrMsg_ResetHud\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_ResetHud.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ResetHud();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.reset = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_ResetHud;\n})());\nexports.CCSUsrMsg_GameTitle = ($root.CCSUsrMsg_GameTitle = (() => {\n    /**\n     * Properties of a CCSUsrMsg_GameTitle.\n     * @exports ICCSUsrMsg_GameTitle\n     * @interface ICCSUsrMsg_GameTitle\n     * @property {number|null} [dummy] CCSUsrMsg_GameTitle dummy\n     */\n    /**\n     * Constructs a new CCSUsrMsg_GameTitle.\n     * @exports CCSUsrMsg_GameTitle\n     * @classdesc Represents a CCSUsrMsg_GameTitle.\n     * @implements ICCSUsrMsg_GameTitle\n     * @constructor\n     * @param {ICCSUsrMsg_GameTitle=} [properties] Properties to set\n     */\n    function CCSUsrMsg_GameTitle(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_GameTitle dummy.\n     * @member {number} dummy\n     * @memberof CCSUsrMsg_GameTitle\n     * @instance\n     */\n    CCSUsrMsg_GameTitle.prototype.dummy = 0;\n    /**\n     * Decodes a CCSUsrMsg_GameTitle message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_GameTitle\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_GameTitle} CCSUsrMsg_GameTitle\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_GameTitle.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_GameTitle();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.dummy = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_GameTitle;\n})());\nexports.CCSUsrMsg_RequestState = ($root.CCSUsrMsg_RequestState = (() => {\n    /**\n     * Properties of a CCSUsrMsg_RequestState.\n     * @exports ICCSUsrMsg_RequestState\n     * @interface ICCSUsrMsg_RequestState\n     * @property {number|null} [dummy] CCSUsrMsg_RequestState dummy\n     */\n    /**\n     * Constructs a new CCSUsrMsg_RequestState.\n     * @exports CCSUsrMsg_RequestState\n     * @classdesc Represents a CCSUsrMsg_RequestState.\n     * @implements ICCSUsrMsg_RequestState\n     * @constructor\n     * @param {ICCSUsrMsg_RequestState=} [properties] Properties to set\n     */\n    function CCSUsrMsg_RequestState(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_RequestState dummy.\n     * @member {number} dummy\n     * @memberof CCSUsrMsg_RequestState\n     * @instance\n     */\n    CCSUsrMsg_RequestState.prototype.dummy = 0;\n    /**\n     * Decodes a CCSUsrMsg_RequestState message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_RequestState\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_RequestState} CCSUsrMsg_RequestState\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_RequestState.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_RequestState();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.dummy = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_RequestState;\n})());\nexports.CCSUsrMsg_StopSpectatorMode = ($root.CCSUsrMsg_StopSpectatorMode = (() => {\n    /**\n     * Properties of a CCSUsrMsg_StopSpectatorMode.\n     * @exports ICCSUsrMsg_StopSpectatorMode\n     * @interface ICCSUsrMsg_StopSpectatorMode\n     * @property {number|null} [dummy] CCSUsrMsg_StopSpectatorMode dummy\n     */\n    /**\n     * Constructs a new CCSUsrMsg_StopSpectatorMode.\n     * @exports CCSUsrMsg_StopSpectatorMode\n     * @classdesc Represents a CCSUsrMsg_StopSpectatorMode.\n     * @implements ICCSUsrMsg_StopSpectatorMode\n     * @constructor\n     * @param {ICCSUsrMsg_StopSpectatorMode=} [properties] Properties to set\n     */\n    function CCSUsrMsg_StopSpectatorMode(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_StopSpectatorMode dummy.\n     * @member {number} dummy\n     * @memberof CCSUsrMsg_StopSpectatorMode\n     * @instance\n     */\n    CCSUsrMsg_StopSpectatorMode.prototype.dummy = 0;\n    /**\n     * Decodes a CCSUsrMsg_StopSpectatorMode message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_StopSpectatorMode\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_StopSpectatorMode} CCSUsrMsg_StopSpectatorMode\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_StopSpectatorMode.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_StopSpectatorMode();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.dummy = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_StopSpectatorMode;\n})());\nexports.CCSUsrMsg_DisconnectToLobby = ($root.CCSUsrMsg_DisconnectToLobby = (() => {\n    /**\n     * Properties of a CCSUsrMsg_DisconnectToLobby.\n     * @exports ICCSUsrMsg_DisconnectToLobby\n     * @interface ICCSUsrMsg_DisconnectToLobby\n     * @property {number|null} [dummy] CCSUsrMsg_DisconnectToLobby dummy\n     */\n    /**\n     * Constructs a new CCSUsrMsg_DisconnectToLobby.\n     * @exports CCSUsrMsg_DisconnectToLobby\n     * @classdesc Represents a CCSUsrMsg_DisconnectToLobby.\n     * @implements ICCSUsrMsg_DisconnectToLobby\n     * @constructor\n     * @param {ICCSUsrMsg_DisconnectToLobby=} [properties] Properties to set\n     */\n    function CCSUsrMsg_DisconnectToLobby(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_DisconnectToLobby dummy.\n     * @member {number} dummy\n     * @memberof CCSUsrMsg_DisconnectToLobby\n     * @instance\n     */\n    CCSUsrMsg_DisconnectToLobby.prototype.dummy = 0;\n    /**\n     * Decodes a CCSUsrMsg_DisconnectToLobby message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_DisconnectToLobby\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_DisconnectToLobby} CCSUsrMsg_DisconnectToLobby\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_DisconnectToLobby.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_DisconnectToLobby();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.dummy = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_DisconnectToLobby;\n})());\nexports.CCSUsrMsg_WarmupHasEnded = ($root.CCSUsrMsg_WarmupHasEnded = (() => {\n    /**\n     * Properties of a CCSUsrMsg_WarmupHasEnded.\n     * @exports ICCSUsrMsg_WarmupHasEnded\n     * @interface ICCSUsrMsg_WarmupHasEnded\n     * @property {number|null} [dummy] CCSUsrMsg_WarmupHasEnded dummy\n     */\n    /**\n     * Constructs a new CCSUsrMsg_WarmupHasEnded.\n     * @exports CCSUsrMsg_WarmupHasEnded\n     * @classdesc Represents a CCSUsrMsg_WarmupHasEnded.\n     * @implements ICCSUsrMsg_WarmupHasEnded\n     * @constructor\n     * @param {ICCSUsrMsg_WarmupHasEnded=} [properties] Properties to set\n     */\n    function CCSUsrMsg_WarmupHasEnded(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_WarmupHasEnded dummy.\n     * @member {number} dummy\n     * @memberof CCSUsrMsg_WarmupHasEnded\n     * @instance\n     */\n    CCSUsrMsg_WarmupHasEnded.prototype.dummy = 0;\n    /**\n     * Decodes a CCSUsrMsg_WarmupHasEnded message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_WarmupHasEnded\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_WarmupHasEnded} CCSUsrMsg_WarmupHasEnded\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_WarmupHasEnded.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_WarmupHasEnded();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.dummy = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_WarmupHasEnded;\n})());\nexports.CCSUsrMsg_ClientInfo = ($root.CCSUsrMsg_ClientInfo = (() => {\n    /**\n     * Properties of a CCSUsrMsg_ClientInfo.\n     * @exports ICCSUsrMsg_ClientInfo\n     * @interface ICCSUsrMsg_ClientInfo\n     * @property {number|null} [dummy] CCSUsrMsg_ClientInfo dummy\n     */\n    /**\n     * Constructs a new CCSUsrMsg_ClientInfo.\n     * @exports CCSUsrMsg_ClientInfo\n     * @classdesc Represents a CCSUsrMsg_ClientInfo.\n     * @implements ICCSUsrMsg_ClientInfo\n     * @constructor\n     * @param {ICCSUsrMsg_ClientInfo=} [properties] Properties to set\n     */\n    function CCSUsrMsg_ClientInfo(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_ClientInfo dummy.\n     * @member {number} dummy\n     * @memberof CCSUsrMsg_ClientInfo\n     * @instance\n     */\n    CCSUsrMsg_ClientInfo.prototype.dummy = 0;\n    /**\n     * Decodes a CCSUsrMsg_ClientInfo message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_ClientInfo\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_ClientInfo} CCSUsrMsg_ClientInfo\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_ClientInfo.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ClientInfo();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.dummy = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_ClientInfo;\n})());\nexports.CCSUsrMsg_ServerRankRevealAll = ($root.CCSUsrMsg_ServerRankRevealAll = (() => {\n    /**\n     * Properties of a CCSUsrMsg_ServerRankRevealAll.\n     * @exports ICCSUsrMsg_ServerRankRevealAll\n     * @interface ICCSUsrMsg_ServerRankRevealAll\n     * @property {number|null} [secondsTillShutdown] CCSUsrMsg_ServerRankRevealAll secondsTillShutdown\n     */\n    /**\n     * Constructs a new CCSUsrMsg_ServerRankRevealAll.\n     * @exports CCSUsrMsg_ServerRankRevealAll\n     * @classdesc Represents a CCSUsrMsg_ServerRankRevealAll.\n     * @implements ICCSUsrMsg_ServerRankRevealAll\n     * @constructor\n     * @param {ICCSUsrMsg_ServerRankRevealAll=} [properties] Properties to set\n     */\n    function CCSUsrMsg_ServerRankRevealAll(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCSUsrMsg_ServerRankRevealAll secondsTillShutdown.\n     * @member {number} secondsTillShutdown\n     * @memberof CCSUsrMsg_ServerRankRevealAll\n     * @instance\n     */\n    CCSUsrMsg_ServerRankRevealAll.prototype.secondsTillShutdown = 0;\n    /**\n     * Decodes a CCSUsrMsg_ServerRankRevealAll message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCSUsrMsg_ServerRankRevealAll\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCSUsrMsg_ServerRankRevealAll} CCSUsrMsg_ServerRankRevealAll\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCSUsrMsg_ServerRankRevealAll.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCSUsrMsg_ServerRankRevealAll();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.secondsTillShutdown = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCSUsrMsg_ServerRankRevealAll;\n})());\nexports.google = ($root.google = (() => {\n    /**\n     * Namespace google.\n     * @exports google\n     * @namespace\n     */\n    const google = {};\n    google.protobuf = (function () {\n        /**\n         * Namespace protobuf.\n         * @memberof google\n         * @namespace\n         */\n        const protobuf = {};\n        protobuf.FileDescriptorSet = (function () {\n            /**\n             * Properties of a FileDescriptorSet.\n             * @memberof google.protobuf\n             * @interface IFileDescriptorSet\n             * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file\n             */\n            /**\n             * Constructs a new FileDescriptorSet.\n             * @memberof google.protobuf\n             * @classdesc Represents a FileDescriptorSet.\n             * @implements IFileDescriptorSet\n             * @constructor\n             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set\n             */\n            function FileDescriptorSet(properties) {\n                this.file = [];\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * FileDescriptorSet file.\n             * @member {Array.<google.protobuf.IFileDescriptorProto>} file\n             * @memberof google.protobuf.FileDescriptorSet\n             * @instance\n             */\n            FileDescriptorSet.prototype.file = $util.emptyArray;\n            /**\n             * Decodes a FileDescriptorSet message from the specified reader or buffer.\n             * @function decode\n             * @memberof google.protobuf.FileDescriptorSet\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            FileDescriptorSet.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorSet();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.file && message.file.length))\n                                message.file = [];\n                            message.file.push($root.google.protobuf.FileDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            return FileDescriptorSet;\n        })();\n        protobuf.FileDescriptorProto = (function () {\n            /**\n             * Properties of a FileDescriptorProto.\n             * @memberof google.protobuf\n             * @interface IFileDescriptorProto\n             * @property {string|null} [name] FileDescriptorProto name\n             * @property {string|null} [\"package\"] FileDescriptorProto package\n             * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency\n             * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency\n             * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency\n             * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType\n             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType\n             * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service\n             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension\n             * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options\n             * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo\n             * @property {string|null} [syntax] FileDescriptorProto syntax\n             */\n            /**\n             * Constructs a new FileDescriptorProto.\n             * @memberof google.protobuf\n             * @classdesc Represents a FileDescriptorProto.\n             * @implements IFileDescriptorProto\n             * @constructor\n             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set\n             */\n            function FileDescriptorProto(properties) {\n                this.dependency = [];\n                this.publicDependency = [];\n                this.weakDependency = [];\n                this.messageType = [];\n                this.enumType = [];\n                this.service = [];\n                this.extension = [];\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * FileDescriptorProto name.\n             * @member {string} name\n             * @memberof google.protobuf.FileDescriptorProto\n             * @instance\n             */\n            FileDescriptorProto.prototype.name = \"\";\n            /**\n             * FileDescriptorProto package.\n             * @member {string} package\n             * @memberof google.protobuf.FileDescriptorProto\n             * @instance\n             */\n            FileDescriptorProto.prototype[\"package\"] = \"\";\n            /**\n             * FileDescriptorProto dependency.\n             * @member {Array.<string>} dependency\n             * @memberof google.protobuf.FileDescriptorProto\n             * @instance\n             */\n            FileDescriptorProto.prototype.dependency = $util.emptyArray;\n            /**\n             * FileDescriptorProto publicDependency.\n             * @member {Array.<number>} publicDependency\n             * @memberof google.protobuf.FileDescriptorProto\n             * @instance\n             */\n            FileDescriptorProto.prototype.publicDependency = $util.emptyArray;\n            /**\n             * FileDescriptorProto weakDependency.\n             * @member {Array.<number>} weakDependency\n             * @memberof google.protobuf.FileDescriptorProto\n             * @instance\n             */\n            FileDescriptorProto.prototype.weakDependency = $util.emptyArray;\n            /**\n             * FileDescriptorProto messageType.\n             * @member {Array.<google.protobuf.IDescriptorProto>} messageType\n             * @memberof google.protobuf.FileDescriptorProto\n             * @instance\n             */\n            FileDescriptorProto.prototype.messageType = $util.emptyArray;\n            /**\n             * FileDescriptorProto enumType.\n             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType\n             * @memberof google.protobuf.FileDescriptorProto\n             * @instance\n             */\n            FileDescriptorProto.prototype.enumType = $util.emptyArray;\n            /**\n             * FileDescriptorProto service.\n             * @member {Array.<google.protobuf.IServiceDescriptorProto>} service\n             * @memberof google.protobuf.FileDescriptorProto\n             * @instance\n             */\n            FileDescriptorProto.prototype.service = $util.emptyArray;\n            /**\n             * FileDescriptorProto extension.\n             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension\n             * @memberof google.protobuf.FileDescriptorProto\n             * @instance\n             */\n            FileDescriptorProto.prototype.extension = $util.emptyArray;\n            /**\n             * FileDescriptorProto options.\n             * @member {google.protobuf.IFileOptions|null|undefined} options\n             * @memberof google.protobuf.FileDescriptorProto\n             * @instance\n             */\n            FileDescriptorProto.prototype.options = null;\n            /**\n             * FileDescriptorProto sourceCodeInfo.\n             * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo\n             * @memberof google.protobuf.FileDescriptorProto\n             * @instance\n             */\n            FileDescriptorProto.prototype.sourceCodeInfo = null;\n            /**\n             * FileDescriptorProto syntax.\n             * @member {string} syntax\n             * @memberof google.protobuf.FileDescriptorProto\n             * @instance\n             */\n            FileDescriptorProto.prototype.syntax = \"\";\n            /**\n             * Decodes a FileDescriptorProto message from the specified reader or buffer.\n             * @function decode\n             * @memberof google.protobuf.FileDescriptorProto\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            FileDescriptorProto.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileDescriptorProto();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            message.name = reader.string();\n                            break;\n                        case 2:\n                            message[\"package\"] = reader.string();\n                            break;\n                        case 3:\n                            if (!(message.dependency && message.dependency.length))\n                                message.dependency = [];\n                            message.dependency.push(reader.string());\n                            break;\n                        case 10:\n                            if (!(message.publicDependency && message.publicDependency.length))\n                                message.publicDependency = [];\n                            if ((tag & 7) === 2) {\n                                let end2 = reader.uint32() + reader.pos;\n                                while (reader.pos < end2)\n                                    message.publicDependency.push(reader.int32());\n                            }\n                            else\n                                message.publicDependency.push(reader.int32());\n                            break;\n                        case 11:\n                            if (!(message.weakDependency && message.weakDependency.length))\n                                message.weakDependency = [];\n                            if ((tag & 7) === 2) {\n                                let end2 = reader.uint32() + reader.pos;\n                                while (reader.pos < end2)\n                                    message.weakDependency.push(reader.int32());\n                            }\n                            else\n                                message.weakDependency.push(reader.int32());\n                            break;\n                        case 4:\n                            if (!(message.messageType && message.messageType.length))\n                                message.messageType = [];\n                            message.messageType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 5:\n                            if (!(message.enumType && message.enumType.length))\n                                message.enumType = [];\n                            message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 6:\n                            if (!(message.service && message.service.length))\n                                message.service = [];\n                            message.service.push($root.google.protobuf.ServiceDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 7:\n                            if (!(message.extension && message.extension.length))\n                                message.extension = [];\n                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 8:\n                            message.options = $root.google.protobuf.FileOptions.decode(reader, reader.uint32());\n                            break;\n                        case 9:\n                            message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.decode(reader, reader.uint32());\n                            break;\n                        case 12:\n                            message.syntax = reader.string();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            return FileDescriptorProto;\n        })();\n        protobuf.DescriptorProto = (function () {\n            /**\n             * Properties of a DescriptorProto.\n             * @memberof google.protobuf\n             * @interface IDescriptorProto\n             * @property {string|null} [name] DescriptorProto name\n             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field\n             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension\n             * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType\n             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType\n             * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange\n             * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl\n             * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options\n             * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange\n             * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName\n             */\n            /**\n             * Constructs a new DescriptorProto.\n             * @memberof google.protobuf\n             * @classdesc Represents a DescriptorProto.\n             * @implements IDescriptorProto\n             * @constructor\n             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set\n             */\n            function DescriptorProto(properties) {\n                this.field = [];\n                this.extension = [];\n                this.nestedType = [];\n                this.enumType = [];\n                this.extensionRange = [];\n                this.oneofDecl = [];\n                this.reservedRange = [];\n                this.reservedName = [];\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * DescriptorProto name.\n             * @member {string} name\n             * @memberof google.protobuf.DescriptorProto\n             * @instance\n             */\n            DescriptorProto.prototype.name = \"\";\n            /**\n             * DescriptorProto field.\n             * @member {Array.<google.protobuf.IFieldDescriptorProto>} field\n             * @memberof google.protobuf.DescriptorProto\n             * @instance\n             */\n            DescriptorProto.prototype.field = $util.emptyArray;\n            /**\n             * DescriptorProto extension.\n             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension\n             * @memberof google.protobuf.DescriptorProto\n             * @instance\n             */\n            DescriptorProto.prototype.extension = $util.emptyArray;\n            /**\n             * DescriptorProto nestedType.\n             * @member {Array.<google.protobuf.IDescriptorProto>} nestedType\n             * @memberof google.protobuf.DescriptorProto\n             * @instance\n             */\n            DescriptorProto.prototype.nestedType = $util.emptyArray;\n            /**\n             * DescriptorProto enumType.\n             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType\n             * @memberof google.protobuf.DescriptorProto\n             * @instance\n             */\n            DescriptorProto.prototype.enumType = $util.emptyArray;\n            /**\n             * DescriptorProto extensionRange.\n             * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange\n             * @memberof google.protobuf.DescriptorProto\n             * @instance\n             */\n            DescriptorProto.prototype.extensionRange = $util.emptyArray;\n            /**\n             * DescriptorProto oneofDecl.\n             * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl\n             * @memberof google.protobuf.DescriptorProto\n             * @instance\n             */\n            DescriptorProto.prototype.oneofDecl = $util.emptyArray;\n            /**\n             * DescriptorProto options.\n             * @member {google.protobuf.IMessageOptions|null|undefined} options\n             * @memberof google.protobuf.DescriptorProto\n             * @instance\n             */\n            DescriptorProto.prototype.options = null;\n            /**\n             * DescriptorProto reservedRange.\n             * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange\n             * @memberof google.protobuf.DescriptorProto\n             * @instance\n             */\n            DescriptorProto.prototype.reservedRange = $util.emptyArray;\n            /**\n             * DescriptorProto reservedName.\n             * @member {Array.<string>} reservedName\n             * @memberof google.protobuf.DescriptorProto\n             * @instance\n             */\n            DescriptorProto.prototype.reservedName = $util.emptyArray;\n            /**\n             * Decodes a DescriptorProto message from the specified reader or buffer.\n             * @function decode\n             * @memberof google.protobuf.DescriptorProto\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {google.protobuf.DescriptorProto} DescriptorProto\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            DescriptorProto.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            message.name = reader.string();\n                            break;\n                        case 2:\n                            if (!(message.field && message.field.length))\n                                message.field = [];\n                            message.field.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 6:\n                            if (!(message.extension && message.extension.length))\n                                message.extension = [];\n                            message.extension.push($root.google.protobuf.FieldDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 3:\n                            if (!(message.nestedType && message.nestedType.length))\n                                message.nestedType = [];\n                            message.nestedType.push($root.google.protobuf.DescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 4:\n                            if (!(message.enumType && message.enumType.length))\n                                message.enumType = [];\n                            message.enumType.push($root.google.protobuf.EnumDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 5:\n                            if (!(message.extensionRange && message.extensionRange.length))\n                                message.extensionRange = [];\n                            message.extensionRange.push($root.google.protobuf.DescriptorProto.ExtensionRange.decode(reader, reader.uint32()));\n                            break;\n                        case 8:\n                            if (!(message.oneofDecl && message.oneofDecl.length))\n                                message.oneofDecl = [];\n                            message.oneofDecl.push($root.google.protobuf.OneofDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 7:\n                            message.options = $root.google.protobuf.MessageOptions.decode(reader, reader.uint32());\n                            break;\n                        case 9:\n                            if (!(message.reservedRange && message.reservedRange.length))\n                                message.reservedRange = [];\n                            message.reservedRange.push($root.google.protobuf.DescriptorProto.ReservedRange.decode(reader, reader.uint32()));\n                            break;\n                        case 10:\n                            if (!(message.reservedName && message.reservedName.length))\n                                message.reservedName = [];\n                            message.reservedName.push(reader.string());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            DescriptorProto.ExtensionRange = (function () {\n                /**\n                 * Properties of an ExtensionRange.\n                 * @memberof google.protobuf.DescriptorProto\n                 * @interface IExtensionRange\n                 * @property {number|null} [start] ExtensionRange start\n                 * @property {number|null} [end] ExtensionRange end\n                 */\n                /**\n                 * Constructs a new ExtensionRange.\n                 * @memberof google.protobuf.DescriptorProto\n                 * @classdesc Represents an ExtensionRange.\n                 * @implements IExtensionRange\n                 * @constructor\n                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set\n                 */\n                function ExtensionRange(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n                /**\n                 * ExtensionRange start.\n                 * @member {number} start\n                 * @memberof google.protobuf.DescriptorProto.ExtensionRange\n                 * @instance\n                 */\n                ExtensionRange.prototype.start = 0;\n                /**\n                 * ExtensionRange end.\n                 * @member {number} end\n                 * @memberof google.protobuf.DescriptorProto.ExtensionRange\n                 * @instance\n                 */\n                ExtensionRange.prototype.end = 0;\n                /**\n                 * Decodes an ExtensionRange message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.DescriptorProto.ExtensionRange\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ExtensionRange.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ExtensionRange();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                            case 1:\n                                message.start = reader.int32();\n                                break;\n                            case 2:\n                                message.end = reader.int32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                        }\n                    }\n                    return message;\n                };\n                return ExtensionRange;\n            })();\n            DescriptorProto.ReservedRange = (function () {\n                /**\n                 * Properties of a ReservedRange.\n                 * @memberof google.protobuf.DescriptorProto\n                 * @interface IReservedRange\n                 * @property {number|null} [start] ReservedRange start\n                 * @property {number|null} [end] ReservedRange end\n                 */\n                /**\n                 * Constructs a new ReservedRange.\n                 * @memberof google.protobuf.DescriptorProto\n                 * @classdesc Represents a ReservedRange.\n                 * @implements IReservedRange\n                 * @constructor\n                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set\n                 */\n                function ReservedRange(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n                /**\n                 * ReservedRange start.\n                 * @member {number} start\n                 * @memberof google.protobuf.DescriptorProto.ReservedRange\n                 * @instance\n                 */\n                ReservedRange.prototype.start = 0;\n                /**\n                 * ReservedRange end.\n                 * @member {number} end\n                 * @memberof google.protobuf.DescriptorProto.ReservedRange\n                 * @instance\n                 */\n                ReservedRange.prototype.end = 0;\n                /**\n                 * Decodes a ReservedRange message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.DescriptorProto.ReservedRange\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                ReservedRange.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.DescriptorProto.ReservedRange();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                            case 1:\n                                message.start = reader.int32();\n                                break;\n                            case 2:\n                                message.end = reader.int32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                        }\n                    }\n                    return message;\n                };\n                return ReservedRange;\n            })();\n            return DescriptorProto;\n        })();\n        protobuf.FieldDescriptorProto = (function () {\n            /**\n             * Properties of a FieldDescriptorProto.\n             * @memberof google.protobuf\n             * @interface IFieldDescriptorProto\n             * @property {string|null} [name] FieldDescriptorProto name\n             * @property {number|null} [number] FieldDescriptorProto number\n             * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label\n             * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type\n             * @property {string|null} [typeName] FieldDescriptorProto typeName\n             * @property {string|null} [extendee] FieldDescriptorProto extendee\n             * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue\n             * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex\n             * @property {string|null} [jsonName] FieldDescriptorProto jsonName\n             * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options\n             */\n            /**\n             * Constructs a new FieldDescriptorProto.\n             * @memberof google.protobuf\n             * @classdesc Represents a FieldDescriptorProto.\n             * @implements IFieldDescriptorProto\n             * @constructor\n             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set\n             */\n            function FieldDescriptorProto(properties) {\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * FieldDescriptorProto name.\n             * @member {string} name\n             * @memberof google.protobuf.FieldDescriptorProto\n             * @instance\n             */\n            FieldDescriptorProto.prototype.name = \"\";\n            /**\n             * FieldDescriptorProto number.\n             * @member {number} number\n             * @memberof google.protobuf.FieldDescriptorProto\n             * @instance\n             */\n            FieldDescriptorProto.prototype.number = 0;\n            /**\n             * FieldDescriptorProto label.\n             * @member {google.protobuf.FieldDescriptorProto.Label} label\n             * @memberof google.protobuf.FieldDescriptorProto\n             * @instance\n             */\n            FieldDescriptorProto.prototype.label = 1;\n            /**\n             * FieldDescriptorProto type.\n             * @member {google.protobuf.FieldDescriptorProto.Type} type\n             * @memberof google.protobuf.FieldDescriptorProto\n             * @instance\n             */\n            FieldDescriptorProto.prototype.type = 1;\n            /**\n             * FieldDescriptorProto typeName.\n             * @member {string} typeName\n             * @memberof google.protobuf.FieldDescriptorProto\n             * @instance\n             */\n            FieldDescriptorProto.prototype.typeName = \"\";\n            /**\n             * FieldDescriptorProto extendee.\n             * @member {string} extendee\n             * @memberof google.protobuf.FieldDescriptorProto\n             * @instance\n             */\n            FieldDescriptorProto.prototype.extendee = \"\";\n            /**\n             * FieldDescriptorProto defaultValue.\n             * @member {string} defaultValue\n             * @memberof google.protobuf.FieldDescriptorProto\n             * @instance\n             */\n            FieldDescriptorProto.prototype.defaultValue = \"\";\n            /**\n             * FieldDescriptorProto oneofIndex.\n             * @member {number} oneofIndex\n             * @memberof google.protobuf.FieldDescriptorProto\n             * @instance\n             */\n            FieldDescriptorProto.prototype.oneofIndex = 0;\n            /**\n             * FieldDescriptorProto jsonName.\n             * @member {string} jsonName\n             * @memberof google.protobuf.FieldDescriptorProto\n             * @instance\n             */\n            FieldDescriptorProto.prototype.jsonName = \"\";\n            /**\n             * FieldDescriptorProto options.\n             * @member {google.protobuf.IFieldOptions|null|undefined} options\n             * @memberof google.protobuf.FieldDescriptorProto\n             * @instance\n             */\n            FieldDescriptorProto.prototype.options = null;\n            /**\n             * Decodes a FieldDescriptorProto message from the specified reader or buffer.\n             * @function decode\n             * @memberof google.protobuf.FieldDescriptorProto\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            FieldDescriptorProto.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldDescriptorProto();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            message.name = reader.string();\n                            break;\n                        case 3:\n                            message.number = reader.int32();\n                            break;\n                        case 4:\n                            message.label = reader.int32();\n                            break;\n                        case 5:\n                            message.type = reader.int32();\n                            break;\n                        case 6:\n                            message.typeName = reader.string();\n                            break;\n                        case 2:\n                            message.extendee = reader.string();\n                            break;\n                        case 7:\n                            message.defaultValue = reader.string();\n                            break;\n                        case 9:\n                            message.oneofIndex = reader.int32();\n                            break;\n                        case 10:\n                            message.jsonName = reader.string();\n                            break;\n                        case 8:\n                            message.options = $root.google.protobuf.FieldOptions.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            /**\n             * Type enum.\n             * @name google.protobuf.FieldDescriptorProto.Type\n             * @enum {string}\n             * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value\n             * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value\n             * @property {number} TYPE_INT64=3 TYPE_INT64 value\n             * @property {number} TYPE_UINT64=4 TYPE_UINT64 value\n             * @property {number} TYPE_INT32=5 TYPE_INT32 value\n             * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value\n             * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value\n             * @property {number} TYPE_BOOL=8 TYPE_BOOL value\n             * @property {number} TYPE_STRING=9 TYPE_STRING value\n             * @property {number} TYPE_GROUP=10 TYPE_GROUP value\n             * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value\n             * @property {number} TYPE_BYTES=12 TYPE_BYTES value\n             * @property {number} TYPE_UINT32=13 TYPE_UINT32 value\n             * @property {number} TYPE_ENUM=14 TYPE_ENUM value\n             * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value\n             * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value\n             * @property {number} TYPE_SINT32=17 TYPE_SINT32 value\n             * @property {number} TYPE_SINT64=18 TYPE_SINT64 value\n             */\n            FieldDescriptorProto.Type = (function () {\n                const valuesById = {}, values = Object.create(valuesById);\n                values[(valuesById[1] = \"TYPE_DOUBLE\")] = 1;\n                values[(valuesById[2] = \"TYPE_FLOAT\")] = 2;\n                values[(valuesById[3] = \"TYPE_INT64\")] = 3;\n                values[(valuesById[4] = \"TYPE_UINT64\")] = 4;\n                values[(valuesById[5] = \"TYPE_INT32\")] = 5;\n                values[(valuesById[6] = \"TYPE_FIXED64\")] = 6;\n                values[(valuesById[7] = \"TYPE_FIXED32\")] = 7;\n                values[(valuesById[8] = \"TYPE_BOOL\")] = 8;\n                values[(valuesById[9] = \"TYPE_STRING\")] = 9;\n                values[(valuesById[10] = \"TYPE_GROUP\")] = 10;\n                values[(valuesById[11] = \"TYPE_MESSAGE\")] = 11;\n                values[(valuesById[12] = \"TYPE_BYTES\")] = 12;\n                values[(valuesById[13] = \"TYPE_UINT32\")] = 13;\n                values[(valuesById[14] = \"TYPE_ENUM\")] = 14;\n                values[(valuesById[15] = \"TYPE_SFIXED32\")] = 15;\n                values[(valuesById[16] = \"TYPE_SFIXED64\")] = 16;\n                values[(valuesById[17] = \"TYPE_SINT32\")] = 17;\n                values[(valuesById[18] = \"TYPE_SINT64\")] = 18;\n                return values;\n            })();\n            /**\n             * Label enum.\n             * @name google.protobuf.FieldDescriptorProto.Label\n             * @enum {string}\n             * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value\n             * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value\n             * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value\n             */\n            FieldDescriptorProto.Label = (function () {\n                const valuesById = {}, values = Object.create(valuesById);\n                values[(valuesById[1] = \"LABEL_OPTIONAL\")] = 1;\n                values[(valuesById[2] = \"LABEL_REQUIRED\")] = 2;\n                values[(valuesById[3] = \"LABEL_REPEATED\")] = 3;\n                return values;\n            })();\n            return FieldDescriptorProto;\n        })();\n        protobuf.OneofDescriptorProto = (function () {\n            /**\n             * Properties of an OneofDescriptorProto.\n             * @memberof google.protobuf\n             * @interface IOneofDescriptorProto\n             * @property {string|null} [name] OneofDescriptorProto name\n             * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options\n             */\n            /**\n             * Constructs a new OneofDescriptorProto.\n             * @memberof google.protobuf\n             * @classdesc Represents an OneofDescriptorProto.\n             * @implements IOneofDescriptorProto\n             * @constructor\n             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set\n             */\n            function OneofDescriptorProto(properties) {\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * OneofDescriptorProto name.\n             * @member {string} name\n             * @memberof google.protobuf.OneofDescriptorProto\n             * @instance\n             */\n            OneofDescriptorProto.prototype.name = \"\";\n            /**\n             * OneofDescriptorProto options.\n             * @member {google.protobuf.IOneofOptions|null|undefined} options\n             * @memberof google.protobuf.OneofDescriptorProto\n             * @instance\n             */\n            OneofDescriptorProto.prototype.options = null;\n            /**\n             * Decodes an OneofDescriptorProto message from the specified reader or buffer.\n             * @function decode\n             * @memberof google.protobuf.OneofDescriptorProto\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            OneofDescriptorProto.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofDescriptorProto();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            message.name = reader.string();\n                            break;\n                        case 2:\n                            message.options = $root.google.protobuf.OneofOptions.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            return OneofDescriptorProto;\n        })();\n        protobuf.EnumDescriptorProto = (function () {\n            /**\n             * Properties of an EnumDescriptorProto.\n             * @memberof google.protobuf\n             * @interface IEnumDescriptorProto\n             * @property {string|null} [name] EnumDescriptorProto name\n             * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value\n             * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options\n             */\n            /**\n             * Constructs a new EnumDescriptorProto.\n             * @memberof google.protobuf\n             * @classdesc Represents an EnumDescriptorProto.\n             * @implements IEnumDescriptorProto\n             * @constructor\n             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set\n             */\n            function EnumDescriptorProto(properties) {\n                this.value = [];\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * EnumDescriptorProto name.\n             * @member {string} name\n             * @memberof google.protobuf.EnumDescriptorProto\n             * @instance\n             */\n            EnumDescriptorProto.prototype.name = \"\";\n            /**\n             * EnumDescriptorProto value.\n             * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value\n             * @memberof google.protobuf.EnumDescriptorProto\n             * @instance\n             */\n            EnumDescriptorProto.prototype.value = $util.emptyArray;\n            /**\n             * EnumDescriptorProto options.\n             * @member {google.protobuf.IEnumOptions|null|undefined} options\n             * @memberof google.protobuf.EnumDescriptorProto\n             * @instance\n             */\n            EnumDescriptorProto.prototype.options = null;\n            /**\n             * Decodes an EnumDescriptorProto message from the specified reader or buffer.\n             * @function decode\n             * @memberof google.protobuf.EnumDescriptorProto\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            EnumDescriptorProto.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumDescriptorProto();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            message.name = reader.string();\n                            break;\n                        case 2:\n                            if (!(message.value && message.value.length))\n                                message.value = [];\n                            message.value.push($root.google.protobuf.EnumValueDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 3:\n                            message.options = $root.google.protobuf.EnumOptions.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            return EnumDescriptorProto;\n        })();\n        protobuf.EnumValueDescriptorProto = (function () {\n            /**\n             * Properties of an EnumValueDescriptorProto.\n             * @memberof google.protobuf\n             * @interface IEnumValueDescriptorProto\n             * @property {string|null} [name] EnumValueDescriptorProto name\n             * @property {number|null} [number] EnumValueDescriptorProto number\n             * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options\n             */\n            /**\n             * Constructs a new EnumValueDescriptorProto.\n             * @memberof google.protobuf\n             * @classdesc Represents an EnumValueDescriptorProto.\n             * @implements IEnumValueDescriptorProto\n             * @constructor\n             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set\n             */\n            function EnumValueDescriptorProto(properties) {\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * EnumValueDescriptorProto name.\n             * @member {string} name\n             * @memberof google.protobuf.EnumValueDescriptorProto\n             * @instance\n             */\n            EnumValueDescriptorProto.prototype.name = \"\";\n            /**\n             * EnumValueDescriptorProto number.\n             * @member {number} number\n             * @memberof google.protobuf.EnumValueDescriptorProto\n             * @instance\n             */\n            EnumValueDescriptorProto.prototype.number = 0;\n            /**\n             * EnumValueDescriptorProto options.\n             * @member {google.protobuf.IEnumValueOptions|null|undefined} options\n             * @memberof google.protobuf.EnumValueDescriptorProto\n             * @instance\n             */\n            EnumValueDescriptorProto.prototype.options = null;\n            /**\n             * Decodes an EnumValueDescriptorProto message from the specified reader or buffer.\n             * @function decode\n             * @memberof google.protobuf.EnumValueDescriptorProto\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            EnumValueDescriptorProto.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueDescriptorProto();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            message.name = reader.string();\n                            break;\n                        case 2:\n                            message.number = reader.int32();\n                            break;\n                        case 3:\n                            message.options = $root.google.protobuf.EnumValueOptions.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            return EnumValueDescriptorProto;\n        })();\n        protobuf.ServiceDescriptorProto = (function () {\n            /**\n             * Properties of a ServiceDescriptorProto.\n             * @memberof google.protobuf\n             * @interface IServiceDescriptorProto\n             * @property {string|null} [name] ServiceDescriptorProto name\n             * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method\n             * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options\n             */\n            /**\n             * Constructs a new ServiceDescriptorProto.\n             * @memberof google.protobuf\n             * @classdesc Represents a ServiceDescriptorProto.\n             * @implements IServiceDescriptorProto\n             * @constructor\n             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set\n             */\n            function ServiceDescriptorProto(properties) {\n                this.method = [];\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * ServiceDescriptorProto name.\n             * @member {string} name\n             * @memberof google.protobuf.ServiceDescriptorProto\n             * @instance\n             */\n            ServiceDescriptorProto.prototype.name = \"\";\n            /**\n             * ServiceDescriptorProto method.\n             * @member {Array.<google.protobuf.IMethodDescriptorProto>} method\n             * @memberof google.protobuf.ServiceDescriptorProto\n             * @instance\n             */\n            ServiceDescriptorProto.prototype.method = $util.emptyArray;\n            /**\n             * ServiceDescriptorProto options.\n             * @member {google.protobuf.IServiceOptions|null|undefined} options\n             * @memberof google.protobuf.ServiceDescriptorProto\n             * @instance\n             */\n            ServiceDescriptorProto.prototype.options = null;\n            /**\n             * Decodes a ServiceDescriptorProto message from the specified reader or buffer.\n             * @function decode\n             * @memberof google.protobuf.ServiceDescriptorProto\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ServiceDescriptorProto.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceDescriptorProto();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            message.name = reader.string();\n                            break;\n                        case 2:\n                            if (!(message.method && message.method.length))\n                                message.method = [];\n                            message.method.push($root.google.protobuf.MethodDescriptorProto.decode(reader, reader.uint32()));\n                            break;\n                        case 3:\n                            message.options = $root.google.protobuf.ServiceOptions.decode(reader, reader.uint32());\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            return ServiceDescriptorProto;\n        })();\n        protobuf.MethodDescriptorProto = (function () {\n            /**\n             * Properties of a MethodDescriptorProto.\n             * @memberof google.protobuf\n             * @interface IMethodDescriptorProto\n             * @property {string|null} [name] MethodDescriptorProto name\n             * @property {string|null} [inputType] MethodDescriptorProto inputType\n             * @property {string|null} [outputType] MethodDescriptorProto outputType\n             * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options\n             * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming\n             * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming\n             */\n            /**\n             * Constructs a new MethodDescriptorProto.\n             * @memberof google.protobuf\n             * @classdesc Represents a MethodDescriptorProto.\n             * @implements IMethodDescriptorProto\n             * @constructor\n             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set\n             */\n            function MethodDescriptorProto(properties) {\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * MethodDescriptorProto name.\n             * @member {string} name\n             * @memberof google.protobuf.MethodDescriptorProto\n             * @instance\n             */\n            MethodDescriptorProto.prototype.name = \"\";\n            /**\n             * MethodDescriptorProto inputType.\n             * @member {string} inputType\n             * @memberof google.protobuf.MethodDescriptorProto\n             * @instance\n             */\n            MethodDescriptorProto.prototype.inputType = \"\";\n            /**\n             * MethodDescriptorProto outputType.\n             * @member {string} outputType\n             * @memberof google.protobuf.MethodDescriptorProto\n             * @instance\n             */\n            MethodDescriptorProto.prototype.outputType = \"\";\n            /**\n             * MethodDescriptorProto options.\n             * @member {google.protobuf.IMethodOptions|null|undefined} options\n             * @memberof google.protobuf.MethodDescriptorProto\n             * @instance\n             */\n            MethodDescriptorProto.prototype.options = null;\n            /**\n             * MethodDescriptorProto clientStreaming.\n             * @member {boolean} clientStreaming\n             * @memberof google.protobuf.MethodDescriptorProto\n             * @instance\n             */\n            MethodDescriptorProto.prototype.clientStreaming = false;\n            /**\n             * MethodDescriptorProto serverStreaming.\n             * @member {boolean} serverStreaming\n             * @memberof google.protobuf.MethodDescriptorProto\n             * @instance\n             */\n            MethodDescriptorProto.prototype.serverStreaming = false;\n            /**\n             * Decodes a MethodDescriptorProto message from the specified reader or buffer.\n             * @function decode\n             * @memberof google.protobuf.MethodDescriptorProto\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            MethodDescriptorProto.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodDescriptorProto();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            message.name = reader.string();\n                            break;\n                        case 2:\n                            message.inputType = reader.string();\n                            break;\n                        case 3:\n                            message.outputType = reader.string();\n                            break;\n                        case 4:\n                            message.options = $root.google.protobuf.MethodOptions.decode(reader, reader.uint32());\n                            break;\n                        case 5:\n                            message.clientStreaming = reader.bool();\n                            break;\n                        case 6:\n                            message.serverStreaming = reader.bool();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            return MethodDescriptorProto;\n        })();\n        protobuf.FileOptions = (function () {\n            /**\n             * Properties of a FileOptions.\n             * @memberof google.protobuf\n             * @interface IFileOptions\n             * @property {string|null} [javaPackage] FileOptions javaPackage\n             * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname\n             * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles\n             * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash\n             * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8\n             * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor\n             * @property {string|null} [goPackage] FileOptions goPackage\n             * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices\n             * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices\n             * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices\n             * @property {boolean|null} [deprecated] FileOptions deprecated\n             * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas\n             * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix\n             * @property {string|null} [csharpNamespace] FileOptions csharpNamespace\n             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption\n             */\n            /**\n             * Constructs a new FileOptions.\n             * @memberof google.protobuf\n             * @classdesc Represents a FileOptions.\n             * @implements IFileOptions\n             * @constructor\n             * @param {google.protobuf.IFileOptions=} [properties] Properties to set\n             */\n            function FileOptions(properties) {\n                this.uninterpretedOption = [];\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * FileOptions javaPackage.\n             * @member {string} javaPackage\n             * @memberof google.protobuf.FileOptions\n             * @instance\n             */\n            FileOptions.prototype.javaPackage = \"\";\n            /**\n             * FileOptions javaOuterClassname.\n             * @member {string} javaOuterClassname\n             * @memberof google.protobuf.FileOptions\n             * @instance\n             */\n            FileOptions.prototype.javaOuterClassname = \"\";\n            /**\n             * FileOptions javaMultipleFiles.\n             * @member {boolean} javaMultipleFiles\n             * @memberof google.protobuf.FileOptions\n             * @instance\n             */\n            FileOptions.prototype.javaMultipleFiles = false;\n            /**\n             * FileOptions javaGenerateEqualsAndHash.\n             * @member {boolean} javaGenerateEqualsAndHash\n             * @memberof google.protobuf.FileOptions\n             * @instance\n             */\n            FileOptions.prototype.javaGenerateEqualsAndHash = false;\n            /**\n             * FileOptions javaStringCheckUtf8.\n             * @member {boolean} javaStringCheckUtf8\n             * @memberof google.protobuf.FileOptions\n             * @instance\n             */\n            FileOptions.prototype.javaStringCheckUtf8 = false;\n            /**\n             * FileOptions optimizeFor.\n             * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor\n             * @memberof google.protobuf.FileOptions\n             * @instance\n             */\n            FileOptions.prototype.optimizeFor = 1;\n            /**\n             * FileOptions goPackage.\n             * @member {string} goPackage\n             * @memberof google.protobuf.FileOptions\n             * @instance\n             */\n            FileOptions.prototype.goPackage = \"\";\n            /**\n             * FileOptions ccGenericServices.\n             * @member {boolean} ccGenericServices\n             * @memberof google.protobuf.FileOptions\n             * @instance\n             */\n            FileOptions.prototype.ccGenericServices = false;\n            /**\n             * FileOptions javaGenericServices.\n             * @member {boolean} javaGenericServices\n             * @memberof google.protobuf.FileOptions\n             * @instance\n             */\n            FileOptions.prototype.javaGenericServices = false;\n            /**\n             * FileOptions pyGenericServices.\n             * @member {boolean} pyGenericServices\n             * @memberof google.protobuf.FileOptions\n             * @instance\n             */\n            FileOptions.prototype.pyGenericServices = false;\n            /**\n             * FileOptions deprecated.\n             * @member {boolean} deprecated\n             * @memberof google.protobuf.FileOptions\n             * @instance\n             */\n            FileOptions.prototype.deprecated = false;\n            /**\n             * FileOptions ccEnableArenas.\n             * @member {boolean} ccEnableArenas\n             * @memberof google.protobuf.FileOptions\n             * @instance\n             */\n            FileOptions.prototype.ccEnableArenas = false;\n            /**\n             * FileOptions objcClassPrefix.\n             * @member {string} objcClassPrefix\n             * @memberof google.protobuf.FileOptions\n             * @instance\n             */\n            FileOptions.prototype.objcClassPrefix = \"\";\n            /**\n             * FileOptions csharpNamespace.\n             * @member {string} csharpNamespace\n             * @memberof google.protobuf.FileOptions\n             * @instance\n             */\n            FileOptions.prototype.csharpNamespace = \"\";\n            /**\n             * FileOptions uninterpretedOption.\n             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n             * @memberof google.protobuf.FileOptions\n             * @instance\n             */\n            FileOptions.prototype.uninterpretedOption = $util.emptyArray;\n            /**\n             * Decodes a FileOptions message from the specified reader or buffer.\n             * @function decode\n             * @memberof google.protobuf.FileOptions\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {google.protobuf.FileOptions} FileOptions\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            FileOptions.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FileOptions();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            message.javaPackage = reader.string();\n                            break;\n                        case 8:\n                            message.javaOuterClassname = reader.string();\n                            break;\n                        case 10:\n                            message.javaMultipleFiles = reader.bool();\n                            break;\n                        case 20:\n                            message.javaGenerateEqualsAndHash = reader.bool();\n                            break;\n                        case 27:\n                            message.javaStringCheckUtf8 = reader.bool();\n                            break;\n                        case 9:\n                            message.optimizeFor = reader.int32();\n                            break;\n                        case 11:\n                            message.goPackage = reader.string();\n                            break;\n                        case 16:\n                            message.ccGenericServices = reader.bool();\n                            break;\n                        case 17:\n                            message.javaGenericServices = reader.bool();\n                            break;\n                        case 18:\n                            message.pyGenericServices = reader.bool();\n                            break;\n                        case 23:\n                            message.deprecated = reader.bool();\n                            break;\n                        case 31:\n                            message.ccEnableArenas = reader.bool();\n                            break;\n                        case 36:\n                            message.objcClassPrefix = reader.string();\n                            break;\n                        case 37:\n                            message.csharpNamespace = reader.string();\n                            break;\n                        case 999:\n                            if (!(message.uninterpretedOption &&\n                                message.uninterpretedOption.length))\n                                message.uninterpretedOption = [];\n                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            /**\n             * OptimizeMode enum.\n             * @name google.protobuf.FileOptions.OptimizeMode\n             * @enum {string}\n             * @property {number} SPEED=1 SPEED value\n             * @property {number} CODE_SIZE=2 CODE_SIZE value\n             * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value\n             */\n            FileOptions.OptimizeMode = (function () {\n                const valuesById = {}, values = Object.create(valuesById);\n                values[(valuesById[1] = \"SPEED\")] = 1;\n                values[(valuesById[2] = \"CODE_SIZE\")] = 2;\n                values[(valuesById[3] = \"LITE_RUNTIME\")] = 3;\n                return values;\n            })();\n            return FileOptions;\n        })();\n        protobuf.MessageOptions = (function () {\n            /**\n             * Properties of a MessageOptions.\n             * @memberof google.protobuf\n             * @interface IMessageOptions\n             * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat\n             * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor\n             * @property {boolean|null} [deprecated] MessageOptions deprecated\n             * @property {boolean|null} [mapEntry] MessageOptions mapEntry\n             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption\n             * @property {number|null} [\".msgpoolSoftLimit\"] MessageOptions .msgpoolSoftLimit\n             * @property {number|null} [\".msgpoolHardLimit\"] MessageOptions .msgpoolHardLimit\n             */\n            /**\n             * Constructs a new MessageOptions.\n             * @memberof google.protobuf\n             * @classdesc Represents a MessageOptions.\n             * @implements IMessageOptions\n             * @constructor\n             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set\n             */\n            function MessageOptions(properties) {\n                this.uninterpretedOption = [];\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * MessageOptions messageSetWireFormat.\n             * @member {boolean} messageSetWireFormat\n             * @memberof google.protobuf.MessageOptions\n             * @instance\n             */\n            MessageOptions.prototype.messageSetWireFormat = false;\n            /**\n             * MessageOptions noStandardDescriptorAccessor.\n             * @member {boolean} noStandardDescriptorAccessor\n             * @memberof google.protobuf.MessageOptions\n             * @instance\n             */\n            MessageOptions.prototype.noStandardDescriptorAccessor = false;\n            /**\n             * MessageOptions deprecated.\n             * @member {boolean} deprecated\n             * @memberof google.protobuf.MessageOptions\n             * @instance\n             */\n            MessageOptions.prototype.deprecated = false;\n            /**\n             * MessageOptions mapEntry.\n             * @member {boolean} mapEntry\n             * @memberof google.protobuf.MessageOptions\n             * @instance\n             */\n            MessageOptions.prototype.mapEntry = false;\n            /**\n             * MessageOptions uninterpretedOption.\n             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n             * @memberof google.protobuf.MessageOptions\n             * @instance\n             */\n            MessageOptions.prototype.uninterpretedOption = $util.emptyArray;\n            /**\n             * MessageOptions .msgpoolSoftLimit.\n             * @member {number} .msgpoolSoftLimit\n             * @memberof google.protobuf.MessageOptions\n             * @instance\n             */\n            MessageOptions.prototype[\".msgpoolSoftLimit\"] = 32;\n            /**\n             * MessageOptions .msgpoolHardLimit.\n             * @member {number} .msgpoolHardLimit\n             * @memberof google.protobuf.MessageOptions\n             * @instance\n             */\n            MessageOptions.prototype[\".msgpoolHardLimit\"] = 384;\n            /**\n             * Decodes a MessageOptions message from the specified reader or buffer.\n             * @function decode\n             * @memberof google.protobuf.MessageOptions\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {google.protobuf.MessageOptions} MessageOptions\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            MessageOptions.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MessageOptions();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            message.messageSetWireFormat = reader.bool();\n                            break;\n                        case 2:\n                            message.noStandardDescriptorAccessor = reader.bool();\n                            break;\n                        case 3:\n                            message.deprecated = reader.bool();\n                            break;\n                        case 7:\n                            message.mapEntry = reader.bool();\n                            break;\n                        case 999:\n                            if (!(message.uninterpretedOption &&\n                                message.uninterpretedOption.length))\n                                message.uninterpretedOption = [];\n                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                            break;\n                        case 60000:\n                            message[\".msgpoolSoftLimit\"] = reader.int32();\n                            break;\n                        case 60001:\n                            message[\".msgpoolHardLimit\"] = reader.int32();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            return MessageOptions;\n        })();\n        protobuf.FieldOptions = (function () {\n            /**\n             * Properties of a FieldOptions.\n             * @memberof google.protobuf\n             * @interface IFieldOptions\n             * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype\n             * @property {boolean|null} [packed] FieldOptions packed\n             * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype\n             * @property {boolean|null} [lazy] FieldOptions lazy\n             * @property {boolean|null} [deprecated] FieldOptions deprecated\n             * @property {boolean|null} [weak] FieldOptions weak\n             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption\n             * @property {boolean|null} [\".keyField\"] FieldOptions .keyField\n             */\n            /**\n             * Constructs a new FieldOptions.\n             * @memberof google.protobuf\n             * @classdesc Represents a FieldOptions.\n             * @implements IFieldOptions\n             * @constructor\n             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set\n             */\n            function FieldOptions(properties) {\n                this.uninterpretedOption = [];\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * FieldOptions ctype.\n             * @member {google.protobuf.FieldOptions.CType} ctype\n             * @memberof google.protobuf.FieldOptions\n             * @instance\n             */\n            FieldOptions.prototype.ctype = 0;\n            /**\n             * FieldOptions packed.\n             * @member {boolean} packed\n             * @memberof google.protobuf.FieldOptions\n             * @instance\n             */\n            FieldOptions.prototype.packed = false;\n            /**\n             * FieldOptions jstype.\n             * @member {google.protobuf.FieldOptions.JSType} jstype\n             * @memberof google.protobuf.FieldOptions\n             * @instance\n             */\n            FieldOptions.prototype.jstype = 0;\n            /**\n             * FieldOptions lazy.\n             * @member {boolean} lazy\n             * @memberof google.protobuf.FieldOptions\n             * @instance\n             */\n            FieldOptions.prototype.lazy = false;\n            /**\n             * FieldOptions deprecated.\n             * @member {boolean} deprecated\n             * @memberof google.protobuf.FieldOptions\n             * @instance\n             */\n            FieldOptions.prototype.deprecated = false;\n            /**\n             * FieldOptions weak.\n             * @member {boolean} weak\n             * @memberof google.protobuf.FieldOptions\n             * @instance\n             */\n            FieldOptions.prototype.weak = false;\n            /**\n             * FieldOptions uninterpretedOption.\n             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n             * @memberof google.protobuf.FieldOptions\n             * @instance\n             */\n            FieldOptions.prototype.uninterpretedOption = $util.emptyArray;\n            /**\n             * FieldOptions .keyField.\n             * @member {boolean} .keyField\n             * @memberof google.protobuf.FieldOptions\n             * @instance\n             */\n            FieldOptions.prototype[\".keyField\"] = false;\n            /**\n             * Decodes a FieldOptions message from the specified reader or buffer.\n             * @function decode\n             * @memberof google.protobuf.FieldOptions\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {google.protobuf.FieldOptions} FieldOptions\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            FieldOptions.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.FieldOptions();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            message.ctype = reader.int32();\n                            break;\n                        case 2:\n                            message.packed = reader.bool();\n                            break;\n                        case 6:\n                            message.jstype = reader.int32();\n                            break;\n                        case 5:\n                            message.lazy = reader.bool();\n                            break;\n                        case 3:\n                            message.deprecated = reader.bool();\n                            break;\n                        case 10:\n                            message.weak = reader.bool();\n                            break;\n                        case 999:\n                            if (!(message.uninterpretedOption &&\n                                message.uninterpretedOption.length))\n                                message.uninterpretedOption = [];\n                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                            break;\n                        case 60000:\n                            message[\".keyField\"] = reader.bool();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            /**\n             * CType enum.\n             * @name google.protobuf.FieldOptions.CType\n             * @enum {string}\n             * @property {number} STRING=0 STRING value\n             * @property {number} CORD=1 CORD value\n             * @property {number} STRING_PIECE=2 STRING_PIECE value\n             */\n            FieldOptions.CType = (function () {\n                const valuesById = {}, values = Object.create(valuesById);\n                values[(valuesById[0] = \"STRING\")] = 0;\n                values[(valuesById[1] = \"CORD\")] = 1;\n                values[(valuesById[2] = \"STRING_PIECE\")] = 2;\n                return values;\n            })();\n            /**\n             * JSType enum.\n             * @name google.protobuf.FieldOptions.JSType\n             * @enum {string}\n             * @property {number} JS_NORMAL=0 JS_NORMAL value\n             * @property {number} JS_STRING=1 JS_STRING value\n             * @property {number} JS_NUMBER=2 JS_NUMBER value\n             */\n            FieldOptions.JSType = (function () {\n                const valuesById = {}, values = Object.create(valuesById);\n                values[(valuesById[0] = \"JS_NORMAL\")] = 0;\n                values[(valuesById[1] = \"JS_STRING\")] = 1;\n                values[(valuesById[2] = \"JS_NUMBER\")] = 2;\n                return values;\n            })();\n            return FieldOptions;\n        })();\n        protobuf.OneofOptions = (function () {\n            /**\n             * Properties of an OneofOptions.\n             * @memberof google.protobuf\n             * @interface IOneofOptions\n             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption\n             */\n            /**\n             * Constructs a new OneofOptions.\n             * @memberof google.protobuf\n             * @classdesc Represents an OneofOptions.\n             * @implements IOneofOptions\n             * @constructor\n             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set\n             */\n            function OneofOptions(properties) {\n                this.uninterpretedOption = [];\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * OneofOptions uninterpretedOption.\n             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n             * @memberof google.protobuf.OneofOptions\n             * @instance\n             */\n            OneofOptions.prototype.uninterpretedOption = $util.emptyArray;\n            /**\n             * Decodes an OneofOptions message from the specified reader or buffer.\n             * @function decode\n             * @memberof google.protobuf.OneofOptions\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {google.protobuf.OneofOptions} OneofOptions\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            OneofOptions.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.OneofOptions();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 999:\n                            if (!(message.uninterpretedOption &&\n                                message.uninterpretedOption.length))\n                                message.uninterpretedOption = [];\n                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            return OneofOptions;\n        })();\n        protobuf.EnumOptions = (function () {\n            /**\n             * Properties of an EnumOptions.\n             * @memberof google.protobuf\n             * @interface IEnumOptions\n             * @property {boolean|null} [allowAlias] EnumOptions allowAlias\n             * @property {boolean|null} [deprecated] EnumOptions deprecated\n             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption\n             */\n            /**\n             * Constructs a new EnumOptions.\n             * @memberof google.protobuf\n             * @classdesc Represents an EnumOptions.\n             * @implements IEnumOptions\n             * @constructor\n             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set\n             */\n            function EnumOptions(properties) {\n                this.uninterpretedOption = [];\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * EnumOptions allowAlias.\n             * @member {boolean} allowAlias\n             * @memberof google.protobuf.EnumOptions\n             * @instance\n             */\n            EnumOptions.prototype.allowAlias = false;\n            /**\n             * EnumOptions deprecated.\n             * @member {boolean} deprecated\n             * @memberof google.protobuf.EnumOptions\n             * @instance\n             */\n            EnumOptions.prototype.deprecated = false;\n            /**\n             * EnumOptions uninterpretedOption.\n             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n             * @memberof google.protobuf.EnumOptions\n             * @instance\n             */\n            EnumOptions.prototype.uninterpretedOption = $util.emptyArray;\n            /**\n             * Decodes an EnumOptions message from the specified reader or buffer.\n             * @function decode\n             * @memberof google.protobuf.EnumOptions\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {google.protobuf.EnumOptions} EnumOptions\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            EnumOptions.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumOptions();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 2:\n                            message.allowAlias = reader.bool();\n                            break;\n                        case 3:\n                            message.deprecated = reader.bool();\n                            break;\n                        case 999:\n                            if (!(message.uninterpretedOption &&\n                                message.uninterpretedOption.length))\n                                message.uninterpretedOption = [];\n                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            return EnumOptions;\n        })();\n        protobuf.EnumValueOptions = (function () {\n            /**\n             * Properties of an EnumValueOptions.\n             * @memberof google.protobuf\n             * @interface IEnumValueOptions\n             * @property {boolean|null} [deprecated] EnumValueOptions deprecated\n             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption\n             */\n            /**\n             * Constructs a new EnumValueOptions.\n             * @memberof google.protobuf\n             * @classdesc Represents an EnumValueOptions.\n             * @implements IEnumValueOptions\n             * @constructor\n             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set\n             */\n            function EnumValueOptions(properties) {\n                this.uninterpretedOption = [];\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * EnumValueOptions deprecated.\n             * @member {boolean} deprecated\n             * @memberof google.protobuf.EnumValueOptions\n             * @instance\n             */\n            EnumValueOptions.prototype.deprecated = false;\n            /**\n             * EnumValueOptions uninterpretedOption.\n             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n             * @memberof google.protobuf.EnumValueOptions\n             * @instance\n             */\n            EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;\n            /**\n             * Decodes an EnumValueOptions message from the specified reader or buffer.\n             * @function decode\n             * @memberof google.protobuf.EnumValueOptions\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            EnumValueOptions.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.EnumValueOptions();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            message.deprecated = reader.bool();\n                            break;\n                        case 999:\n                            if (!(message.uninterpretedOption &&\n                                message.uninterpretedOption.length))\n                                message.uninterpretedOption = [];\n                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            return EnumValueOptions;\n        })();\n        protobuf.ServiceOptions = (function () {\n            /**\n             * Properties of a ServiceOptions.\n             * @memberof google.protobuf\n             * @interface IServiceOptions\n             * @property {boolean|null} [deprecated] ServiceOptions deprecated\n             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption\n             */\n            /**\n             * Constructs a new ServiceOptions.\n             * @memberof google.protobuf\n             * @classdesc Represents a ServiceOptions.\n             * @implements IServiceOptions\n             * @constructor\n             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set\n             */\n            function ServiceOptions(properties) {\n                this.uninterpretedOption = [];\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * ServiceOptions deprecated.\n             * @member {boolean} deprecated\n             * @memberof google.protobuf.ServiceOptions\n             * @instance\n             */\n            ServiceOptions.prototype.deprecated = false;\n            /**\n             * ServiceOptions uninterpretedOption.\n             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n             * @memberof google.protobuf.ServiceOptions\n             * @instance\n             */\n            ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;\n            /**\n             * Decodes a ServiceOptions message from the specified reader or buffer.\n             * @function decode\n             * @memberof google.protobuf.ServiceOptions\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {google.protobuf.ServiceOptions} ServiceOptions\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            ServiceOptions.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.ServiceOptions();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 33:\n                            message.deprecated = reader.bool();\n                            break;\n                        case 999:\n                            if (!(message.uninterpretedOption &&\n                                message.uninterpretedOption.length))\n                                message.uninterpretedOption = [];\n                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            return ServiceOptions;\n        })();\n        protobuf.MethodOptions = (function () {\n            /**\n             * Properties of a MethodOptions.\n             * @memberof google.protobuf\n             * @interface IMethodOptions\n             * @property {boolean|null} [deprecated] MethodOptions deprecated\n             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption\n             */\n            /**\n             * Constructs a new MethodOptions.\n             * @memberof google.protobuf\n             * @classdesc Represents a MethodOptions.\n             * @implements IMethodOptions\n             * @constructor\n             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set\n             */\n            function MethodOptions(properties) {\n                this.uninterpretedOption = [];\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * MethodOptions deprecated.\n             * @member {boolean} deprecated\n             * @memberof google.protobuf.MethodOptions\n             * @instance\n             */\n            MethodOptions.prototype.deprecated = false;\n            /**\n             * MethodOptions uninterpretedOption.\n             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption\n             * @memberof google.protobuf.MethodOptions\n             * @instance\n             */\n            MethodOptions.prototype.uninterpretedOption = $util.emptyArray;\n            /**\n             * Decodes a MethodOptions message from the specified reader or buffer.\n             * @function decode\n             * @memberof google.protobuf.MethodOptions\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {google.protobuf.MethodOptions} MethodOptions\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            MethodOptions.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.MethodOptions();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 33:\n                            message.deprecated = reader.bool();\n                            break;\n                        case 999:\n                            if (!(message.uninterpretedOption &&\n                                message.uninterpretedOption.length))\n                                message.uninterpretedOption = [];\n                            message.uninterpretedOption.push($root.google.protobuf.UninterpretedOption.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            return MethodOptions;\n        })();\n        protobuf.UninterpretedOption = (function () {\n            /**\n             * Properties of an UninterpretedOption.\n             * @memberof google.protobuf\n             * @interface IUninterpretedOption\n             * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name\n             * @property {string|null} [identifierValue] UninterpretedOption identifierValue\n             * @property {number|Long|null} [positiveIntValue] UninterpretedOption positiveIntValue\n             * @property {number|Long|null} [negativeIntValue] UninterpretedOption negativeIntValue\n             * @property {number|null} [doubleValue] UninterpretedOption doubleValue\n             * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue\n             * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue\n             */\n            /**\n             * Constructs a new UninterpretedOption.\n             * @memberof google.protobuf\n             * @classdesc Represents an UninterpretedOption.\n             * @implements IUninterpretedOption\n             * @constructor\n             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set\n             */\n            function UninterpretedOption(properties) {\n                this.name = [];\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * UninterpretedOption name.\n             * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name\n             * @memberof google.protobuf.UninterpretedOption\n             * @instance\n             */\n            UninterpretedOption.prototype.name = $util.emptyArray;\n            /**\n             * UninterpretedOption identifierValue.\n             * @member {string} identifierValue\n             * @memberof google.protobuf.UninterpretedOption\n             * @instance\n             */\n            UninterpretedOption.prototype.identifierValue = \"\";\n            /**\n             * UninterpretedOption positiveIntValue.\n             * @member {number|Long} positiveIntValue\n             * @memberof google.protobuf.UninterpretedOption\n             * @instance\n             */\n            UninterpretedOption.prototype.positiveIntValue = $util.Long\n                ? $util.Long.fromBits(0, 0, true)\n                : 0;\n            /**\n             * UninterpretedOption negativeIntValue.\n             * @member {number|Long} negativeIntValue\n             * @memberof google.protobuf.UninterpretedOption\n             * @instance\n             */\n            UninterpretedOption.prototype.negativeIntValue = $util.Long\n                ? $util.Long.fromBits(0, 0, false)\n                : 0;\n            /**\n             * UninterpretedOption doubleValue.\n             * @member {number} doubleValue\n             * @memberof google.protobuf.UninterpretedOption\n             * @instance\n             */\n            UninterpretedOption.prototype.doubleValue = 0;\n            /**\n             * UninterpretedOption stringValue.\n             * @member {Uint8Array} stringValue\n             * @memberof google.protobuf.UninterpretedOption\n             * @instance\n             */\n            UninterpretedOption.prototype.stringValue = $util.newBuffer([]);\n            /**\n             * UninterpretedOption aggregateValue.\n             * @member {string} aggregateValue\n             * @memberof google.protobuf.UninterpretedOption\n             * @instance\n             */\n            UninterpretedOption.prototype.aggregateValue = \"\";\n            /**\n             * Decodes an UninterpretedOption message from the specified reader or buffer.\n             * @function decode\n             * @memberof google.protobuf.UninterpretedOption\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            UninterpretedOption.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 2:\n                            if (!(message.name && message.name.length))\n                                message.name = [];\n                            message.name.push($root.google.protobuf.UninterpretedOption.NamePart.decode(reader, reader.uint32()));\n                            break;\n                        case 3:\n                            message.identifierValue = reader.string();\n                            break;\n                        case 4:\n                            message.positiveIntValue = reader.uint64();\n                            break;\n                        case 5:\n                            message.negativeIntValue = reader.int64();\n                            break;\n                        case 6:\n                            message.doubleValue = reader.double();\n                            break;\n                        case 7:\n                            message.stringValue = reader.bytes();\n                            break;\n                        case 8:\n                            message.aggregateValue = reader.string();\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            UninterpretedOption.NamePart = (function () {\n                /**\n                 * Properties of a NamePart.\n                 * @memberof google.protobuf.UninterpretedOption\n                 * @interface INamePart\n                 * @property {string} namePart NamePart namePart\n                 * @property {boolean} isExtension NamePart isExtension\n                 */\n                /**\n                 * Constructs a new NamePart.\n                 * @memberof google.protobuf.UninterpretedOption\n                 * @classdesc Represents a NamePart.\n                 * @implements INamePart\n                 * @constructor\n                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set\n                 */\n                function NamePart(properties) {\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n                /**\n                 * NamePart namePart.\n                 * @member {string} namePart\n                 * @memberof google.protobuf.UninterpretedOption.NamePart\n                 * @instance\n                 */\n                NamePart.prototype.namePart = \"\";\n                /**\n                 * NamePart isExtension.\n                 * @member {boolean} isExtension\n                 * @memberof google.protobuf.UninterpretedOption.NamePart\n                 * @instance\n                 */\n                NamePart.prototype.isExtension = false;\n                /**\n                 * Decodes a NamePart message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.UninterpretedOption.NamePart\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                NamePart.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.UninterpretedOption.NamePart();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                            case 1:\n                                message.namePart = reader.string();\n                                break;\n                            case 2:\n                                message.isExtension = reader.bool();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                        }\n                    }\n                    if (!message.hasOwnProperty(\"namePart\"))\n                        throw $util.ProtocolError(\"missing required 'namePart'\", {\n                            instance: message\n                        });\n                    if (!message.hasOwnProperty(\"isExtension\"))\n                        throw $util.ProtocolError(\"missing required 'isExtension'\", {\n                            instance: message\n                        });\n                    return message;\n                };\n                return NamePart;\n            })();\n            return UninterpretedOption;\n        })();\n        protobuf.SourceCodeInfo = (function () {\n            /**\n             * Properties of a SourceCodeInfo.\n             * @memberof google.protobuf\n             * @interface ISourceCodeInfo\n             * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location\n             */\n            /**\n             * Constructs a new SourceCodeInfo.\n             * @memberof google.protobuf\n             * @classdesc Represents a SourceCodeInfo.\n             * @implements ISourceCodeInfo\n             * @constructor\n             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set\n             */\n            function SourceCodeInfo(properties) {\n                this.location = [];\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * SourceCodeInfo location.\n             * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location\n             * @memberof google.protobuf.SourceCodeInfo\n             * @instance\n             */\n            SourceCodeInfo.prototype.location = $util.emptyArray;\n            /**\n             * Decodes a SourceCodeInfo message from the specified reader or buffer.\n             * @function decode\n             * @memberof google.protobuf.SourceCodeInfo\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            SourceCodeInfo.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.location && message.location.length))\n                                message.location = [];\n                            message.location.push($root.google.protobuf.SourceCodeInfo.Location.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            SourceCodeInfo.Location = (function () {\n                /**\n                 * Properties of a Location.\n                 * @memberof google.protobuf.SourceCodeInfo\n                 * @interface ILocation\n                 * @property {Array.<number>|null} [path] Location path\n                 * @property {Array.<number>|null} [span] Location span\n                 * @property {string|null} [leadingComments] Location leadingComments\n                 * @property {string|null} [trailingComments] Location trailingComments\n                 * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments\n                 */\n                /**\n                 * Constructs a new Location.\n                 * @memberof google.protobuf.SourceCodeInfo\n                 * @classdesc Represents a Location.\n                 * @implements ILocation\n                 * @constructor\n                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set\n                 */\n                function Location(properties) {\n                    this.path = [];\n                    this.span = [];\n                    this.leadingDetachedComments = [];\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n                /**\n                 * Location path.\n                 * @member {Array.<number>} path\n                 * @memberof google.protobuf.SourceCodeInfo.Location\n                 * @instance\n                 */\n                Location.prototype.path = $util.emptyArray;\n                /**\n                 * Location span.\n                 * @member {Array.<number>} span\n                 * @memberof google.protobuf.SourceCodeInfo.Location\n                 * @instance\n                 */\n                Location.prototype.span = $util.emptyArray;\n                /**\n                 * Location leadingComments.\n                 * @member {string} leadingComments\n                 * @memberof google.protobuf.SourceCodeInfo.Location\n                 * @instance\n                 */\n                Location.prototype.leadingComments = \"\";\n                /**\n                 * Location trailingComments.\n                 * @member {string} trailingComments\n                 * @memberof google.protobuf.SourceCodeInfo.Location\n                 * @instance\n                 */\n                Location.prototype.trailingComments = \"\";\n                /**\n                 * Location leadingDetachedComments.\n                 * @member {Array.<string>} leadingDetachedComments\n                 * @memberof google.protobuf.SourceCodeInfo.Location\n                 * @instance\n                 */\n                Location.prototype.leadingDetachedComments = $util.emptyArray;\n                /**\n                 * Decodes a Location message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.SourceCodeInfo.Location\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.SourceCodeInfo.Location} Location\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Location.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.SourceCodeInfo.Location();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                            case 1:\n                                if (!(message.path && message.path.length))\n                                    message.path = [];\n                                if ((tag & 7) === 2) {\n                                    let end2 = reader.uint32() + reader.pos;\n                                    while (reader.pos < end2)\n                                        message.path.push(reader.int32());\n                                }\n                                else\n                                    message.path.push(reader.int32());\n                                break;\n                            case 2:\n                                if (!(message.span && message.span.length))\n                                    message.span = [];\n                                if ((tag & 7) === 2) {\n                                    let end2 = reader.uint32() + reader.pos;\n                                    while (reader.pos < end2)\n                                        message.span.push(reader.int32());\n                                }\n                                else\n                                    message.span.push(reader.int32());\n                                break;\n                            case 3:\n                                message.leadingComments = reader.string();\n                                break;\n                            case 4:\n                                message.trailingComments = reader.string();\n                                break;\n                            case 6:\n                                if (!(message.leadingDetachedComments &&\n                                    message.leadingDetachedComments.length))\n                                    message.leadingDetachedComments = [];\n                                message.leadingDetachedComments.push(reader.string());\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                        }\n                    }\n                    return message;\n                };\n                return Location;\n            })();\n            return SourceCodeInfo;\n        })();\n        protobuf.GeneratedCodeInfo = (function () {\n            /**\n             * Properties of a GeneratedCodeInfo.\n             * @memberof google.protobuf\n             * @interface IGeneratedCodeInfo\n             * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation\n             */\n            /**\n             * Constructs a new GeneratedCodeInfo.\n             * @memberof google.protobuf\n             * @classdesc Represents a GeneratedCodeInfo.\n             * @implements IGeneratedCodeInfo\n             * @constructor\n             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set\n             */\n            function GeneratedCodeInfo(properties) {\n                this.annotation = [];\n                if (properties)\n                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                        if (properties[keys[i]] != null)\n                            this[keys[i]] = properties[keys[i]];\n            }\n            /**\n             * GeneratedCodeInfo annotation.\n             * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation\n             * @memberof google.protobuf.GeneratedCodeInfo\n             * @instance\n             */\n            GeneratedCodeInfo.prototype.annotation = $util.emptyArray;\n            /**\n             * Decodes a GeneratedCodeInfo message from the specified reader or buffer.\n             * @function decode\n             * @memberof google.protobuf.GeneratedCodeInfo\n             * @static\n             * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n             * @param {number} [length] Message length if known beforehand\n             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo\n             * @throws {Error} If the payload is not a reader or valid buffer\n             * @throws {$protobuf.util.ProtocolError} If required fields are missing\n             */\n            GeneratedCodeInfo.decode = function decode(reader, length) {\n                if (!(reader instanceof $Reader))\n                    reader = $Reader.create(reader);\n                let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo();\n                while (reader.pos < end) {\n                    let tag = reader.uint32();\n                    switch (tag >>> 3) {\n                        case 1:\n                            if (!(message.annotation && message.annotation.length))\n                                message.annotation = [];\n                            message.annotation.push($root.google.protobuf.GeneratedCodeInfo.Annotation.decode(reader, reader.uint32()));\n                            break;\n                        default:\n                            reader.skipType(tag & 7);\n                            break;\n                    }\n                }\n                return message;\n            };\n            GeneratedCodeInfo.Annotation = (function () {\n                /**\n                 * Properties of an Annotation.\n                 * @memberof google.protobuf.GeneratedCodeInfo\n                 * @interface IAnnotation\n                 * @property {Array.<number>|null} [path] Annotation path\n                 * @property {string|null} [sourceFile] Annotation sourceFile\n                 * @property {number|null} [begin] Annotation begin\n                 * @property {number|null} [end] Annotation end\n                 */\n                /**\n                 * Constructs a new Annotation.\n                 * @memberof google.protobuf.GeneratedCodeInfo\n                 * @classdesc Represents an Annotation.\n                 * @implements IAnnotation\n                 * @constructor\n                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set\n                 */\n                function Annotation(properties) {\n                    this.path = [];\n                    if (properties)\n                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                            if (properties[keys[i]] != null)\n                                this[keys[i]] = properties[keys[i]];\n                }\n                /**\n                 * Annotation path.\n                 * @member {Array.<number>} path\n                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n                 * @instance\n                 */\n                Annotation.prototype.path = $util.emptyArray;\n                /**\n                 * Annotation sourceFile.\n                 * @member {string} sourceFile\n                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n                 * @instance\n                 */\n                Annotation.prototype.sourceFile = \"\";\n                /**\n                 * Annotation begin.\n                 * @member {number} begin\n                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n                 * @instance\n                 */\n                Annotation.prototype.begin = 0;\n                /**\n                 * Annotation end.\n                 * @member {number} end\n                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n                 * @instance\n                 */\n                Annotation.prototype.end = 0;\n                /**\n                 * Decodes an Annotation message from the specified reader or buffer.\n                 * @function decode\n                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation\n                 * @static\n                 * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n                 * @param {number} [length] Message length if known beforehand\n                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation\n                 * @throws {Error} If the payload is not a reader or valid buffer\n                 * @throws {$protobuf.util.ProtocolError} If required fields are missing\n                 */\n                Annotation.decode = function decode(reader, length) {\n                    if (!(reader instanceof $Reader))\n                        reader = $Reader.create(reader);\n                    let end = length === undefined ? reader.len : reader.pos + length, message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();\n                    while (reader.pos < end) {\n                        let tag = reader.uint32();\n                        switch (tag >>> 3) {\n                            case 1:\n                                if (!(message.path && message.path.length))\n                                    message.path = [];\n                                if ((tag & 7) === 2) {\n                                    let end2 = reader.uint32() + reader.pos;\n                                    while (reader.pos < end2)\n                                        message.path.push(reader.int32());\n                                }\n                                else\n                                    message.path.push(reader.int32());\n                                break;\n                            case 2:\n                                message.sourceFile = reader.string();\n                                break;\n                            case 3:\n                                message.begin = reader.int32();\n                                break;\n                            case 4:\n                                message.end = reader.int32();\n                                break;\n                            default:\n                                reader.skipType(tag & 7);\n                                break;\n                        }\n                    }\n                    return message;\n                };\n                return Annotation;\n            })();\n            return GeneratedCodeInfo;\n        })();\n        return protobuf;\n    })();\n    return google;\n})());\n/**\n * NET_Messages enum.\n * @exports NET_Messages\n * @enum {string}\n * @property {number} net_NOP=0 net_NOP value\n * @property {number} net_Disconnect=1 net_Disconnect value\n * @property {number} net_File=2 net_File value\n * @property {number} net_SplitScreenUser=3 net_SplitScreenUser value\n * @property {number} net_Tick=4 net_Tick value\n * @property {number} net_StringCmd=5 net_StringCmd value\n * @property {number} net_SetConVar=6 net_SetConVar value\n * @property {number} net_SignonState=7 net_SignonState value\n * @property {number} net_PlayerAvatarData=100 net_PlayerAvatarData value\n */\n$root.NET_Messages = (function () {\n    const valuesById = {}, values = Object.create(valuesById);\n    values[(valuesById[0] = \"net_NOP\")] = 0;\n    values[(valuesById[1] = \"net_Disconnect\")] = 1;\n    values[(valuesById[2] = \"net_File\")] = 2;\n    values[(valuesById[3] = \"net_SplitScreenUser\")] = 3;\n    values[(valuesById[4] = \"net_Tick\")] = 4;\n    values[(valuesById[5] = \"net_StringCmd\")] = 5;\n    values[(valuesById[6] = \"net_SetConVar\")] = 6;\n    values[(valuesById[7] = \"net_SignonState\")] = 7;\n    values[(valuesById[100] = \"net_PlayerAvatarData\")] = 100;\n    return values;\n})();\n/**\n * CLC_Messages enum.\n * @exports CLC_Messages\n * @enum {string}\n * @property {number} clc_ClientInfo=8 clc_ClientInfo value\n * @property {number} clc_Move=9 clc_Move value\n * @property {number} clc_VoiceData=10 clc_VoiceData value\n * @property {number} clc_BaselineAck=11 clc_BaselineAck value\n * @property {number} clc_ListenEvents=12 clc_ListenEvents value\n * @property {number} clc_RespondCvarValue=13 clc_RespondCvarValue value\n * @property {number} clc_FileCRCCheck=14 clc_FileCRCCheck value\n * @property {number} clc_LoadingProgress=15 clc_LoadingProgress value\n * @property {number} clc_SplitPlayerConnect=16 clc_SplitPlayerConnect value\n * @property {number} clc_ClientMessage=17 clc_ClientMessage value\n * @property {number} clc_CmdKeyValues=18 clc_CmdKeyValues value\n * @property {number} clc_HltvReplay=20 clc_HltvReplay value\n */\n$root.CLC_Messages = (function () {\n    const valuesById = {}, values = Object.create(valuesById);\n    values[(valuesById[8] = \"clc_ClientInfo\")] = 8;\n    values[(valuesById[9] = \"clc_Move\")] = 9;\n    values[(valuesById[10] = \"clc_VoiceData\")] = 10;\n    values[(valuesById[11] = \"clc_BaselineAck\")] = 11;\n    values[(valuesById[12] = \"clc_ListenEvents\")] = 12;\n    values[(valuesById[13] = \"clc_RespondCvarValue\")] = 13;\n    values[(valuesById[14] = \"clc_FileCRCCheck\")] = 14;\n    values[(valuesById[15] = \"clc_LoadingProgress\")] = 15;\n    values[(valuesById[16] = \"clc_SplitPlayerConnect\")] = 16;\n    values[(valuesById[17] = \"clc_ClientMessage\")] = 17;\n    values[(valuesById[18] = \"clc_CmdKeyValues\")] = 18;\n    values[(valuesById[20] = \"clc_HltvReplay\")] = 20;\n    return values;\n})();\n/**\n * VoiceDataFormat_t enum.\n * @exports VoiceDataFormat_t\n * @enum {string}\n * @property {number} VOICEDATA_FORMAT_STEAM=0 VOICEDATA_FORMAT_STEAM value\n * @property {number} VOICEDATA_FORMAT_ENGINE=1 VOICEDATA_FORMAT_ENGINE value\n */\n$root.VoiceDataFormat_t = (function () {\n    const valuesById = {}, values = Object.create(valuesById);\n    values[(valuesById[0] = \"VOICEDATA_FORMAT_STEAM\")] = 0;\n    values[(valuesById[1] = \"VOICEDATA_FORMAT_ENGINE\")] = 1;\n    return values;\n})();\n/**\n * ESplitScreenMessageType enum.\n * @exports ESplitScreenMessageType\n * @enum {string}\n * @property {number} MSG_SPLITSCREEN_ADDUSER=0 MSG_SPLITSCREEN_ADDUSER value\n * @property {number} MSG_SPLITSCREEN_REMOVEUSER=1 MSG_SPLITSCREEN_REMOVEUSER value\n * @property {number} MSG_SPLITSCREEN_TYPE_BITS=1 MSG_SPLITSCREEN_TYPE_BITS value\n */\n$root.ESplitScreenMessageType = (function () {\n    const valuesById = {}, values = Object.create(valuesById);\n    values[(valuesById[0] = \"MSG_SPLITSCREEN_ADDUSER\")] = 0;\n    values[(valuesById[1] = \"MSG_SPLITSCREEN_REMOVEUSER\")] = 1;\n    values[\"MSG_SPLITSCREEN_TYPE_BITS\"] = 1;\n    return values;\n})();\n/**\n * SVC_Messages enum.\n * @exports SVC_Messages\n * @enum {string}\n * @property {number} svc_ServerInfo=8 svc_ServerInfo value\n * @property {number} svc_SendTable=9 svc_SendTable value\n * @property {number} svc_ClassInfo=10 svc_ClassInfo value\n * @property {number} svc_SetPause=11 svc_SetPause value\n * @property {number} svc_CreateStringTable=12 svc_CreateStringTable value\n * @property {number} svc_UpdateStringTable=13 svc_UpdateStringTable value\n * @property {number} svc_VoiceInit=14 svc_VoiceInit value\n * @property {number} svc_VoiceData=15 svc_VoiceData value\n * @property {number} svc_Print=16 svc_Print value\n * @property {number} svc_Sounds=17 svc_Sounds value\n * @property {number} svc_SetView=18 svc_SetView value\n * @property {number} svc_FixAngle=19 svc_FixAngle value\n * @property {number} svc_CrosshairAngle=20 svc_CrosshairAngle value\n * @property {number} svc_BSPDecal=21 svc_BSPDecal value\n * @property {number} svc_SplitScreen=22 svc_SplitScreen value\n * @property {number} svc_UserMessage=23 svc_UserMessage value\n * @property {number} svc_EntityMessage=24 svc_EntityMessage value\n * @property {number} svc_GameEvent=25 svc_GameEvent value\n * @property {number} svc_PacketEntities=26 svc_PacketEntities value\n * @property {number} svc_TempEntities=27 svc_TempEntities value\n * @property {number} svc_Prefetch=28 svc_Prefetch value\n * @property {number} svc_Menu=29 svc_Menu value\n * @property {number} svc_GameEventList=30 svc_GameEventList value\n * @property {number} svc_GetCvarValue=31 svc_GetCvarValue value\n * @property {number} svc_PaintmapData=33 svc_PaintmapData value\n * @property {number} svc_CmdKeyValues=34 svc_CmdKeyValues value\n * @property {number} svc_EncryptedData=35 svc_EncryptedData value\n * @property {number} svc_HltvReplay=36 svc_HltvReplay value\n */\n$root.SVC_Messages = (function () {\n    const valuesById = {}, values = Object.create(valuesById);\n    values[(valuesById[8] = \"svc_ServerInfo\")] = 8;\n    values[(valuesById[9] = \"svc_SendTable\")] = 9;\n    values[(valuesById[10] = \"svc_ClassInfo\")] = 10;\n    values[(valuesById[11] = \"svc_SetPause\")] = 11;\n    values[(valuesById[12] = \"svc_CreateStringTable\")] = 12;\n    values[(valuesById[13] = \"svc_UpdateStringTable\")] = 13;\n    values[(valuesById[14] = \"svc_VoiceInit\")] = 14;\n    values[(valuesById[15] = \"svc_VoiceData\")] = 15;\n    values[(valuesById[16] = \"svc_Print\")] = 16;\n    values[(valuesById[17] = \"svc_Sounds\")] = 17;\n    values[(valuesById[18] = \"svc_SetView\")] = 18;\n    values[(valuesById[19] = \"svc_FixAngle\")] = 19;\n    values[(valuesById[20] = \"svc_CrosshairAngle\")] = 20;\n    values[(valuesById[21] = \"svc_BSPDecal\")] = 21;\n    values[(valuesById[22] = \"svc_SplitScreen\")] = 22;\n    values[(valuesById[23] = \"svc_UserMessage\")] = 23;\n    values[(valuesById[24] = \"svc_EntityMessage\")] = 24;\n    values[(valuesById[25] = \"svc_GameEvent\")] = 25;\n    values[(valuesById[26] = \"svc_PacketEntities\")] = 26;\n    values[(valuesById[27] = \"svc_TempEntities\")] = 27;\n    values[(valuesById[28] = \"svc_Prefetch\")] = 28;\n    values[(valuesById[29] = \"svc_Menu\")] = 29;\n    values[(valuesById[30] = \"svc_GameEventList\")] = 30;\n    values[(valuesById[31] = \"svc_GetCvarValue\")] = 31;\n    values[(valuesById[33] = \"svc_PaintmapData\")] = 33;\n    values[(valuesById[34] = \"svc_CmdKeyValues\")] = 34;\n    values[(valuesById[35] = \"svc_EncryptedData\")] = 35;\n    values[(valuesById[36] = \"svc_HltvReplay\")] = 36;\n    return values;\n})();\n/**\n * ReplayEventType_t enum.\n * @exports ReplayEventType_t\n * @enum {string}\n * @property {number} REPLAY_EVENT_CANCEL=0 REPLAY_EVENT_CANCEL value\n * @property {number} REPLAY_EVENT_DEATH=1 REPLAY_EVENT_DEATH value\n * @property {number} REPLAY_EVENT_GENERIC=2 REPLAY_EVENT_GENERIC value\n */\n$root.ReplayEventType_t = (function () {\n    const valuesById = {}, values = Object.create(valuesById);\n    values[(valuesById[0] = \"REPLAY_EVENT_CANCEL\")] = 0;\n    values[(valuesById[1] = \"REPLAY_EVENT_DEATH\")] = 1;\n    values[(valuesById[2] = \"REPLAY_EVENT_GENERIC\")] = 2;\n    return values;\n})();\nexports.CMsgVector = ($root.CMsgVector = (() => {\n    /**\n     * Properties of a CMsgVector.\n     * @exports ICMsgVector\n     * @interface ICMsgVector\n     * @property {number|null} [x] CMsgVector x\n     * @property {number|null} [y] CMsgVector y\n     * @property {number|null} [z] CMsgVector z\n     */\n    /**\n     * Constructs a new CMsgVector.\n     * @exports CMsgVector\n     * @classdesc Represents a CMsgVector.\n     * @implements ICMsgVector\n     * @constructor\n     * @param {ICMsgVector=} [properties] Properties to set\n     */\n    function CMsgVector(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgVector x.\n     * @member {number} x\n     * @memberof CMsgVector\n     * @instance\n     */\n    CMsgVector.prototype.x = 0;\n    /**\n     * CMsgVector y.\n     * @member {number} y\n     * @memberof CMsgVector\n     * @instance\n     */\n    CMsgVector.prototype.y = 0;\n    /**\n     * CMsgVector z.\n     * @member {number} z\n     * @memberof CMsgVector\n     * @instance\n     */\n    CMsgVector.prototype.z = 0;\n    /**\n     * Decodes a CMsgVector message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgVector\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgVector} CMsgVector\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgVector.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgVector();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.x = reader.float();\n                    break;\n                case 2:\n                    message.y = reader.float();\n                    break;\n                case 3:\n                    message.z = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgVector;\n})());\nexports.CMsgVector2D = ($root.CMsgVector2D = (() => {\n    /**\n     * Properties of a CMsgVector2D.\n     * @exports ICMsgVector2D\n     * @interface ICMsgVector2D\n     * @property {number|null} [x] CMsgVector2D x\n     * @property {number|null} [y] CMsgVector2D y\n     */\n    /**\n     * Constructs a new CMsgVector2D.\n     * @exports CMsgVector2D\n     * @classdesc Represents a CMsgVector2D.\n     * @implements ICMsgVector2D\n     * @constructor\n     * @param {ICMsgVector2D=} [properties] Properties to set\n     */\n    function CMsgVector2D(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgVector2D x.\n     * @member {number} x\n     * @memberof CMsgVector2D\n     * @instance\n     */\n    CMsgVector2D.prototype.x = 0;\n    /**\n     * CMsgVector2D y.\n     * @member {number} y\n     * @memberof CMsgVector2D\n     * @instance\n     */\n    CMsgVector2D.prototype.y = 0;\n    /**\n     * Decodes a CMsgVector2D message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgVector2D\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgVector2D} CMsgVector2D\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgVector2D.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgVector2D();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.x = reader.float();\n                    break;\n                case 2:\n                    message.y = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgVector2D;\n})());\nexports.CMsgQAngle = ($root.CMsgQAngle = (() => {\n    /**\n     * Properties of a CMsgQAngle.\n     * @exports ICMsgQAngle\n     * @interface ICMsgQAngle\n     * @property {number|null} [x] CMsgQAngle x\n     * @property {number|null} [y] CMsgQAngle y\n     * @property {number|null} [z] CMsgQAngle z\n     */\n    /**\n     * Constructs a new CMsgQAngle.\n     * @exports CMsgQAngle\n     * @classdesc Represents a CMsgQAngle.\n     * @implements ICMsgQAngle\n     * @constructor\n     * @param {ICMsgQAngle=} [properties] Properties to set\n     */\n    function CMsgQAngle(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgQAngle x.\n     * @member {number} x\n     * @memberof CMsgQAngle\n     * @instance\n     */\n    CMsgQAngle.prototype.x = 0;\n    /**\n     * CMsgQAngle y.\n     * @member {number} y\n     * @memberof CMsgQAngle\n     * @instance\n     */\n    CMsgQAngle.prototype.y = 0;\n    /**\n     * CMsgQAngle z.\n     * @member {number} z\n     * @memberof CMsgQAngle\n     * @instance\n     */\n    CMsgQAngle.prototype.z = 0;\n    /**\n     * Decodes a CMsgQAngle message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgQAngle\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgQAngle} CMsgQAngle\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgQAngle.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgQAngle();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.x = reader.float();\n                    break;\n                case 2:\n                    message.y = reader.float();\n                    break;\n                case 3:\n                    message.z = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgQAngle;\n})());\nexports.CMsgRGBA = ($root.CMsgRGBA = (() => {\n    /**\n     * Properties of a CMsgRGBA.\n     * @exports ICMsgRGBA\n     * @interface ICMsgRGBA\n     * @property {number|null} [r] CMsgRGBA r\n     * @property {number|null} [g] CMsgRGBA g\n     * @property {number|null} [b] CMsgRGBA b\n     * @property {number|null} [a] CMsgRGBA a\n     */\n    /**\n     * Constructs a new CMsgRGBA.\n     * @exports CMsgRGBA\n     * @classdesc Represents a CMsgRGBA.\n     * @implements ICMsgRGBA\n     * @constructor\n     * @param {ICMsgRGBA=} [properties] Properties to set\n     */\n    function CMsgRGBA(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgRGBA r.\n     * @member {number} r\n     * @memberof CMsgRGBA\n     * @instance\n     */\n    CMsgRGBA.prototype.r = 0;\n    /**\n     * CMsgRGBA g.\n     * @member {number} g\n     * @memberof CMsgRGBA\n     * @instance\n     */\n    CMsgRGBA.prototype.g = 0;\n    /**\n     * CMsgRGBA b.\n     * @member {number} b\n     * @memberof CMsgRGBA\n     * @instance\n     */\n    CMsgRGBA.prototype.b = 0;\n    /**\n     * CMsgRGBA a.\n     * @member {number} a\n     * @memberof CMsgRGBA\n     * @instance\n     */\n    CMsgRGBA.prototype.a = 0;\n    /**\n     * Decodes a CMsgRGBA message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgRGBA\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgRGBA} CMsgRGBA\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgRGBA.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgRGBA();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.r = reader.int32();\n                    break;\n                case 2:\n                    message.g = reader.int32();\n                    break;\n                case 3:\n                    message.b = reader.int32();\n                    break;\n                case 4:\n                    message.a = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgRGBA;\n})());\nexports.CNETMsg_Tick = ($root.CNETMsg_Tick = (() => {\n    /**\n     * Properties of a CNETMsg_Tick.\n     * @exports ICNETMsg_Tick\n     * @interface ICNETMsg_Tick\n     * @property {number|null} [tick] CNETMsg_Tick tick\n     * @property {number|null} [hostComputationtime] CNETMsg_Tick hostComputationtime\n     * @property {number|null} [hostComputationtimeStdDeviation] CNETMsg_Tick hostComputationtimeStdDeviation\n     * @property {number|null} [hostFramestarttimeStdDeviation] CNETMsg_Tick hostFramestarttimeStdDeviation\n     * @property {number|null} [hltvReplayFlags] CNETMsg_Tick hltvReplayFlags\n     */\n    /**\n     * Constructs a new CNETMsg_Tick.\n     * @exports CNETMsg_Tick\n     * @classdesc Represents a CNETMsg_Tick.\n     * @implements ICNETMsg_Tick\n     * @constructor\n     * @param {ICNETMsg_Tick=} [properties] Properties to set\n     */\n    function CNETMsg_Tick(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CNETMsg_Tick tick.\n     * @member {number} tick\n     * @memberof CNETMsg_Tick\n     * @instance\n     */\n    CNETMsg_Tick.prototype.tick = 0;\n    /**\n     * CNETMsg_Tick hostComputationtime.\n     * @member {number} hostComputationtime\n     * @memberof CNETMsg_Tick\n     * @instance\n     */\n    CNETMsg_Tick.prototype.hostComputationtime = 0;\n    /**\n     * CNETMsg_Tick hostComputationtimeStdDeviation.\n     * @member {number} hostComputationtimeStdDeviation\n     * @memberof CNETMsg_Tick\n     * @instance\n     */\n    CNETMsg_Tick.prototype.hostComputationtimeStdDeviation = 0;\n    /**\n     * CNETMsg_Tick hostFramestarttimeStdDeviation.\n     * @member {number} hostFramestarttimeStdDeviation\n     * @memberof CNETMsg_Tick\n     * @instance\n     */\n    CNETMsg_Tick.prototype.hostFramestarttimeStdDeviation = 0;\n    /**\n     * CNETMsg_Tick hltvReplayFlags.\n     * @member {number} hltvReplayFlags\n     * @memberof CNETMsg_Tick\n     * @instance\n     */\n    CNETMsg_Tick.prototype.hltvReplayFlags = 0;\n    /**\n     * Decodes a CNETMsg_Tick message from the specified reader or buffer.\n     * @function decode\n     * @memberof CNETMsg_Tick\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CNETMsg_Tick} CNETMsg_Tick\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CNETMsg_Tick.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_Tick();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.tick = reader.uint32();\n                    break;\n                case 4:\n                    message.hostComputationtime = reader.uint32();\n                    break;\n                case 5:\n                    message.hostComputationtimeStdDeviation = reader.uint32();\n                    break;\n                case 6:\n                    message.hostFramestarttimeStdDeviation = reader.uint32();\n                    break;\n                case 7:\n                    message.hltvReplayFlags = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CNETMsg_Tick;\n})());\nexports.CNETMsg_StringCmd = ($root.CNETMsg_StringCmd = (() => {\n    /**\n     * Properties of a CNETMsg_StringCmd.\n     * @exports ICNETMsg_StringCmd\n     * @interface ICNETMsg_StringCmd\n     * @property {string|null} [command] CNETMsg_StringCmd command\n     */\n    /**\n     * Constructs a new CNETMsg_StringCmd.\n     * @exports CNETMsg_StringCmd\n     * @classdesc Represents a CNETMsg_StringCmd.\n     * @implements ICNETMsg_StringCmd\n     * @constructor\n     * @param {ICNETMsg_StringCmd=} [properties] Properties to set\n     */\n    function CNETMsg_StringCmd(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CNETMsg_StringCmd command.\n     * @member {string} command\n     * @memberof CNETMsg_StringCmd\n     * @instance\n     */\n    CNETMsg_StringCmd.prototype.command = \"\";\n    /**\n     * Decodes a CNETMsg_StringCmd message from the specified reader or buffer.\n     * @function decode\n     * @memberof CNETMsg_StringCmd\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CNETMsg_StringCmd} CNETMsg_StringCmd\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CNETMsg_StringCmd.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_StringCmd();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.command = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CNETMsg_StringCmd;\n})());\nexports.CNETMsg_SignonState = ($root.CNETMsg_SignonState = (() => {\n    /**\n     * Properties of a CNETMsg_SignonState.\n     * @exports ICNETMsg_SignonState\n     * @interface ICNETMsg_SignonState\n     * @property {number|null} [signonState] CNETMsg_SignonState signonState\n     * @property {number|null} [spawnCount] CNETMsg_SignonState spawnCount\n     * @property {number|null} [numServerPlayers] CNETMsg_SignonState numServerPlayers\n     * @property {Array.<string>|null} [playersNetworkids] CNETMsg_SignonState playersNetworkids\n     * @property {string|null} [mapName] CNETMsg_SignonState mapName\n     */\n    /**\n     * Constructs a new CNETMsg_SignonState.\n     * @exports CNETMsg_SignonState\n     * @classdesc Represents a CNETMsg_SignonState.\n     * @implements ICNETMsg_SignonState\n     * @constructor\n     * @param {ICNETMsg_SignonState=} [properties] Properties to set\n     */\n    function CNETMsg_SignonState(properties) {\n        this.playersNetworkids = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CNETMsg_SignonState signonState.\n     * @member {number} signonState\n     * @memberof CNETMsg_SignonState\n     * @instance\n     */\n    CNETMsg_SignonState.prototype.signonState = 0;\n    /**\n     * CNETMsg_SignonState spawnCount.\n     * @member {number} spawnCount\n     * @memberof CNETMsg_SignonState\n     * @instance\n     */\n    CNETMsg_SignonState.prototype.spawnCount = 0;\n    /**\n     * CNETMsg_SignonState numServerPlayers.\n     * @member {number} numServerPlayers\n     * @memberof CNETMsg_SignonState\n     * @instance\n     */\n    CNETMsg_SignonState.prototype.numServerPlayers = 0;\n    /**\n     * CNETMsg_SignonState playersNetworkids.\n     * @member {Array.<string>} playersNetworkids\n     * @memberof CNETMsg_SignonState\n     * @instance\n     */\n    CNETMsg_SignonState.prototype.playersNetworkids = $util.emptyArray;\n    /**\n     * CNETMsg_SignonState mapName.\n     * @member {string} mapName\n     * @memberof CNETMsg_SignonState\n     * @instance\n     */\n    CNETMsg_SignonState.prototype.mapName = \"\";\n    /**\n     * Decodes a CNETMsg_SignonState message from the specified reader or buffer.\n     * @function decode\n     * @memberof CNETMsg_SignonState\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CNETMsg_SignonState} CNETMsg_SignonState\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CNETMsg_SignonState.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SignonState();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.signonState = reader.uint32();\n                    break;\n                case 2:\n                    message.spawnCount = reader.uint32();\n                    break;\n                case 3:\n                    message.numServerPlayers = reader.uint32();\n                    break;\n                case 4:\n                    if (!(message.playersNetworkids && message.playersNetworkids.length))\n                        message.playersNetworkids = [];\n                    message.playersNetworkids.push(reader.string());\n                    break;\n                case 5:\n                    message.mapName = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CNETMsg_SignonState;\n})());\nexports.CMsg_CVars = ($root.CMsg_CVars = (() => {\n    /**\n     * Properties of a CMsg_CVars.\n     * @exports ICMsg_CVars\n     * @interface ICMsg_CVars\n     * @property {Array.<CMsg_CVars.ICVar>|null} [cvars] CMsg_CVars cvars\n     */\n    /**\n     * Constructs a new CMsg_CVars.\n     * @exports CMsg_CVars\n     * @classdesc Represents a CMsg_CVars.\n     * @implements ICMsg_CVars\n     * @constructor\n     * @param {ICMsg_CVars=} [properties] Properties to set\n     */\n    function CMsg_CVars(properties) {\n        this.cvars = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsg_CVars cvars.\n     * @member {Array.<CMsg_CVars.ICVar>} cvars\n     * @memberof CMsg_CVars\n     * @instance\n     */\n    CMsg_CVars.prototype.cvars = $util.emptyArray;\n    /**\n     * Decodes a CMsg_CVars message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsg_CVars\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsg_CVars} CMsg_CVars\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsg_CVars.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsg_CVars();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.cvars && message.cvars.length))\n                        message.cvars = [];\n                    message.cvars.push($root.CMsg_CVars.CVar.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CMsg_CVars.CVar = (function () {\n        /**\n         * Properties of a CVar.\n         * @memberof CMsg_CVars\n         * @interface ICVar\n         * @property {string|null} [name] CVar name\n         * @property {string|null} [value] CVar value\n         * @property {number|null} [dictionaryName] CVar dictionaryName\n         */\n        /**\n         * Constructs a new CVar.\n         * @memberof CMsg_CVars\n         * @classdesc Represents a CVar.\n         * @implements ICVar\n         * @constructor\n         * @param {CMsg_CVars.ICVar=} [properties] Properties to set\n         */\n        function CVar(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * CVar name.\n         * @member {string} name\n         * @memberof CMsg_CVars.CVar\n         * @instance\n         */\n        CVar.prototype.name = \"\";\n        /**\n         * CVar value.\n         * @member {string} value\n         * @memberof CMsg_CVars.CVar\n         * @instance\n         */\n        CVar.prototype.value = \"\";\n        /**\n         * CVar dictionaryName.\n         * @member {number} dictionaryName\n         * @memberof CMsg_CVars.CVar\n         * @instance\n         */\n        CVar.prototype.dictionaryName = 0;\n        /**\n         * Decodes a CVar message from the specified reader or buffer.\n         * @function decode\n         * @memberof CMsg_CVars.CVar\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CMsg_CVars.CVar} CVar\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        CVar.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsg_CVars.CVar();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.name = reader.string();\n                        break;\n                    case 2:\n                        message.value = reader.string();\n                        break;\n                    case 3:\n                        message.dictionaryName = reader.uint32();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return CVar;\n    })();\n    return CMsg_CVars;\n})());\nexports.CNETMsg_SetConVar = ($root.CNETMsg_SetConVar = (() => {\n    /**\n     * Properties of a CNETMsg_SetConVar.\n     * @exports ICNETMsg_SetConVar\n     * @interface ICNETMsg_SetConVar\n     * @property {ICMsg_CVars|null} [convars] CNETMsg_SetConVar convars\n     */\n    /**\n     * Constructs a new CNETMsg_SetConVar.\n     * @exports CNETMsg_SetConVar\n     * @classdesc Represents a CNETMsg_SetConVar.\n     * @implements ICNETMsg_SetConVar\n     * @constructor\n     * @param {ICNETMsg_SetConVar=} [properties] Properties to set\n     */\n    function CNETMsg_SetConVar(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CNETMsg_SetConVar convars.\n     * @member {ICMsg_CVars|null|undefined} convars\n     * @memberof CNETMsg_SetConVar\n     * @instance\n     */\n    CNETMsg_SetConVar.prototype.convars = null;\n    /**\n     * Decodes a CNETMsg_SetConVar message from the specified reader or buffer.\n     * @function decode\n     * @memberof CNETMsg_SetConVar\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CNETMsg_SetConVar} CNETMsg_SetConVar\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CNETMsg_SetConVar.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SetConVar();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.convars = $root.CMsg_CVars.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CNETMsg_SetConVar;\n})());\nexports.CNETMsg_NOP = ($root.CNETMsg_NOP = (() => {\n    /**\n     * Properties of a CNETMsg_NOP.\n     * @exports ICNETMsg_NOP\n     * @interface ICNETMsg_NOP\n     */\n    /**\n     * Constructs a new CNETMsg_NOP.\n     * @exports CNETMsg_NOP\n     * @classdesc Represents a CNETMsg_NOP.\n     * @implements ICNETMsg_NOP\n     * @constructor\n     * @param {ICNETMsg_NOP=} [properties] Properties to set\n     */\n    function CNETMsg_NOP(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Decodes a CNETMsg_NOP message from the specified reader or buffer.\n     * @function decode\n     * @memberof CNETMsg_NOP\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CNETMsg_NOP} CNETMsg_NOP\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CNETMsg_NOP.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_NOP();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CNETMsg_NOP;\n})());\nexports.CNETMsg_Disconnect = ($root.CNETMsg_Disconnect = (() => {\n    /**\n     * Properties of a CNETMsg_Disconnect.\n     * @exports ICNETMsg_Disconnect\n     * @interface ICNETMsg_Disconnect\n     * @property {string|null} [text] CNETMsg_Disconnect text\n     */\n    /**\n     * Constructs a new CNETMsg_Disconnect.\n     * @exports CNETMsg_Disconnect\n     * @classdesc Represents a CNETMsg_Disconnect.\n     * @implements ICNETMsg_Disconnect\n     * @constructor\n     * @param {ICNETMsg_Disconnect=} [properties] Properties to set\n     */\n    function CNETMsg_Disconnect(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CNETMsg_Disconnect text.\n     * @member {string} text\n     * @memberof CNETMsg_Disconnect\n     * @instance\n     */\n    CNETMsg_Disconnect.prototype.text = \"\";\n    /**\n     * Decodes a CNETMsg_Disconnect message from the specified reader or buffer.\n     * @function decode\n     * @memberof CNETMsg_Disconnect\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CNETMsg_Disconnect} CNETMsg_Disconnect\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CNETMsg_Disconnect.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_Disconnect();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.text = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CNETMsg_Disconnect;\n})());\nexports.CNETMsg_File = ($root.CNETMsg_File = (() => {\n    /**\n     * Properties of a CNETMsg_File.\n     * @exports ICNETMsg_File\n     * @interface ICNETMsg_File\n     * @property {number|null} [transferId] CNETMsg_File transferId\n     * @property {string|null} [fileName] CNETMsg_File fileName\n     * @property {boolean|null} [isReplayDemoFile] CNETMsg_File isReplayDemoFile\n     * @property {boolean|null} [deny] CNETMsg_File deny\n     */\n    /**\n     * Constructs a new CNETMsg_File.\n     * @exports CNETMsg_File\n     * @classdesc Represents a CNETMsg_File.\n     * @implements ICNETMsg_File\n     * @constructor\n     * @param {ICNETMsg_File=} [properties] Properties to set\n     */\n    function CNETMsg_File(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CNETMsg_File transferId.\n     * @member {number} transferId\n     * @memberof CNETMsg_File\n     * @instance\n     */\n    CNETMsg_File.prototype.transferId = 0;\n    /**\n     * CNETMsg_File fileName.\n     * @member {string} fileName\n     * @memberof CNETMsg_File\n     * @instance\n     */\n    CNETMsg_File.prototype.fileName = \"\";\n    /**\n     * CNETMsg_File isReplayDemoFile.\n     * @member {boolean} isReplayDemoFile\n     * @memberof CNETMsg_File\n     * @instance\n     */\n    CNETMsg_File.prototype.isReplayDemoFile = false;\n    /**\n     * CNETMsg_File deny.\n     * @member {boolean} deny\n     * @memberof CNETMsg_File\n     * @instance\n     */\n    CNETMsg_File.prototype.deny = false;\n    /**\n     * Decodes a CNETMsg_File message from the specified reader or buffer.\n     * @function decode\n     * @memberof CNETMsg_File\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CNETMsg_File} CNETMsg_File\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CNETMsg_File.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_File();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.transferId = reader.int32();\n                    break;\n                case 2:\n                    message.fileName = reader.string();\n                    break;\n                case 3:\n                    message.isReplayDemoFile = reader.bool();\n                    break;\n                case 4:\n                    message.deny = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CNETMsg_File;\n})());\nexports.CNETMsg_SplitScreenUser = ($root.CNETMsg_SplitScreenUser = (() => {\n    /**\n     * Properties of a CNETMsg_SplitScreenUser.\n     * @exports ICNETMsg_SplitScreenUser\n     * @interface ICNETMsg_SplitScreenUser\n     * @property {number|null} [slot] CNETMsg_SplitScreenUser slot\n     */\n    /**\n     * Constructs a new CNETMsg_SplitScreenUser.\n     * @exports CNETMsg_SplitScreenUser\n     * @classdesc Represents a CNETMsg_SplitScreenUser.\n     * @implements ICNETMsg_SplitScreenUser\n     * @constructor\n     * @param {ICNETMsg_SplitScreenUser=} [properties] Properties to set\n     */\n    function CNETMsg_SplitScreenUser(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CNETMsg_SplitScreenUser slot.\n     * @member {number} slot\n     * @memberof CNETMsg_SplitScreenUser\n     * @instance\n     */\n    CNETMsg_SplitScreenUser.prototype.slot = 0;\n    /**\n     * Decodes a CNETMsg_SplitScreenUser message from the specified reader or buffer.\n     * @function decode\n     * @memberof CNETMsg_SplitScreenUser\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CNETMsg_SplitScreenUser} CNETMsg_SplitScreenUser\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CNETMsg_SplitScreenUser.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_SplitScreenUser();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.slot = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CNETMsg_SplitScreenUser;\n})());\nexports.CNETMsg_PlayerAvatarData = ($root.CNETMsg_PlayerAvatarData = (() => {\n    /**\n     * Properties of a CNETMsg_PlayerAvatarData.\n     * @exports ICNETMsg_PlayerAvatarData\n     * @interface ICNETMsg_PlayerAvatarData\n     * @property {number|null} [accountid] CNETMsg_PlayerAvatarData accountid\n     * @property {Uint8Array|null} [rgb] CNETMsg_PlayerAvatarData rgb\n     */\n    /**\n     * Constructs a new CNETMsg_PlayerAvatarData.\n     * @exports CNETMsg_PlayerAvatarData\n     * @classdesc Represents a CNETMsg_PlayerAvatarData.\n     * @implements ICNETMsg_PlayerAvatarData\n     * @constructor\n     * @param {ICNETMsg_PlayerAvatarData=} [properties] Properties to set\n     */\n    function CNETMsg_PlayerAvatarData(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CNETMsg_PlayerAvatarData accountid.\n     * @member {number} accountid\n     * @memberof CNETMsg_PlayerAvatarData\n     * @instance\n     */\n    CNETMsg_PlayerAvatarData.prototype.accountid = 0;\n    /**\n     * CNETMsg_PlayerAvatarData rgb.\n     * @member {Uint8Array} rgb\n     * @memberof CNETMsg_PlayerAvatarData\n     * @instance\n     */\n    CNETMsg_PlayerAvatarData.prototype.rgb = $util.newBuffer([]);\n    /**\n     * Decodes a CNETMsg_PlayerAvatarData message from the specified reader or buffer.\n     * @function decode\n     * @memberof CNETMsg_PlayerAvatarData\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CNETMsg_PlayerAvatarData} CNETMsg_PlayerAvatarData\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CNETMsg_PlayerAvatarData.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CNETMsg_PlayerAvatarData();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.accountid = reader.uint32();\n                    break;\n                case 2:\n                    message.rgb = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CNETMsg_PlayerAvatarData;\n})());\nexports.CCLCMsg_ClientInfo = ($root.CCLCMsg_ClientInfo = (() => {\n    /**\n     * Properties of a CCLCMsg_ClientInfo.\n     * @exports ICCLCMsg_ClientInfo\n     * @interface ICCLCMsg_ClientInfo\n     * @property {number|null} [sendTableCrc] CCLCMsg_ClientInfo sendTableCrc\n     * @property {number|null} [serverCount] CCLCMsg_ClientInfo serverCount\n     * @property {boolean|null} [isHltv] CCLCMsg_ClientInfo isHltv\n     * @property {boolean|null} [isReplay] CCLCMsg_ClientInfo isReplay\n     * @property {number|null} [friendsId] CCLCMsg_ClientInfo friendsId\n     * @property {string|null} [friendsName] CCLCMsg_ClientInfo friendsName\n     * @property {Array.<number>|null} [customFiles] CCLCMsg_ClientInfo customFiles\n     */\n    /**\n     * Constructs a new CCLCMsg_ClientInfo.\n     * @exports CCLCMsg_ClientInfo\n     * @classdesc Represents a CCLCMsg_ClientInfo.\n     * @implements ICCLCMsg_ClientInfo\n     * @constructor\n     * @param {ICCLCMsg_ClientInfo=} [properties] Properties to set\n     */\n    function CCLCMsg_ClientInfo(properties) {\n        this.customFiles = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCLCMsg_ClientInfo sendTableCrc.\n     * @member {number} sendTableCrc\n     * @memberof CCLCMsg_ClientInfo\n     * @instance\n     */\n    CCLCMsg_ClientInfo.prototype.sendTableCrc = 0;\n    /**\n     * CCLCMsg_ClientInfo serverCount.\n     * @member {number} serverCount\n     * @memberof CCLCMsg_ClientInfo\n     * @instance\n     */\n    CCLCMsg_ClientInfo.prototype.serverCount = 0;\n    /**\n     * CCLCMsg_ClientInfo isHltv.\n     * @member {boolean} isHltv\n     * @memberof CCLCMsg_ClientInfo\n     * @instance\n     */\n    CCLCMsg_ClientInfo.prototype.isHltv = false;\n    /**\n     * CCLCMsg_ClientInfo isReplay.\n     * @member {boolean} isReplay\n     * @memberof CCLCMsg_ClientInfo\n     * @instance\n     */\n    CCLCMsg_ClientInfo.prototype.isReplay = false;\n    /**\n     * CCLCMsg_ClientInfo friendsId.\n     * @member {number} friendsId\n     * @memberof CCLCMsg_ClientInfo\n     * @instance\n     */\n    CCLCMsg_ClientInfo.prototype.friendsId = 0;\n    /**\n     * CCLCMsg_ClientInfo friendsName.\n     * @member {string} friendsName\n     * @memberof CCLCMsg_ClientInfo\n     * @instance\n     */\n    CCLCMsg_ClientInfo.prototype.friendsName = \"\";\n    /**\n     * CCLCMsg_ClientInfo customFiles.\n     * @member {Array.<number>} customFiles\n     * @memberof CCLCMsg_ClientInfo\n     * @instance\n     */\n    CCLCMsg_ClientInfo.prototype.customFiles = $util.emptyArray;\n    /**\n     * Decodes a CCLCMsg_ClientInfo message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCLCMsg_ClientInfo\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCLCMsg_ClientInfo} CCLCMsg_ClientInfo\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCLCMsg_ClientInfo.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_ClientInfo();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.sendTableCrc = reader.fixed32();\n                    break;\n                case 2:\n                    message.serverCount = reader.uint32();\n                    break;\n                case 3:\n                    message.isHltv = reader.bool();\n                    break;\n                case 4:\n                    message.isReplay = reader.bool();\n                    break;\n                case 5:\n                    message.friendsId = reader.uint32();\n                    break;\n                case 6:\n                    message.friendsName = reader.string();\n                    break;\n                case 7:\n                    if (!(message.customFiles && message.customFiles.length))\n                        message.customFiles = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.customFiles.push(reader.fixed32());\n                    }\n                    else\n                        message.customFiles.push(reader.fixed32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCLCMsg_ClientInfo;\n})());\nexports.CCLCMsg_Move = ($root.CCLCMsg_Move = (() => {\n    /**\n     * Properties of a CCLCMsg_Move.\n     * @exports ICCLCMsg_Move\n     * @interface ICCLCMsg_Move\n     * @property {number|null} [numBackupCommands] CCLCMsg_Move numBackupCommands\n     * @property {number|null} [numNewCommands] CCLCMsg_Move numNewCommands\n     * @property {Uint8Array|null} [data] CCLCMsg_Move data\n     */\n    /**\n     * Constructs a new CCLCMsg_Move.\n     * @exports CCLCMsg_Move\n     * @classdesc Represents a CCLCMsg_Move.\n     * @implements ICCLCMsg_Move\n     * @constructor\n     * @param {ICCLCMsg_Move=} [properties] Properties to set\n     */\n    function CCLCMsg_Move(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCLCMsg_Move numBackupCommands.\n     * @member {number} numBackupCommands\n     * @memberof CCLCMsg_Move\n     * @instance\n     */\n    CCLCMsg_Move.prototype.numBackupCommands = 0;\n    /**\n     * CCLCMsg_Move numNewCommands.\n     * @member {number} numNewCommands\n     * @memberof CCLCMsg_Move\n     * @instance\n     */\n    CCLCMsg_Move.prototype.numNewCommands = 0;\n    /**\n     * CCLCMsg_Move data.\n     * @member {Uint8Array} data\n     * @memberof CCLCMsg_Move\n     * @instance\n     */\n    CCLCMsg_Move.prototype.data = $util.newBuffer([]);\n    /**\n     * Decodes a CCLCMsg_Move message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCLCMsg_Move\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCLCMsg_Move} CCLCMsg_Move\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCLCMsg_Move.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_Move();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.numBackupCommands = reader.uint32();\n                    break;\n                case 2:\n                    message.numNewCommands = reader.uint32();\n                    break;\n                case 3:\n                    message.data = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCLCMsg_Move;\n})());\nexports.CCLCMsg_VoiceData = ($root.CCLCMsg_VoiceData = (() => {\n    /**\n     * Properties of a CCLCMsg_VoiceData.\n     * @exports ICCLCMsg_VoiceData\n     * @interface ICCLCMsg_VoiceData\n     * @property {Uint8Array|null} [data] CCLCMsg_VoiceData data\n     * @property {number|Long|null} [xuid] CCLCMsg_VoiceData xuid\n     * @property {VoiceDataFormat_t|null} [format] CCLCMsg_VoiceData format\n     * @property {number|null} [sequenceBytes] CCLCMsg_VoiceData sequenceBytes\n     * @property {number|null} [sectionNumber] CCLCMsg_VoiceData sectionNumber\n     * @property {number|null} [uncompressedSampleOffset] CCLCMsg_VoiceData uncompressedSampleOffset\n     */\n    /**\n     * Constructs a new CCLCMsg_VoiceData.\n     * @exports CCLCMsg_VoiceData\n     * @classdesc Represents a CCLCMsg_VoiceData.\n     * @implements ICCLCMsg_VoiceData\n     * @constructor\n     * @param {ICCLCMsg_VoiceData=} [properties] Properties to set\n     */\n    function CCLCMsg_VoiceData(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCLCMsg_VoiceData data.\n     * @member {Uint8Array} data\n     * @memberof CCLCMsg_VoiceData\n     * @instance\n     */\n    CCLCMsg_VoiceData.prototype.data = $util.newBuffer([]);\n    /**\n     * CCLCMsg_VoiceData xuid.\n     * @member {number|Long} xuid\n     * @memberof CCLCMsg_VoiceData\n     * @instance\n     */\n    CCLCMsg_VoiceData.prototype.xuid = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0;\n    /**\n     * CCLCMsg_VoiceData format.\n     * @member {VoiceDataFormat_t} format\n     * @memberof CCLCMsg_VoiceData\n     * @instance\n     */\n    CCLCMsg_VoiceData.prototype.format = 1;\n    /**\n     * CCLCMsg_VoiceData sequenceBytes.\n     * @member {number} sequenceBytes\n     * @memberof CCLCMsg_VoiceData\n     * @instance\n     */\n    CCLCMsg_VoiceData.prototype.sequenceBytes = 0;\n    /**\n     * CCLCMsg_VoiceData sectionNumber.\n     * @member {number} sectionNumber\n     * @memberof CCLCMsg_VoiceData\n     * @instance\n     */\n    CCLCMsg_VoiceData.prototype.sectionNumber = 0;\n    /**\n     * CCLCMsg_VoiceData uncompressedSampleOffset.\n     * @member {number} uncompressedSampleOffset\n     * @memberof CCLCMsg_VoiceData\n     * @instance\n     */\n    CCLCMsg_VoiceData.prototype.uncompressedSampleOffset = 0;\n    /**\n     * Decodes a CCLCMsg_VoiceData message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCLCMsg_VoiceData\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCLCMsg_VoiceData} CCLCMsg_VoiceData\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCLCMsg_VoiceData.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_VoiceData();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.data = reader.bytes();\n                    break;\n                case 2:\n                    message.xuid = reader.fixed64();\n                    break;\n                case 3:\n                    message.format = reader.int32();\n                    break;\n                case 4:\n                    message.sequenceBytes = reader.int32();\n                    break;\n                case 5:\n                    message.sectionNumber = reader.uint32();\n                    break;\n                case 6:\n                    message.uncompressedSampleOffset = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCLCMsg_VoiceData;\n})());\nexports.CCLCMsg_BaselineAck = ($root.CCLCMsg_BaselineAck = (() => {\n    /**\n     * Properties of a CCLCMsg_BaselineAck.\n     * @exports ICCLCMsg_BaselineAck\n     * @interface ICCLCMsg_BaselineAck\n     * @property {number|null} [baselineTick] CCLCMsg_BaselineAck baselineTick\n     * @property {number|null} [baselineNr] CCLCMsg_BaselineAck baselineNr\n     */\n    /**\n     * Constructs a new CCLCMsg_BaselineAck.\n     * @exports CCLCMsg_BaselineAck\n     * @classdesc Represents a CCLCMsg_BaselineAck.\n     * @implements ICCLCMsg_BaselineAck\n     * @constructor\n     * @param {ICCLCMsg_BaselineAck=} [properties] Properties to set\n     */\n    function CCLCMsg_BaselineAck(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCLCMsg_BaselineAck baselineTick.\n     * @member {number} baselineTick\n     * @memberof CCLCMsg_BaselineAck\n     * @instance\n     */\n    CCLCMsg_BaselineAck.prototype.baselineTick = 0;\n    /**\n     * CCLCMsg_BaselineAck baselineNr.\n     * @member {number} baselineNr\n     * @memberof CCLCMsg_BaselineAck\n     * @instance\n     */\n    CCLCMsg_BaselineAck.prototype.baselineNr = 0;\n    /**\n     * Decodes a CCLCMsg_BaselineAck message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCLCMsg_BaselineAck\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCLCMsg_BaselineAck} CCLCMsg_BaselineAck\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCLCMsg_BaselineAck.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_BaselineAck();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.baselineTick = reader.int32();\n                    break;\n                case 2:\n                    message.baselineNr = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCLCMsg_BaselineAck;\n})());\nexports.CCLCMsg_ListenEvents = ($root.CCLCMsg_ListenEvents = (() => {\n    /**\n     * Properties of a CCLCMsg_ListenEvents.\n     * @exports ICCLCMsg_ListenEvents\n     * @interface ICCLCMsg_ListenEvents\n     * @property {Array.<number>|null} [eventMask] CCLCMsg_ListenEvents eventMask\n     */\n    /**\n     * Constructs a new CCLCMsg_ListenEvents.\n     * @exports CCLCMsg_ListenEvents\n     * @classdesc Represents a CCLCMsg_ListenEvents.\n     * @implements ICCLCMsg_ListenEvents\n     * @constructor\n     * @param {ICCLCMsg_ListenEvents=} [properties] Properties to set\n     */\n    function CCLCMsg_ListenEvents(properties) {\n        this.eventMask = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCLCMsg_ListenEvents eventMask.\n     * @member {Array.<number>} eventMask\n     * @memberof CCLCMsg_ListenEvents\n     * @instance\n     */\n    CCLCMsg_ListenEvents.prototype.eventMask = $util.emptyArray;\n    /**\n     * Decodes a CCLCMsg_ListenEvents message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCLCMsg_ListenEvents\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCLCMsg_ListenEvents} CCLCMsg_ListenEvents\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCLCMsg_ListenEvents.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_ListenEvents();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.eventMask && message.eventMask.length))\n                        message.eventMask = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.eventMask.push(reader.fixed32());\n                    }\n                    else\n                        message.eventMask.push(reader.fixed32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCLCMsg_ListenEvents;\n})());\nexports.CCLCMsg_RespondCvarValue = ($root.CCLCMsg_RespondCvarValue = (() => {\n    /**\n     * Properties of a CCLCMsg_RespondCvarValue.\n     * @exports ICCLCMsg_RespondCvarValue\n     * @interface ICCLCMsg_RespondCvarValue\n     * @property {number|null} [cookie] CCLCMsg_RespondCvarValue cookie\n     * @property {number|null} [statusCode] CCLCMsg_RespondCvarValue statusCode\n     * @property {string|null} [name] CCLCMsg_RespondCvarValue name\n     * @property {string|null} [value] CCLCMsg_RespondCvarValue value\n     */\n    /**\n     * Constructs a new CCLCMsg_RespondCvarValue.\n     * @exports CCLCMsg_RespondCvarValue\n     * @classdesc Represents a CCLCMsg_RespondCvarValue.\n     * @implements ICCLCMsg_RespondCvarValue\n     * @constructor\n     * @param {ICCLCMsg_RespondCvarValue=} [properties] Properties to set\n     */\n    function CCLCMsg_RespondCvarValue(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCLCMsg_RespondCvarValue cookie.\n     * @member {number} cookie\n     * @memberof CCLCMsg_RespondCvarValue\n     * @instance\n     */\n    CCLCMsg_RespondCvarValue.prototype.cookie = 0;\n    /**\n     * CCLCMsg_RespondCvarValue statusCode.\n     * @member {number} statusCode\n     * @memberof CCLCMsg_RespondCvarValue\n     * @instance\n     */\n    CCLCMsg_RespondCvarValue.prototype.statusCode = 0;\n    /**\n     * CCLCMsg_RespondCvarValue name.\n     * @member {string} name\n     * @memberof CCLCMsg_RespondCvarValue\n     * @instance\n     */\n    CCLCMsg_RespondCvarValue.prototype.name = \"\";\n    /**\n     * CCLCMsg_RespondCvarValue value.\n     * @member {string} value\n     * @memberof CCLCMsg_RespondCvarValue\n     * @instance\n     */\n    CCLCMsg_RespondCvarValue.prototype.value = \"\";\n    /**\n     * Decodes a CCLCMsg_RespondCvarValue message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCLCMsg_RespondCvarValue\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCLCMsg_RespondCvarValue} CCLCMsg_RespondCvarValue\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCLCMsg_RespondCvarValue.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_RespondCvarValue();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.cookie = reader.int32();\n                    break;\n                case 2:\n                    message.statusCode = reader.int32();\n                    break;\n                case 3:\n                    message.name = reader.string();\n                    break;\n                case 4:\n                    message.value = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCLCMsg_RespondCvarValue;\n})());\nexports.CCLCMsg_FileCRCCheck = ($root.CCLCMsg_FileCRCCheck = (() => {\n    /**\n     * Properties of a CCLCMsg_FileCRCCheck.\n     * @exports ICCLCMsg_FileCRCCheck\n     * @interface ICCLCMsg_FileCRCCheck\n     * @property {number|null} [codePath] CCLCMsg_FileCRCCheck codePath\n     * @property {string|null} [path] CCLCMsg_FileCRCCheck path\n     * @property {number|null} [codeFilename] CCLCMsg_FileCRCCheck codeFilename\n     * @property {string|null} [filename] CCLCMsg_FileCRCCheck filename\n     * @property {number|null} [fileFraction] CCLCMsg_FileCRCCheck fileFraction\n     * @property {Uint8Array|null} [md5] CCLCMsg_FileCRCCheck md5\n     * @property {number|null} [crc] CCLCMsg_FileCRCCheck crc\n     * @property {number|null} [fileHashType] CCLCMsg_FileCRCCheck fileHashType\n     * @property {number|null} [fileLen] CCLCMsg_FileCRCCheck fileLen\n     * @property {number|null} [packFileId] CCLCMsg_FileCRCCheck packFileId\n     * @property {number|null} [packFileNumber] CCLCMsg_FileCRCCheck packFileNumber\n     */\n    /**\n     * Constructs a new CCLCMsg_FileCRCCheck.\n     * @exports CCLCMsg_FileCRCCheck\n     * @classdesc Represents a CCLCMsg_FileCRCCheck.\n     * @implements ICCLCMsg_FileCRCCheck\n     * @constructor\n     * @param {ICCLCMsg_FileCRCCheck=} [properties] Properties to set\n     */\n    function CCLCMsg_FileCRCCheck(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCLCMsg_FileCRCCheck codePath.\n     * @member {number} codePath\n     * @memberof CCLCMsg_FileCRCCheck\n     * @instance\n     */\n    CCLCMsg_FileCRCCheck.prototype.codePath = 0;\n    /**\n     * CCLCMsg_FileCRCCheck path.\n     * @member {string} path\n     * @memberof CCLCMsg_FileCRCCheck\n     * @instance\n     */\n    CCLCMsg_FileCRCCheck.prototype.path = \"\";\n    /**\n     * CCLCMsg_FileCRCCheck codeFilename.\n     * @member {number} codeFilename\n     * @memberof CCLCMsg_FileCRCCheck\n     * @instance\n     */\n    CCLCMsg_FileCRCCheck.prototype.codeFilename = 0;\n    /**\n     * CCLCMsg_FileCRCCheck filename.\n     * @member {string} filename\n     * @memberof CCLCMsg_FileCRCCheck\n     * @instance\n     */\n    CCLCMsg_FileCRCCheck.prototype.filename = \"\";\n    /**\n     * CCLCMsg_FileCRCCheck fileFraction.\n     * @member {number} fileFraction\n     * @memberof CCLCMsg_FileCRCCheck\n     * @instance\n     */\n    CCLCMsg_FileCRCCheck.prototype.fileFraction = 0;\n    /**\n     * CCLCMsg_FileCRCCheck md5.\n     * @member {Uint8Array} md5\n     * @memberof CCLCMsg_FileCRCCheck\n     * @instance\n     */\n    CCLCMsg_FileCRCCheck.prototype.md5 = $util.newBuffer([]);\n    /**\n     * CCLCMsg_FileCRCCheck crc.\n     * @member {number} crc\n     * @memberof CCLCMsg_FileCRCCheck\n     * @instance\n     */\n    CCLCMsg_FileCRCCheck.prototype.crc = 0;\n    /**\n     * CCLCMsg_FileCRCCheck fileHashType.\n     * @member {number} fileHashType\n     * @memberof CCLCMsg_FileCRCCheck\n     * @instance\n     */\n    CCLCMsg_FileCRCCheck.prototype.fileHashType = 0;\n    /**\n     * CCLCMsg_FileCRCCheck fileLen.\n     * @member {number} fileLen\n     * @memberof CCLCMsg_FileCRCCheck\n     * @instance\n     */\n    CCLCMsg_FileCRCCheck.prototype.fileLen = 0;\n    /**\n     * CCLCMsg_FileCRCCheck packFileId.\n     * @member {number} packFileId\n     * @memberof CCLCMsg_FileCRCCheck\n     * @instance\n     */\n    CCLCMsg_FileCRCCheck.prototype.packFileId = 0;\n    /**\n     * CCLCMsg_FileCRCCheck packFileNumber.\n     * @member {number} packFileNumber\n     * @memberof CCLCMsg_FileCRCCheck\n     * @instance\n     */\n    CCLCMsg_FileCRCCheck.prototype.packFileNumber = 0;\n    /**\n     * Decodes a CCLCMsg_FileCRCCheck message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCLCMsg_FileCRCCheck\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCLCMsg_FileCRCCheck} CCLCMsg_FileCRCCheck\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCLCMsg_FileCRCCheck.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_FileCRCCheck();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.codePath = reader.int32();\n                    break;\n                case 2:\n                    message.path = reader.string();\n                    break;\n                case 3:\n                    message.codeFilename = reader.int32();\n                    break;\n                case 4:\n                    message.filename = reader.string();\n                    break;\n                case 5:\n                    message.fileFraction = reader.int32();\n                    break;\n                case 6:\n                    message.md5 = reader.bytes();\n                    break;\n                case 7:\n                    message.crc = reader.uint32();\n                    break;\n                case 8:\n                    message.fileHashType = reader.int32();\n                    break;\n                case 9:\n                    message.fileLen = reader.int32();\n                    break;\n                case 10:\n                    message.packFileId = reader.int32();\n                    break;\n                case 11:\n                    message.packFileNumber = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCLCMsg_FileCRCCheck;\n})());\nexports.CCLCMsg_LoadingProgress = ($root.CCLCMsg_LoadingProgress = (() => {\n    /**\n     * Properties of a CCLCMsg_LoadingProgress.\n     * @exports ICCLCMsg_LoadingProgress\n     * @interface ICCLCMsg_LoadingProgress\n     * @property {number|null} [progress] CCLCMsg_LoadingProgress progress\n     */\n    /**\n     * Constructs a new CCLCMsg_LoadingProgress.\n     * @exports CCLCMsg_LoadingProgress\n     * @classdesc Represents a CCLCMsg_LoadingProgress.\n     * @implements ICCLCMsg_LoadingProgress\n     * @constructor\n     * @param {ICCLCMsg_LoadingProgress=} [properties] Properties to set\n     */\n    function CCLCMsg_LoadingProgress(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCLCMsg_LoadingProgress progress.\n     * @member {number} progress\n     * @memberof CCLCMsg_LoadingProgress\n     * @instance\n     */\n    CCLCMsg_LoadingProgress.prototype.progress = 0;\n    /**\n     * Decodes a CCLCMsg_LoadingProgress message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCLCMsg_LoadingProgress\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCLCMsg_LoadingProgress} CCLCMsg_LoadingProgress\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCLCMsg_LoadingProgress.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_LoadingProgress();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.progress = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCLCMsg_LoadingProgress;\n})());\nexports.CCLCMsg_SplitPlayerConnect = ($root.CCLCMsg_SplitPlayerConnect = (() => {\n    /**\n     * Properties of a CCLCMsg_SplitPlayerConnect.\n     * @exports ICCLCMsg_SplitPlayerConnect\n     * @interface ICCLCMsg_SplitPlayerConnect\n     * @property {ICMsg_CVars|null} [convars] CCLCMsg_SplitPlayerConnect convars\n     */\n    /**\n     * Constructs a new CCLCMsg_SplitPlayerConnect.\n     * @exports CCLCMsg_SplitPlayerConnect\n     * @classdesc Represents a CCLCMsg_SplitPlayerConnect.\n     * @implements ICCLCMsg_SplitPlayerConnect\n     * @constructor\n     * @param {ICCLCMsg_SplitPlayerConnect=} [properties] Properties to set\n     */\n    function CCLCMsg_SplitPlayerConnect(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCLCMsg_SplitPlayerConnect convars.\n     * @member {ICMsg_CVars|null|undefined} convars\n     * @memberof CCLCMsg_SplitPlayerConnect\n     * @instance\n     */\n    CCLCMsg_SplitPlayerConnect.prototype.convars = null;\n    /**\n     * Decodes a CCLCMsg_SplitPlayerConnect message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCLCMsg_SplitPlayerConnect\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCLCMsg_SplitPlayerConnect} CCLCMsg_SplitPlayerConnect\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCLCMsg_SplitPlayerConnect.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_SplitPlayerConnect();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.convars = $root.CMsg_CVars.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCLCMsg_SplitPlayerConnect;\n})());\nexports.CCLCMsg_CmdKeyValues = ($root.CCLCMsg_CmdKeyValues = (() => {\n    /**\n     * Properties of a CCLCMsg_CmdKeyValues.\n     * @exports ICCLCMsg_CmdKeyValues\n     * @interface ICCLCMsg_CmdKeyValues\n     * @property {Uint8Array|null} [keyvalues] CCLCMsg_CmdKeyValues keyvalues\n     */\n    /**\n     * Constructs a new CCLCMsg_CmdKeyValues.\n     * @exports CCLCMsg_CmdKeyValues\n     * @classdesc Represents a CCLCMsg_CmdKeyValues.\n     * @implements ICCLCMsg_CmdKeyValues\n     * @constructor\n     * @param {ICCLCMsg_CmdKeyValues=} [properties] Properties to set\n     */\n    function CCLCMsg_CmdKeyValues(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCLCMsg_CmdKeyValues keyvalues.\n     * @member {Uint8Array} keyvalues\n     * @memberof CCLCMsg_CmdKeyValues\n     * @instance\n     */\n    CCLCMsg_CmdKeyValues.prototype.keyvalues = $util.newBuffer([]);\n    /**\n     * Decodes a CCLCMsg_CmdKeyValues message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCLCMsg_CmdKeyValues\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCLCMsg_CmdKeyValues} CCLCMsg_CmdKeyValues\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCLCMsg_CmdKeyValues.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_CmdKeyValues();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.keyvalues = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCLCMsg_CmdKeyValues;\n})());\nexports.CSVCMsg_ServerInfo = ($root.CSVCMsg_ServerInfo = (() => {\n    /**\n     * Properties of a CSVCMsg_ServerInfo.\n     * @exports ICSVCMsg_ServerInfo\n     * @interface ICSVCMsg_ServerInfo\n     * @property {number|null} [protocol] CSVCMsg_ServerInfo protocol\n     * @property {number|null} [serverCount] CSVCMsg_ServerInfo serverCount\n     * @property {boolean|null} [isDedicated] CSVCMsg_ServerInfo isDedicated\n     * @property {boolean|null} [isOfficialValveServer] CSVCMsg_ServerInfo isOfficialValveServer\n     * @property {boolean|null} [isHltv] CSVCMsg_ServerInfo isHltv\n     * @property {boolean|null} [isReplay] CSVCMsg_ServerInfo isReplay\n     * @property {boolean|null} [isRedirectingToProxyRelay] CSVCMsg_ServerInfo isRedirectingToProxyRelay\n     * @property {number|null} [cOs] CSVCMsg_ServerInfo cOs\n     * @property {number|null} [mapCrc] CSVCMsg_ServerInfo mapCrc\n     * @property {number|null} [clientCrc] CSVCMsg_ServerInfo clientCrc\n     * @property {number|null} [stringTableCrc] CSVCMsg_ServerInfo stringTableCrc\n     * @property {number|null} [maxClients] CSVCMsg_ServerInfo maxClients\n     * @property {number|null} [maxClasses] CSVCMsg_ServerInfo maxClasses\n     * @property {number|null} [playerSlot] CSVCMsg_ServerInfo playerSlot\n     * @property {number|null} [tickInterval] CSVCMsg_ServerInfo tickInterval\n     * @property {string|null} [gameDir] CSVCMsg_ServerInfo gameDir\n     * @property {string|null} [mapName] CSVCMsg_ServerInfo mapName\n     * @property {string|null} [mapGroupName] CSVCMsg_ServerInfo mapGroupName\n     * @property {string|null} [skyName] CSVCMsg_ServerInfo skyName\n     * @property {string|null} [hostName] CSVCMsg_ServerInfo hostName\n     * @property {number|null} [publicIp] CSVCMsg_ServerInfo publicIp\n     * @property {number|Long|null} [ugcMapId] CSVCMsg_ServerInfo ugcMapId\n     */\n    /**\n     * Constructs a new CSVCMsg_ServerInfo.\n     * @exports CSVCMsg_ServerInfo\n     * @classdesc Represents a CSVCMsg_ServerInfo.\n     * @implements ICSVCMsg_ServerInfo\n     * @constructor\n     * @param {ICSVCMsg_ServerInfo=} [properties] Properties to set\n     */\n    function CSVCMsg_ServerInfo(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_ServerInfo protocol.\n     * @member {number} protocol\n     * @memberof CSVCMsg_ServerInfo\n     * @instance\n     */\n    CSVCMsg_ServerInfo.prototype.protocol = 0;\n    /**\n     * CSVCMsg_ServerInfo serverCount.\n     * @member {number} serverCount\n     * @memberof CSVCMsg_ServerInfo\n     * @instance\n     */\n    CSVCMsg_ServerInfo.prototype.serverCount = 0;\n    /**\n     * CSVCMsg_ServerInfo isDedicated.\n     * @member {boolean} isDedicated\n     * @memberof CSVCMsg_ServerInfo\n     * @instance\n     */\n    CSVCMsg_ServerInfo.prototype.isDedicated = false;\n    /**\n     * CSVCMsg_ServerInfo isOfficialValveServer.\n     * @member {boolean} isOfficialValveServer\n     * @memberof CSVCMsg_ServerInfo\n     * @instance\n     */\n    CSVCMsg_ServerInfo.prototype.isOfficialValveServer = false;\n    /**\n     * CSVCMsg_ServerInfo isHltv.\n     * @member {boolean} isHltv\n     * @memberof CSVCMsg_ServerInfo\n     * @instance\n     */\n    CSVCMsg_ServerInfo.prototype.isHltv = false;\n    /**\n     * CSVCMsg_ServerInfo isReplay.\n     * @member {boolean} isReplay\n     * @memberof CSVCMsg_ServerInfo\n     * @instance\n     */\n    CSVCMsg_ServerInfo.prototype.isReplay = false;\n    /**\n     * CSVCMsg_ServerInfo isRedirectingToProxyRelay.\n     * @member {boolean} isRedirectingToProxyRelay\n     * @memberof CSVCMsg_ServerInfo\n     * @instance\n     */\n    CSVCMsg_ServerInfo.prototype.isRedirectingToProxyRelay = false;\n    /**\n     * CSVCMsg_ServerInfo cOs.\n     * @member {number} cOs\n     * @memberof CSVCMsg_ServerInfo\n     * @instance\n     */\n    CSVCMsg_ServerInfo.prototype.cOs = 0;\n    /**\n     * CSVCMsg_ServerInfo mapCrc.\n     * @member {number} mapCrc\n     * @memberof CSVCMsg_ServerInfo\n     * @instance\n     */\n    CSVCMsg_ServerInfo.prototype.mapCrc = 0;\n    /**\n     * CSVCMsg_ServerInfo clientCrc.\n     * @member {number} clientCrc\n     * @memberof CSVCMsg_ServerInfo\n     * @instance\n     */\n    CSVCMsg_ServerInfo.prototype.clientCrc = 0;\n    /**\n     * CSVCMsg_ServerInfo stringTableCrc.\n     * @member {number} stringTableCrc\n     * @memberof CSVCMsg_ServerInfo\n     * @instance\n     */\n    CSVCMsg_ServerInfo.prototype.stringTableCrc = 0;\n    /**\n     * CSVCMsg_ServerInfo maxClients.\n     * @member {number} maxClients\n     * @memberof CSVCMsg_ServerInfo\n     * @instance\n     */\n    CSVCMsg_ServerInfo.prototype.maxClients = 0;\n    /**\n     * CSVCMsg_ServerInfo maxClasses.\n     * @member {number} maxClasses\n     * @memberof CSVCMsg_ServerInfo\n     * @instance\n     */\n    CSVCMsg_ServerInfo.prototype.maxClasses = 0;\n    /**\n     * CSVCMsg_ServerInfo playerSlot.\n     * @member {number} playerSlot\n     * @memberof CSVCMsg_ServerInfo\n     * @instance\n     */\n    CSVCMsg_ServerInfo.prototype.playerSlot = 0;\n    /**\n     * CSVCMsg_ServerInfo tickInterval.\n     * @member {number} tickInterval\n     * @memberof CSVCMsg_ServerInfo\n     * @instance\n     */\n    CSVCMsg_ServerInfo.prototype.tickInterval = 0;\n    /**\n     * CSVCMsg_ServerInfo gameDir.\n     * @member {string} gameDir\n     * @memberof CSVCMsg_ServerInfo\n     * @instance\n     */\n    CSVCMsg_ServerInfo.prototype.gameDir = \"\";\n    /**\n     * CSVCMsg_ServerInfo mapName.\n     * @member {string} mapName\n     * @memberof CSVCMsg_ServerInfo\n     * @instance\n     */\n    CSVCMsg_ServerInfo.prototype.mapName = \"\";\n    /**\n     * CSVCMsg_ServerInfo mapGroupName.\n     * @member {string} mapGroupName\n     * @memberof CSVCMsg_ServerInfo\n     * @instance\n     */\n    CSVCMsg_ServerInfo.prototype.mapGroupName = \"\";\n    /**\n     * CSVCMsg_ServerInfo skyName.\n     * @member {string} skyName\n     * @memberof CSVCMsg_ServerInfo\n     * @instance\n     */\n    CSVCMsg_ServerInfo.prototype.skyName = \"\";\n    /**\n     * CSVCMsg_ServerInfo hostName.\n     * @member {string} hostName\n     * @memberof CSVCMsg_ServerInfo\n     * @instance\n     */\n    CSVCMsg_ServerInfo.prototype.hostName = \"\";\n    /**\n     * CSVCMsg_ServerInfo publicIp.\n     * @member {number} publicIp\n     * @memberof CSVCMsg_ServerInfo\n     * @instance\n     */\n    CSVCMsg_ServerInfo.prototype.publicIp = 0;\n    /**\n     * CSVCMsg_ServerInfo ugcMapId.\n     * @member {number|Long} ugcMapId\n     * @memberof CSVCMsg_ServerInfo\n     * @instance\n     */\n    CSVCMsg_ServerInfo.prototype.ugcMapId = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * Decodes a CSVCMsg_ServerInfo message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_ServerInfo\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_ServerInfo} CSVCMsg_ServerInfo\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_ServerInfo.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_ServerInfo();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.protocol = reader.int32();\n                    break;\n                case 2:\n                    message.serverCount = reader.int32();\n                    break;\n                case 3:\n                    message.isDedicated = reader.bool();\n                    break;\n                case 4:\n                    message.isOfficialValveServer = reader.bool();\n                    break;\n                case 5:\n                    message.isHltv = reader.bool();\n                    break;\n                case 6:\n                    message.isReplay = reader.bool();\n                    break;\n                case 21:\n                    message.isRedirectingToProxyRelay = reader.bool();\n                    break;\n                case 7:\n                    message.cOs = reader.int32();\n                    break;\n                case 8:\n                    message.mapCrc = reader.fixed32();\n                    break;\n                case 9:\n                    message.clientCrc = reader.fixed32();\n                    break;\n                case 10:\n                    message.stringTableCrc = reader.fixed32();\n                    break;\n                case 11:\n                    message.maxClients = reader.int32();\n                    break;\n                case 12:\n                    message.maxClasses = reader.int32();\n                    break;\n                case 13:\n                    message.playerSlot = reader.int32();\n                    break;\n                case 14:\n                    message.tickInterval = reader.float();\n                    break;\n                case 15:\n                    message.gameDir = reader.string();\n                    break;\n                case 16:\n                    message.mapName = reader.string();\n                    break;\n                case 17:\n                    message.mapGroupName = reader.string();\n                    break;\n                case 18:\n                    message.skyName = reader.string();\n                    break;\n                case 19:\n                    message.hostName = reader.string();\n                    break;\n                case 20:\n                    message.publicIp = reader.uint32();\n                    break;\n                case 22:\n                    message.ugcMapId = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CSVCMsg_ServerInfo;\n})());\nexports.CSVCMsg_ClassInfo = ($root.CSVCMsg_ClassInfo = (() => {\n    /**\n     * Properties of a CSVCMsg_ClassInfo.\n     * @exports ICSVCMsg_ClassInfo\n     * @interface ICSVCMsg_ClassInfo\n     * @property {boolean|null} [createOnClient] CSVCMsg_ClassInfo createOnClient\n     * @property {Array.<CSVCMsg_ClassInfo.Iclass_t>|null} [classes] CSVCMsg_ClassInfo classes\n     */\n    /**\n     * Constructs a new CSVCMsg_ClassInfo.\n     * @exports CSVCMsg_ClassInfo\n     * @classdesc Represents a CSVCMsg_ClassInfo.\n     * @implements ICSVCMsg_ClassInfo\n     * @constructor\n     * @param {ICSVCMsg_ClassInfo=} [properties] Properties to set\n     */\n    function CSVCMsg_ClassInfo(properties) {\n        this.classes = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_ClassInfo createOnClient.\n     * @member {boolean} createOnClient\n     * @memberof CSVCMsg_ClassInfo\n     * @instance\n     */\n    CSVCMsg_ClassInfo.prototype.createOnClient = false;\n    /**\n     * CSVCMsg_ClassInfo classes.\n     * @member {Array.<CSVCMsg_ClassInfo.Iclass_t>} classes\n     * @memberof CSVCMsg_ClassInfo\n     * @instance\n     */\n    CSVCMsg_ClassInfo.prototype.classes = $util.emptyArray;\n    /**\n     * Decodes a CSVCMsg_ClassInfo message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_ClassInfo\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_ClassInfo} CSVCMsg_ClassInfo\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_ClassInfo.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_ClassInfo();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.createOnClient = reader.bool();\n                    break;\n                case 2:\n                    if (!(message.classes && message.classes.length))\n                        message.classes = [];\n                    message.classes.push($root.CSVCMsg_ClassInfo.class_t.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CSVCMsg_ClassInfo.class_t = (function () {\n        /**\n         * Properties of a class_t.\n         * @memberof CSVCMsg_ClassInfo\n         * @interface Iclass_t\n         * @property {number|null} [classId] class_t classId\n         * @property {string|null} [dataTableName] class_t dataTableName\n         * @property {string|null} [className] class_t className\n         */\n        /**\n         * Constructs a new class_t.\n         * @memberof CSVCMsg_ClassInfo\n         * @classdesc Represents a class_t.\n         * @implements Iclass_t\n         * @constructor\n         * @param {CSVCMsg_ClassInfo.Iclass_t=} [properties] Properties to set\n         */\n        function class_t(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * class_t classId.\n         * @member {number} classId\n         * @memberof CSVCMsg_ClassInfo.class_t\n         * @instance\n         */\n        class_t.prototype.classId = 0;\n        /**\n         * class_t dataTableName.\n         * @member {string} dataTableName\n         * @memberof CSVCMsg_ClassInfo.class_t\n         * @instance\n         */\n        class_t.prototype.dataTableName = \"\";\n        /**\n         * class_t className.\n         * @member {string} className\n         * @memberof CSVCMsg_ClassInfo.class_t\n         * @instance\n         */\n        class_t.prototype.className = \"\";\n        /**\n         * Decodes a class_t message from the specified reader or buffer.\n         * @function decode\n         * @memberof CSVCMsg_ClassInfo.class_t\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CSVCMsg_ClassInfo.class_t} class_t\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        class_t.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_ClassInfo.class_t();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.classId = reader.int32();\n                        break;\n                    case 2:\n                        message.dataTableName = reader.string();\n                        break;\n                    case 3:\n                        message.className = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return class_t;\n    })();\n    return CSVCMsg_ClassInfo;\n})());\nexports.CSVCMsg_SendTable = ($root.CSVCMsg_SendTable = (() => {\n    /**\n     * Properties of a CSVCMsg_SendTable.\n     * @exports ICSVCMsg_SendTable\n     * @interface ICSVCMsg_SendTable\n     * @property {boolean|null} [isEnd] CSVCMsg_SendTable isEnd\n     * @property {string|null} [netTableName] CSVCMsg_SendTable netTableName\n     * @property {boolean|null} [needsDecoder] CSVCMsg_SendTable needsDecoder\n     * @property {Array.<CSVCMsg_SendTable.Isendprop_t>|null} [props] CSVCMsg_SendTable props\n     */\n    /**\n     * Constructs a new CSVCMsg_SendTable.\n     * @exports CSVCMsg_SendTable\n     * @classdesc Represents a CSVCMsg_SendTable.\n     * @implements ICSVCMsg_SendTable\n     * @constructor\n     * @param {ICSVCMsg_SendTable=} [properties] Properties to set\n     */\n    function CSVCMsg_SendTable(properties) {\n        this.props = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_SendTable isEnd.\n     * @member {boolean} isEnd\n     * @memberof CSVCMsg_SendTable\n     * @instance\n     */\n    CSVCMsg_SendTable.prototype.isEnd = false;\n    /**\n     * CSVCMsg_SendTable netTableName.\n     * @member {string} netTableName\n     * @memberof CSVCMsg_SendTable\n     * @instance\n     */\n    CSVCMsg_SendTable.prototype.netTableName = \"\";\n    /**\n     * CSVCMsg_SendTable needsDecoder.\n     * @member {boolean} needsDecoder\n     * @memberof CSVCMsg_SendTable\n     * @instance\n     */\n    CSVCMsg_SendTable.prototype.needsDecoder = false;\n    /**\n     * CSVCMsg_SendTable props.\n     * @member {Array.<CSVCMsg_SendTable.Isendprop_t>} props\n     * @memberof CSVCMsg_SendTable\n     * @instance\n     */\n    CSVCMsg_SendTable.prototype.props = $util.emptyArray;\n    /**\n     * Decodes a CSVCMsg_SendTable message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_SendTable\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_SendTable} CSVCMsg_SendTable\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_SendTable.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SendTable();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.isEnd = reader.bool();\n                    break;\n                case 2:\n                    message.netTableName = reader.string();\n                    break;\n                case 3:\n                    message.needsDecoder = reader.bool();\n                    break;\n                case 4:\n                    if (!(message.props && message.props.length))\n                        message.props = [];\n                    message.props.push($root.CSVCMsg_SendTable.sendprop_t.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CSVCMsg_SendTable.sendprop_t = (function () {\n        /**\n         * Properties of a sendprop_t.\n         * @memberof CSVCMsg_SendTable\n         * @interface Isendprop_t\n         * @property {number|null} [type] sendprop_t type\n         * @property {string|null} [varName] sendprop_t varName\n         * @property {number|null} [flags] sendprop_t flags\n         * @property {number|null} [priority] sendprop_t priority\n         * @property {string|null} [dtName] sendprop_t dtName\n         * @property {number|null} [numElements] sendprop_t numElements\n         * @property {number|null} [lowValue] sendprop_t lowValue\n         * @property {number|null} [highValue] sendprop_t highValue\n         * @property {number|null} [numBits] sendprop_t numBits\n         */\n        /**\n         * Constructs a new sendprop_t.\n         * @memberof CSVCMsg_SendTable\n         * @classdesc Represents a sendprop_t.\n         * @implements Isendprop_t\n         * @constructor\n         * @param {CSVCMsg_SendTable.Isendprop_t=} [properties] Properties to set\n         */\n        function sendprop_t(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * sendprop_t type.\n         * @member {number} type\n         * @memberof CSVCMsg_SendTable.sendprop_t\n         * @instance\n         */\n        sendprop_t.prototype.type = 0;\n        /**\n         * sendprop_t varName.\n         * @member {string} varName\n         * @memberof CSVCMsg_SendTable.sendprop_t\n         * @instance\n         */\n        sendprop_t.prototype.varName = \"\";\n        /**\n         * sendprop_t flags.\n         * @member {number} flags\n         * @memberof CSVCMsg_SendTable.sendprop_t\n         * @instance\n         */\n        sendprop_t.prototype.flags = 0;\n        /**\n         * sendprop_t priority.\n         * @member {number} priority\n         * @memberof CSVCMsg_SendTable.sendprop_t\n         * @instance\n         */\n        sendprop_t.prototype.priority = 0;\n        /**\n         * sendprop_t dtName.\n         * @member {string} dtName\n         * @memberof CSVCMsg_SendTable.sendprop_t\n         * @instance\n         */\n        sendprop_t.prototype.dtName = \"\";\n        /**\n         * sendprop_t numElements.\n         * @member {number} numElements\n         * @memberof CSVCMsg_SendTable.sendprop_t\n         * @instance\n         */\n        sendprop_t.prototype.numElements = 0;\n        /**\n         * sendprop_t lowValue.\n         * @member {number} lowValue\n         * @memberof CSVCMsg_SendTable.sendprop_t\n         * @instance\n         */\n        sendprop_t.prototype.lowValue = 0;\n        /**\n         * sendprop_t highValue.\n         * @member {number} highValue\n         * @memberof CSVCMsg_SendTable.sendprop_t\n         * @instance\n         */\n        sendprop_t.prototype.highValue = 0;\n        /**\n         * sendprop_t numBits.\n         * @member {number} numBits\n         * @memberof CSVCMsg_SendTable.sendprop_t\n         * @instance\n         */\n        sendprop_t.prototype.numBits = 0;\n        /**\n         * Decodes a sendprop_t message from the specified reader or buffer.\n         * @function decode\n         * @memberof CSVCMsg_SendTable.sendprop_t\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CSVCMsg_SendTable.sendprop_t} sendprop_t\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        sendprop_t.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SendTable.sendprop_t();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.type = reader.int32();\n                        break;\n                    case 2:\n                        message.varName = reader.string();\n                        break;\n                    case 3:\n                        message.flags = reader.int32();\n                        break;\n                    case 4:\n                        message.priority = reader.int32();\n                        break;\n                    case 5:\n                        message.dtName = reader.string();\n                        break;\n                    case 6:\n                        message.numElements = reader.int32();\n                        break;\n                    case 7:\n                        message.lowValue = reader.float();\n                        break;\n                    case 8:\n                        message.highValue = reader.float();\n                        break;\n                    case 9:\n                        message.numBits = reader.int32();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return sendprop_t;\n    })();\n    return CSVCMsg_SendTable;\n})());\nexports.CSVCMsg_Print = ($root.CSVCMsg_Print = (() => {\n    /**\n     * Properties of a CSVCMsg_Print.\n     * @exports ICSVCMsg_Print\n     * @interface ICSVCMsg_Print\n     * @property {string|null} [text] CSVCMsg_Print text\n     */\n    /**\n     * Constructs a new CSVCMsg_Print.\n     * @exports CSVCMsg_Print\n     * @classdesc Represents a CSVCMsg_Print.\n     * @implements ICSVCMsg_Print\n     * @constructor\n     * @param {ICSVCMsg_Print=} [properties] Properties to set\n     */\n    function CSVCMsg_Print(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_Print text.\n     * @member {string} text\n     * @memberof CSVCMsg_Print\n     * @instance\n     */\n    CSVCMsg_Print.prototype.text = \"\";\n    /**\n     * Decodes a CSVCMsg_Print message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_Print\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_Print} CSVCMsg_Print\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_Print.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Print();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.text = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CSVCMsg_Print;\n})());\nexports.CSVCMsg_SetPause = ($root.CSVCMsg_SetPause = (() => {\n    /**\n     * Properties of a CSVCMsg_SetPause.\n     * @exports ICSVCMsg_SetPause\n     * @interface ICSVCMsg_SetPause\n     * @property {boolean|null} [paused] CSVCMsg_SetPause paused\n     */\n    /**\n     * Constructs a new CSVCMsg_SetPause.\n     * @exports CSVCMsg_SetPause\n     * @classdesc Represents a CSVCMsg_SetPause.\n     * @implements ICSVCMsg_SetPause\n     * @constructor\n     * @param {ICSVCMsg_SetPause=} [properties] Properties to set\n     */\n    function CSVCMsg_SetPause(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_SetPause paused.\n     * @member {boolean} paused\n     * @memberof CSVCMsg_SetPause\n     * @instance\n     */\n    CSVCMsg_SetPause.prototype.paused = false;\n    /**\n     * Decodes a CSVCMsg_SetPause message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_SetPause\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_SetPause} CSVCMsg_SetPause\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_SetPause.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SetPause();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.paused = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CSVCMsg_SetPause;\n})());\nexports.CSVCMsg_SetView = ($root.CSVCMsg_SetView = (() => {\n    /**\n     * Properties of a CSVCMsg_SetView.\n     * @exports ICSVCMsg_SetView\n     * @interface ICSVCMsg_SetView\n     * @property {number|null} [entityIndex] CSVCMsg_SetView entityIndex\n     */\n    /**\n     * Constructs a new CSVCMsg_SetView.\n     * @exports CSVCMsg_SetView\n     * @classdesc Represents a CSVCMsg_SetView.\n     * @implements ICSVCMsg_SetView\n     * @constructor\n     * @param {ICSVCMsg_SetView=} [properties] Properties to set\n     */\n    function CSVCMsg_SetView(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_SetView entityIndex.\n     * @member {number} entityIndex\n     * @memberof CSVCMsg_SetView\n     * @instance\n     */\n    CSVCMsg_SetView.prototype.entityIndex = 0;\n    /**\n     * Decodes a CSVCMsg_SetView message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_SetView\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_SetView} CSVCMsg_SetView\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_SetView.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SetView();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.entityIndex = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CSVCMsg_SetView;\n})());\nexports.CSVCMsg_CreateStringTable = ($root.CSVCMsg_CreateStringTable = (() => {\n    /**\n     * Properties of a CSVCMsg_CreateStringTable.\n     * @exports ICSVCMsg_CreateStringTable\n     * @interface ICSVCMsg_CreateStringTable\n     * @property {string|null} [name] CSVCMsg_CreateStringTable name\n     * @property {number|null} [maxEntries] CSVCMsg_CreateStringTable maxEntries\n     * @property {number|null} [numEntries] CSVCMsg_CreateStringTable numEntries\n     * @property {boolean|null} [userDataFixedSize] CSVCMsg_CreateStringTable userDataFixedSize\n     * @property {number|null} [userDataSize] CSVCMsg_CreateStringTable userDataSize\n     * @property {number|null} [userDataSizeBits] CSVCMsg_CreateStringTable userDataSizeBits\n     * @property {number|null} [flags] CSVCMsg_CreateStringTable flags\n     * @property {Uint8Array|null} [stringData] CSVCMsg_CreateStringTable stringData\n     */\n    /**\n     * Constructs a new CSVCMsg_CreateStringTable.\n     * @exports CSVCMsg_CreateStringTable\n     * @classdesc Represents a CSVCMsg_CreateStringTable.\n     * @implements ICSVCMsg_CreateStringTable\n     * @constructor\n     * @param {ICSVCMsg_CreateStringTable=} [properties] Properties to set\n     */\n    function CSVCMsg_CreateStringTable(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_CreateStringTable name.\n     * @member {string} name\n     * @memberof CSVCMsg_CreateStringTable\n     * @instance\n     */\n    CSVCMsg_CreateStringTable.prototype.name = \"\";\n    /**\n     * CSVCMsg_CreateStringTable maxEntries.\n     * @member {number} maxEntries\n     * @memberof CSVCMsg_CreateStringTable\n     * @instance\n     */\n    CSVCMsg_CreateStringTable.prototype.maxEntries = 0;\n    /**\n     * CSVCMsg_CreateStringTable numEntries.\n     * @member {number} numEntries\n     * @memberof CSVCMsg_CreateStringTable\n     * @instance\n     */\n    CSVCMsg_CreateStringTable.prototype.numEntries = 0;\n    /**\n     * CSVCMsg_CreateStringTable userDataFixedSize.\n     * @member {boolean} userDataFixedSize\n     * @memberof CSVCMsg_CreateStringTable\n     * @instance\n     */\n    CSVCMsg_CreateStringTable.prototype.userDataFixedSize = false;\n    /**\n     * CSVCMsg_CreateStringTable userDataSize.\n     * @member {number} userDataSize\n     * @memberof CSVCMsg_CreateStringTable\n     * @instance\n     */\n    CSVCMsg_CreateStringTable.prototype.userDataSize = 0;\n    /**\n     * CSVCMsg_CreateStringTable userDataSizeBits.\n     * @member {number} userDataSizeBits\n     * @memberof CSVCMsg_CreateStringTable\n     * @instance\n     */\n    CSVCMsg_CreateStringTable.prototype.userDataSizeBits = 0;\n    /**\n     * CSVCMsg_CreateStringTable flags.\n     * @member {number} flags\n     * @memberof CSVCMsg_CreateStringTable\n     * @instance\n     */\n    CSVCMsg_CreateStringTable.prototype.flags = 0;\n    /**\n     * CSVCMsg_CreateStringTable stringData.\n     * @member {Uint8Array} stringData\n     * @memberof CSVCMsg_CreateStringTable\n     * @instance\n     */\n    CSVCMsg_CreateStringTable.prototype.stringData = $util.newBuffer([]);\n    /**\n     * Decodes a CSVCMsg_CreateStringTable message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_CreateStringTable\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_CreateStringTable} CSVCMsg_CreateStringTable\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_CreateStringTable.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_CreateStringTable();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 2:\n                    message.maxEntries = reader.int32();\n                    break;\n                case 3:\n                    message.numEntries = reader.int32();\n                    break;\n                case 4:\n                    message.userDataFixedSize = reader.bool();\n                    break;\n                case 5:\n                    message.userDataSize = reader.int32();\n                    break;\n                case 6:\n                    message.userDataSizeBits = reader.int32();\n                    break;\n                case 7:\n                    message.flags = reader.int32();\n                    break;\n                case 8:\n                    message.stringData = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CSVCMsg_CreateStringTable;\n})());\nexports.CSVCMsg_UpdateStringTable = ($root.CSVCMsg_UpdateStringTable = (() => {\n    /**\n     * Properties of a CSVCMsg_UpdateStringTable.\n     * @exports ICSVCMsg_UpdateStringTable\n     * @interface ICSVCMsg_UpdateStringTable\n     * @property {number|null} [tableId] CSVCMsg_UpdateStringTable tableId\n     * @property {number|null} [numChangedEntries] CSVCMsg_UpdateStringTable numChangedEntries\n     * @property {Uint8Array|null} [stringData] CSVCMsg_UpdateStringTable stringData\n     */\n    /**\n     * Constructs a new CSVCMsg_UpdateStringTable.\n     * @exports CSVCMsg_UpdateStringTable\n     * @classdesc Represents a CSVCMsg_UpdateStringTable.\n     * @implements ICSVCMsg_UpdateStringTable\n     * @constructor\n     * @param {ICSVCMsg_UpdateStringTable=} [properties] Properties to set\n     */\n    function CSVCMsg_UpdateStringTable(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_UpdateStringTable tableId.\n     * @member {number} tableId\n     * @memberof CSVCMsg_UpdateStringTable\n     * @instance\n     */\n    CSVCMsg_UpdateStringTable.prototype.tableId = 0;\n    /**\n     * CSVCMsg_UpdateStringTable numChangedEntries.\n     * @member {number} numChangedEntries\n     * @memberof CSVCMsg_UpdateStringTable\n     * @instance\n     */\n    CSVCMsg_UpdateStringTable.prototype.numChangedEntries = 0;\n    /**\n     * CSVCMsg_UpdateStringTable stringData.\n     * @member {Uint8Array} stringData\n     * @memberof CSVCMsg_UpdateStringTable\n     * @instance\n     */\n    CSVCMsg_UpdateStringTable.prototype.stringData = $util.newBuffer([]);\n    /**\n     * Decodes a CSVCMsg_UpdateStringTable message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_UpdateStringTable\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_UpdateStringTable} CSVCMsg_UpdateStringTable\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_UpdateStringTable.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_UpdateStringTable();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.tableId = reader.int32();\n                    break;\n                case 2:\n                    message.numChangedEntries = reader.int32();\n                    break;\n                case 3:\n                    message.stringData = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CSVCMsg_UpdateStringTable;\n})());\nexports.CSVCMsg_VoiceInit = ($root.CSVCMsg_VoiceInit = (() => {\n    /**\n     * Properties of a CSVCMsg_VoiceInit.\n     * @exports ICSVCMsg_VoiceInit\n     * @interface ICSVCMsg_VoiceInit\n     * @property {number|null} [quality] CSVCMsg_VoiceInit quality\n     * @property {string|null} [codec] CSVCMsg_VoiceInit codec\n     * @property {number|null} [version] CSVCMsg_VoiceInit version\n     */\n    /**\n     * Constructs a new CSVCMsg_VoiceInit.\n     * @exports CSVCMsg_VoiceInit\n     * @classdesc Represents a CSVCMsg_VoiceInit.\n     * @implements ICSVCMsg_VoiceInit\n     * @constructor\n     * @param {ICSVCMsg_VoiceInit=} [properties] Properties to set\n     */\n    function CSVCMsg_VoiceInit(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_VoiceInit quality.\n     * @member {number} quality\n     * @memberof CSVCMsg_VoiceInit\n     * @instance\n     */\n    CSVCMsg_VoiceInit.prototype.quality = 0;\n    /**\n     * CSVCMsg_VoiceInit codec.\n     * @member {string} codec\n     * @memberof CSVCMsg_VoiceInit\n     * @instance\n     */\n    CSVCMsg_VoiceInit.prototype.codec = \"\";\n    /**\n     * CSVCMsg_VoiceInit version.\n     * @member {number} version\n     * @memberof CSVCMsg_VoiceInit\n     * @instance\n     */\n    CSVCMsg_VoiceInit.prototype.version = 0;\n    /**\n     * Decodes a CSVCMsg_VoiceInit message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_VoiceInit\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_VoiceInit} CSVCMsg_VoiceInit\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_VoiceInit.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_VoiceInit();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.quality = reader.int32();\n                    break;\n                case 2:\n                    message.codec = reader.string();\n                    break;\n                case 3:\n                    message.version = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CSVCMsg_VoiceInit;\n})());\nexports.CSVCMsg_VoiceData = ($root.CSVCMsg_VoiceData = (() => {\n    /**\n     * Properties of a CSVCMsg_VoiceData.\n     * @exports ICSVCMsg_VoiceData\n     * @interface ICSVCMsg_VoiceData\n     * @property {number|null} [client] CSVCMsg_VoiceData client\n     * @property {boolean|null} [proximity] CSVCMsg_VoiceData proximity\n     * @property {number|Long|null} [xuid] CSVCMsg_VoiceData xuid\n     * @property {number|null} [audibleMask] CSVCMsg_VoiceData audibleMask\n     * @property {Uint8Array|null} [voiceData] CSVCMsg_VoiceData voiceData\n     * @property {boolean|null} [caster] CSVCMsg_VoiceData caster\n     * @property {VoiceDataFormat_t|null} [format] CSVCMsg_VoiceData format\n     * @property {number|null} [sequenceBytes] CSVCMsg_VoiceData sequenceBytes\n     * @property {number|null} [sectionNumber] CSVCMsg_VoiceData sectionNumber\n     * @property {number|null} [uncompressedSampleOffset] CSVCMsg_VoiceData uncompressedSampleOffset\n     */\n    /**\n     * Constructs a new CSVCMsg_VoiceData.\n     * @exports CSVCMsg_VoiceData\n     * @classdesc Represents a CSVCMsg_VoiceData.\n     * @implements ICSVCMsg_VoiceData\n     * @constructor\n     * @param {ICSVCMsg_VoiceData=} [properties] Properties to set\n     */\n    function CSVCMsg_VoiceData(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_VoiceData client.\n     * @member {number} client\n     * @memberof CSVCMsg_VoiceData\n     * @instance\n     */\n    CSVCMsg_VoiceData.prototype.client = 0;\n    /**\n     * CSVCMsg_VoiceData proximity.\n     * @member {boolean} proximity\n     * @memberof CSVCMsg_VoiceData\n     * @instance\n     */\n    CSVCMsg_VoiceData.prototype.proximity = false;\n    /**\n     * CSVCMsg_VoiceData xuid.\n     * @member {number|Long} xuid\n     * @memberof CSVCMsg_VoiceData\n     * @instance\n     */\n    CSVCMsg_VoiceData.prototype.xuid = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0;\n    /**\n     * CSVCMsg_VoiceData audibleMask.\n     * @member {number} audibleMask\n     * @memberof CSVCMsg_VoiceData\n     * @instance\n     */\n    CSVCMsg_VoiceData.prototype.audibleMask = 0;\n    /**\n     * CSVCMsg_VoiceData voiceData.\n     * @member {Uint8Array} voiceData\n     * @memberof CSVCMsg_VoiceData\n     * @instance\n     */\n    CSVCMsg_VoiceData.prototype.voiceData = $util.newBuffer([]);\n    /**\n     * CSVCMsg_VoiceData caster.\n     * @member {boolean} caster\n     * @memberof CSVCMsg_VoiceData\n     * @instance\n     */\n    CSVCMsg_VoiceData.prototype.caster = false;\n    /**\n     * CSVCMsg_VoiceData format.\n     * @member {VoiceDataFormat_t} format\n     * @memberof CSVCMsg_VoiceData\n     * @instance\n     */\n    CSVCMsg_VoiceData.prototype.format = 1;\n    /**\n     * CSVCMsg_VoiceData sequenceBytes.\n     * @member {number} sequenceBytes\n     * @memberof CSVCMsg_VoiceData\n     * @instance\n     */\n    CSVCMsg_VoiceData.prototype.sequenceBytes = 0;\n    /**\n     * CSVCMsg_VoiceData sectionNumber.\n     * @member {number} sectionNumber\n     * @memberof CSVCMsg_VoiceData\n     * @instance\n     */\n    CSVCMsg_VoiceData.prototype.sectionNumber = 0;\n    /**\n     * CSVCMsg_VoiceData uncompressedSampleOffset.\n     * @member {number} uncompressedSampleOffset\n     * @memberof CSVCMsg_VoiceData\n     * @instance\n     */\n    CSVCMsg_VoiceData.prototype.uncompressedSampleOffset = 0;\n    /**\n     * Decodes a CSVCMsg_VoiceData message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_VoiceData\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_VoiceData} CSVCMsg_VoiceData\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_VoiceData.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_VoiceData();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.client = reader.int32();\n                    break;\n                case 2:\n                    message.proximity = reader.bool();\n                    break;\n                case 3:\n                    message.xuid = reader.fixed64();\n                    break;\n                case 4:\n                    message.audibleMask = reader.int32();\n                    break;\n                case 5:\n                    message.voiceData = reader.bytes();\n                    break;\n                case 6:\n                    message.caster = reader.bool();\n                    break;\n                case 7:\n                    message.format = reader.int32();\n                    break;\n                case 8:\n                    message.sequenceBytes = reader.int32();\n                    break;\n                case 9:\n                    message.sectionNumber = reader.uint32();\n                    break;\n                case 10:\n                    message.uncompressedSampleOffset = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CSVCMsg_VoiceData;\n})());\nexports.CSVCMsg_FixAngle = ($root.CSVCMsg_FixAngle = (() => {\n    /**\n     * Properties of a CSVCMsg_FixAngle.\n     * @exports ICSVCMsg_FixAngle\n     * @interface ICSVCMsg_FixAngle\n     * @property {boolean|null} [relative] CSVCMsg_FixAngle relative\n     * @property {ICMsgQAngle|null} [angle] CSVCMsg_FixAngle angle\n     */\n    /**\n     * Constructs a new CSVCMsg_FixAngle.\n     * @exports CSVCMsg_FixAngle\n     * @classdesc Represents a CSVCMsg_FixAngle.\n     * @implements ICSVCMsg_FixAngle\n     * @constructor\n     * @param {ICSVCMsg_FixAngle=} [properties] Properties to set\n     */\n    function CSVCMsg_FixAngle(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_FixAngle relative.\n     * @member {boolean} relative\n     * @memberof CSVCMsg_FixAngle\n     * @instance\n     */\n    CSVCMsg_FixAngle.prototype.relative = false;\n    /**\n     * CSVCMsg_FixAngle angle.\n     * @member {ICMsgQAngle|null|undefined} angle\n     * @memberof CSVCMsg_FixAngle\n     * @instance\n     */\n    CSVCMsg_FixAngle.prototype.angle = null;\n    /**\n     * Decodes a CSVCMsg_FixAngle message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_FixAngle\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_FixAngle} CSVCMsg_FixAngle\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_FixAngle.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_FixAngle();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.relative = reader.bool();\n                    break;\n                case 2:\n                    message.angle = $root.CMsgQAngle.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CSVCMsg_FixAngle;\n})());\nexports.CSVCMsg_CrosshairAngle = ($root.CSVCMsg_CrosshairAngle = (() => {\n    /**\n     * Properties of a CSVCMsg_CrosshairAngle.\n     * @exports ICSVCMsg_CrosshairAngle\n     * @interface ICSVCMsg_CrosshairAngle\n     * @property {ICMsgQAngle|null} [angle] CSVCMsg_CrosshairAngle angle\n     */\n    /**\n     * Constructs a new CSVCMsg_CrosshairAngle.\n     * @exports CSVCMsg_CrosshairAngle\n     * @classdesc Represents a CSVCMsg_CrosshairAngle.\n     * @implements ICSVCMsg_CrosshairAngle\n     * @constructor\n     * @param {ICSVCMsg_CrosshairAngle=} [properties] Properties to set\n     */\n    function CSVCMsg_CrosshairAngle(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_CrosshairAngle angle.\n     * @member {ICMsgQAngle|null|undefined} angle\n     * @memberof CSVCMsg_CrosshairAngle\n     * @instance\n     */\n    CSVCMsg_CrosshairAngle.prototype.angle = null;\n    /**\n     * Decodes a CSVCMsg_CrosshairAngle message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_CrosshairAngle\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_CrosshairAngle} CSVCMsg_CrosshairAngle\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_CrosshairAngle.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_CrosshairAngle();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.angle = $root.CMsgQAngle.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CSVCMsg_CrosshairAngle;\n})());\nexports.CSVCMsg_Prefetch = ($root.CSVCMsg_Prefetch = (() => {\n    /**\n     * Properties of a CSVCMsg_Prefetch.\n     * @exports ICSVCMsg_Prefetch\n     * @interface ICSVCMsg_Prefetch\n     * @property {number|null} [soundIndex] CSVCMsg_Prefetch soundIndex\n     */\n    /**\n     * Constructs a new CSVCMsg_Prefetch.\n     * @exports CSVCMsg_Prefetch\n     * @classdesc Represents a CSVCMsg_Prefetch.\n     * @implements ICSVCMsg_Prefetch\n     * @constructor\n     * @param {ICSVCMsg_Prefetch=} [properties] Properties to set\n     */\n    function CSVCMsg_Prefetch(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_Prefetch soundIndex.\n     * @member {number} soundIndex\n     * @memberof CSVCMsg_Prefetch\n     * @instance\n     */\n    CSVCMsg_Prefetch.prototype.soundIndex = 0;\n    /**\n     * Decodes a CSVCMsg_Prefetch message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_Prefetch\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_Prefetch} CSVCMsg_Prefetch\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_Prefetch.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Prefetch();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.soundIndex = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CSVCMsg_Prefetch;\n})());\nexports.CSVCMsg_BSPDecal = ($root.CSVCMsg_BSPDecal = (() => {\n    /**\n     * Properties of a CSVCMsg_BSPDecal.\n     * @exports ICSVCMsg_BSPDecal\n     * @interface ICSVCMsg_BSPDecal\n     * @property {ICMsgVector|null} [pos] CSVCMsg_BSPDecal pos\n     * @property {number|null} [decalTextureIndex] CSVCMsg_BSPDecal decalTextureIndex\n     * @property {number|null} [entityIndex] CSVCMsg_BSPDecal entityIndex\n     * @property {number|null} [modelIndex] CSVCMsg_BSPDecal modelIndex\n     * @property {boolean|null} [lowPriority] CSVCMsg_BSPDecal lowPriority\n     */\n    /**\n     * Constructs a new CSVCMsg_BSPDecal.\n     * @exports CSVCMsg_BSPDecal\n     * @classdesc Represents a CSVCMsg_BSPDecal.\n     * @implements ICSVCMsg_BSPDecal\n     * @constructor\n     * @param {ICSVCMsg_BSPDecal=} [properties] Properties to set\n     */\n    function CSVCMsg_BSPDecal(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_BSPDecal pos.\n     * @member {ICMsgVector|null|undefined} pos\n     * @memberof CSVCMsg_BSPDecal\n     * @instance\n     */\n    CSVCMsg_BSPDecal.prototype.pos = null;\n    /**\n     * CSVCMsg_BSPDecal decalTextureIndex.\n     * @member {number} decalTextureIndex\n     * @memberof CSVCMsg_BSPDecal\n     * @instance\n     */\n    CSVCMsg_BSPDecal.prototype.decalTextureIndex = 0;\n    /**\n     * CSVCMsg_BSPDecal entityIndex.\n     * @member {number} entityIndex\n     * @memberof CSVCMsg_BSPDecal\n     * @instance\n     */\n    CSVCMsg_BSPDecal.prototype.entityIndex = 0;\n    /**\n     * CSVCMsg_BSPDecal modelIndex.\n     * @member {number} modelIndex\n     * @memberof CSVCMsg_BSPDecal\n     * @instance\n     */\n    CSVCMsg_BSPDecal.prototype.modelIndex = 0;\n    /**\n     * CSVCMsg_BSPDecal lowPriority.\n     * @member {boolean} lowPriority\n     * @memberof CSVCMsg_BSPDecal\n     * @instance\n     */\n    CSVCMsg_BSPDecal.prototype.lowPriority = false;\n    /**\n     * Decodes a CSVCMsg_BSPDecal message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_BSPDecal\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_BSPDecal} CSVCMsg_BSPDecal\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_BSPDecal.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_BSPDecal();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.pos = $root.CMsgVector.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.decalTextureIndex = reader.int32();\n                    break;\n                case 3:\n                    message.entityIndex = reader.int32();\n                    break;\n                case 4:\n                    message.modelIndex = reader.int32();\n                    break;\n                case 5:\n                    message.lowPriority = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CSVCMsg_BSPDecal;\n})());\nexports.CSVCMsg_SplitScreen = ($root.CSVCMsg_SplitScreen = (() => {\n    /**\n     * Properties of a CSVCMsg_SplitScreen.\n     * @exports ICSVCMsg_SplitScreen\n     * @interface ICSVCMsg_SplitScreen\n     * @property {ESplitScreenMessageType|null} [type] CSVCMsg_SplitScreen type\n     * @property {number|null} [slot] CSVCMsg_SplitScreen slot\n     * @property {number|null} [playerIndex] CSVCMsg_SplitScreen playerIndex\n     */\n    /**\n     * Constructs a new CSVCMsg_SplitScreen.\n     * @exports CSVCMsg_SplitScreen\n     * @classdesc Represents a CSVCMsg_SplitScreen.\n     * @implements ICSVCMsg_SplitScreen\n     * @constructor\n     * @param {ICSVCMsg_SplitScreen=} [properties] Properties to set\n     */\n    function CSVCMsg_SplitScreen(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_SplitScreen type.\n     * @member {ESplitScreenMessageType} type\n     * @memberof CSVCMsg_SplitScreen\n     * @instance\n     */\n    CSVCMsg_SplitScreen.prototype.type = 0;\n    /**\n     * CSVCMsg_SplitScreen slot.\n     * @member {number} slot\n     * @memberof CSVCMsg_SplitScreen\n     * @instance\n     */\n    CSVCMsg_SplitScreen.prototype.slot = 0;\n    /**\n     * CSVCMsg_SplitScreen playerIndex.\n     * @member {number} playerIndex\n     * @memberof CSVCMsg_SplitScreen\n     * @instance\n     */\n    CSVCMsg_SplitScreen.prototype.playerIndex = 0;\n    /**\n     * Decodes a CSVCMsg_SplitScreen message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_SplitScreen\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_SplitScreen} CSVCMsg_SplitScreen\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_SplitScreen.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_SplitScreen();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.type = reader.int32();\n                    break;\n                case 2:\n                    message.slot = reader.int32();\n                    break;\n                case 3:\n                    message.playerIndex = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CSVCMsg_SplitScreen;\n})());\nexports.CSVCMsg_GetCvarValue = ($root.CSVCMsg_GetCvarValue = (() => {\n    /**\n     * Properties of a CSVCMsg_GetCvarValue.\n     * @exports ICSVCMsg_GetCvarValue\n     * @interface ICSVCMsg_GetCvarValue\n     * @property {number|null} [cookie] CSVCMsg_GetCvarValue cookie\n     * @property {string|null} [cvarName] CSVCMsg_GetCvarValue cvarName\n     */\n    /**\n     * Constructs a new CSVCMsg_GetCvarValue.\n     * @exports CSVCMsg_GetCvarValue\n     * @classdesc Represents a CSVCMsg_GetCvarValue.\n     * @implements ICSVCMsg_GetCvarValue\n     * @constructor\n     * @param {ICSVCMsg_GetCvarValue=} [properties] Properties to set\n     */\n    function CSVCMsg_GetCvarValue(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_GetCvarValue cookie.\n     * @member {number} cookie\n     * @memberof CSVCMsg_GetCvarValue\n     * @instance\n     */\n    CSVCMsg_GetCvarValue.prototype.cookie = 0;\n    /**\n     * CSVCMsg_GetCvarValue cvarName.\n     * @member {string} cvarName\n     * @memberof CSVCMsg_GetCvarValue\n     * @instance\n     */\n    CSVCMsg_GetCvarValue.prototype.cvarName = \"\";\n    /**\n     * Decodes a CSVCMsg_GetCvarValue message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_GetCvarValue\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_GetCvarValue} CSVCMsg_GetCvarValue\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_GetCvarValue.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GetCvarValue();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.cookie = reader.int32();\n                    break;\n                case 2:\n                    message.cvarName = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CSVCMsg_GetCvarValue;\n})());\nexports.CSVCMsg_Menu = ($root.CSVCMsg_Menu = (() => {\n    /**\n     * Properties of a CSVCMsg_Menu.\n     * @exports ICSVCMsg_Menu\n     * @interface ICSVCMsg_Menu\n     * @property {number|null} [dialogType] CSVCMsg_Menu dialogType\n     * @property {Uint8Array|null} [menuKeyValues] CSVCMsg_Menu menuKeyValues\n     */\n    /**\n     * Constructs a new CSVCMsg_Menu.\n     * @exports CSVCMsg_Menu\n     * @classdesc Represents a CSVCMsg_Menu.\n     * @implements ICSVCMsg_Menu\n     * @constructor\n     * @param {ICSVCMsg_Menu=} [properties] Properties to set\n     */\n    function CSVCMsg_Menu(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_Menu dialogType.\n     * @member {number} dialogType\n     * @memberof CSVCMsg_Menu\n     * @instance\n     */\n    CSVCMsg_Menu.prototype.dialogType = 0;\n    /**\n     * CSVCMsg_Menu menuKeyValues.\n     * @member {Uint8Array} menuKeyValues\n     * @memberof CSVCMsg_Menu\n     * @instance\n     */\n    CSVCMsg_Menu.prototype.menuKeyValues = $util.newBuffer([]);\n    /**\n     * Decodes a CSVCMsg_Menu message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_Menu\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_Menu} CSVCMsg_Menu\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_Menu.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Menu();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.dialogType = reader.int32();\n                    break;\n                case 2:\n                    message.menuKeyValues = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CSVCMsg_Menu;\n})());\nexports.CSVCMsg_UserMessage = ($root.CSVCMsg_UserMessage = (() => {\n    /**\n     * Properties of a CSVCMsg_UserMessage.\n     * @exports ICSVCMsg_UserMessage\n     * @interface ICSVCMsg_UserMessage\n     * @property {number|null} [msgType] CSVCMsg_UserMessage msgType\n     * @property {Uint8Array|null} [msgData] CSVCMsg_UserMessage msgData\n     * @property {number|null} [passthrough] CSVCMsg_UserMessage passthrough\n     */\n    /**\n     * Constructs a new CSVCMsg_UserMessage.\n     * @exports CSVCMsg_UserMessage\n     * @classdesc Represents a CSVCMsg_UserMessage.\n     * @implements ICSVCMsg_UserMessage\n     * @constructor\n     * @param {ICSVCMsg_UserMessage=} [properties] Properties to set\n     */\n    function CSVCMsg_UserMessage(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_UserMessage msgType.\n     * @member {number} msgType\n     * @memberof CSVCMsg_UserMessage\n     * @instance\n     */\n    CSVCMsg_UserMessage.prototype.msgType = 0;\n    /**\n     * CSVCMsg_UserMessage msgData.\n     * @member {Uint8Array} msgData\n     * @memberof CSVCMsg_UserMessage\n     * @instance\n     */\n    CSVCMsg_UserMessage.prototype.msgData = $util.newBuffer([]);\n    /**\n     * CSVCMsg_UserMessage passthrough.\n     * @member {number} passthrough\n     * @memberof CSVCMsg_UserMessage\n     * @instance\n     */\n    CSVCMsg_UserMessage.prototype.passthrough = 0;\n    /**\n     * Decodes a CSVCMsg_UserMessage message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_UserMessage\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_UserMessage} CSVCMsg_UserMessage\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_UserMessage.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_UserMessage();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.msgType = reader.int32();\n                    break;\n                case 2:\n                    message.msgData = reader.bytes();\n                    break;\n                case 3:\n                    message.passthrough = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CSVCMsg_UserMessage;\n})());\nexports.CSVCMsg_PaintmapData = ($root.CSVCMsg_PaintmapData = (() => {\n    /**\n     * Properties of a CSVCMsg_PaintmapData.\n     * @exports ICSVCMsg_PaintmapData\n     * @interface ICSVCMsg_PaintmapData\n     * @property {Uint8Array|null} [paintmap] CSVCMsg_PaintmapData paintmap\n     */\n    /**\n     * Constructs a new CSVCMsg_PaintmapData.\n     * @exports CSVCMsg_PaintmapData\n     * @classdesc Represents a CSVCMsg_PaintmapData.\n     * @implements ICSVCMsg_PaintmapData\n     * @constructor\n     * @param {ICSVCMsg_PaintmapData=} [properties] Properties to set\n     */\n    function CSVCMsg_PaintmapData(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_PaintmapData paintmap.\n     * @member {Uint8Array} paintmap\n     * @memberof CSVCMsg_PaintmapData\n     * @instance\n     */\n    CSVCMsg_PaintmapData.prototype.paintmap = $util.newBuffer([]);\n    /**\n     * Decodes a CSVCMsg_PaintmapData message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_PaintmapData\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_PaintmapData} CSVCMsg_PaintmapData\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_PaintmapData.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_PaintmapData();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.paintmap = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CSVCMsg_PaintmapData;\n})());\nexports.CSVCMsg_GameEvent = ($root.CSVCMsg_GameEvent = (() => {\n    /**\n     * Properties of a CSVCMsg_GameEvent.\n     * @exports ICSVCMsg_GameEvent\n     * @interface ICSVCMsg_GameEvent\n     * @property {string|null} [eventName] CSVCMsg_GameEvent eventName\n     * @property {number|null} [eventid] CSVCMsg_GameEvent eventid\n     * @property {Array.<CSVCMsg_GameEvent.Ikey_t>|null} [keys] CSVCMsg_GameEvent keys\n     * @property {number|null} [passthrough] CSVCMsg_GameEvent passthrough\n     */\n    /**\n     * Constructs a new CSVCMsg_GameEvent.\n     * @exports CSVCMsg_GameEvent\n     * @classdesc Represents a CSVCMsg_GameEvent.\n     * @implements ICSVCMsg_GameEvent\n     * @constructor\n     * @param {ICSVCMsg_GameEvent=} [properties] Properties to set\n     */\n    function CSVCMsg_GameEvent(properties) {\n        this.keys = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_GameEvent eventName.\n     * @member {string} eventName\n     * @memberof CSVCMsg_GameEvent\n     * @instance\n     */\n    CSVCMsg_GameEvent.prototype.eventName = \"\";\n    /**\n     * CSVCMsg_GameEvent eventid.\n     * @member {number} eventid\n     * @memberof CSVCMsg_GameEvent\n     * @instance\n     */\n    CSVCMsg_GameEvent.prototype.eventid = 0;\n    /**\n     * CSVCMsg_GameEvent keys.\n     * @member {Array.<CSVCMsg_GameEvent.Ikey_t>} keys\n     * @memberof CSVCMsg_GameEvent\n     * @instance\n     */\n    CSVCMsg_GameEvent.prototype.keys = $util.emptyArray;\n    /**\n     * CSVCMsg_GameEvent passthrough.\n     * @member {number} passthrough\n     * @memberof CSVCMsg_GameEvent\n     * @instance\n     */\n    CSVCMsg_GameEvent.prototype.passthrough = 0;\n    /**\n     * Decodes a CSVCMsg_GameEvent message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_GameEvent\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_GameEvent} CSVCMsg_GameEvent\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_GameEvent.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEvent();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.eventName = reader.string();\n                    break;\n                case 2:\n                    message.eventid = reader.int32();\n                    break;\n                case 3:\n                    if (!(message.keys && message.keys.length))\n                        message.keys = [];\n                    message.keys.push($root.CSVCMsg_GameEvent.key_t.decode(reader, reader.uint32()));\n                    break;\n                case 4:\n                    message.passthrough = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CSVCMsg_GameEvent.key_t = (function () {\n        /**\n         * Properties of a key_t.\n         * @memberof CSVCMsg_GameEvent\n         * @interface Ikey_t\n         * @property {number|null} [type] key_t type\n         * @property {string|null} [valString] key_t valString\n         * @property {number|null} [valFloat] key_t valFloat\n         * @property {number|null} [valLong] key_t valLong\n         * @property {number|null} [valShort] key_t valShort\n         * @property {number|null} [valByte] key_t valByte\n         * @property {boolean|null} [valBool] key_t valBool\n         * @property {number|Long|null} [valUint64] key_t valUint64\n         * @property {Uint8Array|null} [valWstring] key_t valWstring\n         */\n        /**\n         * Constructs a new key_t.\n         * @memberof CSVCMsg_GameEvent\n         * @classdesc Represents a key_t.\n         * @implements Ikey_t\n         * @constructor\n         * @param {CSVCMsg_GameEvent.Ikey_t=} [properties] Properties to set\n         */\n        function key_t(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * key_t type.\n         * @member {number} type\n         * @memberof CSVCMsg_GameEvent.key_t\n         * @instance\n         */\n        key_t.prototype.type = 0;\n        /**\n         * key_t valString.\n         * @member {string} valString\n         * @memberof CSVCMsg_GameEvent.key_t\n         * @instance\n         */\n        key_t.prototype.valString = \"\";\n        /**\n         * key_t valFloat.\n         * @member {number} valFloat\n         * @memberof CSVCMsg_GameEvent.key_t\n         * @instance\n         */\n        key_t.prototype.valFloat = 0;\n        /**\n         * key_t valLong.\n         * @member {number} valLong\n         * @memberof CSVCMsg_GameEvent.key_t\n         * @instance\n         */\n        key_t.prototype.valLong = 0;\n        /**\n         * key_t valShort.\n         * @member {number} valShort\n         * @memberof CSVCMsg_GameEvent.key_t\n         * @instance\n         */\n        key_t.prototype.valShort = 0;\n        /**\n         * key_t valByte.\n         * @member {number} valByte\n         * @memberof CSVCMsg_GameEvent.key_t\n         * @instance\n         */\n        key_t.prototype.valByte = 0;\n        /**\n         * key_t valBool.\n         * @member {boolean} valBool\n         * @memberof CSVCMsg_GameEvent.key_t\n         * @instance\n         */\n        key_t.prototype.valBool = false;\n        /**\n         * key_t valUint64.\n         * @member {number|Long} valUint64\n         * @memberof CSVCMsg_GameEvent.key_t\n         * @instance\n         */\n        key_t.prototype.valUint64 = $util.Long\n            ? $util.Long.fromBits(0, 0, true)\n            : 0;\n        /**\n         * key_t valWstring.\n         * @member {Uint8Array} valWstring\n         * @memberof CSVCMsg_GameEvent.key_t\n         * @instance\n         */\n        key_t.prototype.valWstring = $util.newBuffer([]);\n        /**\n         * Decodes a key_t message from the specified reader or buffer.\n         * @function decode\n         * @memberof CSVCMsg_GameEvent.key_t\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CSVCMsg_GameEvent.key_t} key_t\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        key_t.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEvent.key_t();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.type = reader.int32();\n                        break;\n                    case 2:\n                        message.valString = reader.string();\n                        break;\n                    case 3:\n                        message.valFloat = reader.float();\n                        break;\n                    case 4:\n                        message.valLong = reader.int32();\n                        break;\n                    case 5:\n                        message.valShort = reader.int32();\n                        break;\n                    case 6:\n                        message.valByte = reader.int32();\n                        break;\n                    case 7:\n                        message.valBool = reader.bool();\n                        break;\n                    case 8:\n                        message.valUint64 = reader.uint64();\n                        break;\n                    case 9:\n                        message.valWstring = reader.bytes();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return key_t;\n    })();\n    return CSVCMsg_GameEvent;\n})());\nexports.CSVCMsg_GameEventList = ($root.CSVCMsg_GameEventList = (() => {\n    /**\n     * Properties of a CSVCMsg_GameEventList.\n     * @exports ICSVCMsg_GameEventList\n     * @interface ICSVCMsg_GameEventList\n     * @property {Array.<CSVCMsg_GameEventList.Idescriptor_t>|null} [descriptors] CSVCMsg_GameEventList descriptors\n     */\n    /**\n     * Constructs a new CSVCMsg_GameEventList.\n     * @exports CSVCMsg_GameEventList\n     * @classdesc Represents a CSVCMsg_GameEventList.\n     * @implements ICSVCMsg_GameEventList\n     * @constructor\n     * @param {ICSVCMsg_GameEventList=} [properties] Properties to set\n     */\n    function CSVCMsg_GameEventList(properties) {\n        this.descriptors = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_GameEventList descriptors.\n     * @member {Array.<CSVCMsg_GameEventList.Idescriptor_t>} descriptors\n     * @memberof CSVCMsg_GameEventList\n     * @instance\n     */\n    CSVCMsg_GameEventList.prototype.descriptors = $util.emptyArray;\n    /**\n     * Decodes a CSVCMsg_GameEventList message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_GameEventList\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_GameEventList} CSVCMsg_GameEventList\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_GameEventList.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEventList();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.descriptors && message.descriptors.length))\n                        message.descriptors = [];\n                    message.descriptors.push($root.CSVCMsg_GameEventList.descriptor_t.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CSVCMsg_GameEventList.key_t = (function () {\n        /**\n         * Properties of a key_t.\n         * @memberof CSVCMsg_GameEventList\n         * @interface Ikey_t\n         * @property {number|null} [type] key_t type\n         * @property {string|null} [name] key_t name\n         */\n        /**\n         * Constructs a new key_t.\n         * @memberof CSVCMsg_GameEventList\n         * @classdesc Represents a key_t.\n         * @implements Ikey_t\n         * @constructor\n         * @param {CSVCMsg_GameEventList.Ikey_t=} [properties] Properties to set\n         */\n        function key_t(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * key_t type.\n         * @member {number} type\n         * @memberof CSVCMsg_GameEventList.key_t\n         * @instance\n         */\n        key_t.prototype.type = 0;\n        /**\n         * key_t name.\n         * @member {string} name\n         * @memberof CSVCMsg_GameEventList.key_t\n         * @instance\n         */\n        key_t.prototype.name = \"\";\n        /**\n         * Decodes a key_t message from the specified reader or buffer.\n         * @function decode\n         * @memberof CSVCMsg_GameEventList.key_t\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CSVCMsg_GameEventList.key_t} key_t\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        key_t.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEventList.key_t();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.type = reader.int32();\n                        break;\n                    case 2:\n                        message.name = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return key_t;\n    })();\n    CSVCMsg_GameEventList.descriptor_t = (function () {\n        /**\n         * Properties of a descriptor_t.\n         * @memberof CSVCMsg_GameEventList\n         * @interface Idescriptor_t\n         * @property {number|null} [eventid] descriptor_t eventid\n         * @property {string|null} [name] descriptor_t name\n         * @property {Array.<CSVCMsg_GameEventList.Ikey_t>|null} [keys] descriptor_t keys\n         */\n        /**\n         * Constructs a new descriptor_t.\n         * @memberof CSVCMsg_GameEventList\n         * @classdesc Represents a descriptor_t.\n         * @implements Idescriptor_t\n         * @constructor\n         * @param {CSVCMsg_GameEventList.Idescriptor_t=} [properties] Properties to set\n         */\n        function descriptor_t(properties) {\n            this.keys = [];\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * descriptor_t eventid.\n         * @member {number} eventid\n         * @memberof CSVCMsg_GameEventList.descriptor_t\n         * @instance\n         */\n        descriptor_t.prototype.eventid = 0;\n        /**\n         * descriptor_t name.\n         * @member {string} name\n         * @memberof CSVCMsg_GameEventList.descriptor_t\n         * @instance\n         */\n        descriptor_t.prototype.name = \"\";\n        /**\n         * descriptor_t keys.\n         * @member {Array.<CSVCMsg_GameEventList.Ikey_t>} keys\n         * @memberof CSVCMsg_GameEventList.descriptor_t\n         * @instance\n         */\n        descriptor_t.prototype.keys = $util.emptyArray;\n        /**\n         * Decodes a descriptor_t message from the specified reader or buffer.\n         * @function decode\n         * @memberof CSVCMsg_GameEventList.descriptor_t\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CSVCMsg_GameEventList.descriptor_t} descriptor_t\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        descriptor_t.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_GameEventList.descriptor_t();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.eventid = reader.int32();\n                        break;\n                    case 2:\n                        message.name = reader.string();\n                        break;\n                    case 3:\n                        if (!(message.keys && message.keys.length))\n                            message.keys = [];\n                        message.keys.push($root.CSVCMsg_GameEventList.key_t.decode(reader, reader.uint32()));\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return descriptor_t;\n    })();\n    return CSVCMsg_GameEventList;\n})());\nexports.CSVCMsg_TempEntities = ($root.CSVCMsg_TempEntities = (() => {\n    /**\n     * Properties of a CSVCMsg_TempEntities.\n     * @exports ICSVCMsg_TempEntities\n     * @interface ICSVCMsg_TempEntities\n     * @property {boolean|null} [reliable] CSVCMsg_TempEntities reliable\n     * @property {number|null} [numEntries] CSVCMsg_TempEntities numEntries\n     * @property {Uint8Array|null} [entityData] CSVCMsg_TempEntities entityData\n     */\n    /**\n     * Constructs a new CSVCMsg_TempEntities.\n     * @exports CSVCMsg_TempEntities\n     * @classdesc Represents a CSVCMsg_TempEntities.\n     * @implements ICSVCMsg_TempEntities\n     * @constructor\n     * @param {ICSVCMsg_TempEntities=} [properties] Properties to set\n     */\n    function CSVCMsg_TempEntities(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_TempEntities reliable.\n     * @member {boolean} reliable\n     * @memberof CSVCMsg_TempEntities\n     * @instance\n     */\n    CSVCMsg_TempEntities.prototype.reliable = false;\n    /**\n     * CSVCMsg_TempEntities numEntries.\n     * @member {number} numEntries\n     * @memberof CSVCMsg_TempEntities\n     * @instance\n     */\n    CSVCMsg_TempEntities.prototype.numEntries = 0;\n    /**\n     * CSVCMsg_TempEntities entityData.\n     * @member {Uint8Array} entityData\n     * @memberof CSVCMsg_TempEntities\n     * @instance\n     */\n    CSVCMsg_TempEntities.prototype.entityData = $util.newBuffer([]);\n    /**\n     * Decodes a CSVCMsg_TempEntities message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_TempEntities\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_TempEntities} CSVCMsg_TempEntities\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_TempEntities.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_TempEntities();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.reliable = reader.bool();\n                    break;\n                case 2:\n                    message.numEntries = reader.int32();\n                    break;\n                case 3:\n                    message.entityData = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CSVCMsg_TempEntities;\n})());\nexports.CSVCMsg_PacketEntities = ($root.CSVCMsg_PacketEntities = (() => {\n    /**\n     * Properties of a CSVCMsg_PacketEntities.\n     * @exports ICSVCMsg_PacketEntities\n     * @interface ICSVCMsg_PacketEntities\n     * @property {number|null} [maxEntries] CSVCMsg_PacketEntities maxEntries\n     * @property {number|null} [updatedEntries] CSVCMsg_PacketEntities updatedEntries\n     * @property {boolean|null} [isDelta] CSVCMsg_PacketEntities isDelta\n     * @property {boolean|null} [updateBaseline] CSVCMsg_PacketEntities updateBaseline\n     * @property {number|null} [baseline] CSVCMsg_PacketEntities baseline\n     * @property {number|null} [deltaFrom] CSVCMsg_PacketEntities deltaFrom\n     * @property {Uint8Array|null} [entityData] CSVCMsg_PacketEntities entityData\n     */\n    /**\n     * Constructs a new CSVCMsg_PacketEntities.\n     * @exports CSVCMsg_PacketEntities\n     * @classdesc Represents a CSVCMsg_PacketEntities.\n     * @implements ICSVCMsg_PacketEntities\n     * @constructor\n     * @param {ICSVCMsg_PacketEntities=} [properties] Properties to set\n     */\n    function CSVCMsg_PacketEntities(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_PacketEntities maxEntries.\n     * @member {number} maxEntries\n     * @memberof CSVCMsg_PacketEntities\n     * @instance\n     */\n    CSVCMsg_PacketEntities.prototype.maxEntries = 0;\n    /**\n     * CSVCMsg_PacketEntities updatedEntries.\n     * @member {number} updatedEntries\n     * @memberof CSVCMsg_PacketEntities\n     * @instance\n     */\n    CSVCMsg_PacketEntities.prototype.updatedEntries = 0;\n    /**\n     * CSVCMsg_PacketEntities isDelta.\n     * @member {boolean} isDelta\n     * @memberof CSVCMsg_PacketEntities\n     * @instance\n     */\n    CSVCMsg_PacketEntities.prototype.isDelta = false;\n    /**\n     * CSVCMsg_PacketEntities updateBaseline.\n     * @member {boolean} updateBaseline\n     * @memberof CSVCMsg_PacketEntities\n     * @instance\n     */\n    CSVCMsg_PacketEntities.prototype.updateBaseline = false;\n    /**\n     * CSVCMsg_PacketEntities baseline.\n     * @member {number} baseline\n     * @memberof CSVCMsg_PacketEntities\n     * @instance\n     */\n    CSVCMsg_PacketEntities.prototype.baseline = 0;\n    /**\n     * CSVCMsg_PacketEntities deltaFrom.\n     * @member {number} deltaFrom\n     * @memberof CSVCMsg_PacketEntities\n     * @instance\n     */\n    CSVCMsg_PacketEntities.prototype.deltaFrom = 0;\n    /**\n     * CSVCMsg_PacketEntities entityData.\n     * @member {Uint8Array} entityData\n     * @memberof CSVCMsg_PacketEntities\n     * @instance\n     */\n    CSVCMsg_PacketEntities.prototype.entityData = $util.newBuffer([]);\n    /**\n     * Decodes a CSVCMsg_PacketEntities message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_PacketEntities\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_PacketEntities} CSVCMsg_PacketEntities\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_PacketEntities.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_PacketEntities();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.maxEntries = reader.int32();\n                    break;\n                case 2:\n                    message.updatedEntries = reader.int32();\n                    break;\n                case 3:\n                    message.isDelta = reader.bool();\n                    break;\n                case 4:\n                    message.updateBaseline = reader.bool();\n                    break;\n                case 5:\n                    message.baseline = reader.int32();\n                    break;\n                case 6:\n                    message.deltaFrom = reader.int32();\n                    break;\n                case 7:\n                    message.entityData = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CSVCMsg_PacketEntities;\n})());\nexports.CSVCMsg_Sounds = ($root.CSVCMsg_Sounds = (() => {\n    /**\n     * Properties of a CSVCMsg_Sounds.\n     * @exports ICSVCMsg_Sounds\n     * @interface ICSVCMsg_Sounds\n     * @property {boolean|null} [reliableSound] CSVCMsg_Sounds reliableSound\n     * @property {Array.<CSVCMsg_Sounds.Isounddata_t>|null} [sounds] CSVCMsg_Sounds sounds\n     */\n    /**\n     * Constructs a new CSVCMsg_Sounds.\n     * @exports CSVCMsg_Sounds\n     * @classdesc Represents a CSVCMsg_Sounds.\n     * @implements ICSVCMsg_Sounds\n     * @constructor\n     * @param {ICSVCMsg_Sounds=} [properties] Properties to set\n     */\n    function CSVCMsg_Sounds(properties) {\n        this.sounds = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_Sounds reliableSound.\n     * @member {boolean} reliableSound\n     * @memberof CSVCMsg_Sounds\n     * @instance\n     */\n    CSVCMsg_Sounds.prototype.reliableSound = false;\n    /**\n     * CSVCMsg_Sounds sounds.\n     * @member {Array.<CSVCMsg_Sounds.Isounddata_t>} sounds\n     * @memberof CSVCMsg_Sounds\n     * @instance\n     */\n    CSVCMsg_Sounds.prototype.sounds = $util.emptyArray;\n    /**\n     * Decodes a CSVCMsg_Sounds message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_Sounds\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_Sounds} CSVCMsg_Sounds\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_Sounds.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Sounds();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.reliableSound = reader.bool();\n                    break;\n                case 2:\n                    if (!(message.sounds && message.sounds.length))\n                        message.sounds = [];\n                    message.sounds.push($root.CSVCMsg_Sounds.sounddata_t.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CSVCMsg_Sounds.sounddata_t = (function () {\n        /**\n         * Properties of a sounddata_t.\n         * @memberof CSVCMsg_Sounds\n         * @interface Isounddata_t\n         * @property {number|null} [originX] sounddata_t originX\n         * @property {number|null} [originY] sounddata_t originY\n         * @property {number|null} [originZ] sounddata_t originZ\n         * @property {number|null} [volume] sounddata_t volume\n         * @property {number|null} [delayValue] sounddata_t delayValue\n         * @property {number|null} [sequenceNumber] sounddata_t sequenceNumber\n         * @property {number|null} [entityIndex] sounddata_t entityIndex\n         * @property {number|null} [channel] sounddata_t channel\n         * @property {number|null} [pitch] sounddata_t pitch\n         * @property {number|null} [flags] sounddata_t flags\n         * @property {number|null} [soundNum] sounddata_t soundNum\n         * @property {number|null} [soundNumHandle] sounddata_t soundNumHandle\n         * @property {number|null} [speakerEntity] sounddata_t speakerEntity\n         * @property {number|null} [randomSeed] sounddata_t randomSeed\n         * @property {number|null} [soundLevel] sounddata_t soundLevel\n         * @property {boolean|null} [isSentence] sounddata_t isSentence\n         * @property {boolean|null} [isAmbient] sounddata_t isAmbient\n         */\n        /**\n         * Constructs a new sounddata_t.\n         * @memberof CSVCMsg_Sounds\n         * @classdesc Represents a sounddata_t.\n         * @implements Isounddata_t\n         * @constructor\n         * @param {CSVCMsg_Sounds.Isounddata_t=} [properties] Properties to set\n         */\n        function sounddata_t(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * sounddata_t originX.\n         * @member {number} originX\n         * @memberof CSVCMsg_Sounds.sounddata_t\n         * @instance\n         */\n        sounddata_t.prototype.originX = 0;\n        /**\n         * sounddata_t originY.\n         * @member {number} originY\n         * @memberof CSVCMsg_Sounds.sounddata_t\n         * @instance\n         */\n        sounddata_t.prototype.originY = 0;\n        /**\n         * sounddata_t originZ.\n         * @member {number} originZ\n         * @memberof CSVCMsg_Sounds.sounddata_t\n         * @instance\n         */\n        sounddata_t.prototype.originZ = 0;\n        /**\n         * sounddata_t volume.\n         * @member {number} volume\n         * @memberof CSVCMsg_Sounds.sounddata_t\n         * @instance\n         */\n        sounddata_t.prototype.volume = 0;\n        /**\n         * sounddata_t delayValue.\n         * @member {number} delayValue\n         * @memberof CSVCMsg_Sounds.sounddata_t\n         * @instance\n         */\n        sounddata_t.prototype.delayValue = 0;\n        /**\n         * sounddata_t sequenceNumber.\n         * @member {number} sequenceNumber\n         * @memberof CSVCMsg_Sounds.sounddata_t\n         * @instance\n         */\n        sounddata_t.prototype.sequenceNumber = 0;\n        /**\n         * sounddata_t entityIndex.\n         * @member {number} entityIndex\n         * @memberof CSVCMsg_Sounds.sounddata_t\n         * @instance\n         */\n        sounddata_t.prototype.entityIndex = 0;\n        /**\n         * sounddata_t channel.\n         * @member {number} channel\n         * @memberof CSVCMsg_Sounds.sounddata_t\n         * @instance\n         */\n        sounddata_t.prototype.channel = 0;\n        /**\n         * sounddata_t pitch.\n         * @member {number} pitch\n         * @memberof CSVCMsg_Sounds.sounddata_t\n         * @instance\n         */\n        sounddata_t.prototype.pitch = 0;\n        /**\n         * sounddata_t flags.\n         * @member {number} flags\n         * @memberof CSVCMsg_Sounds.sounddata_t\n         * @instance\n         */\n        sounddata_t.prototype.flags = 0;\n        /**\n         * sounddata_t soundNum.\n         * @member {number} soundNum\n         * @memberof CSVCMsg_Sounds.sounddata_t\n         * @instance\n         */\n        sounddata_t.prototype.soundNum = 0;\n        /**\n         * sounddata_t soundNumHandle.\n         * @member {number} soundNumHandle\n         * @memberof CSVCMsg_Sounds.sounddata_t\n         * @instance\n         */\n        sounddata_t.prototype.soundNumHandle = 0;\n        /**\n         * sounddata_t speakerEntity.\n         * @member {number} speakerEntity\n         * @memberof CSVCMsg_Sounds.sounddata_t\n         * @instance\n         */\n        sounddata_t.prototype.speakerEntity = 0;\n        /**\n         * sounddata_t randomSeed.\n         * @member {number} randomSeed\n         * @memberof CSVCMsg_Sounds.sounddata_t\n         * @instance\n         */\n        sounddata_t.prototype.randomSeed = 0;\n        /**\n         * sounddata_t soundLevel.\n         * @member {number} soundLevel\n         * @memberof CSVCMsg_Sounds.sounddata_t\n         * @instance\n         */\n        sounddata_t.prototype.soundLevel = 0;\n        /**\n         * sounddata_t isSentence.\n         * @member {boolean} isSentence\n         * @memberof CSVCMsg_Sounds.sounddata_t\n         * @instance\n         */\n        sounddata_t.prototype.isSentence = false;\n        /**\n         * sounddata_t isAmbient.\n         * @member {boolean} isAmbient\n         * @memberof CSVCMsg_Sounds.sounddata_t\n         * @instance\n         */\n        sounddata_t.prototype.isAmbient = false;\n        /**\n         * Decodes a sounddata_t message from the specified reader or buffer.\n         * @function decode\n         * @memberof CSVCMsg_Sounds.sounddata_t\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CSVCMsg_Sounds.sounddata_t} sounddata_t\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        sounddata_t.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_Sounds.sounddata_t();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.originX = reader.sint32();\n                        break;\n                    case 2:\n                        message.originY = reader.sint32();\n                        break;\n                    case 3:\n                        message.originZ = reader.sint32();\n                        break;\n                    case 4:\n                        message.volume = reader.uint32();\n                        break;\n                    case 5:\n                        message.delayValue = reader.float();\n                        break;\n                    case 6:\n                        message.sequenceNumber = reader.int32();\n                        break;\n                    case 7:\n                        message.entityIndex = reader.int32();\n                        break;\n                    case 8:\n                        message.channel = reader.int32();\n                        break;\n                    case 9:\n                        message.pitch = reader.int32();\n                        break;\n                    case 10:\n                        message.flags = reader.int32();\n                        break;\n                    case 11:\n                        message.soundNum = reader.uint32();\n                        break;\n                    case 12:\n                        message.soundNumHandle = reader.fixed32();\n                        break;\n                    case 13:\n                        message.speakerEntity = reader.int32();\n                        break;\n                    case 14:\n                        message.randomSeed = reader.int32();\n                        break;\n                    case 15:\n                        message.soundLevel = reader.int32();\n                        break;\n                    case 16:\n                        message.isSentence = reader.bool();\n                        break;\n                    case 17:\n                        message.isAmbient = reader.bool();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return sounddata_t;\n    })();\n    return CSVCMsg_Sounds;\n})());\nexports.CSVCMsg_EntityMsg = ($root.CSVCMsg_EntityMsg = (() => {\n    /**\n     * Properties of a CSVCMsg_EntityMsg.\n     * @exports ICSVCMsg_EntityMsg\n     * @interface ICSVCMsg_EntityMsg\n     * @property {number|null} [entIndex] CSVCMsg_EntityMsg entIndex\n     * @property {number|null} [classId] CSVCMsg_EntityMsg classId\n     * @property {Uint8Array|null} [entData] CSVCMsg_EntityMsg entData\n     */\n    /**\n     * Constructs a new CSVCMsg_EntityMsg.\n     * @exports CSVCMsg_EntityMsg\n     * @classdesc Represents a CSVCMsg_EntityMsg.\n     * @implements ICSVCMsg_EntityMsg\n     * @constructor\n     * @param {ICSVCMsg_EntityMsg=} [properties] Properties to set\n     */\n    function CSVCMsg_EntityMsg(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_EntityMsg entIndex.\n     * @member {number} entIndex\n     * @memberof CSVCMsg_EntityMsg\n     * @instance\n     */\n    CSVCMsg_EntityMsg.prototype.entIndex = 0;\n    /**\n     * CSVCMsg_EntityMsg classId.\n     * @member {number} classId\n     * @memberof CSVCMsg_EntityMsg\n     * @instance\n     */\n    CSVCMsg_EntityMsg.prototype.classId = 0;\n    /**\n     * CSVCMsg_EntityMsg entData.\n     * @member {Uint8Array} entData\n     * @memberof CSVCMsg_EntityMsg\n     * @instance\n     */\n    CSVCMsg_EntityMsg.prototype.entData = $util.newBuffer([]);\n    /**\n     * Decodes a CSVCMsg_EntityMsg message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_EntityMsg\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_EntityMsg} CSVCMsg_EntityMsg\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_EntityMsg.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_EntityMsg();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.entIndex = reader.int32();\n                    break;\n                case 2:\n                    message.classId = reader.int32();\n                    break;\n                case 3:\n                    message.entData = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CSVCMsg_EntityMsg;\n})());\nexports.CSVCMsg_CmdKeyValues = ($root.CSVCMsg_CmdKeyValues = (() => {\n    /**\n     * Properties of a CSVCMsg_CmdKeyValues.\n     * @exports ICSVCMsg_CmdKeyValues\n     * @interface ICSVCMsg_CmdKeyValues\n     * @property {Uint8Array|null} [keyvalues] CSVCMsg_CmdKeyValues keyvalues\n     */\n    /**\n     * Constructs a new CSVCMsg_CmdKeyValues.\n     * @exports CSVCMsg_CmdKeyValues\n     * @classdesc Represents a CSVCMsg_CmdKeyValues.\n     * @implements ICSVCMsg_CmdKeyValues\n     * @constructor\n     * @param {ICSVCMsg_CmdKeyValues=} [properties] Properties to set\n     */\n    function CSVCMsg_CmdKeyValues(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_CmdKeyValues keyvalues.\n     * @member {Uint8Array} keyvalues\n     * @memberof CSVCMsg_CmdKeyValues\n     * @instance\n     */\n    CSVCMsg_CmdKeyValues.prototype.keyvalues = $util.newBuffer([]);\n    /**\n     * Decodes a CSVCMsg_CmdKeyValues message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_CmdKeyValues\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_CmdKeyValues} CSVCMsg_CmdKeyValues\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_CmdKeyValues.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_CmdKeyValues();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.keyvalues = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CSVCMsg_CmdKeyValues;\n})());\nexports.CSVCMsg_EncryptedData = ($root.CSVCMsg_EncryptedData = (() => {\n    /**\n     * Properties of a CSVCMsg_EncryptedData.\n     * @exports ICSVCMsg_EncryptedData\n     * @interface ICSVCMsg_EncryptedData\n     * @property {Uint8Array|null} [encrypted] CSVCMsg_EncryptedData encrypted\n     * @property {number|null} [keyType] CSVCMsg_EncryptedData keyType\n     */\n    /**\n     * Constructs a new CSVCMsg_EncryptedData.\n     * @exports CSVCMsg_EncryptedData\n     * @classdesc Represents a CSVCMsg_EncryptedData.\n     * @implements ICSVCMsg_EncryptedData\n     * @constructor\n     * @param {ICSVCMsg_EncryptedData=} [properties] Properties to set\n     */\n    function CSVCMsg_EncryptedData(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_EncryptedData encrypted.\n     * @member {Uint8Array} encrypted\n     * @memberof CSVCMsg_EncryptedData\n     * @instance\n     */\n    CSVCMsg_EncryptedData.prototype.encrypted = $util.newBuffer([]);\n    /**\n     * CSVCMsg_EncryptedData keyType.\n     * @member {number} keyType\n     * @memberof CSVCMsg_EncryptedData\n     * @instance\n     */\n    CSVCMsg_EncryptedData.prototype.keyType = 0;\n    /**\n     * Decodes a CSVCMsg_EncryptedData message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_EncryptedData\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_EncryptedData} CSVCMsg_EncryptedData\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_EncryptedData.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_EncryptedData();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.encrypted = reader.bytes();\n                    break;\n                case 2:\n                    message.keyType = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CSVCMsg_EncryptedData;\n})());\nexports.CSVCMsg_HltvReplay = ($root.CSVCMsg_HltvReplay = (() => {\n    /**\n     * Properties of a CSVCMsg_HltvReplay.\n     * @exports ICSVCMsg_HltvReplay\n     * @interface ICSVCMsg_HltvReplay\n     * @property {number|null} [delay] CSVCMsg_HltvReplay delay\n     * @property {number|null} [primaryTarget] CSVCMsg_HltvReplay primaryTarget\n     * @property {number|null} [replayStopAt] CSVCMsg_HltvReplay replayStopAt\n     * @property {number|null} [replayStartAt] CSVCMsg_HltvReplay replayStartAt\n     * @property {number|null} [replaySlowdownBegin] CSVCMsg_HltvReplay replaySlowdownBegin\n     * @property {number|null} [replaySlowdownEnd] CSVCMsg_HltvReplay replaySlowdownEnd\n     * @property {number|null} [replaySlowdownRate] CSVCMsg_HltvReplay replaySlowdownRate\n     */\n    /**\n     * Constructs a new CSVCMsg_HltvReplay.\n     * @exports CSVCMsg_HltvReplay\n     * @classdesc Represents a CSVCMsg_HltvReplay.\n     * @implements ICSVCMsg_HltvReplay\n     * @constructor\n     * @param {ICSVCMsg_HltvReplay=} [properties] Properties to set\n     */\n    function CSVCMsg_HltvReplay(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSVCMsg_HltvReplay delay.\n     * @member {number} delay\n     * @memberof CSVCMsg_HltvReplay\n     * @instance\n     */\n    CSVCMsg_HltvReplay.prototype.delay = 0;\n    /**\n     * CSVCMsg_HltvReplay primaryTarget.\n     * @member {number} primaryTarget\n     * @memberof CSVCMsg_HltvReplay\n     * @instance\n     */\n    CSVCMsg_HltvReplay.prototype.primaryTarget = 0;\n    /**\n     * CSVCMsg_HltvReplay replayStopAt.\n     * @member {number} replayStopAt\n     * @memberof CSVCMsg_HltvReplay\n     * @instance\n     */\n    CSVCMsg_HltvReplay.prototype.replayStopAt = 0;\n    /**\n     * CSVCMsg_HltvReplay replayStartAt.\n     * @member {number} replayStartAt\n     * @memberof CSVCMsg_HltvReplay\n     * @instance\n     */\n    CSVCMsg_HltvReplay.prototype.replayStartAt = 0;\n    /**\n     * CSVCMsg_HltvReplay replaySlowdownBegin.\n     * @member {number} replaySlowdownBegin\n     * @memberof CSVCMsg_HltvReplay\n     * @instance\n     */\n    CSVCMsg_HltvReplay.prototype.replaySlowdownBegin = 0;\n    /**\n     * CSVCMsg_HltvReplay replaySlowdownEnd.\n     * @member {number} replaySlowdownEnd\n     * @memberof CSVCMsg_HltvReplay\n     * @instance\n     */\n    CSVCMsg_HltvReplay.prototype.replaySlowdownEnd = 0;\n    /**\n     * CSVCMsg_HltvReplay replaySlowdownRate.\n     * @member {number} replaySlowdownRate\n     * @memberof CSVCMsg_HltvReplay\n     * @instance\n     */\n    CSVCMsg_HltvReplay.prototype.replaySlowdownRate = 0;\n    /**\n     * Decodes a CSVCMsg_HltvReplay message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSVCMsg_HltvReplay\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSVCMsg_HltvReplay} CSVCMsg_HltvReplay\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSVCMsg_HltvReplay.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSVCMsg_HltvReplay();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.delay = reader.int32();\n                    break;\n                case 2:\n                    message.primaryTarget = reader.int32();\n                    break;\n                case 3:\n                    message.replayStopAt = reader.int32();\n                    break;\n                case 4:\n                    message.replayStartAt = reader.int32();\n                    break;\n                case 5:\n                    message.replaySlowdownBegin = reader.int32();\n                    break;\n                case 6:\n                    message.replaySlowdownEnd = reader.int32();\n                    break;\n                case 7:\n                    message.replaySlowdownRate = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CSVCMsg_HltvReplay;\n})());\nexports.CCLCMsg_HltvReplay = ($root.CCLCMsg_HltvReplay = (() => {\n    /**\n     * Properties of a CCLCMsg_HltvReplay.\n     * @exports ICCLCMsg_HltvReplay\n     * @interface ICCLCMsg_HltvReplay\n     * @property {number|null} [request] CCLCMsg_HltvReplay request\n     * @property {number|null} [slowdownLength] CCLCMsg_HltvReplay slowdownLength\n     * @property {number|null} [slowdownRate] CCLCMsg_HltvReplay slowdownRate\n     * @property {number|null} [primaryTargetEntIndex] CCLCMsg_HltvReplay primaryTargetEntIndex\n     * @property {number|null} [eventTime] CCLCMsg_HltvReplay eventTime\n     */\n    /**\n     * Constructs a new CCLCMsg_HltvReplay.\n     * @exports CCLCMsg_HltvReplay\n     * @classdesc Represents a CCLCMsg_HltvReplay.\n     * @implements ICCLCMsg_HltvReplay\n     * @constructor\n     * @param {ICCLCMsg_HltvReplay=} [properties] Properties to set\n     */\n    function CCLCMsg_HltvReplay(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CCLCMsg_HltvReplay request.\n     * @member {number} request\n     * @memberof CCLCMsg_HltvReplay\n     * @instance\n     */\n    CCLCMsg_HltvReplay.prototype.request = 0;\n    /**\n     * CCLCMsg_HltvReplay slowdownLength.\n     * @member {number} slowdownLength\n     * @memberof CCLCMsg_HltvReplay\n     * @instance\n     */\n    CCLCMsg_HltvReplay.prototype.slowdownLength = 0;\n    /**\n     * CCLCMsg_HltvReplay slowdownRate.\n     * @member {number} slowdownRate\n     * @memberof CCLCMsg_HltvReplay\n     * @instance\n     */\n    CCLCMsg_HltvReplay.prototype.slowdownRate = 0;\n    /**\n     * CCLCMsg_HltvReplay primaryTargetEntIndex.\n     * @member {number} primaryTargetEntIndex\n     * @memberof CCLCMsg_HltvReplay\n     * @instance\n     */\n    CCLCMsg_HltvReplay.prototype.primaryTargetEntIndex = 0;\n    /**\n     * CCLCMsg_HltvReplay eventTime.\n     * @member {number} eventTime\n     * @memberof CCLCMsg_HltvReplay\n     * @instance\n     */\n    CCLCMsg_HltvReplay.prototype.eventTime = 0;\n    /**\n     * Decodes a CCLCMsg_HltvReplay message from the specified reader or buffer.\n     * @function decode\n     * @memberof CCLCMsg_HltvReplay\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CCLCMsg_HltvReplay} CCLCMsg_HltvReplay\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CCLCMsg_HltvReplay.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CCLCMsg_HltvReplay();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.request = reader.int32();\n                    break;\n                case 2:\n                    message.slowdownLength = reader.float();\n                    break;\n                case 3:\n                    message.slowdownRate = reader.float();\n                    break;\n                case 4:\n                    message.primaryTargetEntIndex = reader.int32();\n                    break;\n                case 5:\n                    message.eventTime = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CCLCMsg_HltvReplay;\n})());\n/**\n * ECsgoGCMsg enum.\n * @exports ECsgoGCMsg\n * @enum {string}\n * @property {number} k_EMsgGCCStrike15_v2_Base=9100 k_EMsgGCCStrike15_v2_Base value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingStart=9101 k_EMsgGCCStrike15_v2_MatchmakingStart value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingStop=9102 k_EMsgGCCStrike15_v2_MatchmakingStop value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing=9103 k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate=9104 k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ServerReserve=9105 k_EMsgGCCStrike15_v2_MatchmakingGC2ServerReserve value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse=9106 k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve=9107 k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingServerRoundStats=9108 k_EMsgGCCStrike15_v2_MatchmakingServerRoundStats value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello=9109 k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello=9110 k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingServerMatchEnd=9111 k_EMsgGCCStrike15_v2_MatchmakingServerMatchEnd value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon=9112 k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick=9113 k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm=9114 k_EMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats=9115 k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate=9116 k_EMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate value\n * @property {number} k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate=9117 k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate value\n * @property {number} k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty=9118 k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty value\n * @property {number} k_EMsgGCCStrike15_v2_ClientReportPlayer=9119 k_EMsgGCCStrike15_v2_ClientReportPlayer value\n * @property {number} k_EMsgGCCStrike15_v2_ClientReportServer=9120 k_EMsgGCCStrike15_v2_ClientReportServer value\n * @property {number} k_EMsgGCCStrike15_v2_ClientCommendPlayer=9121 k_EMsgGCCStrike15_v2_ClientCommendPlayer value\n * @property {number} k_EMsgGCCStrike15_v2_ClientReportResponse=9122 k_EMsgGCCStrike15_v2_ClientReportResponse value\n * @property {number} k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery=9123 k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery value\n * @property {number} k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse=9124 k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse value\n * @property {number} k_EMsgGCCStrike15_v2_WatchInfoUsers=9126 k_EMsgGCCStrike15_v2_WatchInfoUsers value\n * @property {number} k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile=9127 k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile value\n * @property {number} k_EMsgGCCStrike15_v2_PlayersProfile=9128 k_EMsgGCCStrike15_v2_PlayersProfile value\n * @property {number} k_EMsgGCCStrike15_v2_SetMyMedalsInfo=9129 k_EMsgGCCStrike15_v2_SetMyMedalsInfo value\n * @property {number} k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate=9131 k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate value\n * @property {number} k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment=9132 k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment value\n * @property {number} k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus=9133 k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus value\n * @property {number} k_EMsgGCCStrike15_v2_GC2ClientTextMsg=9134 k_EMsgGCCStrike15_v2_GC2ClientTextMsg value\n * @property {number} k_EMsgGCCStrike15_v2_Client2GCTextMsg=9135 k_EMsgGCCStrike15_v2_Client2GCTextMsg value\n * @property {number} k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops=9136 k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops value\n * @property {number} k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification=9137 k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification value\n * @property {number} k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2=9138 k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2 value\n * @property {number} k_EMsgGCCStrike15_v2_MatchList=9139 k_EMsgGCCStrike15_v2_MatchList value\n * @property {number} k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames=9140 k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames value\n * @property {number} k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames=9141 k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames value\n * @property {number} k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate=9142 k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate value\n * @property {number} k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo=9144 k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo value\n * @property {number} k_EMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification=9145 k_EMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification value\n * @property {number} k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames=9146 k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames value\n * @property {number} k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo=9147 k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo value\n * @property {number} k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest=9148 k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest value\n * @property {number} k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse=9149 k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse value\n * @property {number} k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo=9150 k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo value\n * @property {number} k_EMsgGCToGCReloadVersions=9151 k_EMsgGCToGCReloadVersions value\n * @property {number} k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote=9152 k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote value\n * @property {number} k_EMsgGCCStrike15_v2_Server2GCClientValidate=9153 k_EMsgGCCStrike15_v2_Server2GCClientValidate value\n * @property {number} k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser=9154 k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser value\n * @property {number} k_EMsgGCCStrike15_v2_Server2GCPureServerValidationFailure=9155 k_EMsgGCCStrike15_v2_Server2GCPureServerValidationFailure value\n * @property {number} k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest=9156 k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest value\n * @property {number} k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse=9157 k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse value\n * @property {number} k_EMsgGCCStrike15_v2_AccountPrivacySettings=9158 k_EMsgGCCStrike15_v2_AccountPrivacySettings value\n * @property {number} k_EMsgGCCStrike15_v2_SetMyActivityInfo=9159 k_EMsgGCCStrike15_v2_SetMyActivityInfo value\n * @property {number} k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions=9160 k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions value\n * @property {number} k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions=9161 k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions value\n * @property {number} k_EMsgGCCStrike15_v2_DraftSummary=9162 k_EMsgGCCStrike15_v2_DraftSummary value\n * @property {number} k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData=9163 k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData value\n * @property {number} k_EMsgGCCStrike15_v2_ClientRequestJoinServerData=9164 k_EMsgGCCStrike15_v2_ClientRequestJoinServerData value\n * @property {number} k_EMsgGCCStrike15_v2_ClientRequestNewMission=9165 k_EMsgGCCStrike15_v2_ClientRequestNewMission value\n * @property {number} k_EMsgGCCStrike15_v2_GC2ServerNotifyXPRewarded=9166 k_EMsgGCCStrike15_v2_GC2ServerNotifyXPRewarded value\n * @property {number} k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo=9167 k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo value\n * @property {number} k_EMsgGC_GlobalGame_Subscribe=9168 k_EMsgGC_GlobalGame_Subscribe value\n * @property {number} k_EMsgGC_GlobalGame_Unsubscribe=9169 k_EMsgGC_GlobalGame_Unsubscribe value\n * @property {number} k_EMsgGC_GlobalGame_Play=9170 k_EMsgGC_GlobalGame_Play value\n * @property {number} k_EMsgGCCStrike15_v2_AcknowledgePenalty=9171 k_EMsgGCCStrike15_v2_AcknowledgePenalty value\n * @property {number} k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin=9172 k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin value\n * @property {number} k_EMsgGCCStrike15_v2_GC2ClientGlobalStats=9173 k_EMsgGCCStrike15_v2_GC2ClientGlobalStats value\n * @property {number} k_EMsgGCCStrike15_v2_Client2GCStreamUnlock=9174 k_EMsgGCCStrike15_v2_Client2GCStreamUnlock value\n * @property {number} k_EMsgGCCStrike15_v2_FantasyRequestClientData=9175 k_EMsgGCCStrike15_v2_FantasyRequestClientData value\n * @property {number} k_EMsgGCCStrike15_v2_FantasyUpdateClientData=9176 k_EMsgGCCStrike15_v2_FantasyUpdateClientData value\n */\n$root.ECsgoGCMsg = (function () {\n    const valuesById = {}, values = Object.create(valuesById);\n    values[(valuesById[9100] = \"k_EMsgGCCStrike15_v2_Base\")] = 9100;\n    values[(valuesById[9101] = \"k_EMsgGCCStrike15_v2_MatchmakingStart\")] = 9101;\n    values[(valuesById[9102] = \"k_EMsgGCCStrike15_v2_MatchmakingStop\")] = 9102;\n    values[(valuesById[9103] = \"k_EMsgGCCStrike15_v2_MatchmakingClient2ServerPing\")] = 9103;\n    values[(valuesById[9104] = \"k_EMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\")] = 9104;\n    values[(valuesById[9105] = \"k_EMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\")] = 9105;\n    values[(valuesById[9106] =\n        \"k_EMsgGCCStrike15_v2_MatchmakingServerReservationResponse\")] = 9106;\n    values[(valuesById[9107] = \"k_EMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\")] = 9107;\n    values[(valuesById[9108] = \"k_EMsgGCCStrike15_v2_MatchmakingServerRoundStats\")] = 9108;\n    values[(valuesById[9109] = \"k_EMsgGCCStrike15_v2_MatchmakingClient2GCHello\")] = 9109;\n    values[(valuesById[9110] = \"k_EMsgGCCStrike15_v2_MatchmakingGC2ClientHello\")] = 9110;\n    values[(valuesById[9111] = \"k_EMsgGCCStrike15_v2_MatchmakingServerMatchEnd\")] = 9111;\n    values[(valuesById[9112] = \"k_EMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon\")] = 9112;\n    values[(valuesById[9113] = \"k_EMsgGCCStrike15_v2_MatchmakingServer2GCKick\")] = 9113;\n    values[(valuesById[9114] = \"k_EMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm\")] = 9114;\n    values[(valuesById[9115] = \"k_EMsgGCCStrike15_v2_MatchmakingGCOperationalStats\")] = 9115;\n    values[(valuesById[9116] = \"k_EMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate\")] = 9116;\n    values[(valuesById[9117] = \"k_EMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate\")] = 9117;\n    values[(valuesById[9118] = \"k_EMsgGCCStrike15_v2_ServerNotificationForUserPenalty\")] = 9118;\n    values[(valuesById[9119] = \"k_EMsgGCCStrike15_v2_ClientReportPlayer\")] = 9119;\n    values[(valuesById[9120] = \"k_EMsgGCCStrike15_v2_ClientReportServer\")] = 9120;\n    values[(valuesById[9121] = \"k_EMsgGCCStrike15_v2_ClientCommendPlayer\")] = 9121;\n    values[(valuesById[9122] = \"k_EMsgGCCStrike15_v2_ClientReportResponse\")] = 9122;\n    values[(valuesById[9123] = \"k_EMsgGCCStrike15_v2_ClientCommendPlayerQuery\")] = 9123;\n    values[(valuesById[9124] = \"k_EMsgGCCStrike15_v2_ClientCommendPlayerQueryResponse\")] = 9124;\n    values[(valuesById[9126] = \"k_EMsgGCCStrike15_v2_WatchInfoUsers\")] = 9126;\n    values[(valuesById[9127] = \"k_EMsgGCCStrike15_v2_ClientRequestPlayersProfile\")] = 9127;\n    values[(valuesById[9128] = \"k_EMsgGCCStrike15_v2_PlayersProfile\")] = 9128;\n    values[(valuesById[9129] = \"k_EMsgGCCStrike15_v2_SetMyMedalsInfo\")] = 9129;\n    values[(valuesById[9131] = \"k_EMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\")] = 9131;\n    values[(valuesById[9132] = \"k_EMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\")] = 9132;\n    values[(valuesById[9133] = \"k_EMsgGCCStrike15_v2_PlayerOverwatchCaseStatus\")] = 9133;\n    values[(valuesById[9134] = \"k_EMsgGCCStrike15_v2_GC2ClientTextMsg\")] = 9134;\n    values[(valuesById[9135] = \"k_EMsgGCCStrike15_v2_Client2GCTextMsg\")] = 9135;\n    values[(valuesById[9136] = \"k_EMsgGCCStrike15_v2_MatchEndRunRewardDrops\")] = 9136;\n    values[(valuesById[9137] = \"k_EMsgGCCStrike15_v2_MatchEndRewardDropsNotification\")] = 9137;\n    values[(valuesById[9138] = \"k_EMsgGCCStrike15_v2_ClientRequestWatchInfoFriends2\")] = 9138;\n    values[(valuesById[9139] = \"k_EMsgGCCStrike15_v2_MatchList\")] = 9139;\n    values[(valuesById[9140] = \"k_EMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames\")] = 9140;\n    values[(valuesById[9141] = \"k_EMsgGCCStrike15_v2_MatchListRequestRecentUserGames\")] = 9141;\n    values[(valuesById[9142] = \"k_EMsgGCCStrike15_v2_GC2ServerReservationUpdate\")] = 9142;\n    values[(valuesById[9144] = \"k_EMsgGCCStrike15_v2_ClientVarValueNotificationInfo\")] = 9144;\n    values[(valuesById[9145] =\n        \"k_EMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification\")] = 9145;\n    values[(valuesById[9146] = \"k_EMsgGCCStrike15_v2_MatchListRequestTournamentGames\")] = 9146;\n    values[(valuesById[9147] = \"k_EMsgGCCStrike15_v2_MatchListRequestFullGameInfo\")] = 9147;\n    values[(valuesById[9148] = \"k_EMsgGCCStrike15_v2_GiftsLeaderboardRequest\")] = 9148;\n    values[(valuesById[9149] = \"k_EMsgGCCStrike15_v2_GiftsLeaderboardResponse\")] = 9149;\n    values[(valuesById[9150] = \"k_EMsgGCCStrike15_v2_ServerVarValueNotificationInfo\")] = 9150;\n    values[(valuesById[9151] = \"k_EMsgGCToGCReloadVersions\")] = 9151;\n    values[(valuesById[9152] = \"k_EMsgGCCStrike15_v2_ClientSubmitSurveyVote\")] = 9152;\n    values[(valuesById[9153] = \"k_EMsgGCCStrike15_v2_Server2GCClientValidate\")] = 9153;\n    values[(valuesById[9154] = \"k_EMsgGCCStrike15_v2_MatchListRequestLiveGameForUser\")] = 9154;\n    values[(valuesById[9155] =\n        \"k_EMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\")] = 9155;\n    values[(valuesById[9156] =\n        \"k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest\")] = 9156;\n    values[(valuesById[9157] =\n        \"k_EMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse\")] = 9157;\n    values[(valuesById[9158] = \"k_EMsgGCCStrike15_v2_AccountPrivacySettings\")] = 9158;\n    values[(valuesById[9159] = \"k_EMsgGCCStrike15_v2_SetMyActivityInfo\")] = 9159;\n    values[(valuesById[9160] =\n        \"k_EMsgGCCStrike15_v2_MatchListRequestTournamentPredictions\")] = 9160;\n    values[(valuesById[9161] =\n        \"k_EMsgGCCStrike15_v2_MatchListUploadTournamentPredictions\")] = 9161;\n    values[(valuesById[9162] = \"k_EMsgGCCStrike15_v2_DraftSummary\")] = 9162;\n    values[(valuesById[9163] = \"k_EMsgGCCStrike15_v2_ClientRequestJoinFriendData\")] = 9163;\n    values[(valuesById[9164] = \"k_EMsgGCCStrike15_v2_ClientRequestJoinServerData\")] = 9164;\n    values[(valuesById[9165] = \"k_EMsgGCCStrike15_v2_ClientRequestNewMission\")] = 9165;\n    values[(valuesById[9166] = \"k_EMsgGCCStrike15_v2_GC2ServerNotifyXPRewarded\")] = 9166;\n    values[(valuesById[9167] = \"k_EMsgGCCStrike15_v2_GC2ClientTournamentInfo\")] = 9167;\n    values[(valuesById[9168] = \"k_EMsgGC_GlobalGame_Subscribe\")] = 9168;\n    values[(valuesById[9169] = \"k_EMsgGC_GlobalGame_Unsubscribe\")] = 9169;\n    values[(valuesById[9170] = \"k_EMsgGC_GlobalGame_Play\")] = 9170;\n    values[(valuesById[9171] = \"k_EMsgGCCStrike15_v2_AcknowledgePenalty\")] = 9171;\n    values[(valuesById[9172] = \"k_EMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin\")] = 9172;\n    values[(valuesById[9173] = \"k_EMsgGCCStrike15_v2_GC2ClientGlobalStats\")] = 9173;\n    values[(valuesById[9174] = \"k_EMsgGCCStrike15_v2_Client2GCStreamUnlock\")] = 9174;\n    values[(valuesById[9175] = \"k_EMsgGCCStrike15_v2_FantasyRequestClientData\")] = 9175;\n    values[(valuesById[9176] = \"k_EMsgGCCStrike15_v2_FantasyUpdateClientData\")] = 9176;\n    return values;\n})();\nexports.GameServerPing = ($root.GameServerPing = (() => {\n    /**\n     * Properties of a GameServerPing.\n     * @exports IGameServerPing\n     * @interface IGameServerPing\n     * @property {number|Long|null} [gameserverId] GameServerPing gameserverId\n     * @property {number|null} [ping] GameServerPing ping\n     * @property {number|null} [ip] GameServerPing ip\n     * @property {number|null} [port] GameServerPing port\n     * @property {number|null} [instances] GameServerPing instances\n     */\n    /**\n     * Constructs a new GameServerPing.\n     * @exports GameServerPing\n     * @classdesc Represents a GameServerPing.\n     * @implements IGameServerPing\n     * @constructor\n     * @param {IGameServerPing=} [properties] Properties to set\n     */\n    function GameServerPing(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * GameServerPing gameserverId.\n     * @member {number|Long} gameserverId\n     * @memberof GameServerPing\n     * @instance\n     */\n    GameServerPing.prototype.gameserverId = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * GameServerPing ping.\n     * @member {number} ping\n     * @memberof GameServerPing\n     * @instance\n     */\n    GameServerPing.prototype.ping = 0;\n    /**\n     * GameServerPing ip.\n     * @member {number} ip\n     * @memberof GameServerPing\n     * @instance\n     */\n    GameServerPing.prototype.ip = 0;\n    /**\n     * GameServerPing port.\n     * @member {number} port\n     * @memberof GameServerPing\n     * @instance\n     */\n    GameServerPing.prototype.port = 0;\n    /**\n     * GameServerPing instances.\n     * @member {number} instances\n     * @memberof GameServerPing\n     * @instance\n     */\n    GameServerPing.prototype.instances = 0;\n    /**\n     * Decodes a GameServerPing message from the specified reader or buffer.\n     * @function decode\n     * @memberof GameServerPing\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {GameServerPing} GameServerPing\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    GameServerPing.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GameServerPing();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.gameserverId = reader.uint64();\n                    break;\n                case 2:\n                    message.ping = reader.int32();\n                    break;\n                case 3:\n                    message.ip = reader.uint32();\n                    break;\n                case 4:\n                    message.port = reader.uint32();\n                    break;\n                case 5:\n                    message.instances = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return GameServerPing;\n})());\nexports.DetailedSearchStatistic = ($root.DetailedSearchStatistic = (() => {\n    /**\n     * Properties of a DetailedSearchStatistic.\n     * @exports IDetailedSearchStatistic\n     * @interface IDetailedSearchStatistic\n     * @property {number|null} [gameType] DetailedSearchStatistic gameType\n     * @property {number|null} [searchTimeAvg] DetailedSearchStatistic searchTimeAvg\n     * @property {number|null} [playersSearching] DetailedSearchStatistic playersSearching\n     */\n    /**\n     * Constructs a new DetailedSearchStatistic.\n     * @exports DetailedSearchStatistic\n     * @classdesc Represents a DetailedSearchStatistic.\n     * @implements IDetailedSearchStatistic\n     * @constructor\n     * @param {IDetailedSearchStatistic=} [properties] Properties to set\n     */\n    function DetailedSearchStatistic(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * DetailedSearchStatistic gameType.\n     * @member {number} gameType\n     * @memberof DetailedSearchStatistic\n     * @instance\n     */\n    DetailedSearchStatistic.prototype.gameType = 0;\n    /**\n     * DetailedSearchStatistic searchTimeAvg.\n     * @member {number} searchTimeAvg\n     * @memberof DetailedSearchStatistic\n     * @instance\n     */\n    DetailedSearchStatistic.prototype.searchTimeAvg = 0;\n    /**\n     * DetailedSearchStatistic playersSearching.\n     * @member {number} playersSearching\n     * @memberof DetailedSearchStatistic\n     * @instance\n     */\n    DetailedSearchStatistic.prototype.playersSearching = 0;\n    /**\n     * Decodes a DetailedSearchStatistic message from the specified reader or buffer.\n     * @function decode\n     * @memberof DetailedSearchStatistic\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {DetailedSearchStatistic} DetailedSearchStatistic\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    DetailedSearchStatistic.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.DetailedSearchStatistic();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.gameType = reader.uint32();\n                    break;\n                case 2:\n                    message.searchTimeAvg = reader.uint32();\n                    break;\n                case 4:\n                    message.playersSearching = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return DetailedSearchStatistic;\n})());\nexports.TournamentPlayer = ($root.TournamentPlayer = (() => {\n    /**\n     * Properties of a TournamentPlayer.\n     * @exports ITournamentPlayer\n     * @interface ITournamentPlayer\n     * @property {number|null} [accountId] TournamentPlayer accountId\n     * @property {string|null} [playerNick] TournamentPlayer playerNick\n     * @property {string|null} [playerName] TournamentPlayer playerName\n     * @property {number|null} [playerDob] TournamentPlayer playerDob\n     * @property {string|null} [playerFlag] TournamentPlayer playerFlag\n     * @property {string|null} [playerLocation] TournamentPlayer playerLocation\n     * @property {string|null} [playerDesc] TournamentPlayer playerDesc\n     */\n    /**\n     * Constructs a new TournamentPlayer.\n     * @exports TournamentPlayer\n     * @classdesc Represents a TournamentPlayer.\n     * @implements ITournamentPlayer\n     * @constructor\n     * @param {ITournamentPlayer=} [properties] Properties to set\n     */\n    function TournamentPlayer(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * TournamentPlayer accountId.\n     * @member {number} accountId\n     * @memberof TournamentPlayer\n     * @instance\n     */\n    TournamentPlayer.prototype.accountId = 0;\n    /**\n     * TournamentPlayer playerNick.\n     * @member {string} playerNick\n     * @memberof TournamentPlayer\n     * @instance\n     */\n    TournamentPlayer.prototype.playerNick = \"\";\n    /**\n     * TournamentPlayer playerName.\n     * @member {string} playerName\n     * @memberof TournamentPlayer\n     * @instance\n     */\n    TournamentPlayer.prototype.playerName = \"\";\n    /**\n     * TournamentPlayer playerDob.\n     * @member {number} playerDob\n     * @memberof TournamentPlayer\n     * @instance\n     */\n    TournamentPlayer.prototype.playerDob = 0;\n    /**\n     * TournamentPlayer playerFlag.\n     * @member {string} playerFlag\n     * @memberof TournamentPlayer\n     * @instance\n     */\n    TournamentPlayer.prototype.playerFlag = \"\";\n    /**\n     * TournamentPlayer playerLocation.\n     * @member {string} playerLocation\n     * @memberof TournamentPlayer\n     * @instance\n     */\n    TournamentPlayer.prototype.playerLocation = \"\";\n    /**\n     * TournamentPlayer playerDesc.\n     * @member {string} playerDesc\n     * @memberof TournamentPlayer\n     * @instance\n     */\n    TournamentPlayer.prototype.playerDesc = \"\";\n    /**\n     * Decodes a TournamentPlayer message from the specified reader or buffer.\n     * @function decode\n     * @memberof TournamentPlayer\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {TournamentPlayer} TournamentPlayer\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TournamentPlayer.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TournamentPlayer();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.accountId = reader.uint32();\n                    break;\n                case 2:\n                    message.playerNick = reader.string();\n                    break;\n                case 3:\n                    message.playerName = reader.string();\n                    break;\n                case 4:\n                    message.playerDob = reader.uint32();\n                    break;\n                case 5:\n                    message.playerFlag = reader.string();\n                    break;\n                case 6:\n                    message.playerLocation = reader.string();\n                    break;\n                case 7:\n                    message.playerDesc = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return TournamentPlayer;\n})());\nexports.TournamentTeam = ($root.TournamentTeam = (() => {\n    /**\n     * Properties of a TournamentTeam.\n     * @exports ITournamentTeam\n     * @interface ITournamentTeam\n     * @property {number|null} [teamId] TournamentTeam teamId\n     * @property {string|null} [teamTag] TournamentTeam teamTag\n     * @property {string|null} [teamFlag] TournamentTeam teamFlag\n     * @property {string|null} [teamName] TournamentTeam teamName\n     * @property {Array.<ITournamentPlayer>|null} [players] TournamentTeam players\n     */\n    /**\n     * Constructs a new TournamentTeam.\n     * @exports TournamentTeam\n     * @classdesc Represents a TournamentTeam.\n     * @implements ITournamentTeam\n     * @constructor\n     * @param {ITournamentTeam=} [properties] Properties to set\n     */\n    function TournamentTeam(properties) {\n        this.players = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * TournamentTeam teamId.\n     * @member {number} teamId\n     * @memberof TournamentTeam\n     * @instance\n     */\n    TournamentTeam.prototype.teamId = 0;\n    /**\n     * TournamentTeam teamTag.\n     * @member {string} teamTag\n     * @memberof TournamentTeam\n     * @instance\n     */\n    TournamentTeam.prototype.teamTag = \"\";\n    /**\n     * TournamentTeam teamFlag.\n     * @member {string} teamFlag\n     * @memberof TournamentTeam\n     * @instance\n     */\n    TournamentTeam.prototype.teamFlag = \"\";\n    /**\n     * TournamentTeam teamName.\n     * @member {string} teamName\n     * @memberof TournamentTeam\n     * @instance\n     */\n    TournamentTeam.prototype.teamName = \"\";\n    /**\n     * TournamentTeam players.\n     * @member {Array.<ITournamentPlayer>} players\n     * @memberof TournamentTeam\n     * @instance\n     */\n    TournamentTeam.prototype.players = $util.emptyArray;\n    /**\n     * Decodes a TournamentTeam message from the specified reader or buffer.\n     * @function decode\n     * @memberof TournamentTeam\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {TournamentTeam} TournamentTeam\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TournamentTeam.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TournamentTeam();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.teamId = reader.int32();\n                    break;\n                case 2:\n                    message.teamTag = reader.string();\n                    break;\n                case 3:\n                    message.teamFlag = reader.string();\n                    break;\n                case 4:\n                    message.teamName = reader.string();\n                    break;\n                case 5:\n                    if (!(message.players && message.players.length))\n                        message.players = [];\n                    message.players.push($root.TournamentPlayer.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return TournamentTeam;\n})());\nexports.TournamentEvent = ($root.TournamentEvent = (() => {\n    /**\n     * Properties of a TournamentEvent.\n     * @exports ITournamentEvent\n     * @interface ITournamentEvent\n     * @property {number|null} [eventId] TournamentEvent eventId\n     * @property {string|null} [eventTag] TournamentEvent eventTag\n     * @property {string|null} [eventName] TournamentEvent eventName\n     * @property {number|null} [eventTimeStart] TournamentEvent eventTimeStart\n     * @property {number|null} [eventTimeEnd] TournamentEvent eventTimeEnd\n     * @property {number|null} [eventPublic] TournamentEvent eventPublic\n     * @property {number|null} [eventStageId] TournamentEvent eventStageId\n     * @property {string|null} [eventStageName] TournamentEvent eventStageName\n     * @property {number|null} [activeSectionId] TournamentEvent activeSectionId\n     */\n    /**\n     * Constructs a new TournamentEvent.\n     * @exports TournamentEvent\n     * @classdesc Represents a TournamentEvent.\n     * @implements ITournamentEvent\n     * @constructor\n     * @param {ITournamentEvent=} [properties] Properties to set\n     */\n    function TournamentEvent(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * TournamentEvent eventId.\n     * @member {number} eventId\n     * @memberof TournamentEvent\n     * @instance\n     */\n    TournamentEvent.prototype.eventId = 0;\n    /**\n     * TournamentEvent eventTag.\n     * @member {string} eventTag\n     * @memberof TournamentEvent\n     * @instance\n     */\n    TournamentEvent.prototype.eventTag = \"\";\n    /**\n     * TournamentEvent eventName.\n     * @member {string} eventName\n     * @memberof TournamentEvent\n     * @instance\n     */\n    TournamentEvent.prototype.eventName = \"\";\n    /**\n     * TournamentEvent eventTimeStart.\n     * @member {number} eventTimeStart\n     * @memberof TournamentEvent\n     * @instance\n     */\n    TournamentEvent.prototype.eventTimeStart = 0;\n    /**\n     * TournamentEvent eventTimeEnd.\n     * @member {number} eventTimeEnd\n     * @memberof TournamentEvent\n     * @instance\n     */\n    TournamentEvent.prototype.eventTimeEnd = 0;\n    /**\n     * TournamentEvent eventPublic.\n     * @member {number} eventPublic\n     * @memberof TournamentEvent\n     * @instance\n     */\n    TournamentEvent.prototype.eventPublic = 0;\n    /**\n     * TournamentEvent eventStageId.\n     * @member {number} eventStageId\n     * @memberof TournamentEvent\n     * @instance\n     */\n    TournamentEvent.prototype.eventStageId = 0;\n    /**\n     * TournamentEvent eventStageName.\n     * @member {string} eventStageName\n     * @memberof TournamentEvent\n     * @instance\n     */\n    TournamentEvent.prototype.eventStageName = \"\";\n    /**\n     * TournamentEvent activeSectionId.\n     * @member {number} activeSectionId\n     * @memberof TournamentEvent\n     * @instance\n     */\n    TournamentEvent.prototype.activeSectionId = 0;\n    /**\n     * Decodes a TournamentEvent message from the specified reader or buffer.\n     * @function decode\n     * @memberof TournamentEvent\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {TournamentEvent} TournamentEvent\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TournamentEvent.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TournamentEvent();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.eventId = reader.int32();\n                    break;\n                case 2:\n                    message.eventTag = reader.string();\n                    break;\n                case 3:\n                    message.eventName = reader.string();\n                    break;\n                case 4:\n                    message.eventTimeStart = reader.uint32();\n                    break;\n                case 5:\n                    message.eventTimeEnd = reader.uint32();\n                    break;\n                case 6:\n                    message.eventPublic = reader.int32();\n                    break;\n                case 7:\n                    message.eventStageId = reader.int32();\n                    break;\n                case 8:\n                    message.eventStageName = reader.string();\n                    break;\n                case 9:\n                    message.activeSectionId = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return TournamentEvent;\n})());\nexports.GlobalStatistics = ($root.GlobalStatistics = (() => {\n    /**\n     * Properties of a GlobalStatistics.\n     * @exports IGlobalStatistics\n     * @interface IGlobalStatistics\n     * @property {number|null} [playersOnline] GlobalStatistics playersOnline\n     * @property {number|null} [serversOnline] GlobalStatistics serversOnline\n     * @property {number|null} [playersSearching] GlobalStatistics playersSearching\n     * @property {number|null} [serversAvailable] GlobalStatistics serversAvailable\n     * @property {number|null} [ongoingMatches] GlobalStatistics ongoingMatches\n     * @property {number|null} [searchTimeAvg] GlobalStatistics searchTimeAvg\n     * @property {Array.<IDetailedSearchStatistic>|null} [searchStatistics] GlobalStatistics searchStatistics\n     * @property {string|null} [mainPostUrl] GlobalStatistics mainPostUrl\n     * @property {number|null} [requiredAppidVersion] GlobalStatistics requiredAppidVersion\n     * @property {number|null} [pricesheetVersion] GlobalStatistics pricesheetVersion\n     * @property {number|null} [twitchStreamsVersion] GlobalStatistics twitchStreamsVersion\n     * @property {number|null} [activeTournamentEventid] GlobalStatistics activeTournamentEventid\n     * @property {number|null} [activeSurveyId] GlobalStatistics activeSurveyId\n     */\n    /**\n     * Constructs a new GlobalStatistics.\n     * @exports GlobalStatistics\n     * @classdesc Represents a GlobalStatistics.\n     * @implements IGlobalStatistics\n     * @constructor\n     * @param {IGlobalStatistics=} [properties] Properties to set\n     */\n    function GlobalStatistics(properties) {\n        this.searchStatistics = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * GlobalStatistics playersOnline.\n     * @member {number} playersOnline\n     * @memberof GlobalStatistics\n     * @instance\n     */\n    GlobalStatistics.prototype.playersOnline = 0;\n    /**\n     * GlobalStatistics serversOnline.\n     * @member {number} serversOnline\n     * @memberof GlobalStatistics\n     * @instance\n     */\n    GlobalStatistics.prototype.serversOnline = 0;\n    /**\n     * GlobalStatistics playersSearching.\n     * @member {number} playersSearching\n     * @memberof GlobalStatistics\n     * @instance\n     */\n    GlobalStatistics.prototype.playersSearching = 0;\n    /**\n     * GlobalStatistics serversAvailable.\n     * @member {number} serversAvailable\n     * @memberof GlobalStatistics\n     * @instance\n     */\n    GlobalStatistics.prototype.serversAvailable = 0;\n    /**\n     * GlobalStatistics ongoingMatches.\n     * @member {number} ongoingMatches\n     * @memberof GlobalStatistics\n     * @instance\n     */\n    GlobalStatistics.prototype.ongoingMatches = 0;\n    /**\n     * GlobalStatistics searchTimeAvg.\n     * @member {number} searchTimeAvg\n     * @memberof GlobalStatistics\n     * @instance\n     */\n    GlobalStatistics.prototype.searchTimeAvg = 0;\n    /**\n     * GlobalStatistics searchStatistics.\n     * @member {Array.<IDetailedSearchStatistic>} searchStatistics\n     * @memberof GlobalStatistics\n     * @instance\n     */\n    GlobalStatistics.prototype.searchStatistics = $util.emptyArray;\n    /**\n     * GlobalStatistics mainPostUrl.\n     * @member {string} mainPostUrl\n     * @memberof GlobalStatistics\n     * @instance\n     */\n    GlobalStatistics.prototype.mainPostUrl = \"\";\n    /**\n     * GlobalStatistics requiredAppidVersion.\n     * @member {number} requiredAppidVersion\n     * @memberof GlobalStatistics\n     * @instance\n     */\n    GlobalStatistics.prototype.requiredAppidVersion = 0;\n    /**\n     * GlobalStatistics pricesheetVersion.\n     * @member {number} pricesheetVersion\n     * @memberof GlobalStatistics\n     * @instance\n     */\n    GlobalStatistics.prototype.pricesheetVersion = 0;\n    /**\n     * GlobalStatistics twitchStreamsVersion.\n     * @member {number} twitchStreamsVersion\n     * @memberof GlobalStatistics\n     * @instance\n     */\n    GlobalStatistics.prototype.twitchStreamsVersion = 0;\n    /**\n     * GlobalStatistics activeTournamentEventid.\n     * @member {number} activeTournamentEventid\n     * @memberof GlobalStatistics\n     * @instance\n     */\n    GlobalStatistics.prototype.activeTournamentEventid = 0;\n    /**\n     * GlobalStatistics activeSurveyId.\n     * @member {number} activeSurveyId\n     * @memberof GlobalStatistics\n     * @instance\n     */\n    GlobalStatistics.prototype.activeSurveyId = 0;\n    /**\n     * Decodes a GlobalStatistics message from the specified reader or buffer.\n     * @function decode\n     * @memberof GlobalStatistics\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {GlobalStatistics} GlobalStatistics\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    GlobalStatistics.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.GlobalStatistics();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.playersOnline = reader.uint32();\n                    break;\n                case 2:\n                    message.serversOnline = reader.uint32();\n                    break;\n                case 3:\n                    message.playersSearching = reader.uint32();\n                    break;\n                case 4:\n                    message.serversAvailable = reader.uint32();\n                    break;\n                case 5:\n                    message.ongoingMatches = reader.uint32();\n                    break;\n                case 6:\n                    message.searchTimeAvg = reader.uint32();\n                    break;\n                case 7:\n                    if (!(message.searchStatistics && message.searchStatistics.length))\n                        message.searchStatistics = [];\n                    message.searchStatistics.push($root.DetailedSearchStatistic.decode(reader, reader.uint32()));\n                    break;\n                case 8:\n                    message.mainPostUrl = reader.string();\n                    break;\n                case 9:\n                    message.requiredAppidVersion = reader.uint32();\n                    break;\n                case 10:\n                    message.pricesheetVersion = reader.uint32();\n                    break;\n                case 11:\n                    message.twitchStreamsVersion = reader.uint32();\n                    break;\n                case 12:\n                    message.activeTournamentEventid = reader.uint32();\n                    break;\n                case 13:\n                    message.activeSurveyId = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return GlobalStatistics;\n})());\nexports.OperationalStatisticDescription = ($root.OperationalStatisticDescription = (() => {\n    /**\n     * Properties of an OperationalStatisticDescription.\n     * @exports IOperationalStatisticDescription\n     * @interface IOperationalStatisticDescription\n     * @property {string|null} [name] OperationalStatisticDescription name\n     * @property {number|null} [idkey] OperationalStatisticDescription idkey\n     */\n    /**\n     * Constructs a new OperationalStatisticDescription.\n     * @exports OperationalStatisticDescription\n     * @classdesc Represents an OperationalStatisticDescription.\n     * @implements IOperationalStatisticDescription\n     * @constructor\n     * @param {IOperationalStatisticDescription=} [properties] Properties to set\n     */\n    function OperationalStatisticDescription(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * OperationalStatisticDescription name.\n     * @member {string} name\n     * @memberof OperationalStatisticDescription\n     * @instance\n     */\n    OperationalStatisticDescription.prototype.name = \"\";\n    /**\n     * OperationalStatisticDescription idkey.\n     * @member {number} idkey\n     * @memberof OperationalStatisticDescription\n     * @instance\n     */\n    OperationalStatisticDescription.prototype.idkey = 0;\n    /**\n     * Decodes an OperationalStatisticDescription message from the specified reader or buffer.\n     * @function decode\n     * @memberof OperationalStatisticDescription\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {OperationalStatisticDescription} OperationalStatisticDescription\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    OperationalStatisticDescription.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.OperationalStatisticDescription();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 2:\n                    message.idkey = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return OperationalStatisticDescription;\n})());\nexports.OperationalStatisticElement = ($root.OperationalStatisticElement = (() => {\n    /**\n     * Properties of an OperationalStatisticElement.\n     * @exports IOperationalStatisticElement\n     * @interface IOperationalStatisticElement\n     * @property {number|null} [idkey] OperationalStatisticElement idkey\n     * @property {Array.<number>|null} [values] OperationalStatisticElement values\n     */\n    /**\n     * Constructs a new OperationalStatisticElement.\n     * @exports OperationalStatisticElement\n     * @classdesc Represents an OperationalStatisticElement.\n     * @implements IOperationalStatisticElement\n     * @constructor\n     * @param {IOperationalStatisticElement=} [properties] Properties to set\n     */\n    function OperationalStatisticElement(properties) {\n        this.values = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * OperationalStatisticElement idkey.\n     * @member {number} idkey\n     * @memberof OperationalStatisticElement\n     * @instance\n     */\n    OperationalStatisticElement.prototype.idkey = 0;\n    /**\n     * OperationalStatisticElement values.\n     * @member {Array.<number>} values\n     * @memberof OperationalStatisticElement\n     * @instance\n     */\n    OperationalStatisticElement.prototype.values = $util.emptyArray;\n    /**\n     * Decodes an OperationalStatisticElement message from the specified reader or buffer.\n     * @function decode\n     * @memberof OperationalStatisticElement\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {OperationalStatisticElement} OperationalStatisticElement\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    OperationalStatisticElement.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.OperationalStatisticElement();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.idkey = reader.uint32();\n                    break;\n                case 2:\n                    if (!(message.values && message.values.length))\n                        message.values = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.values.push(reader.int32());\n                    }\n                    else\n                        message.values.push(reader.int32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return OperationalStatisticElement;\n})());\nexports.OperationalStatisticsPacket = ($root.OperationalStatisticsPacket = (() => {\n    /**\n     * Properties of an OperationalStatisticsPacket.\n     * @exports IOperationalStatisticsPacket\n     * @interface IOperationalStatisticsPacket\n     * @property {number|null} [packetid] OperationalStatisticsPacket packetid\n     * @property {number|null} [mstimestamp] OperationalStatisticsPacket mstimestamp\n     * @property {Array.<IOperationalStatisticElement>|null} [values] OperationalStatisticsPacket values\n     */\n    /**\n     * Constructs a new OperationalStatisticsPacket.\n     * @exports OperationalStatisticsPacket\n     * @classdesc Represents an OperationalStatisticsPacket.\n     * @implements IOperationalStatisticsPacket\n     * @constructor\n     * @param {IOperationalStatisticsPacket=} [properties] Properties to set\n     */\n    function OperationalStatisticsPacket(properties) {\n        this.values = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * OperationalStatisticsPacket packetid.\n     * @member {number} packetid\n     * @memberof OperationalStatisticsPacket\n     * @instance\n     */\n    OperationalStatisticsPacket.prototype.packetid = 0;\n    /**\n     * OperationalStatisticsPacket mstimestamp.\n     * @member {number} mstimestamp\n     * @memberof OperationalStatisticsPacket\n     * @instance\n     */\n    OperationalStatisticsPacket.prototype.mstimestamp = 0;\n    /**\n     * OperationalStatisticsPacket values.\n     * @member {Array.<IOperationalStatisticElement>} values\n     * @memberof OperationalStatisticsPacket\n     * @instance\n     */\n    OperationalStatisticsPacket.prototype.values = $util.emptyArray;\n    /**\n     * Decodes an OperationalStatisticsPacket message from the specified reader or buffer.\n     * @function decode\n     * @memberof OperationalStatisticsPacket\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {OperationalStatisticsPacket} OperationalStatisticsPacket\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    OperationalStatisticsPacket.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.OperationalStatisticsPacket();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.packetid = reader.int32();\n                    break;\n                case 2:\n                    message.mstimestamp = reader.int32();\n                    break;\n                case 3:\n                    if (!(message.values && message.values.length))\n                        message.values = [];\n                    message.values.push($root.OperationalStatisticElement.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return OperationalStatisticsPacket;\n})());\nexports.PlayerRankingInfo = ($root.PlayerRankingInfo = (() => {\n    /**\n     * Properties of a PlayerRankingInfo.\n     * @exports IPlayerRankingInfo\n     * @interface IPlayerRankingInfo\n     * @property {number|null} [accountId] PlayerRankingInfo accountId\n     * @property {number|null} [rankId] PlayerRankingInfo rankId\n     * @property {number|null} [wins] PlayerRankingInfo wins\n     * @property {number|null} [rankChange] PlayerRankingInfo rankChange\n     */\n    /**\n     * Constructs a new PlayerRankingInfo.\n     * @exports PlayerRankingInfo\n     * @classdesc Represents a PlayerRankingInfo.\n     * @implements IPlayerRankingInfo\n     * @constructor\n     * @param {IPlayerRankingInfo=} [properties] Properties to set\n     */\n    function PlayerRankingInfo(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * PlayerRankingInfo accountId.\n     * @member {number} accountId\n     * @memberof PlayerRankingInfo\n     * @instance\n     */\n    PlayerRankingInfo.prototype.accountId = 0;\n    /**\n     * PlayerRankingInfo rankId.\n     * @member {number} rankId\n     * @memberof PlayerRankingInfo\n     * @instance\n     */\n    PlayerRankingInfo.prototype.rankId = 0;\n    /**\n     * PlayerRankingInfo wins.\n     * @member {number} wins\n     * @memberof PlayerRankingInfo\n     * @instance\n     */\n    PlayerRankingInfo.prototype.wins = 0;\n    /**\n     * PlayerRankingInfo rankChange.\n     * @member {number} rankChange\n     * @memberof PlayerRankingInfo\n     * @instance\n     */\n    PlayerRankingInfo.prototype.rankChange = 0;\n    /**\n     * Decodes a PlayerRankingInfo message from the specified reader or buffer.\n     * @function decode\n     * @memberof PlayerRankingInfo\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {PlayerRankingInfo} PlayerRankingInfo\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PlayerRankingInfo.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PlayerRankingInfo();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.accountId = reader.uint32();\n                    break;\n                case 2:\n                    message.rankId = reader.uint32();\n                    break;\n                case 3:\n                    message.wins = reader.uint32();\n                    break;\n                case 4:\n                    message.rankChange = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return PlayerRankingInfo;\n})());\nexports.PlayerCommendationInfo = ($root.PlayerCommendationInfo = (() => {\n    /**\n     * Properties of a PlayerCommendationInfo.\n     * @exports IPlayerCommendationInfo\n     * @interface IPlayerCommendationInfo\n     * @property {number|null} [cmdFriendly] PlayerCommendationInfo cmdFriendly\n     * @property {number|null} [cmdTeaching] PlayerCommendationInfo cmdTeaching\n     * @property {number|null} [cmdLeader] PlayerCommendationInfo cmdLeader\n     */\n    /**\n     * Constructs a new PlayerCommendationInfo.\n     * @exports PlayerCommendationInfo\n     * @classdesc Represents a PlayerCommendationInfo.\n     * @implements IPlayerCommendationInfo\n     * @constructor\n     * @param {IPlayerCommendationInfo=} [properties] Properties to set\n     */\n    function PlayerCommendationInfo(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * PlayerCommendationInfo cmdFriendly.\n     * @member {number} cmdFriendly\n     * @memberof PlayerCommendationInfo\n     * @instance\n     */\n    PlayerCommendationInfo.prototype.cmdFriendly = 0;\n    /**\n     * PlayerCommendationInfo cmdTeaching.\n     * @member {number} cmdTeaching\n     * @memberof PlayerCommendationInfo\n     * @instance\n     */\n    PlayerCommendationInfo.prototype.cmdTeaching = 0;\n    /**\n     * PlayerCommendationInfo cmdLeader.\n     * @member {number} cmdLeader\n     * @memberof PlayerCommendationInfo\n     * @instance\n     */\n    PlayerCommendationInfo.prototype.cmdLeader = 0;\n    /**\n     * Decodes a PlayerCommendationInfo message from the specified reader or buffer.\n     * @function decode\n     * @memberof PlayerCommendationInfo\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {PlayerCommendationInfo} PlayerCommendationInfo\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PlayerCommendationInfo.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PlayerCommendationInfo();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.cmdFriendly = reader.uint32();\n                    break;\n                case 2:\n                    message.cmdTeaching = reader.uint32();\n                    break;\n                case 4:\n                    message.cmdLeader = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return PlayerCommendationInfo;\n})());\nexports.PlayerMedalsInfo = ($root.PlayerMedalsInfo = (() => {\n    /**\n     * Properties of a PlayerMedalsInfo.\n     * @exports IPlayerMedalsInfo\n     * @interface IPlayerMedalsInfo\n     * @property {number|null} [medalTeam] PlayerMedalsInfo medalTeam\n     * @property {number|null} [medalCombat] PlayerMedalsInfo medalCombat\n     * @property {number|null} [medalWeapon] PlayerMedalsInfo medalWeapon\n     * @property {number|null} [medalGlobal] PlayerMedalsInfo medalGlobal\n     * @property {number|null} [medalArms] PlayerMedalsInfo medalArms\n     * @property {Array.<number>|null} [displayItemsDefidx] PlayerMedalsInfo displayItemsDefidx\n     * @property {number|null} [featuredDisplayItemDefidx] PlayerMedalsInfo featuredDisplayItemDefidx\n     */\n    /**\n     * Constructs a new PlayerMedalsInfo.\n     * @exports PlayerMedalsInfo\n     * @classdesc Represents a PlayerMedalsInfo.\n     * @implements IPlayerMedalsInfo\n     * @constructor\n     * @param {IPlayerMedalsInfo=} [properties] Properties to set\n     */\n    function PlayerMedalsInfo(properties) {\n        this.displayItemsDefidx = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * PlayerMedalsInfo medalTeam.\n     * @member {number} medalTeam\n     * @memberof PlayerMedalsInfo\n     * @instance\n     */\n    PlayerMedalsInfo.prototype.medalTeam = 0;\n    /**\n     * PlayerMedalsInfo medalCombat.\n     * @member {number} medalCombat\n     * @memberof PlayerMedalsInfo\n     * @instance\n     */\n    PlayerMedalsInfo.prototype.medalCombat = 0;\n    /**\n     * PlayerMedalsInfo medalWeapon.\n     * @member {number} medalWeapon\n     * @memberof PlayerMedalsInfo\n     * @instance\n     */\n    PlayerMedalsInfo.prototype.medalWeapon = 0;\n    /**\n     * PlayerMedalsInfo medalGlobal.\n     * @member {number} medalGlobal\n     * @memberof PlayerMedalsInfo\n     * @instance\n     */\n    PlayerMedalsInfo.prototype.medalGlobal = 0;\n    /**\n     * PlayerMedalsInfo medalArms.\n     * @member {number} medalArms\n     * @memberof PlayerMedalsInfo\n     * @instance\n     */\n    PlayerMedalsInfo.prototype.medalArms = 0;\n    /**\n     * PlayerMedalsInfo displayItemsDefidx.\n     * @member {Array.<number>} displayItemsDefidx\n     * @memberof PlayerMedalsInfo\n     * @instance\n     */\n    PlayerMedalsInfo.prototype.displayItemsDefidx = $util.emptyArray;\n    /**\n     * PlayerMedalsInfo featuredDisplayItemDefidx.\n     * @member {number} featuredDisplayItemDefidx\n     * @memberof PlayerMedalsInfo\n     * @instance\n     */\n    PlayerMedalsInfo.prototype.featuredDisplayItemDefidx = 0;\n    /**\n     * Decodes a PlayerMedalsInfo message from the specified reader or buffer.\n     * @function decode\n     * @memberof PlayerMedalsInfo\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {PlayerMedalsInfo} PlayerMedalsInfo\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PlayerMedalsInfo.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PlayerMedalsInfo();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.medalTeam = reader.uint32();\n                    break;\n                case 2:\n                    message.medalCombat = reader.uint32();\n                    break;\n                case 3:\n                    message.medalWeapon = reader.uint32();\n                    break;\n                case 4:\n                    message.medalGlobal = reader.uint32();\n                    break;\n                case 5:\n                    message.medalArms = reader.uint32();\n                    break;\n                case 7:\n                    if (!(message.displayItemsDefidx && message.displayItemsDefidx.length))\n                        message.displayItemsDefidx = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.displayItemsDefidx.push(reader.uint32());\n                    }\n                    else\n                        message.displayItemsDefidx.push(reader.uint32());\n                    break;\n                case 8:\n                    message.featuredDisplayItemDefidx = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return PlayerMedalsInfo;\n})());\nexports.AccountActivity = ($root.AccountActivity = (() => {\n    /**\n     * Properties of an AccountActivity.\n     * @exports IAccountActivity\n     * @interface IAccountActivity\n     * @property {number|null} [activity] AccountActivity activity\n     * @property {number|null} [mode] AccountActivity mode\n     * @property {number|null} [map] AccountActivity map\n     */\n    /**\n     * Constructs a new AccountActivity.\n     * @exports AccountActivity\n     * @classdesc Represents an AccountActivity.\n     * @implements IAccountActivity\n     * @constructor\n     * @param {IAccountActivity=} [properties] Properties to set\n     */\n    function AccountActivity(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * AccountActivity activity.\n     * @member {number} activity\n     * @memberof AccountActivity\n     * @instance\n     */\n    AccountActivity.prototype.activity = 0;\n    /**\n     * AccountActivity mode.\n     * @member {number} mode\n     * @memberof AccountActivity\n     * @instance\n     */\n    AccountActivity.prototype.mode = 0;\n    /**\n     * AccountActivity map.\n     * @member {number} map\n     * @memberof AccountActivity\n     * @instance\n     */\n    AccountActivity.prototype.map = 0;\n    /**\n     * Decodes an AccountActivity message from the specified reader or buffer.\n     * @function decode\n     * @memberof AccountActivity\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {AccountActivity} AccountActivity\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    AccountActivity.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.AccountActivity();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.activity = reader.uint32();\n                    break;\n                case 2:\n                    message.mode = reader.uint32();\n                    break;\n                case 3:\n                    message.map = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return AccountActivity;\n})());\nexports.TournamentMatchSetup = ($root.TournamentMatchSetup = (() => {\n    /**\n     * Properties of a TournamentMatchSetup.\n     * @exports ITournamentMatchSetup\n     * @interface ITournamentMatchSetup\n     * @property {number|null} [eventId] TournamentMatchSetup eventId\n     * @property {number|null} [teamIdCt] TournamentMatchSetup teamIdCt\n     * @property {number|null} [teamIdT] TournamentMatchSetup teamIdT\n     * @property {number|null} [eventStageId] TournamentMatchSetup eventStageId\n     */\n    /**\n     * Constructs a new TournamentMatchSetup.\n     * @exports TournamentMatchSetup\n     * @classdesc Represents a TournamentMatchSetup.\n     * @implements ITournamentMatchSetup\n     * @constructor\n     * @param {ITournamentMatchSetup=} [properties] Properties to set\n     */\n    function TournamentMatchSetup(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * TournamentMatchSetup eventId.\n     * @member {number} eventId\n     * @memberof TournamentMatchSetup\n     * @instance\n     */\n    TournamentMatchSetup.prototype.eventId = 0;\n    /**\n     * TournamentMatchSetup teamIdCt.\n     * @member {number} teamIdCt\n     * @memberof TournamentMatchSetup\n     * @instance\n     */\n    TournamentMatchSetup.prototype.teamIdCt = 0;\n    /**\n     * TournamentMatchSetup teamIdT.\n     * @member {number} teamIdT\n     * @memberof TournamentMatchSetup\n     * @instance\n     */\n    TournamentMatchSetup.prototype.teamIdT = 0;\n    /**\n     * TournamentMatchSetup eventStageId.\n     * @member {number} eventStageId\n     * @memberof TournamentMatchSetup\n     * @instance\n     */\n    TournamentMatchSetup.prototype.eventStageId = 0;\n    /**\n     * Decodes a TournamentMatchSetup message from the specified reader or buffer.\n     * @function decode\n     * @memberof TournamentMatchSetup\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {TournamentMatchSetup} TournamentMatchSetup\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    TournamentMatchSetup.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.TournamentMatchSetup();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.eventId = reader.int32();\n                    break;\n                case 2:\n                    message.teamIdCt = reader.int32();\n                    break;\n                case 3:\n                    message.teamIdT = reader.int32();\n                    break;\n                case 4:\n                    message.eventStageId = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return TournamentMatchSetup;\n})());\nexports.ServerHltvInfo = ($root.ServerHltvInfo = (() => {\n    /**\n     * Properties of a ServerHltvInfo.\n     * @exports IServerHltvInfo\n     * @interface IServerHltvInfo\n     * @property {number|null} [tvUdpPort] ServerHltvInfo tvUdpPort\n     * @property {number|Long|null} [tvWatchKey] ServerHltvInfo tvWatchKey\n     * @property {number|null} [tvSlots] ServerHltvInfo tvSlots\n     * @property {number|null} [tvClients] ServerHltvInfo tvClients\n     * @property {number|null} [tvProxies] ServerHltvInfo tvProxies\n     * @property {number|null} [tvTime] ServerHltvInfo tvTime\n     * @property {number|null} [gameType] ServerHltvInfo gameType\n     * @property {string|null} [gameMapgroup] ServerHltvInfo gameMapgroup\n     * @property {string|null} [gameMap] ServerHltvInfo gameMap\n     * @property {number|Long|null} [tvMasterSteamid] ServerHltvInfo tvMasterSteamid\n     * @property {number|null} [tvLocalSlots] ServerHltvInfo tvLocalSlots\n     * @property {number|null} [tvLocalClients] ServerHltvInfo tvLocalClients\n     * @property {number|null} [tvLocalProxies] ServerHltvInfo tvLocalProxies\n     * @property {number|null} [tvRelaySlots] ServerHltvInfo tvRelaySlots\n     * @property {number|null} [tvRelayClients] ServerHltvInfo tvRelayClients\n     * @property {number|null} [tvRelayProxies] ServerHltvInfo tvRelayProxies\n     * @property {number|null} [tvRelayAddress] ServerHltvInfo tvRelayAddress\n     * @property {number|null} [tvRelayPort] ServerHltvInfo tvRelayPort\n     * @property {number|Long|null} [tvRelaySteamid] ServerHltvInfo tvRelaySteamid\n     */\n    /**\n     * Constructs a new ServerHltvInfo.\n     * @exports ServerHltvInfo\n     * @classdesc Represents a ServerHltvInfo.\n     * @implements IServerHltvInfo\n     * @constructor\n     * @param {IServerHltvInfo=} [properties] Properties to set\n     */\n    function ServerHltvInfo(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * ServerHltvInfo tvUdpPort.\n     * @member {number} tvUdpPort\n     * @memberof ServerHltvInfo\n     * @instance\n     */\n    ServerHltvInfo.prototype.tvUdpPort = 0;\n    /**\n     * ServerHltvInfo tvWatchKey.\n     * @member {number|Long} tvWatchKey\n     * @memberof ServerHltvInfo\n     * @instance\n     */\n    ServerHltvInfo.prototype.tvWatchKey = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * ServerHltvInfo tvSlots.\n     * @member {number} tvSlots\n     * @memberof ServerHltvInfo\n     * @instance\n     */\n    ServerHltvInfo.prototype.tvSlots = 0;\n    /**\n     * ServerHltvInfo tvClients.\n     * @member {number} tvClients\n     * @memberof ServerHltvInfo\n     * @instance\n     */\n    ServerHltvInfo.prototype.tvClients = 0;\n    /**\n     * ServerHltvInfo tvProxies.\n     * @member {number} tvProxies\n     * @memberof ServerHltvInfo\n     * @instance\n     */\n    ServerHltvInfo.prototype.tvProxies = 0;\n    /**\n     * ServerHltvInfo tvTime.\n     * @member {number} tvTime\n     * @memberof ServerHltvInfo\n     * @instance\n     */\n    ServerHltvInfo.prototype.tvTime = 0;\n    /**\n     * ServerHltvInfo gameType.\n     * @member {number} gameType\n     * @memberof ServerHltvInfo\n     * @instance\n     */\n    ServerHltvInfo.prototype.gameType = 0;\n    /**\n     * ServerHltvInfo gameMapgroup.\n     * @member {string} gameMapgroup\n     * @memberof ServerHltvInfo\n     * @instance\n     */\n    ServerHltvInfo.prototype.gameMapgroup = \"\";\n    /**\n     * ServerHltvInfo gameMap.\n     * @member {string} gameMap\n     * @memberof ServerHltvInfo\n     * @instance\n     */\n    ServerHltvInfo.prototype.gameMap = \"\";\n    /**\n     * ServerHltvInfo tvMasterSteamid.\n     * @member {number|Long} tvMasterSteamid\n     * @memberof ServerHltvInfo\n     * @instance\n     */\n    ServerHltvInfo.prototype.tvMasterSteamid = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * ServerHltvInfo tvLocalSlots.\n     * @member {number} tvLocalSlots\n     * @memberof ServerHltvInfo\n     * @instance\n     */\n    ServerHltvInfo.prototype.tvLocalSlots = 0;\n    /**\n     * ServerHltvInfo tvLocalClients.\n     * @member {number} tvLocalClients\n     * @memberof ServerHltvInfo\n     * @instance\n     */\n    ServerHltvInfo.prototype.tvLocalClients = 0;\n    /**\n     * ServerHltvInfo tvLocalProxies.\n     * @member {number} tvLocalProxies\n     * @memberof ServerHltvInfo\n     * @instance\n     */\n    ServerHltvInfo.prototype.tvLocalProxies = 0;\n    /**\n     * ServerHltvInfo tvRelaySlots.\n     * @member {number} tvRelaySlots\n     * @memberof ServerHltvInfo\n     * @instance\n     */\n    ServerHltvInfo.prototype.tvRelaySlots = 0;\n    /**\n     * ServerHltvInfo tvRelayClients.\n     * @member {number} tvRelayClients\n     * @memberof ServerHltvInfo\n     * @instance\n     */\n    ServerHltvInfo.prototype.tvRelayClients = 0;\n    /**\n     * ServerHltvInfo tvRelayProxies.\n     * @member {number} tvRelayProxies\n     * @memberof ServerHltvInfo\n     * @instance\n     */\n    ServerHltvInfo.prototype.tvRelayProxies = 0;\n    /**\n     * ServerHltvInfo tvRelayAddress.\n     * @member {number} tvRelayAddress\n     * @memberof ServerHltvInfo\n     * @instance\n     */\n    ServerHltvInfo.prototype.tvRelayAddress = 0;\n    /**\n     * ServerHltvInfo tvRelayPort.\n     * @member {number} tvRelayPort\n     * @memberof ServerHltvInfo\n     * @instance\n     */\n    ServerHltvInfo.prototype.tvRelayPort = 0;\n    /**\n     * ServerHltvInfo tvRelaySteamid.\n     * @member {number|Long} tvRelaySteamid\n     * @memberof ServerHltvInfo\n     * @instance\n     */\n    ServerHltvInfo.prototype.tvRelaySteamid = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * Decodes a ServerHltvInfo message from the specified reader or buffer.\n     * @function decode\n     * @memberof ServerHltvInfo\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {ServerHltvInfo} ServerHltvInfo\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    ServerHltvInfo.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.ServerHltvInfo();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.tvUdpPort = reader.uint32();\n                    break;\n                case 2:\n                    message.tvWatchKey = reader.uint64();\n                    break;\n                case 3:\n                    message.tvSlots = reader.uint32();\n                    break;\n                case 4:\n                    message.tvClients = reader.uint32();\n                    break;\n                case 5:\n                    message.tvProxies = reader.uint32();\n                    break;\n                case 6:\n                    message.tvTime = reader.uint32();\n                    break;\n                case 8:\n                    message.gameType = reader.uint32();\n                    break;\n                case 9:\n                    message.gameMapgroup = reader.string();\n                    break;\n                case 10:\n                    message.gameMap = reader.string();\n                    break;\n                case 11:\n                    message.tvMasterSteamid = reader.uint64();\n                    break;\n                case 12:\n                    message.tvLocalSlots = reader.uint32();\n                    break;\n                case 13:\n                    message.tvLocalClients = reader.uint32();\n                    break;\n                case 14:\n                    message.tvLocalProxies = reader.uint32();\n                    break;\n                case 15:\n                    message.tvRelaySlots = reader.uint32();\n                    break;\n                case 16:\n                    message.tvRelayClients = reader.uint32();\n                    break;\n                case 17:\n                    message.tvRelayProxies = reader.uint32();\n                    break;\n                case 18:\n                    message.tvRelayAddress = reader.uint32();\n                    break;\n                case 19:\n                    message.tvRelayPort = reader.uint32();\n                    break;\n                case 20:\n                    message.tvRelaySteamid = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return ServerHltvInfo;\n})());\nexports.IpAddressMask = ($root.IpAddressMask = (() => {\n    /**\n     * Properties of an IpAddressMask.\n     * @exports IIpAddressMask\n     * @interface IIpAddressMask\n     * @property {number|null} [a] IpAddressMask a\n     * @property {number|null} [b] IpAddressMask b\n     * @property {number|null} [c] IpAddressMask c\n     * @property {number|null} [d] IpAddressMask d\n     * @property {number|null} [bits] IpAddressMask bits\n     * @property {number|null} [token] IpAddressMask token\n     */\n    /**\n     * Constructs a new IpAddressMask.\n     * @exports IpAddressMask\n     * @classdesc Represents an IpAddressMask.\n     * @implements IIpAddressMask\n     * @constructor\n     * @param {IIpAddressMask=} [properties] Properties to set\n     */\n    function IpAddressMask(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * IpAddressMask a.\n     * @member {number} a\n     * @memberof IpAddressMask\n     * @instance\n     */\n    IpAddressMask.prototype.a = 0;\n    /**\n     * IpAddressMask b.\n     * @member {number} b\n     * @memberof IpAddressMask\n     * @instance\n     */\n    IpAddressMask.prototype.b = 0;\n    /**\n     * IpAddressMask c.\n     * @member {number} c\n     * @memberof IpAddressMask\n     * @instance\n     */\n    IpAddressMask.prototype.c = 0;\n    /**\n     * IpAddressMask d.\n     * @member {number} d\n     * @memberof IpAddressMask\n     * @instance\n     */\n    IpAddressMask.prototype.d = 0;\n    /**\n     * IpAddressMask bits.\n     * @member {number} bits\n     * @memberof IpAddressMask\n     * @instance\n     */\n    IpAddressMask.prototype.bits = 0;\n    /**\n     * IpAddressMask token.\n     * @member {number} token\n     * @memberof IpAddressMask\n     * @instance\n     */\n    IpAddressMask.prototype.token = 0;\n    /**\n     * Decodes an IpAddressMask message from the specified reader or buffer.\n     * @function decode\n     * @memberof IpAddressMask\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {IpAddressMask} IpAddressMask\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    IpAddressMask.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.IpAddressMask();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.a = reader.uint32();\n                    break;\n                case 2:\n                    message.b = reader.uint32();\n                    break;\n                case 3:\n                    message.c = reader.uint32();\n                    break;\n                case 4:\n                    message.d = reader.uint32();\n                    break;\n                case 5:\n                    message.bits = reader.uint32();\n                    break;\n                case 6:\n                    message.token = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return IpAddressMask;\n})());\nexports.XpProgressData = ($root.XpProgressData = (() => {\n    /**\n     * Properties of a XpProgressData.\n     * @exports IXpProgressData\n     * @interface IXpProgressData\n     * @property {number|null} [xpPoints] XpProgressData xpPoints\n     * @property {number|null} [xpCategory] XpProgressData xpCategory\n     */\n    /**\n     * Constructs a new XpProgressData.\n     * @exports XpProgressData\n     * @classdesc Represents a XpProgressData.\n     * @implements IXpProgressData\n     * @constructor\n     * @param {IXpProgressData=} [properties] Properties to set\n     */\n    function XpProgressData(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * XpProgressData xpPoints.\n     * @member {number} xpPoints\n     * @memberof XpProgressData\n     * @instance\n     */\n    XpProgressData.prototype.xpPoints = 0;\n    /**\n     * XpProgressData xpCategory.\n     * @member {number} xpCategory\n     * @memberof XpProgressData\n     * @instance\n     */\n    XpProgressData.prototype.xpCategory = 0;\n    /**\n     * Decodes a XpProgressData message from the specified reader or buffer.\n     * @function decode\n     * @memberof XpProgressData\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {XpProgressData} XpProgressData\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    XpProgressData.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.XpProgressData();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.xpPoints = reader.uint32();\n                    break;\n                case 2:\n                    message.xpCategory = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return XpProgressData;\n})());\nexports.MatchEndItemUpdates = ($root.MatchEndItemUpdates = (() => {\n    /**\n     * Properties of a MatchEndItemUpdates.\n     * @exports IMatchEndItemUpdates\n     * @interface IMatchEndItemUpdates\n     * @property {number|Long|null} [itemId] MatchEndItemUpdates itemId\n     * @property {number|null} [itemAttrDefidx] MatchEndItemUpdates itemAttrDefidx\n     * @property {number|null} [itemAttrDeltaValue] MatchEndItemUpdates itemAttrDeltaValue\n     */\n    /**\n     * Constructs a new MatchEndItemUpdates.\n     * @exports MatchEndItemUpdates\n     * @classdesc Represents a MatchEndItemUpdates.\n     * @implements IMatchEndItemUpdates\n     * @constructor\n     * @param {IMatchEndItemUpdates=} [properties] Properties to set\n     */\n    function MatchEndItemUpdates(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * MatchEndItemUpdates itemId.\n     * @member {number|Long} itemId\n     * @memberof MatchEndItemUpdates\n     * @instance\n     */\n    MatchEndItemUpdates.prototype.itemId = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * MatchEndItemUpdates itemAttrDefidx.\n     * @member {number} itemAttrDefidx\n     * @memberof MatchEndItemUpdates\n     * @instance\n     */\n    MatchEndItemUpdates.prototype.itemAttrDefidx = 0;\n    /**\n     * MatchEndItemUpdates itemAttrDeltaValue.\n     * @member {number} itemAttrDeltaValue\n     * @memberof MatchEndItemUpdates\n     * @instance\n     */\n    MatchEndItemUpdates.prototype.itemAttrDeltaValue = 0;\n    /**\n     * Decodes a MatchEndItemUpdates message from the specified reader or buffer.\n     * @function decode\n     * @memberof MatchEndItemUpdates\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {MatchEndItemUpdates} MatchEndItemUpdates\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    MatchEndItemUpdates.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.MatchEndItemUpdates();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.itemId = reader.uint64();\n                    break;\n                case 2:\n                    message.itemAttrDefidx = reader.uint32();\n                    break;\n                case 3:\n                    message.itemAttrDeltaValue = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return MatchEndItemUpdates;\n})());\nexports.PlayerQuestData = ($root.PlayerQuestData = (() => {\n    /**\n     * Properties of a PlayerQuestData.\n     * @exports IPlayerQuestData\n     * @interface IPlayerQuestData\n     * @property {number|null} [questerAccountId] PlayerQuestData questerAccountId\n     * @property {Array.<PlayerQuestData.IQuestItemData>|null} [questItemData] PlayerQuestData questItemData\n     * @property {Array.<IXpProgressData>|null} [xpProgressData] PlayerQuestData xpProgressData\n     * @property {number|null} [timePlayed] PlayerQuestData timePlayed\n     * @property {number|null} [mmGameMode] PlayerQuestData mmGameMode\n     * @property {Array.<IMatchEndItemUpdates>|null} [itemUpdates] PlayerQuestData itemUpdates\n     */\n    /**\n     * Constructs a new PlayerQuestData.\n     * @exports PlayerQuestData\n     * @classdesc Represents a PlayerQuestData.\n     * @implements IPlayerQuestData\n     * @constructor\n     * @param {IPlayerQuestData=} [properties] Properties to set\n     */\n    function PlayerQuestData(properties) {\n        this.questItemData = [];\n        this.xpProgressData = [];\n        this.itemUpdates = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * PlayerQuestData questerAccountId.\n     * @member {number} questerAccountId\n     * @memberof PlayerQuestData\n     * @instance\n     */\n    PlayerQuestData.prototype.questerAccountId = 0;\n    /**\n     * PlayerQuestData questItemData.\n     * @member {Array.<PlayerQuestData.IQuestItemData>} questItemData\n     * @memberof PlayerQuestData\n     * @instance\n     */\n    PlayerQuestData.prototype.questItemData = $util.emptyArray;\n    /**\n     * PlayerQuestData xpProgressData.\n     * @member {Array.<IXpProgressData>} xpProgressData\n     * @memberof PlayerQuestData\n     * @instance\n     */\n    PlayerQuestData.prototype.xpProgressData = $util.emptyArray;\n    /**\n     * PlayerQuestData timePlayed.\n     * @member {number} timePlayed\n     * @memberof PlayerQuestData\n     * @instance\n     */\n    PlayerQuestData.prototype.timePlayed = 0;\n    /**\n     * PlayerQuestData mmGameMode.\n     * @member {number} mmGameMode\n     * @memberof PlayerQuestData\n     * @instance\n     */\n    PlayerQuestData.prototype.mmGameMode = 0;\n    /**\n     * PlayerQuestData itemUpdates.\n     * @member {Array.<IMatchEndItemUpdates>} itemUpdates\n     * @memberof PlayerQuestData\n     * @instance\n     */\n    PlayerQuestData.prototype.itemUpdates = $util.emptyArray;\n    /**\n     * Decodes a PlayerQuestData message from the specified reader or buffer.\n     * @function decode\n     * @memberof PlayerQuestData\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {PlayerQuestData} PlayerQuestData\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    PlayerQuestData.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PlayerQuestData();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.questerAccountId = reader.uint32();\n                    break;\n                case 2:\n                    if (!(message.questItemData && message.questItemData.length))\n                        message.questItemData = [];\n                    message.questItemData.push($root.PlayerQuestData.QuestItemData.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    if (!(message.xpProgressData && message.xpProgressData.length))\n                        message.xpProgressData = [];\n                    message.xpProgressData.push($root.XpProgressData.decode(reader, reader.uint32()));\n                    break;\n                case 4:\n                    message.timePlayed = reader.uint32();\n                    break;\n                case 5:\n                    message.mmGameMode = reader.uint32();\n                    break;\n                case 6:\n                    if (!(message.itemUpdates && message.itemUpdates.length))\n                        message.itemUpdates = [];\n                    message.itemUpdates.push($root.MatchEndItemUpdates.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    PlayerQuestData.QuestItemData = (function () {\n        /**\n         * Properties of a QuestItemData.\n         * @memberof PlayerQuestData\n         * @interface IQuestItemData\n         * @property {number|Long|null} [questId] QuestItemData questId\n         * @property {number|null} [questNormalPointsEarned] QuestItemData questNormalPointsEarned\n         * @property {number|null} [questBonusPointsEarned] QuestItemData questBonusPointsEarned\n         */\n        /**\n         * Constructs a new QuestItemData.\n         * @memberof PlayerQuestData\n         * @classdesc Represents a QuestItemData.\n         * @implements IQuestItemData\n         * @constructor\n         * @param {PlayerQuestData.IQuestItemData=} [properties] Properties to set\n         */\n        function QuestItemData(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * QuestItemData questId.\n         * @member {number|Long} questId\n         * @memberof PlayerQuestData.QuestItemData\n         * @instance\n         */\n        QuestItemData.prototype.questId = $util.Long\n            ? $util.Long.fromBits(0, 0, true)\n            : 0;\n        /**\n         * QuestItemData questNormalPointsEarned.\n         * @member {number} questNormalPointsEarned\n         * @memberof PlayerQuestData.QuestItemData\n         * @instance\n         */\n        QuestItemData.prototype.questNormalPointsEarned = 0;\n        /**\n         * QuestItemData questBonusPointsEarned.\n         * @member {number} questBonusPointsEarned\n         * @memberof PlayerQuestData.QuestItemData\n         * @instance\n         */\n        QuestItemData.prototype.questBonusPointsEarned = 0;\n        /**\n         * Decodes a QuestItemData message from the specified reader or buffer.\n         * @function decode\n         * @memberof PlayerQuestData.QuestItemData\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {PlayerQuestData.QuestItemData} QuestItemData\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        QuestItemData.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.PlayerQuestData.QuestItemData();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.questId = reader.uint64();\n                        break;\n                    case 2:\n                        message.questNormalPointsEarned = reader.int32();\n                        break;\n                    case 3:\n                        message.questBonusPointsEarned = reader.int32();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return QuestItemData;\n    })();\n    return PlayerQuestData;\n})());\nexports.CMsgGC_ServerQuestUpdateData = ($root.CMsgGC_ServerQuestUpdateData = (() => {\n    /**\n     * Properties of a CMsgGC_ServerQuestUpdateData.\n     * @exports ICMsgGC_ServerQuestUpdateData\n     * @interface ICMsgGC_ServerQuestUpdateData\n     * @property {Array.<IPlayerQuestData>|null} [playerQuestData] CMsgGC_ServerQuestUpdateData playerQuestData\n     */\n    /**\n     * Constructs a new CMsgGC_ServerQuestUpdateData.\n     * @exports CMsgGC_ServerQuestUpdateData\n     * @classdesc Represents a CMsgGC_ServerQuestUpdateData.\n     * @implements ICMsgGC_ServerQuestUpdateData\n     * @constructor\n     * @param {ICMsgGC_ServerQuestUpdateData=} [properties] Properties to set\n     */\n    function CMsgGC_ServerQuestUpdateData(properties) {\n        this.playerQuestData = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGC_ServerQuestUpdateData playerQuestData.\n     * @member {Array.<IPlayerQuestData>} playerQuestData\n     * @memberof CMsgGC_ServerQuestUpdateData\n     * @instance\n     */\n    CMsgGC_ServerQuestUpdateData.prototype.playerQuestData = $util.emptyArray;\n    /**\n     * Decodes a CMsgGC_ServerQuestUpdateData message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGC_ServerQuestUpdateData\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGC_ServerQuestUpdateData} CMsgGC_ServerQuestUpdateData\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGC_ServerQuestUpdateData.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGC_ServerQuestUpdateData();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.playerQuestData && message.playerQuestData.length))\n                        message.playerQuestData = [];\n                    message.playerQuestData.push($root.PlayerQuestData.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGC_ServerQuestUpdateData;\n})());\nexports.CMsgGCCStrike15_v2_MatchmakingGCOperationalStats = ($root.CMsgGCCStrike15_v2_MatchmakingGCOperationalStats = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.\n     * @exports ICMsgGCCStrike15_v2_MatchmakingGCOperationalStats\n     * @interface ICMsgGCCStrike15_v2_MatchmakingGCOperationalStats\n     * @property {number|null} [packetid] CMsgGCCStrike15_v2_MatchmakingGCOperationalStats packetid\n     * @property {Array.<IOperationalStatisticDescription>|null} [namekeys] CMsgGCCStrike15_v2_MatchmakingGCOperationalStats namekeys\n     * @property {Array.<IOperationalStatisticsPacket>|null} [packets] CMsgGCCStrike15_v2_MatchmakingGCOperationalStats packets\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.\n     * @exports CMsgGCCStrike15_v2_MatchmakingGCOperationalStats\n     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.\n     * @implements ICMsgGCCStrike15_v2_MatchmakingGCOperationalStats\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_MatchmakingGCOperationalStats=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_MatchmakingGCOperationalStats(properties) {\n        this.namekeys = [];\n        this.packets = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGCOperationalStats packetid.\n     * @member {number} packetid\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGCOperationalStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.prototype.packetid = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGCOperationalStats namekeys.\n     * @member {Array.<IOperationalStatisticDescription>} namekeys\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGCOperationalStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.prototype.namekeys =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGCOperationalStats packets.\n     * @member {Array.<IOperationalStatisticsPacket>} packets\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGCOperationalStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.prototype.packets =\n        $util.emptyArray;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_MatchmakingGCOperationalStats message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGCOperationalStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchmakingGCOperationalStats} CMsgGCCStrike15_v2_MatchmakingGCOperationalStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_MatchmakingGCOperationalStats.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGCOperationalStats();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.packetid = reader.int32();\n                    break;\n                case 2:\n                    if (!(message.namekeys && message.namekeys.length))\n                        message.namekeys = [];\n                    message.namekeys.push($root.OperationalStatisticDescription.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    if (!(message.packets && message.packets.length))\n                        message.packets = [];\n                    message.packets.push($root.OperationalStatisticsPacket.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_MatchmakingGCOperationalStats;\n})());\nexports.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm = ($root.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.\n     * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm\n     * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm\n     * @property {number|null} [token] CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm token\n     * @property {number|null} [stamp] CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm stamp\n     * @property {number|Long|null} [exchange] CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm exchange\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.\n     * @exports CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm\n     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.\n     * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm token.\n     * @member {number} token\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.prototype.token = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm stamp.\n     * @member {number} stamp\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.prototype.stamp = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm exchange.\n     * @member {number|Long} exchange\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.prototype.exchange = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm} CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.token = reader.uint32();\n                    break;\n                case 2:\n                    message.stamp = reader.uint32();\n                    break;\n                case 3:\n                    message.exchange = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm;\n})());\nexports.CMsgGCCStrike15_v2_GC2ServerReservationUpdate = ($root.CMsgGCCStrike15_v2_GC2ServerReservationUpdate = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_GC2ServerReservationUpdate.\n     * @exports ICMsgGCCStrike15_v2_GC2ServerReservationUpdate\n     * @interface ICMsgGCCStrike15_v2_GC2ServerReservationUpdate\n     * @property {number|null} [viewersExternalTotal] CMsgGCCStrike15_v2_GC2ServerReservationUpdate viewersExternalTotal\n     * @property {number|null} [viewersExternalSteam] CMsgGCCStrike15_v2_GC2ServerReservationUpdate viewersExternalSteam\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_GC2ServerReservationUpdate.\n     * @exports CMsgGCCStrike15_v2_GC2ServerReservationUpdate\n     * @classdesc Represents a CMsgGCCStrike15_v2_GC2ServerReservationUpdate.\n     * @implements ICMsgGCCStrike15_v2_GC2ServerReservationUpdate\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_GC2ServerReservationUpdate=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_GC2ServerReservationUpdate(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_GC2ServerReservationUpdate viewersExternalTotal.\n     * @member {number} viewersExternalTotal\n     * @memberof CMsgGCCStrike15_v2_GC2ServerReservationUpdate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_GC2ServerReservationUpdate.prototype.viewersExternalTotal = 0;\n    /**\n     * CMsgGCCStrike15_v2_GC2ServerReservationUpdate viewersExternalSteam.\n     * @member {number} viewersExternalSteam\n     * @memberof CMsgGCCStrike15_v2_GC2ServerReservationUpdate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_GC2ServerReservationUpdate.prototype.viewersExternalSteam = 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_GC2ServerReservationUpdate message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_GC2ServerReservationUpdate\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_GC2ServerReservationUpdate} CMsgGCCStrike15_v2_GC2ServerReservationUpdate\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_GC2ServerReservationUpdate.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_GC2ServerReservationUpdate();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.viewersExternalTotal = reader.uint32();\n                    break;\n                case 2:\n                    message.viewersExternalSteam = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_GC2ServerReservationUpdate;\n})());\nexports.CMsgGCCStrike15_v2_MatchmakingStart = ($root.CMsgGCCStrike15_v2_MatchmakingStart = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_MatchmakingStart.\n     * @exports ICMsgGCCStrike15_v2_MatchmakingStart\n     * @interface ICMsgGCCStrike15_v2_MatchmakingStart\n     * @property {Array.<number>|null} [accountIds] CMsgGCCStrike15_v2_MatchmakingStart accountIds\n     * @property {number|null} [gameType] CMsgGCCStrike15_v2_MatchmakingStart gameType\n     * @property {string|null} [ticketData] CMsgGCCStrike15_v2_MatchmakingStart ticketData\n     * @property {number|null} [clientVersion] CMsgGCCStrike15_v2_MatchmakingStart clientVersion\n     * @property {ITournamentMatchSetup|null} [tournamentMatch] CMsgGCCStrike15_v2_MatchmakingStart tournamentMatch\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_MatchmakingStart.\n     * @exports CMsgGCCStrike15_v2_MatchmakingStart\n     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingStart.\n     * @implements ICMsgGCCStrike15_v2_MatchmakingStart\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_MatchmakingStart=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_MatchmakingStart(properties) {\n        this.accountIds = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingStart accountIds.\n     * @member {Array.<number>} accountIds\n     * @memberof CMsgGCCStrike15_v2_MatchmakingStart\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingStart.prototype.accountIds = $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingStart gameType.\n     * @member {number} gameType\n     * @memberof CMsgGCCStrike15_v2_MatchmakingStart\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingStart.prototype.gameType = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingStart ticketData.\n     * @member {string} ticketData\n     * @memberof CMsgGCCStrike15_v2_MatchmakingStart\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingStart.prototype.ticketData = \"\";\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingStart clientVersion.\n     * @member {number} clientVersion\n     * @memberof CMsgGCCStrike15_v2_MatchmakingStart\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingStart.prototype.clientVersion = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingStart tournamentMatch.\n     * @member {ITournamentMatchSetup|null|undefined} tournamentMatch\n     * @memberof CMsgGCCStrike15_v2_MatchmakingStart\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingStart.prototype.tournamentMatch = null;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_MatchmakingStart message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchmakingStart\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchmakingStart} CMsgGCCStrike15_v2_MatchmakingStart\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_MatchmakingStart.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingStart();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.accountIds && message.accountIds.length))\n                        message.accountIds = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.accountIds.push(reader.uint32());\n                    }\n                    else\n                        message.accountIds.push(reader.uint32());\n                    break;\n                case 2:\n                    message.gameType = reader.uint32();\n                    break;\n                case 3:\n                    message.ticketData = reader.string();\n                    break;\n                case 4:\n                    message.clientVersion = reader.uint32();\n                    break;\n                case 5:\n                    message.tournamentMatch = $root.TournamentMatchSetup.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_MatchmakingStart;\n})());\nexports.CMsgGCCStrike15_v2_MatchmakingStop = ($root.CMsgGCCStrike15_v2_MatchmakingStop = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_MatchmakingStop.\n     * @exports ICMsgGCCStrike15_v2_MatchmakingStop\n     * @interface ICMsgGCCStrike15_v2_MatchmakingStop\n     * @property {number|null} [abandon] CMsgGCCStrike15_v2_MatchmakingStop abandon\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_MatchmakingStop.\n     * @exports CMsgGCCStrike15_v2_MatchmakingStop\n     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingStop.\n     * @implements ICMsgGCCStrike15_v2_MatchmakingStop\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_MatchmakingStop=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_MatchmakingStop(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingStop abandon.\n     * @member {number} abandon\n     * @memberof CMsgGCCStrike15_v2_MatchmakingStop\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingStop.prototype.abandon = 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_MatchmakingStop message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchmakingStop\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchmakingStop} CMsgGCCStrike15_v2_MatchmakingStop\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_MatchmakingStop.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingStop();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.abandon = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_MatchmakingStop;\n})());\nexports.CMsgGCCStrike15_v2_MatchmakingClient2ServerPing = ($root.CMsgGCCStrike15_v2_MatchmakingClient2ServerPing = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.\n     * @exports ICMsgGCCStrike15_v2_MatchmakingClient2ServerPing\n     * @interface ICMsgGCCStrike15_v2_MatchmakingClient2ServerPing\n     * @property {Array.<IGameServerPing>|null} [gameserverpings] CMsgGCCStrike15_v2_MatchmakingClient2ServerPing gameserverpings\n     * @property {number|null} [offsetIndex] CMsgGCCStrike15_v2_MatchmakingClient2ServerPing offsetIndex\n     * @property {number|null} [finalBatch] CMsgGCCStrike15_v2_MatchmakingClient2ServerPing finalBatch\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.\n     * @exports CMsgGCCStrike15_v2_MatchmakingClient2ServerPing\n     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.\n     * @implements ICMsgGCCStrike15_v2_MatchmakingClient2ServerPing\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_MatchmakingClient2ServerPing=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_MatchmakingClient2ServerPing(properties) {\n        this.gameserverpings = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingClient2ServerPing gameserverpings.\n     * @member {Array.<IGameServerPing>} gameserverpings\n     * @memberof CMsgGCCStrike15_v2_MatchmakingClient2ServerPing\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.prototype.gameserverpings =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingClient2ServerPing offsetIndex.\n     * @member {number} offsetIndex\n     * @memberof CMsgGCCStrike15_v2_MatchmakingClient2ServerPing\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.prototype.offsetIndex = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingClient2ServerPing finalBatch.\n     * @member {number} finalBatch\n     * @memberof CMsgGCCStrike15_v2_MatchmakingClient2ServerPing\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.prototype.finalBatch = 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_MatchmakingClient2ServerPing message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchmakingClient2ServerPing\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchmakingClient2ServerPing} CMsgGCCStrike15_v2_MatchmakingClient2ServerPing\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_MatchmakingClient2ServerPing.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingClient2ServerPing();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.gameserverpings && message.gameserverpings.length))\n                        message.gameserverpings = [];\n                    message.gameserverpings.push($root.GameServerPing.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.offsetIndex = reader.int32();\n                    break;\n                case 3:\n                    message.finalBatch = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_MatchmakingClient2ServerPing;\n})());\nexports.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate = ($root.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.\n     * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n     * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n     * @property {number|null} [matchmaking] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate matchmaking\n     * @property {Array.<number>|null} [waitingAccountIdSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate waitingAccountIdSessions\n     * @property {string|null} [error] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate error\n     * @property {Array.<number>|null} [ongoingmatchAccountIdSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate ongoingmatchAccountIdSessions\n     * @property {IGlobalStatistics|null} [globalStats] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate globalStats\n     * @property {Array.<number>|null} [failpingAccountIdSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate failpingAccountIdSessions\n     * @property {Array.<number>|null} [penaltyAccountIdSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate penaltyAccountIdSessions\n     * @property {Array.<number>|null} [failreadyAccountIdSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate failreadyAccountIdSessions\n     * @property {Array.<number>|null} [vacbannedAccountIdSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate vacbannedAccountIdSessions\n     * @property {IIpAddressMask|null} [serverIpaddressMask] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate serverIpaddressMask\n     * @property {Array.<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.INote>|null} [notes] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate notes\n     * @property {Array.<number>|null} [penaltyAccountIdSessionsGreen] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate penaltyAccountIdSessionsGreen\n     * @property {Array.<number>|null} [insufficientlevelSessions] CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate insufficientlevelSessions\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.\n     * @exports CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.\n     * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate(properties) {\n        this.waitingAccountIdSessions = [];\n        this.ongoingmatchAccountIdSessions = [];\n        this.failpingAccountIdSessions = [];\n        this.penaltyAccountIdSessions = [];\n        this.failreadyAccountIdSessions = [];\n        this.vacbannedAccountIdSessions = [];\n        this.notes = [];\n        this.penaltyAccountIdSessionsGreen = [];\n        this.insufficientlevelSessions = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate matchmaking.\n     * @member {number} matchmaking\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.matchmaking = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate waitingAccountIdSessions.\n     * @member {Array.<number>} waitingAccountIdSessions\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.waitingAccountIdSessions =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate error.\n     * @member {string} error\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.error = \"\";\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate ongoingmatchAccountIdSessions.\n     * @member {Array.<number>} ongoingmatchAccountIdSessions\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.ongoingmatchAccountIdSessions =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate globalStats.\n     * @member {IGlobalStatistics|null|undefined} globalStats\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.globalStats = null;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate failpingAccountIdSessions.\n     * @member {Array.<number>} failpingAccountIdSessions\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.failpingAccountIdSessions =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate penaltyAccountIdSessions.\n     * @member {Array.<number>} penaltyAccountIdSessions\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.penaltyAccountIdSessions =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate failreadyAccountIdSessions.\n     * @member {Array.<number>} failreadyAccountIdSessions\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.failreadyAccountIdSessions =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate vacbannedAccountIdSessions.\n     * @member {Array.<number>} vacbannedAccountIdSessions\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.vacbannedAccountIdSessions =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate serverIpaddressMask.\n     * @member {IIpAddressMask|null|undefined} serverIpaddressMask\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.serverIpaddressMask = null;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate notes.\n     * @member {Array.<CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.INote>} notes\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.notes =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate penaltyAccountIdSessionsGreen.\n     * @member {Array.<number>} penaltyAccountIdSessionsGreen\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.penaltyAccountIdSessionsGreen =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate insufficientlevelSessions.\n     * @member {Array.<number>} insufficientlevelSessions\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.prototype.insufficientlevelSessions =\n        $util.emptyArray;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate} CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.matchmaking = reader.int32();\n                    break;\n                case 2:\n                    if (!(message.waitingAccountIdSessions &&\n                        message.waitingAccountIdSessions.length))\n                        message.waitingAccountIdSessions = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.waitingAccountIdSessions.push(reader.uint32());\n                    }\n                    else\n                        message.waitingAccountIdSessions.push(reader.uint32());\n                    break;\n                case 3:\n                    message.error = reader.string();\n                    break;\n                case 6:\n                    if (!(message.ongoingmatchAccountIdSessions &&\n                        message.ongoingmatchAccountIdSessions.length))\n                        message.ongoingmatchAccountIdSessions = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.ongoingmatchAccountIdSessions.push(reader.uint32());\n                    }\n                    else\n                        message.ongoingmatchAccountIdSessions.push(reader.uint32());\n                    break;\n                case 7:\n                    message.globalStats = $root.GlobalStatistics.decode(reader, reader.uint32());\n                    break;\n                case 8:\n                    if (!(message.failpingAccountIdSessions &&\n                        message.failpingAccountIdSessions.length))\n                        message.failpingAccountIdSessions = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.failpingAccountIdSessions.push(reader.uint32());\n                    }\n                    else\n                        message.failpingAccountIdSessions.push(reader.uint32());\n                    break;\n                case 9:\n                    if (!(message.penaltyAccountIdSessions &&\n                        message.penaltyAccountIdSessions.length))\n                        message.penaltyAccountIdSessions = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.penaltyAccountIdSessions.push(reader.uint32());\n                    }\n                    else\n                        message.penaltyAccountIdSessions.push(reader.uint32());\n                    break;\n                case 10:\n                    if (!(message.failreadyAccountIdSessions &&\n                        message.failreadyAccountIdSessions.length))\n                        message.failreadyAccountIdSessions = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.failreadyAccountIdSessions.push(reader.uint32());\n                    }\n                    else\n                        message.failreadyAccountIdSessions.push(reader.uint32());\n                    break;\n                case 11:\n                    if (!(message.vacbannedAccountIdSessions &&\n                        message.vacbannedAccountIdSessions.length))\n                        message.vacbannedAccountIdSessions = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.vacbannedAccountIdSessions.push(reader.uint32());\n                    }\n                    else\n                        message.vacbannedAccountIdSessions.push(reader.uint32());\n                    break;\n                case 12:\n                    message.serverIpaddressMask = $root.IpAddressMask.decode(reader, reader.uint32());\n                    break;\n                case 13:\n                    if (!(message.notes && message.notes.length))\n                        message.notes = [];\n                    message.notes.push($root.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note.decode(reader, reader.uint32()));\n                    break;\n                case 14:\n                    if (!(message.penaltyAccountIdSessionsGreen &&\n                        message.penaltyAccountIdSessionsGreen.length))\n                        message.penaltyAccountIdSessionsGreen = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.penaltyAccountIdSessionsGreen.push(reader.uint32());\n                    }\n                    else\n                        message.penaltyAccountIdSessionsGreen.push(reader.uint32());\n                    break;\n                case 15:\n                    if (!(message.insufficientlevelSessions &&\n                        message.insufficientlevelSessions.length))\n                        message.insufficientlevelSessions = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.insufficientlevelSessions.push(reader.uint32());\n                    }\n                    else\n                        message.insufficientlevelSessions.push(reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note = (function () {\n        /**\n         * Properties of a Note.\n         * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n         * @interface INote\n         * @property {number|null} [type] Note type\n         * @property {number|null} [regionId] Note regionId\n         * @property {number|null} [regionR] Note regionR\n         * @property {number|null} [distance] Note distance\n         */\n        /**\n         * Constructs a new Note.\n         * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate\n         * @classdesc Represents a Note.\n         * @implements INote\n         * @constructor\n         * @param {CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.INote=} [properties] Properties to set\n         */\n        function Note(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * Note type.\n         * @member {number} type\n         * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note\n         * @instance\n         */\n        Note.prototype.type = 0;\n        /**\n         * Note regionId.\n         * @member {number} regionId\n         * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note\n         * @instance\n         */\n        Note.prototype.regionId = 0;\n        /**\n         * Note regionR.\n         * @member {number} regionR\n         * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note\n         * @instance\n         */\n        Note.prototype.regionR = 0;\n        /**\n         * Note distance.\n         * @member {number} distance\n         * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note\n         * @instance\n         */\n        Note.prototype.distance = 0;\n        /**\n         * Decodes a Note message from the specified reader or buffer.\n         * @function decode\n         * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note} Note\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Note.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate.Note();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.type = reader.int32();\n                        break;\n                    case 2:\n                        message.regionId = reader.int32();\n                        break;\n                    case 3:\n                        message.regionR = reader.float();\n                        break;\n                    case 4:\n                        message.distance = reader.float();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return Note;\n    })();\n    return CMsgGCCStrike15_v2_MatchmakingGC2ClientUpdate;\n})());\nexports.CDataGCCStrike15_v2_TournamentMatchDraft = ($root.CDataGCCStrike15_v2_TournamentMatchDraft = (() => {\n    /**\n     * Properties of a CDataGCCStrike15_v2_TournamentMatchDraft.\n     * @exports ICDataGCCStrike15_v2_TournamentMatchDraft\n     * @interface ICDataGCCStrike15_v2_TournamentMatchDraft\n     * @property {number|null} [eventId] CDataGCCStrike15_v2_TournamentMatchDraft eventId\n     * @property {number|null} [eventStageId] CDataGCCStrike15_v2_TournamentMatchDraft eventStageId\n     * @property {number|null} [teamId_0] CDataGCCStrike15_v2_TournamentMatchDraft teamId_0\n     * @property {number|null} [teamId_1] CDataGCCStrike15_v2_TournamentMatchDraft teamId_1\n     * @property {number|null} [mapsCount] CDataGCCStrike15_v2_TournamentMatchDraft mapsCount\n     * @property {number|null} [mapsCurrent] CDataGCCStrike15_v2_TournamentMatchDraft mapsCurrent\n     * @property {number|null} [teamIdStart] CDataGCCStrike15_v2_TournamentMatchDraft teamIdStart\n     * @property {number|null} [teamIdVeto1] CDataGCCStrike15_v2_TournamentMatchDraft teamIdVeto1\n     * @property {number|null} [teamIdPickn] CDataGCCStrike15_v2_TournamentMatchDraft teamIdPickn\n     * @property {Array.<CDataGCCStrike15_v2_TournamentMatchDraft.IEntry>|null} [drafts] CDataGCCStrike15_v2_TournamentMatchDraft drafts\n     */\n    /**\n     * Constructs a new CDataGCCStrike15_v2_TournamentMatchDraft.\n     * @exports CDataGCCStrike15_v2_TournamentMatchDraft\n     * @classdesc Represents a CDataGCCStrike15_v2_TournamentMatchDraft.\n     * @implements ICDataGCCStrike15_v2_TournamentMatchDraft\n     * @constructor\n     * @param {ICDataGCCStrike15_v2_TournamentMatchDraft=} [properties] Properties to set\n     */\n    function CDataGCCStrike15_v2_TournamentMatchDraft(properties) {\n        this.drafts = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CDataGCCStrike15_v2_TournamentMatchDraft eventId.\n     * @member {number} eventId\n     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.eventId = 0;\n    /**\n     * CDataGCCStrike15_v2_TournamentMatchDraft eventStageId.\n     * @member {number} eventStageId\n     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.eventStageId = 0;\n    /**\n     * CDataGCCStrike15_v2_TournamentMatchDraft teamId_0.\n     * @member {number} teamId_0\n     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.teamId_0 = 0;\n    /**\n     * CDataGCCStrike15_v2_TournamentMatchDraft teamId_1.\n     * @member {number} teamId_1\n     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.teamId_1 = 0;\n    /**\n     * CDataGCCStrike15_v2_TournamentMatchDraft mapsCount.\n     * @member {number} mapsCount\n     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.mapsCount = 0;\n    /**\n     * CDataGCCStrike15_v2_TournamentMatchDraft mapsCurrent.\n     * @member {number} mapsCurrent\n     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.mapsCurrent = 0;\n    /**\n     * CDataGCCStrike15_v2_TournamentMatchDraft teamIdStart.\n     * @member {number} teamIdStart\n     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.teamIdStart = 0;\n    /**\n     * CDataGCCStrike15_v2_TournamentMatchDraft teamIdVeto1.\n     * @member {number} teamIdVeto1\n     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.teamIdVeto1 = 0;\n    /**\n     * CDataGCCStrike15_v2_TournamentMatchDraft teamIdPickn.\n     * @member {number} teamIdPickn\n     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.teamIdPickn = 0;\n    /**\n     * CDataGCCStrike15_v2_TournamentMatchDraft drafts.\n     * @member {Array.<CDataGCCStrike15_v2_TournamentMatchDraft.IEntry>} drafts\n     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentMatchDraft.prototype.drafts = $util.emptyArray;\n    /**\n     * Decodes a CDataGCCStrike15_v2_TournamentMatchDraft message from the specified reader or buffer.\n     * @function decode\n     * @memberof CDataGCCStrike15_v2_TournamentMatchDraft\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CDataGCCStrike15_v2_TournamentMatchDraft} CDataGCCStrike15_v2_TournamentMatchDraft\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CDataGCCStrike15_v2_TournamentMatchDraft.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDataGCCStrike15_v2_TournamentMatchDraft();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.eventId = reader.int32();\n                    break;\n                case 2:\n                    message.eventStageId = reader.int32();\n                    break;\n                case 3:\n                    message.teamId_0 = reader.int32();\n                    break;\n                case 4:\n                    message.teamId_1 = reader.int32();\n                    break;\n                case 5:\n                    message.mapsCount = reader.int32();\n                    break;\n                case 6:\n                    message.mapsCurrent = reader.int32();\n                    break;\n                case 7:\n                    message.teamIdStart = reader.int32();\n                    break;\n                case 8:\n                    message.teamIdVeto1 = reader.int32();\n                    break;\n                case 9:\n                    message.teamIdPickn = reader.int32();\n                    break;\n                case 10:\n                    if (!(message.drafts && message.drafts.length))\n                        message.drafts = [];\n                    message.drafts.push($root.CDataGCCStrike15_v2_TournamentMatchDraft.Entry.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CDataGCCStrike15_v2_TournamentMatchDraft.Entry = (function () {\n        /**\n         * Properties of an Entry.\n         * @memberof CDataGCCStrike15_v2_TournamentMatchDraft\n         * @interface IEntry\n         * @property {number|null} [mapid] Entry mapid\n         * @property {number|null} [teamIdCt] Entry teamIdCt\n         */\n        /**\n         * Constructs a new Entry.\n         * @memberof CDataGCCStrike15_v2_TournamentMatchDraft\n         * @classdesc Represents an Entry.\n         * @implements IEntry\n         * @constructor\n         * @param {CDataGCCStrike15_v2_TournamentMatchDraft.IEntry=} [properties] Properties to set\n         */\n        function Entry(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * Entry mapid.\n         * @member {number} mapid\n         * @memberof CDataGCCStrike15_v2_TournamentMatchDraft.Entry\n         * @instance\n         */\n        Entry.prototype.mapid = 0;\n        /**\n         * Entry teamIdCt.\n         * @member {number} teamIdCt\n         * @memberof CDataGCCStrike15_v2_TournamentMatchDraft.Entry\n         * @instance\n         */\n        Entry.prototype.teamIdCt = 0;\n        /**\n         * Decodes an Entry message from the specified reader or buffer.\n         * @function decode\n         * @memberof CDataGCCStrike15_v2_TournamentMatchDraft.Entry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CDataGCCStrike15_v2_TournamentMatchDraft.Entry} Entry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Entry.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDataGCCStrike15_v2_TournamentMatchDraft.Entry();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.mapid = reader.int32();\n                        break;\n                    case 2:\n                        message.teamIdCt = reader.int32();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return Entry;\n    })();\n    return CDataGCCStrike15_v2_TournamentMatchDraft;\n})());\nexports.CPreMatchInfoData = ($root.CPreMatchInfoData = (() => {\n    /**\n     * Properties of a CPreMatchInfoData.\n     * @exports ICPreMatchInfoData\n     * @interface ICPreMatchInfoData\n     * @property {number|null} [predictionsPct] CPreMatchInfoData predictionsPct\n     * @property {ICDataGCCStrike15_v2_TournamentMatchDraft|null} [draft] CPreMatchInfoData draft\n     * @property {Array.<CPreMatchInfoData.ITeamStats>|null} [stats] CPreMatchInfoData stats\n     */\n    /**\n     * Constructs a new CPreMatchInfoData.\n     * @exports CPreMatchInfoData\n     * @classdesc Represents a CPreMatchInfoData.\n     * @implements ICPreMatchInfoData\n     * @constructor\n     * @param {ICPreMatchInfoData=} [properties] Properties to set\n     */\n    function CPreMatchInfoData(properties) {\n        this.stats = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CPreMatchInfoData predictionsPct.\n     * @member {number} predictionsPct\n     * @memberof CPreMatchInfoData\n     * @instance\n     */\n    CPreMatchInfoData.prototype.predictionsPct = 0;\n    /**\n     * CPreMatchInfoData draft.\n     * @member {ICDataGCCStrike15_v2_TournamentMatchDraft|null|undefined} draft\n     * @memberof CPreMatchInfoData\n     * @instance\n     */\n    CPreMatchInfoData.prototype.draft = null;\n    /**\n     * CPreMatchInfoData stats.\n     * @member {Array.<CPreMatchInfoData.ITeamStats>} stats\n     * @memberof CPreMatchInfoData\n     * @instance\n     */\n    CPreMatchInfoData.prototype.stats = $util.emptyArray;\n    /**\n     * Decodes a CPreMatchInfoData message from the specified reader or buffer.\n     * @function decode\n     * @memberof CPreMatchInfoData\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CPreMatchInfoData} CPreMatchInfoData\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CPreMatchInfoData.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CPreMatchInfoData();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.predictionsPct = reader.int32();\n                    break;\n                case 4:\n                    message.draft = $root.CDataGCCStrike15_v2_TournamentMatchDraft.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    if (!(message.stats && message.stats.length))\n                        message.stats = [];\n                    message.stats.push($root.CPreMatchInfoData.TeamStats.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CPreMatchInfoData.TeamStats = (function () {\n        /**\n         * Properties of a TeamStats.\n         * @memberof CPreMatchInfoData\n         * @interface ITeamStats\n         * @property {number|null} [matchInfoIdxtxt] TeamStats matchInfoIdxtxt\n         * @property {string|null} [matchInfoTxt] TeamStats matchInfoTxt\n         * @property {Array.<string>|null} [matchInfoTeams] TeamStats matchInfoTeams\n         */\n        /**\n         * Constructs a new TeamStats.\n         * @memberof CPreMatchInfoData\n         * @classdesc Represents a TeamStats.\n         * @implements ITeamStats\n         * @constructor\n         * @param {CPreMatchInfoData.ITeamStats=} [properties] Properties to set\n         */\n        function TeamStats(properties) {\n            this.matchInfoTeams = [];\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * TeamStats matchInfoIdxtxt.\n         * @member {number} matchInfoIdxtxt\n         * @memberof CPreMatchInfoData.TeamStats\n         * @instance\n         */\n        TeamStats.prototype.matchInfoIdxtxt = 0;\n        /**\n         * TeamStats matchInfoTxt.\n         * @member {string} matchInfoTxt\n         * @memberof CPreMatchInfoData.TeamStats\n         * @instance\n         */\n        TeamStats.prototype.matchInfoTxt = \"\";\n        /**\n         * TeamStats matchInfoTeams.\n         * @member {Array.<string>} matchInfoTeams\n         * @memberof CPreMatchInfoData.TeamStats\n         * @instance\n         */\n        TeamStats.prototype.matchInfoTeams = $util.emptyArray;\n        /**\n         * Decodes a TeamStats message from the specified reader or buffer.\n         * @function decode\n         * @memberof CPreMatchInfoData.TeamStats\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CPreMatchInfoData.TeamStats} TeamStats\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        TeamStats.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CPreMatchInfoData.TeamStats();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.matchInfoIdxtxt = reader.int32();\n                        break;\n                    case 2:\n                        message.matchInfoTxt = reader.string();\n                        break;\n                    case 3:\n                        if (!(message.matchInfoTeams && message.matchInfoTeams.length))\n                            message.matchInfoTeams = [];\n                        message.matchInfoTeams.push(reader.string());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return TeamStats;\n    })();\n    return CPreMatchInfoData;\n})());\nexports.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve = ($root.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.\n     * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n     * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n     * @property {Array.<number>|null} [accountIds] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve accountIds\n     * @property {number|null} [gameType] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve gameType\n     * @property {number|Long|null} [matchId] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve matchId\n     * @property {number|null} [serverVersion] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve serverVersion\n     * @property {Array.<IPlayerRankingInfo>|null} [rankings] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve rankings\n     * @property {number|Long|null} [encryptionKey] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve encryptionKey\n     * @property {number|Long|null} [encryptionKeyPub] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve encryptionKeyPub\n     * @property {Array.<number>|null} [partyIds] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve partyIds\n     * @property {Array.<IIpAddressMask>|null} [whitelist] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve whitelist\n     * @property {number|Long|null} [tvMasterSteamid] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tvMasterSteamid\n     * @property {ITournamentEvent|null} [tournamentEvent] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tournamentEvent\n     * @property {Array.<ITournamentTeam>|null} [tournamentTeams] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tournamentTeams\n     * @property {Array.<number>|null} [tournamentCastersAccountIds] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tournamentCastersAccountIds\n     * @property {number|Long|null} [tvRelaySteamid] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tvRelaySteamid\n     * @property {ICPreMatchInfoData|null} [preMatchData] CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve preMatchData\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.\n     * @exports CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.\n     * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve(properties) {\n        this.accountIds = [];\n        this.rankings = [];\n        this.partyIds = [];\n        this.whitelist = [];\n        this.tournamentTeams = [];\n        this.tournamentCastersAccountIds = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve accountIds.\n     * @member {Array.<number>} accountIds\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.accountIds =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve gameType.\n     * @member {number} gameType\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.gameType = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve matchId.\n     * @member {number|Long} matchId\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.matchId = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve serverVersion.\n     * @member {number} serverVersion\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.serverVersion = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve rankings.\n     * @member {Array.<IPlayerRankingInfo>} rankings\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.rankings =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve encryptionKey.\n     * @member {number|Long} encryptionKey\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.encryptionKey = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve encryptionKeyPub.\n     * @member {number|Long} encryptionKeyPub\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.encryptionKeyPub = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve partyIds.\n     * @member {Array.<number>} partyIds\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.partyIds =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve whitelist.\n     * @member {Array.<IIpAddressMask>} whitelist\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.whitelist =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tvMasterSteamid.\n     * @member {number|Long} tvMasterSteamid\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.tvMasterSteamid = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tournamentEvent.\n     * @member {ITournamentEvent|null|undefined} tournamentEvent\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.tournamentEvent = null;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tournamentTeams.\n     * @member {Array.<ITournamentTeam>} tournamentTeams\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.tournamentTeams =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tournamentCastersAccountIds.\n     * @member {Array.<number>} tournamentCastersAccountIds\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.tournamentCastersAccountIds =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve tvRelaySteamid.\n     * @member {number|Long} tvRelaySteamid\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.tvRelaySteamid = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve preMatchData.\n     * @member {ICPreMatchInfoData|null|undefined} preMatchData\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.prototype.preMatchData = null;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve} CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.accountIds && message.accountIds.length))\n                        message.accountIds = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.accountIds.push(reader.uint32());\n                    }\n                    else\n                        message.accountIds.push(reader.uint32());\n                    break;\n                case 2:\n                    message.gameType = reader.uint32();\n                    break;\n                case 3:\n                    message.matchId = reader.uint64();\n                    break;\n                case 4:\n                    message.serverVersion = reader.uint32();\n                    break;\n                case 5:\n                    if (!(message.rankings && message.rankings.length))\n                        message.rankings = [];\n                    message.rankings.push($root.PlayerRankingInfo.decode(reader, reader.uint32()));\n                    break;\n                case 6:\n                    message.encryptionKey = reader.uint64();\n                    break;\n                case 7:\n                    message.encryptionKeyPub = reader.uint64();\n                    break;\n                case 8:\n                    if (!(message.partyIds && message.partyIds.length))\n                        message.partyIds = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.partyIds.push(reader.uint32());\n                    }\n                    else\n                        message.partyIds.push(reader.uint32());\n                    break;\n                case 9:\n                    if (!(message.whitelist && message.whitelist.length))\n                        message.whitelist = [];\n                    message.whitelist.push($root.IpAddressMask.decode(reader, reader.uint32()));\n                    break;\n                case 10:\n                    message.tvMasterSteamid = reader.uint64();\n                    break;\n                case 11:\n                    message.tournamentEvent = $root.TournamentEvent.decode(reader, reader.uint32());\n                    break;\n                case 12:\n                    if (!(message.tournamentTeams && message.tournamentTeams.length))\n                        message.tournamentTeams = [];\n                    message.tournamentTeams.push($root.TournamentTeam.decode(reader, reader.uint32()));\n                    break;\n                case 13:\n                    if (!(message.tournamentCastersAccountIds &&\n                        message.tournamentCastersAccountIds.length))\n                        message.tournamentCastersAccountIds = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.tournamentCastersAccountIds.push(reader.uint32());\n                    }\n                    else\n                        message.tournamentCastersAccountIds.push(reader.uint32());\n                    break;\n                case 14:\n                    message.tvRelaySteamid = reader.uint64();\n                    break;\n                case 15:\n                    message.preMatchData = $root.CPreMatchInfoData.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve;\n})());\nexports.CMsgGCCStrike15_v2_MatchmakingServerReservationResponse = ($root.CMsgGCCStrike15_v2_MatchmakingServerReservationResponse = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.\n     * @exports ICMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n     * @interface ICMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n     * @property {number|Long|null} [reservationid] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse reservationid\n     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null} [reservation] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse reservation\n     * @property {string|null} [map] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse map\n     * @property {number|Long|null} [gcReservationSent] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse gcReservationSent\n     * @property {number|null} [serverVersion] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse serverVersion\n     * @property {IServerHltvInfo|null} [tvInfo] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse tvInfo\n     * @property {Array.<number>|null} [rewardPlayerAccounts] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardPlayerAccounts\n     * @property {Array.<number>|null} [idlePlayerAccounts] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse idlePlayerAccounts\n     * @property {number|null} [rewardItemAttrDefIdx] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardItemAttrDefIdx\n     * @property {number|null} [rewardItemAttrValue] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardItemAttrValue\n     * @property {number|null} [rewardItemAttrRewardIdx] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardItemAttrRewardIdx\n     * @property {number|null} [rewardDropList] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardDropList\n     * @property {string|null} [tournamentTag] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse tournamentTag\n     * @property {number|null} [steamdatagramPort] CMsgGCCStrike15_v2_MatchmakingServerReservationResponse steamdatagramPort\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.\n     * @exports CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.\n     * @implements ICMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_MatchmakingServerReservationResponse=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_MatchmakingServerReservationResponse(properties) {\n        this.rewardPlayerAccounts = [];\n        this.idlePlayerAccounts = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse reservationid.\n     * @member {number|Long} reservationid\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.reservationid = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse reservation.\n     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null|undefined} reservation\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.reservation = null;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse map.\n     * @member {string} map\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.map = \"\";\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse gcReservationSent.\n     * @member {number|Long} gcReservationSent\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.gcReservationSent = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse serverVersion.\n     * @member {number} serverVersion\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.serverVersion = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse tvInfo.\n     * @member {IServerHltvInfo|null|undefined} tvInfo\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.tvInfo = null;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardPlayerAccounts.\n     * @member {Array.<number>} rewardPlayerAccounts\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.rewardPlayerAccounts =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse idlePlayerAccounts.\n     * @member {Array.<number>} idlePlayerAccounts\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.idlePlayerAccounts =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardItemAttrDefIdx.\n     * @member {number} rewardItemAttrDefIdx\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.rewardItemAttrDefIdx = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardItemAttrValue.\n     * @member {number} rewardItemAttrValue\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.rewardItemAttrValue = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardItemAttrRewardIdx.\n     * @member {number} rewardItemAttrRewardIdx\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.rewardItemAttrRewardIdx = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse rewardDropList.\n     * @member {number} rewardDropList\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.rewardDropList = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse tournamentTag.\n     * @member {string} tournamentTag\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.tournamentTag =\n        \"\";\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerReservationResponse steamdatagramPort.\n     * @member {number} steamdatagramPort\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.prototype.steamdatagramPort = 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_MatchmakingServerReservationResponse message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchmakingServerReservationResponse} CMsgGCCStrike15_v2_MatchmakingServerReservationResponse\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingServerReservationResponse();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.reservationid = reader.uint64();\n                    break;\n                case 2:\n                    message.reservation = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.map = reader.string();\n                    break;\n                case 4:\n                    message.gcReservationSent = reader.uint64();\n                    break;\n                case 5:\n                    message.serverVersion = reader.uint32();\n                    break;\n                case 6:\n                    message.tvInfo = $root.ServerHltvInfo.decode(reader, reader.uint32());\n                    break;\n                case 7:\n                    if (!(message.rewardPlayerAccounts &&\n                        message.rewardPlayerAccounts.length))\n                        message.rewardPlayerAccounts = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.rewardPlayerAccounts.push(reader.uint32());\n                    }\n                    else\n                        message.rewardPlayerAccounts.push(reader.uint32());\n                    break;\n                case 8:\n                    if (!(message.idlePlayerAccounts && message.idlePlayerAccounts.length))\n                        message.idlePlayerAccounts = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.idlePlayerAccounts.push(reader.uint32());\n                    }\n                    else\n                        message.idlePlayerAccounts.push(reader.uint32());\n                    break;\n                case 9:\n                    message.rewardItemAttrDefIdx = reader.uint32();\n                    break;\n                case 10:\n                    message.rewardItemAttrValue = reader.uint32();\n                    break;\n                case 11:\n                    message.rewardItemAttrRewardIdx = reader.uint32();\n                    break;\n                case 12:\n                    message.rewardDropList = reader.uint32();\n                    break;\n                case 13:\n                    message.tournamentTag = reader.string();\n                    break;\n                case 14:\n                    message.steamdatagramPort = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_MatchmakingServerReservationResponse;\n})());\nexports.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve = ($root.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.\n     * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\n     * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\n     * @property {number|Long|null} [serverid] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve serverid\n     * @property {string|null} [serverAddress] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve serverAddress\n     * @property {number|null} [legacyServerip] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve legacyServerip\n     * @property {number|null} [legacyServerport] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve legacyServerport\n     * @property {number|Long|null} [reservationid] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve reservationid\n     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null} [reservation] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve reservation\n     * @property {string|null} [map] CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve map\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.\n     * @exports CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\n     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.\n     * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve serverid.\n     * @member {number|Long} serverid\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.serverid = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve serverAddress.\n     * @member {string} serverAddress\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.serverAddress = \"\";\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve legacyServerip.\n     * @member {number} legacyServerip\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.legacyServerip = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve legacyServerport.\n     * @member {number} legacyServerport\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.legacyServerport = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve reservationid.\n     * @member {number|Long} reservationid\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.reservationid = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve reservation.\n     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null|undefined} reservation\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.reservation = null;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve map.\n     * @member {string} map\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.prototype.map = \"\";\n    /**\n     * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve} CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.serverid = reader.uint64();\n                    break;\n                case 7:\n                    message.serverAddress = reader.string();\n                    break;\n                case 2:\n                    message.legacyServerip = reader.uint32();\n                    break;\n                case 3:\n                    message.legacyServerport = reader.uint32();\n                    break;\n                case 4:\n                    message.reservationid = reader.uint64();\n                    break;\n                case 5:\n                    message.reservation = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.decode(reader, reader.uint32());\n                    break;\n                case 6:\n                    message.map = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve;\n})());\nexports.CMsgGCCStrike15_v2_MatchmakingServerRoundStats = ($root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_MatchmakingServerRoundStats.\n     * @exports ICMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @interface ICMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @property {number|Long|null} [reservationid] CMsgGCCStrike15_v2_MatchmakingServerRoundStats reservationid\n     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null} [reservation] CMsgGCCStrike15_v2_MatchmakingServerRoundStats reservation\n     * @property {string|null} [map] CMsgGCCStrike15_v2_MatchmakingServerRoundStats map\n     * @property {number|null} [round] CMsgGCCStrike15_v2_MatchmakingServerRoundStats round\n     * @property {Array.<number>|null} [kills] CMsgGCCStrike15_v2_MatchmakingServerRoundStats kills\n     * @property {Array.<number>|null} [assists] CMsgGCCStrike15_v2_MatchmakingServerRoundStats assists\n     * @property {Array.<number>|null} [deaths] CMsgGCCStrike15_v2_MatchmakingServerRoundStats deaths\n     * @property {Array.<number>|null} [scores] CMsgGCCStrike15_v2_MatchmakingServerRoundStats scores\n     * @property {Array.<number>|null} [pings] CMsgGCCStrike15_v2_MatchmakingServerRoundStats pings\n     * @property {number|null} [roundResult] CMsgGCCStrike15_v2_MatchmakingServerRoundStats roundResult\n     * @property {number|null} [matchResult] CMsgGCCStrike15_v2_MatchmakingServerRoundStats matchResult\n     * @property {Array.<number>|null} [teamScores] CMsgGCCStrike15_v2_MatchmakingServerRoundStats teamScores\n     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm|null} [confirm] CMsgGCCStrike15_v2_MatchmakingServerRoundStats confirm\n     * @property {number|null} [reservationStage] CMsgGCCStrike15_v2_MatchmakingServerRoundStats reservationStage\n     * @property {number|null} [matchDuration] CMsgGCCStrike15_v2_MatchmakingServerRoundStats matchDuration\n     * @property {Array.<number>|null} [enemyKills] CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemyKills\n     * @property {Array.<number>|null} [enemyHeadshots] CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemyHeadshots\n     * @property {Array.<number>|null} [enemy_3ks] CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemy_3ks\n     * @property {Array.<number>|null} [enemy_4ks] CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemy_4ks\n     * @property {Array.<number>|null} [enemy_5ks] CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemy_5ks\n     * @property {Array.<number>|null} [mvps] CMsgGCCStrike15_v2_MatchmakingServerRoundStats mvps\n     * @property {number|null} [spectatorsCount] CMsgGCCStrike15_v2_MatchmakingServerRoundStats spectatorsCount\n     * @property {number|null} [spectatorsCountTv] CMsgGCCStrike15_v2_MatchmakingServerRoundStats spectatorsCountTv\n     * @property {number|null} [spectatorsCountLnk] CMsgGCCStrike15_v2_MatchmakingServerRoundStats spectatorsCountLnk\n     * @property {Array.<number>|null} [enemyKillsAgg] CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemyKillsAgg\n     * @property {CMsgGCCStrike15_v2_MatchmakingServerRoundStats.IDropInfo|null} [dropInfo] CMsgGCCStrike15_v2_MatchmakingServerRoundStats dropInfo\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_MatchmakingServerRoundStats.\n     * @exports CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingServerRoundStats.\n     * @implements ICMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_MatchmakingServerRoundStats=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_MatchmakingServerRoundStats(properties) {\n        this.kills = [];\n        this.assists = [];\n        this.deaths = [];\n        this.scores = [];\n        this.pings = [];\n        this.teamScores = [];\n        this.enemyKills = [];\n        this.enemyHeadshots = [];\n        this.enemy_3ks = [];\n        this.enemy_4ks = [];\n        this.enemy_5ks = [];\n        this.mvps = [];\n        this.enemyKillsAgg = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats reservationid.\n     * @member {number|Long} reservationid\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.reservationid = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats reservation.\n     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null|undefined} reservation\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.reservation = null;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats map.\n     * @member {string} map\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.map = \"\";\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats round.\n     * @member {number} round\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.round = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats kills.\n     * @member {Array.<number>} kills\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.kills =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats assists.\n     * @member {Array.<number>} assists\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.assists =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats deaths.\n     * @member {Array.<number>} deaths\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.deaths =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats scores.\n     * @member {Array.<number>} scores\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.scores =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats pings.\n     * @member {Array.<number>} pings\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.pings =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats roundResult.\n     * @member {number} roundResult\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.roundResult = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats matchResult.\n     * @member {number} matchResult\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.matchResult = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats teamScores.\n     * @member {Array.<number>} teamScores\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.teamScores =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats confirm.\n     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm|null|undefined} confirm\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.confirm = null;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats reservationStage.\n     * @member {number} reservationStage\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.reservationStage = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats matchDuration.\n     * @member {number} matchDuration\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.matchDuration = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemyKills.\n     * @member {Array.<number>} enemyKills\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.enemyKills =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemyHeadshots.\n     * @member {Array.<number>} enemyHeadshots\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.enemyHeadshots =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemy_3ks.\n     * @member {Array.<number>} enemy_3ks\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.enemy_3ks =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemy_4ks.\n     * @member {Array.<number>} enemy_4ks\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.enemy_4ks =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemy_5ks.\n     * @member {Array.<number>} enemy_5ks\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.enemy_5ks =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats mvps.\n     * @member {Array.<number>} mvps\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.mvps =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats spectatorsCount.\n     * @member {number} spectatorsCount\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.spectatorsCount = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats spectatorsCountTv.\n     * @member {number} spectatorsCountTv\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.spectatorsCountTv = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats spectatorsCountLnk.\n     * @member {number} spectatorsCountLnk\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.spectatorsCountLnk = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats enemyKillsAgg.\n     * @member {Array.<number>} enemyKillsAgg\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.enemyKillsAgg =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerRoundStats dropInfo.\n     * @member {CMsgGCCStrike15_v2_MatchmakingServerRoundStats.IDropInfo|null|undefined} dropInfo\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.prototype.dropInfo = null;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_MatchmakingServerRoundStats message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchmakingServerRoundStats} CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.reservationid = reader.uint64();\n                    break;\n                case 2:\n                    message.reservation = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.map = reader.string();\n                    break;\n                case 4:\n                    message.round = reader.int32();\n                    break;\n                case 5:\n                    if (!(message.kills && message.kills.length))\n                        message.kills = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.kills.push(reader.int32());\n                    }\n                    else\n                        message.kills.push(reader.int32());\n                    break;\n                case 6:\n                    if (!(message.assists && message.assists.length))\n                        message.assists = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.assists.push(reader.int32());\n                    }\n                    else\n                        message.assists.push(reader.int32());\n                    break;\n                case 7:\n                    if (!(message.deaths && message.deaths.length))\n                        message.deaths = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.deaths.push(reader.int32());\n                    }\n                    else\n                        message.deaths.push(reader.int32());\n                    break;\n                case 8:\n                    if (!(message.scores && message.scores.length))\n                        message.scores = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.scores.push(reader.int32());\n                    }\n                    else\n                        message.scores.push(reader.int32());\n                    break;\n                case 9:\n                    if (!(message.pings && message.pings.length))\n                        message.pings = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.pings.push(reader.int32());\n                    }\n                    else\n                        message.pings.push(reader.int32());\n                    break;\n                case 10:\n                    message.roundResult = reader.int32();\n                    break;\n                case 11:\n                    message.matchResult = reader.int32();\n                    break;\n                case 12:\n                    if (!(message.teamScores && message.teamScores.length))\n                        message.teamScores = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.teamScores.push(reader.int32());\n                    }\n                    else\n                        message.teamScores.push(reader.int32());\n                    break;\n                case 13:\n                    message.confirm = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.decode(reader, reader.uint32());\n                    break;\n                case 14:\n                    message.reservationStage = reader.int32();\n                    break;\n                case 15:\n                    message.matchDuration = reader.int32();\n                    break;\n                case 16:\n                    if (!(message.enemyKills && message.enemyKills.length))\n                        message.enemyKills = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.enemyKills.push(reader.int32());\n                    }\n                    else\n                        message.enemyKills.push(reader.int32());\n                    break;\n                case 17:\n                    if (!(message.enemyHeadshots && message.enemyHeadshots.length))\n                        message.enemyHeadshots = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.enemyHeadshots.push(reader.int32());\n                    }\n                    else\n                        message.enemyHeadshots.push(reader.int32());\n                    break;\n                case 18:\n                    if (!(message.enemy_3ks && message.enemy_3ks.length))\n                        message.enemy_3ks = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.enemy_3ks.push(reader.int32());\n                    }\n                    else\n                        message.enemy_3ks.push(reader.int32());\n                    break;\n                case 19:\n                    if (!(message.enemy_4ks && message.enemy_4ks.length))\n                        message.enemy_4ks = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.enemy_4ks.push(reader.int32());\n                    }\n                    else\n                        message.enemy_4ks.push(reader.int32());\n                    break;\n                case 20:\n                    if (!(message.enemy_5ks && message.enemy_5ks.length))\n                        message.enemy_5ks = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.enemy_5ks.push(reader.int32());\n                    }\n                    else\n                        message.enemy_5ks.push(reader.int32());\n                    break;\n                case 21:\n                    if (!(message.mvps && message.mvps.length))\n                        message.mvps = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.mvps.push(reader.int32());\n                    }\n                    else\n                        message.mvps.push(reader.int32());\n                    break;\n                case 22:\n                    message.spectatorsCount = reader.uint32();\n                    break;\n                case 23:\n                    message.spectatorsCountTv = reader.uint32();\n                    break;\n                case 24:\n                    message.spectatorsCountLnk = reader.uint32();\n                    break;\n                case 25:\n                    if (!(message.enemyKillsAgg && message.enemyKillsAgg.length))\n                        message.enemyKillsAgg = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.enemyKillsAgg.push(reader.int32());\n                    }\n                    else\n                        message.enemyKillsAgg.push(reader.int32());\n                    break;\n                case 26:\n                    message.dropInfo = $root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo = (function () {\n        /**\n         * Properties of a DropInfo.\n         * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n         * @interface IDropInfo\n         * @property {number|null} [accountMvp] DropInfo accountMvp\n         */\n        /**\n         * Constructs a new DropInfo.\n         * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats\n         * @classdesc Represents a DropInfo.\n         * @implements IDropInfo\n         * @constructor\n         * @param {CMsgGCCStrike15_v2_MatchmakingServerRoundStats.IDropInfo=} [properties] Properties to set\n         */\n        function DropInfo(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * DropInfo accountMvp.\n         * @member {number} accountMvp\n         * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo\n         * @instance\n         */\n        DropInfo.prototype.accountMvp = 0;\n        /**\n         * Decodes a DropInfo message from the specified reader or buffer.\n         * @function decode\n         * @memberof CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo} DropInfo\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        DropInfo.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats.DropInfo();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.accountMvp = reader.uint32();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return DropInfo;\n    })();\n    return CMsgGCCStrike15_v2_MatchmakingServerRoundStats;\n})());\nexports.CMsgGCCStrike15_v2_MatchmakingServerMatchEnd = ($root.CMsgGCCStrike15_v2_MatchmakingServerMatchEnd = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.\n     * @exports ICMsgGCCStrike15_v2_MatchmakingServerMatchEnd\n     * @interface ICMsgGCCStrike15_v2_MatchmakingServerMatchEnd\n     * @property {ICMsgGCCStrike15_v2_MatchmakingServerRoundStats|null} [stats] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd stats\n     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm|null} [confirm] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd confirm\n     * @property {number|Long|null} [rematch] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd rematch\n     * @property {number|null} [replayToken] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd replayToken\n     * @property {number|null} [replayClusterId] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd replayClusterId\n     * @property {boolean|null} [abortedMatch] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd abortedMatch\n     * @property {ICMsgGC_ServerQuestUpdateData|null} [matchEndQuestData] CMsgGCCStrike15_v2_MatchmakingServerMatchEnd matchEndQuestData\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.\n     * @exports CMsgGCCStrike15_v2_MatchmakingServerMatchEnd\n     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.\n     * @implements ICMsgGCCStrike15_v2_MatchmakingServerMatchEnd\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_MatchmakingServerMatchEnd=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_MatchmakingServerMatchEnd(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd stats.\n     * @member {ICMsgGCCStrike15_v2_MatchmakingServerRoundStats|null|undefined} stats\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.stats = null;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd confirm.\n     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm|null|undefined} confirm\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.confirm = null;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd rematch.\n     * @member {number|Long} rematch\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.rematch = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd replayToken.\n     * @member {number} replayToken\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.replayToken = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd replayClusterId.\n     * @member {number} replayClusterId\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.replayClusterId = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd abortedMatch.\n     * @member {boolean} abortedMatch\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.abortedMatch = false;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServerMatchEnd matchEndQuestData.\n     * @member {ICMsgGC_ServerQuestUpdateData|null|undefined} matchEndQuestData\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.prototype.matchEndQuestData = null;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_MatchmakingServerMatchEnd message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServerMatchEnd\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchmakingServerMatchEnd} CMsgGCCStrike15_v2_MatchmakingServerMatchEnd\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_MatchmakingServerMatchEnd.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingServerMatchEnd();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.stats = $root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.confirm = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerConfirm.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.rematch = reader.uint64();\n                    break;\n                case 5:\n                    message.replayToken = reader.uint32();\n                    break;\n                case 6:\n                    message.replayClusterId = reader.uint32();\n                    break;\n                case 7:\n                    message.abortedMatch = reader.bool();\n                    break;\n                case 8:\n                    message.matchEndQuestData = $root.CMsgGC_ServerQuestUpdateData.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_MatchmakingServerMatchEnd;\n})());\nexports.CMsgGCCStrike15_v2_MatchmakingClient2GCHello = ($root.CMsgGCCStrike15_v2_MatchmakingClient2GCHello = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_MatchmakingClient2GCHello.\n     * @exports ICMsgGCCStrike15_v2_MatchmakingClient2GCHello\n     * @interface ICMsgGCCStrike15_v2_MatchmakingClient2GCHello\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_MatchmakingClient2GCHello.\n     * @exports CMsgGCCStrike15_v2_MatchmakingClient2GCHello\n     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingClient2GCHello.\n     * @implements ICMsgGCCStrike15_v2_MatchmakingClient2GCHello\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_MatchmakingClient2GCHello=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_MatchmakingClient2GCHello(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Decodes a CMsgGCCStrike15_v2_MatchmakingClient2GCHello message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchmakingClient2GCHello\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchmakingClient2GCHello} CMsgGCCStrike15_v2_MatchmakingClient2GCHello\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_MatchmakingClient2GCHello.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingClient2GCHello();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_MatchmakingClient2GCHello;\n})());\nexports.CMsgGCCStrike15_v2_MatchmakingGC2ClientHello = ($root.CMsgGCCStrike15_v2_MatchmakingGC2ClientHello = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.\n     * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n     * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n     * @property {number|null} [accountId] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello accountId\n     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null} [ongoingmatch] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello ongoingmatch\n     * @property {IGlobalStatistics|null} [globalStats] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello globalStats\n     * @property {number|null} [penaltySeconds] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello penaltySeconds\n     * @property {number|null} [penaltyReason] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello penaltyReason\n     * @property {number|null} [vacBanned] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello vacBanned\n     * @property {IPlayerRankingInfo|null} [ranking] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello ranking\n     * @property {IPlayerCommendationInfo|null} [commendation] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello commendation\n     * @property {IPlayerMedalsInfo|null} [medals] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello medals\n     * @property {ITournamentEvent|null} [myCurrentEvent] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentEvent\n     * @property {Array.<ITournamentTeam>|null} [myCurrentEventTeams] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentEventTeams\n     * @property {ITournamentTeam|null} [myCurrentTeam] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentTeam\n     * @property {Array.<ITournamentEvent>|null} [myCurrentEventStages] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentEventStages\n     * @property {number|null} [surveyVote] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello surveyVote\n     * @property {IAccountActivity|null} [activity] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello activity\n     * @property {number|null} [playerLevel] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello playerLevel\n     * @property {number|null} [playerCurXp] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello playerCurXp\n     * @property {number|null} [playerXpBonusFlags] CMsgGCCStrike15_v2_MatchmakingGC2ClientHello playerXpBonusFlags\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.\n     * @exports CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.\n     * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ClientHello=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_MatchmakingGC2ClientHello(properties) {\n        this.myCurrentEventTeams = [];\n        this.myCurrentEventStages = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello accountId.\n     * @member {number} accountId\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.accountId = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello ongoingmatch.\n     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null|undefined} ongoingmatch\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.ongoingmatch = null;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello globalStats.\n     * @member {IGlobalStatistics|null|undefined} globalStats\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.globalStats = null;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello penaltySeconds.\n     * @member {number} penaltySeconds\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.penaltySeconds = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello penaltyReason.\n     * @member {number} penaltyReason\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.penaltyReason = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello vacBanned.\n     * @member {number} vacBanned\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.vacBanned = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello ranking.\n     * @member {IPlayerRankingInfo|null|undefined} ranking\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.ranking = null;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello commendation.\n     * @member {IPlayerCommendationInfo|null|undefined} commendation\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.commendation = null;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello medals.\n     * @member {IPlayerMedalsInfo|null|undefined} medals\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.medals = null;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentEvent.\n     * @member {ITournamentEvent|null|undefined} myCurrentEvent\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.myCurrentEvent = null;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentEventTeams.\n     * @member {Array.<ITournamentTeam>} myCurrentEventTeams\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.myCurrentEventTeams =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentTeam.\n     * @member {ITournamentTeam|null|undefined} myCurrentTeam\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.myCurrentTeam = null;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello myCurrentEventStages.\n     * @member {Array.<ITournamentEvent>} myCurrentEventStages\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.myCurrentEventStages =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello surveyVote.\n     * @member {number} surveyVote\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.surveyVote = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello activity.\n     * @member {IAccountActivity|null|undefined} activity\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.activity = null;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello playerLevel.\n     * @member {number} playerLevel\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.playerLevel = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello playerCurXp.\n     * @member {number} playerCurXp\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.playerCurXp = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientHello playerXpBonusFlags.\n     * @member {number} playerXpBonusFlags\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.prototype.playerXpBonusFlags = 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ClientHello message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ClientHello} CMsgGCCStrike15_v2_MatchmakingGC2ClientHello\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientHello();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.accountId = reader.uint32();\n                    break;\n                case 2:\n                    message.ongoingmatch = $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.globalStats = $root.GlobalStatistics.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.penaltySeconds = reader.uint32();\n                    break;\n                case 5:\n                    message.penaltyReason = reader.uint32();\n                    break;\n                case 6:\n                    message.vacBanned = reader.int32();\n                    break;\n                case 7:\n                    message.ranking = $root.PlayerRankingInfo.decode(reader, reader.uint32());\n                    break;\n                case 8:\n                    message.commendation = $root.PlayerCommendationInfo.decode(reader, reader.uint32());\n                    break;\n                case 9:\n                    message.medals = $root.PlayerMedalsInfo.decode(reader, reader.uint32());\n                    break;\n                case 10:\n                    message.myCurrentEvent = $root.TournamentEvent.decode(reader, reader.uint32());\n                    break;\n                case 11:\n                    if (!(message.myCurrentEventTeams && message.myCurrentEventTeams.length))\n                        message.myCurrentEventTeams = [];\n                    message.myCurrentEventTeams.push($root.TournamentTeam.decode(reader, reader.uint32()));\n                    break;\n                case 12:\n                    message.myCurrentTeam = $root.TournamentTeam.decode(reader, reader.uint32());\n                    break;\n                case 13:\n                    if (!(message.myCurrentEventStages &&\n                        message.myCurrentEventStages.length))\n                        message.myCurrentEventStages = [];\n                    message.myCurrentEventStages.push($root.TournamentEvent.decode(reader, reader.uint32()));\n                    break;\n                case 14:\n                    message.surveyVote = reader.uint32();\n                    break;\n                case 15:\n                    message.activity = $root.AccountActivity.decode(reader, reader.uint32());\n                    break;\n                case 17:\n                    message.playerLevel = reader.int32();\n                    break;\n                case 18:\n                    message.playerCurXp = reader.int32();\n                    break;\n                case 19:\n                    message.playerXpBonusFlags = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_MatchmakingGC2ClientHello;\n})());\nexports.CMsgGCCStrike15_v2_AccountPrivacySettings = ($root.CMsgGCCStrike15_v2_AccountPrivacySettings = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_AccountPrivacySettings.\n     * @exports ICMsgGCCStrike15_v2_AccountPrivacySettings\n     * @interface ICMsgGCCStrike15_v2_AccountPrivacySettings\n     * @property {Array.<CMsgGCCStrike15_v2_AccountPrivacySettings.ISetting>|null} [settings] CMsgGCCStrike15_v2_AccountPrivacySettings settings\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_AccountPrivacySettings.\n     * @exports CMsgGCCStrike15_v2_AccountPrivacySettings\n     * @classdesc Represents a CMsgGCCStrike15_v2_AccountPrivacySettings.\n     * @implements ICMsgGCCStrike15_v2_AccountPrivacySettings\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_AccountPrivacySettings=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_AccountPrivacySettings(properties) {\n        this.settings = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_AccountPrivacySettings settings.\n     * @member {Array.<CMsgGCCStrike15_v2_AccountPrivacySettings.ISetting>} settings\n     * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings\n     * @instance\n     */\n    CMsgGCCStrike15_v2_AccountPrivacySettings.prototype.settings =\n        $util.emptyArray;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_AccountPrivacySettings message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_AccountPrivacySettings} CMsgGCCStrike15_v2_AccountPrivacySettings\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_AccountPrivacySettings.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_AccountPrivacySettings();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.settings && message.settings.length))\n                        message.settings = [];\n                    message.settings.push($root.CMsgGCCStrike15_v2_AccountPrivacySettings.Setting.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CMsgGCCStrike15_v2_AccountPrivacySettings.Setting = (function () {\n        /**\n         * Properties of a Setting.\n         * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings\n         * @interface ISetting\n         * @property {number|null} [settingType] Setting settingType\n         * @property {number|null} [settingValue] Setting settingValue\n         */\n        /**\n         * Constructs a new Setting.\n         * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings\n         * @classdesc Represents a Setting.\n         * @implements ISetting\n         * @constructor\n         * @param {CMsgGCCStrike15_v2_AccountPrivacySettings.ISetting=} [properties] Properties to set\n         */\n        function Setting(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * Setting settingType.\n         * @member {number} settingType\n         * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings.Setting\n         * @instance\n         */\n        Setting.prototype.settingType = 0;\n        /**\n         * Setting settingValue.\n         * @member {number} settingValue\n         * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings.Setting\n         * @instance\n         */\n        Setting.prototype.settingValue = 0;\n        /**\n         * Decodes a Setting message from the specified reader or buffer.\n         * @function decode\n         * @memberof CMsgGCCStrike15_v2_AccountPrivacySettings.Setting\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CMsgGCCStrike15_v2_AccountPrivacySettings.Setting} Setting\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Setting.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_AccountPrivacySettings.Setting();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.settingType = reader.uint32();\n                        break;\n                    case 2:\n                        message.settingValue = reader.uint32();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return Setting;\n    })();\n    return CMsgGCCStrike15_v2_AccountPrivacySettings;\n})());\nexports.CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon = ($root.CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.\n     * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon\n     * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon\n     * @property {number|null} [accountId] CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon accountId\n     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null} [abandonedMatch] CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon abandonedMatch\n     * @property {number|null} [penaltySeconds] CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon penaltySeconds\n     * @property {number|null} [penaltyReason] CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon penaltyReason\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.\n     * @exports CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon\n     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.\n     * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon accountId.\n     * @member {number} accountId\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.prototype.accountId = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon abandonedMatch.\n     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null|undefined} abandonedMatch\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.prototype.abandonedMatch = null;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon penaltySeconds.\n     * @member {number} penaltySeconds\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.prototype.penaltySeconds = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon penaltyReason.\n     * @member {number} penaltyReason\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.prototype.penaltyReason = 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon} CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.accountId = reader.uint32();\n                    break;\n                case 2:\n                    message.abandonedMatch = $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.penaltySeconds = reader.uint32();\n                    break;\n                case 4:\n                    message.penaltyReason = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_MatchmakingGC2ClientAbandon;\n})());\nexports.CMsgGCCStrike15_v2_MatchmakingServer2GCKick = ($root.CMsgGCCStrike15_v2_MatchmakingServer2GCKick = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_MatchmakingServer2GCKick.\n     * @exports ICMsgGCCStrike15_v2_MatchmakingServer2GCKick\n     * @interface ICMsgGCCStrike15_v2_MatchmakingServer2GCKick\n     * @property {number|null} [accountId] CMsgGCCStrike15_v2_MatchmakingServer2GCKick accountId\n     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null} [reservation] CMsgGCCStrike15_v2_MatchmakingServer2GCKick reservation\n     * @property {number|null} [reason] CMsgGCCStrike15_v2_MatchmakingServer2GCKick reason\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_MatchmakingServer2GCKick.\n     * @exports CMsgGCCStrike15_v2_MatchmakingServer2GCKick\n     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingServer2GCKick.\n     * @implements ICMsgGCCStrike15_v2_MatchmakingServer2GCKick\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_MatchmakingServer2GCKick=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_MatchmakingServer2GCKick(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServer2GCKick accountId.\n     * @member {number} accountId\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServer2GCKick\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServer2GCKick.prototype.accountId = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServer2GCKick reservation.\n     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ServerReserve|null|undefined} reservation\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServer2GCKick\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServer2GCKick.prototype.reservation = null;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingServer2GCKick reason.\n     * @member {number} reason\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServer2GCKick\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingServer2GCKick.prototype.reason = 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_MatchmakingServer2GCKick message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchmakingServer2GCKick\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchmakingServer2GCKick} CMsgGCCStrike15_v2_MatchmakingServer2GCKick\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_MatchmakingServer2GCKick.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingServer2GCKick();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.accountId = reader.uint32();\n                    break;\n                case 2:\n                    message.reservation = $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerReserve.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.reason = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_MatchmakingServer2GCKick;\n})());\nexports.CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate = ($root.CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.\n     * @exports ICMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate\n     * @interface ICMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate\n     * @property {Array.<IPlayerRankingInfo>|null} [rankings] CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate rankings\n     * @property {number|Long|null} [matchId] CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate matchId\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.\n     * @exports CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate\n     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.\n     * @implements ICMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate(properties) {\n        this.rankings = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate rankings.\n     * @member {Array.<IPlayerRankingInfo>} rankings\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.prototype.rankings =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate matchId.\n     * @member {number|Long} matchId\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.prototype.matchId = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate} CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.rankings && message.rankings.length))\n                        message.rankings = [];\n                    message.rankings.push($root.PlayerRankingInfo.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.matchId = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_MatchmakingGC2ServerRankUpdate;\n})());\nexports.CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate = ($root.CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate.\n     * @exports ICMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate\n     * @interface ICMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate\n     * @property {string|null} [mainPostUrl] CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate mainPostUrl\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate.\n     * @exports CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate\n     * @classdesc Represents a CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate.\n     * @implements ICMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate mainPostUrl.\n     * @member {string} mainPostUrl\n     * @memberof CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate.prototype.mainPostUrl =\n        \"\";\n    /**\n     * Decodes a CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate} CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.mainPostUrl = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_MatchmakingOperator2GCBlogUpdate;\n})());\nexports.CMsgGCCStrike15_v2_ServerNotificationForUserPenalty = ($root.CMsgGCCStrike15_v2_ServerNotificationForUserPenalty = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.\n     * @exports ICMsgGCCStrike15_v2_ServerNotificationForUserPenalty\n     * @interface ICMsgGCCStrike15_v2_ServerNotificationForUserPenalty\n     * @property {number|null} [accountId] CMsgGCCStrike15_v2_ServerNotificationForUserPenalty accountId\n     * @property {number|null} [reason] CMsgGCCStrike15_v2_ServerNotificationForUserPenalty reason\n     * @property {number|null} [seconds] CMsgGCCStrike15_v2_ServerNotificationForUserPenalty seconds\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.\n     * @exports CMsgGCCStrike15_v2_ServerNotificationForUserPenalty\n     * @classdesc Represents a CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.\n     * @implements ICMsgGCCStrike15_v2_ServerNotificationForUserPenalty\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_ServerNotificationForUserPenalty=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_ServerNotificationForUserPenalty(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_ServerNotificationForUserPenalty accountId.\n     * @member {number} accountId\n     * @memberof CMsgGCCStrike15_v2_ServerNotificationForUserPenalty\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.prototype.accountId = 0;\n    /**\n     * CMsgGCCStrike15_v2_ServerNotificationForUserPenalty reason.\n     * @member {number} reason\n     * @memberof CMsgGCCStrike15_v2_ServerNotificationForUserPenalty\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.prototype.reason = 0;\n    /**\n     * CMsgGCCStrike15_v2_ServerNotificationForUserPenalty seconds.\n     * @member {number} seconds\n     * @memberof CMsgGCCStrike15_v2_ServerNotificationForUserPenalty\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.prototype.seconds = 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_ServerNotificationForUserPenalty message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_ServerNotificationForUserPenalty\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_ServerNotificationForUserPenalty} CMsgGCCStrike15_v2_ServerNotificationForUserPenalty\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_ServerNotificationForUserPenalty.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ServerNotificationForUserPenalty();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.accountId = reader.uint32();\n                    break;\n                case 2:\n                    message.reason = reader.uint32();\n                    break;\n                case 3:\n                    message.seconds = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_ServerNotificationForUserPenalty;\n})());\nexports.CMsgGCCStrike15_v2_ClientReportPlayer = ($root.CMsgGCCStrike15_v2_ClientReportPlayer = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_ClientReportPlayer.\n     * @exports ICMsgGCCStrike15_v2_ClientReportPlayer\n     * @interface ICMsgGCCStrike15_v2_ClientReportPlayer\n     * @property {number|null} [accountId] CMsgGCCStrike15_v2_ClientReportPlayer accountId\n     * @property {number|null} [rptAimbot] CMsgGCCStrike15_v2_ClientReportPlayer rptAimbot\n     * @property {number|null} [rptWallhack] CMsgGCCStrike15_v2_ClientReportPlayer rptWallhack\n     * @property {number|null} [rptSpeedhack] CMsgGCCStrike15_v2_ClientReportPlayer rptSpeedhack\n     * @property {number|null} [rptTeamharm] CMsgGCCStrike15_v2_ClientReportPlayer rptTeamharm\n     * @property {number|null} [rptTextabuse] CMsgGCCStrike15_v2_ClientReportPlayer rptTextabuse\n     * @property {number|null} [rptVoiceabuse] CMsgGCCStrike15_v2_ClientReportPlayer rptVoiceabuse\n     * @property {number|Long|null} [matchId] CMsgGCCStrike15_v2_ClientReportPlayer matchId\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_ClientReportPlayer.\n     * @exports CMsgGCCStrike15_v2_ClientReportPlayer\n     * @classdesc Represents a CMsgGCCStrike15_v2_ClientReportPlayer.\n     * @implements ICMsgGCCStrike15_v2_ClientReportPlayer\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_ClientReportPlayer=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_ClientReportPlayer(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_ClientReportPlayer accountId.\n     * @member {number} accountId\n     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientReportPlayer.prototype.accountId = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientReportPlayer rptAimbot.\n     * @member {number} rptAimbot\n     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientReportPlayer.prototype.rptAimbot = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientReportPlayer rptWallhack.\n     * @member {number} rptWallhack\n     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientReportPlayer.prototype.rptWallhack = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientReportPlayer rptSpeedhack.\n     * @member {number} rptSpeedhack\n     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientReportPlayer.prototype.rptSpeedhack = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientReportPlayer rptTeamharm.\n     * @member {number} rptTeamharm\n     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientReportPlayer.prototype.rptTeamharm = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientReportPlayer rptTextabuse.\n     * @member {number} rptTextabuse\n     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientReportPlayer.prototype.rptTextabuse = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientReportPlayer rptVoiceabuse.\n     * @member {number} rptVoiceabuse\n     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientReportPlayer.prototype.rptVoiceabuse = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientReportPlayer matchId.\n     * @member {number|Long} matchId\n     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientReportPlayer.prototype.matchId = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_ClientReportPlayer message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_ClientReportPlayer\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_ClientReportPlayer} CMsgGCCStrike15_v2_ClientReportPlayer\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_ClientReportPlayer.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientReportPlayer();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.accountId = reader.uint32();\n                    break;\n                case 2:\n                    message.rptAimbot = reader.uint32();\n                    break;\n                case 3:\n                    message.rptWallhack = reader.uint32();\n                    break;\n                case 4:\n                    message.rptSpeedhack = reader.uint32();\n                    break;\n                case 5:\n                    message.rptTeamharm = reader.uint32();\n                    break;\n                case 6:\n                    message.rptTextabuse = reader.uint32();\n                    break;\n                case 7:\n                    message.rptVoiceabuse = reader.uint32();\n                    break;\n                case 8:\n                    message.matchId = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_ClientReportPlayer;\n})());\nexports.CMsgGCCStrike15_v2_ClientCommendPlayer = ($root.CMsgGCCStrike15_v2_ClientCommendPlayer = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_ClientCommendPlayer.\n     * @exports ICMsgGCCStrike15_v2_ClientCommendPlayer\n     * @interface ICMsgGCCStrike15_v2_ClientCommendPlayer\n     * @property {number|null} [accountId] CMsgGCCStrike15_v2_ClientCommendPlayer accountId\n     * @property {number|Long|null} [matchId] CMsgGCCStrike15_v2_ClientCommendPlayer matchId\n     * @property {IPlayerCommendationInfo|null} [commendation] CMsgGCCStrike15_v2_ClientCommendPlayer commendation\n     * @property {number|null} [tokens] CMsgGCCStrike15_v2_ClientCommendPlayer tokens\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_ClientCommendPlayer.\n     * @exports CMsgGCCStrike15_v2_ClientCommendPlayer\n     * @classdesc Represents a CMsgGCCStrike15_v2_ClientCommendPlayer.\n     * @implements ICMsgGCCStrike15_v2_ClientCommendPlayer\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_ClientCommendPlayer=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_ClientCommendPlayer(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_ClientCommendPlayer accountId.\n     * @member {number} accountId\n     * @memberof CMsgGCCStrike15_v2_ClientCommendPlayer\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientCommendPlayer.prototype.accountId = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientCommendPlayer matchId.\n     * @member {number|Long} matchId\n     * @memberof CMsgGCCStrike15_v2_ClientCommendPlayer\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientCommendPlayer.prototype.matchId = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientCommendPlayer commendation.\n     * @member {IPlayerCommendationInfo|null|undefined} commendation\n     * @memberof CMsgGCCStrike15_v2_ClientCommendPlayer\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientCommendPlayer.prototype.commendation = null;\n    /**\n     * CMsgGCCStrike15_v2_ClientCommendPlayer tokens.\n     * @member {number} tokens\n     * @memberof CMsgGCCStrike15_v2_ClientCommendPlayer\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientCommendPlayer.prototype.tokens = 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_ClientCommendPlayer message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_ClientCommendPlayer\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_ClientCommendPlayer} CMsgGCCStrike15_v2_ClientCommendPlayer\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_ClientCommendPlayer.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientCommendPlayer();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.accountId = reader.uint32();\n                    break;\n                case 8:\n                    message.matchId = reader.uint64();\n                    break;\n                case 9:\n                    message.commendation = $root.PlayerCommendationInfo.decode(reader, reader.uint32());\n                    break;\n                case 10:\n                    message.tokens = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_ClientCommendPlayer;\n})());\nexports.CMsgGCCStrike15_v2_ClientReportServer = ($root.CMsgGCCStrike15_v2_ClientReportServer = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_ClientReportServer.\n     * @exports ICMsgGCCStrike15_v2_ClientReportServer\n     * @interface ICMsgGCCStrike15_v2_ClientReportServer\n     * @property {number|null} [rptPoorperf] CMsgGCCStrike15_v2_ClientReportServer rptPoorperf\n     * @property {number|null} [rptAbusivemodels] CMsgGCCStrike15_v2_ClientReportServer rptAbusivemodels\n     * @property {number|null} [rptBadmotd] CMsgGCCStrike15_v2_ClientReportServer rptBadmotd\n     * @property {number|null} [rptListingabuse] CMsgGCCStrike15_v2_ClientReportServer rptListingabuse\n     * @property {number|null} [rptInventoryabuse] CMsgGCCStrike15_v2_ClientReportServer rptInventoryabuse\n     * @property {number|Long|null} [matchId] CMsgGCCStrike15_v2_ClientReportServer matchId\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_ClientReportServer.\n     * @exports CMsgGCCStrike15_v2_ClientReportServer\n     * @classdesc Represents a CMsgGCCStrike15_v2_ClientReportServer.\n     * @implements ICMsgGCCStrike15_v2_ClientReportServer\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_ClientReportServer=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_ClientReportServer(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_ClientReportServer rptPoorperf.\n     * @member {number} rptPoorperf\n     * @memberof CMsgGCCStrike15_v2_ClientReportServer\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientReportServer.prototype.rptPoorperf = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientReportServer rptAbusivemodels.\n     * @member {number} rptAbusivemodels\n     * @memberof CMsgGCCStrike15_v2_ClientReportServer\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientReportServer.prototype.rptAbusivemodels = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientReportServer rptBadmotd.\n     * @member {number} rptBadmotd\n     * @memberof CMsgGCCStrike15_v2_ClientReportServer\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientReportServer.prototype.rptBadmotd = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientReportServer rptListingabuse.\n     * @member {number} rptListingabuse\n     * @memberof CMsgGCCStrike15_v2_ClientReportServer\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientReportServer.prototype.rptListingabuse = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientReportServer rptInventoryabuse.\n     * @member {number} rptInventoryabuse\n     * @memberof CMsgGCCStrike15_v2_ClientReportServer\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientReportServer.prototype.rptInventoryabuse = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientReportServer matchId.\n     * @member {number|Long} matchId\n     * @memberof CMsgGCCStrike15_v2_ClientReportServer\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientReportServer.prototype.matchId = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_ClientReportServer message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_ClientReportServer\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_ClientReportServer} CMsgGCCStrike15_v2_ClientReportServer\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_ClientReportServer.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientReportServer();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.rptPoorperf = reader.uint32();\n                    break;\n                case 2:\n                    message.rptAbusivemodels = reader.uint32();\n                    break;\n                case 3:\n                    message.rptBadmotd = reader.uint32();\n                    break;\n                case 4:\n                    message.rptListingabuse = reader.uint32();\n                    break;\n                case 5:\n                    message.rptInventoryabuse = reader.uint32();\n                    break;\n                case 8:\n                    message.matchId = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_ClientReportServer;\n})());\nexports.CMsgGCCStrike15_v2_ClientReportResponse = ($root.CMsgGCCStrike15_v2_ClientReportResponse = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_ClientReportResponse.\n     * @exports ICMsgGCCStrike15_v2_ClientReportResponse\n     * @interface ICMsgGCCStrike15_v2_ClientReportResponse\n     * @property {number|Long|null} [confirmationId] CMsgGCCStrike15_v2_ClientReportResponse confirmationId\n     * @property {number|null} [accountId] CMsgGCCStrike15_v2_ClientReportResponse accountId\n     * @property {number|null} [serverIp] CMsgGCCStrike15_v2_ClientReportResponse serverIp\n     * @property {number|null} [responseType] CMsgGCCStrike15_v2_ClientReportResponse responseType\n     * @property {number|null} [responseResult] CMsgGCCStrike15_v2_ClientReportResponse responseResult\n     * @property {number|null} [tokens] CMsgGCCStrike15_v2_ClientReportResponse tokens\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_ClientReportResponse.\n     * @exports CMsgGCCStrike15_v2_ClientReportResponse\n     * @classdesc Represents a CMsgGCCStrike15_v2_ClientReportResponse.\n     * @implements ICMsgGCCStrike15_v2_ClientReportResponse\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_ClientReportResponse=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_ClientReportResponse(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_ClientReportResponse confirmationId.\n     * @member {number|Long} confirmationId\n     * @memberof CMsgGCCStrike15_v2_ClientReportResponse\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientReportResponse.prototype.confirmationId = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientReportResponse accountId.\n     * @member {number} accountId\n     * @memberof CMsgGCCStrike15_v2_ClientReportResponse\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientReportResponse.prototype.accountId = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientReportResponse serverIp.\n     * @member {number} serverIp\n     * @memberof CMsgGCCStrike15_v2_ClientReportResponse\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientReportResponse.prototype.serverIp = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientReportResponse responseType.\n     * @member {number} responseType\n     * @memberof CMsgGCCStrike15_v2_ClientReportResponse\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientReportResponse.prototype.responseType = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientReportResponse responseResult.\n     * @member {number} responseResult\n     * @memberof CMsgGCCStrike15_v2_ClientReportResponse\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientReportResponse.prototype.responseResult = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientReportResponse tokens.\n     * @member {number} tokens\n     * @memberof CMsgGCCStrike15_v2_ClientReportResponse\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientReportResponse.prototype.tokens = 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_ClientReportResponse message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_ClientReportResponse\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_ClientReportResponse} CMsgGCCStrike15_v2_ClientReportResponse\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_ClientReportResponse.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientReportResponse();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.confirmationId = reader.uint64();\n                    break;\n                case 2:\n                    message.accountId = reader.uint32();\n                    break;\n                case 3:\n                    message.serverIp = reader.uint32();\n                    break;\n                case 4:\n                    message.responseType = reader.uint32();\n                    break;\n                case 5:\n                    message.responseResult = reader.uint32();\n                    break;\n                case 6:\n                    message.tokens = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_ClientReportResponse;\n})());\nexports.CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends = ($root.CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.\n     * @exports ICMsgGCCStrike15_v2_ClientRequestWatchInfoFriends\n     * @interface ICMsgGCCStrike15_v2_ClientRequestWatchInfoFriends\n     * @property {number|null} [requestId] CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends requestId\n     * @property {Array.<number>|null} [accountIds] CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends accountIds\n     * @property {number|Long|null} [serverid] CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends serverid\n     * @property {number|Long|null} [matchid] CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends matchid\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.\n     * @exports CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends\n     * @classdesc Represents a CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.\n     * @implements ICMsgGCCStrike15_v2_ClientRequestWatchInfoFriends\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_ClientRequestWatchInfoFriends=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends(properties) {\n        this.accountIds = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends requestId.\n     * @member {number} requestId\n     * @memberof CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.prototype.requestId = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends accountIds.\n     * @member {Array.<number>} accountIds\n     * @memberof CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.prototype.accountIds =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends serverid.\n     * @member {number|Long} serverid\n     * @memberof CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.prototype.serverid = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends matchid.\n     * @member {number|Long} matchid\n     * @memberof CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.prototype.matchid = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends} CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requestId = reader.uint32();\n                    break;\n                case 2:\n                    if (!(message.accountIds && message.accountIds.length))\n                        message.accountIds = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.accountIds.push(reader.uint32());\n                    }\n                    else\n                        message.accountIds.push(reader.uint32());\n                    break;\n                case 3:\n                    message.serverid = reader.uint64();\n                    break;\n                case 4:\n                    message.matchid = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_ClientRequestWatchInfoFriends;\n})());\nexports.WatchableMatchInfo = ($root.WatchableMatchInfo = (() => {\n    /**\n     * Properties of a WatchableMatchInfo.\n     * @exports IWatchableMatchInfo\n     * @interface IWatchableMatchInfo\n     * @property {number|null} [serverIp] WatchableMatchInfo serverIp\n     * @property {number|null} [tvPort] WatchableMatchInfo tvPort\n     * @property {number|null} [tvSpectators] WatchableMatchInfo tvSpectators\n     * @property {number|null} [tvTime] WatchableMatchInfo tvTime\n     * @property {Uint8Array|null} [tvWatchPassword] WatchableMatchInfo tvWatchPassword\n     * @property {number|Long|null} [clDecryptdataKey] WatchableMatchInfo clDecryptdataKey\n     * @property {number|Long|null} [clDecryptdataKeyPub] WatchableMatchInfo clDecryptdataKeyPub\n     * @property {number|null} [gameType] WatchableMatchInfo gameType\n     * @property {string|null} [gameMapgroup] WatchableMatchInfo gameMapgroup\n     * @property {string|null} [gameMap] WatchableMatchInfo gameMap\n     * @property {number|Long|null} [serverId] WatchableMatchInfo serverId\n     * @property {number|Long|null} [matchId] WatchableMatchInfo matchId\n     * @property {number|Long|null} [reservationId] WatchableMatchInfo reservationId\n     */\n    /**\n     * Constructs a new WatchableMatchInfo.\n     * @exports WatchableMatchInfo\n     * @classdesc Represents a WatchableMatchInfo.\n     * @implements IWatchableMatchInfo\n     * @constructor\n     * @param {IWatchableMatchInfo=} [properties] Properties to set\n     */\n    function WatchableMatchInfo(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * WatchableMatchInfo serverIp.\n     * @member {number} serverIp\n     * @memberof WatchableMatchInfo\n     * @instance\n     */\n    WatchableMatchInfo.prototype.serverIp = 0;\n    /**\n     * WatchableMatchInfo tvPort.\n     * @member {number} tvPort\n     * @memberof WatchableMatchInfo\n     * @instance\n     */\n    WatchableMatchInfo.prototype.tvPort = 0;\n    /**\n     * WatchableMatchInfo tvSpectators.\n     * @member {number} tvSpectators\n     * @memberof WatchableMatchInfo\n     * @instance\n     */\n    WatchableMatchInfo.prototype.tvSpectators = 0;\n    /**\n     * WatchableMatchInfo tvTime.\n     * @member {number} tvTime\n     * @memberof WatchableMatchInfo\n     * @instance\n     */\n    WatchableMatchInfo.prototype.tvTime = 0;\n    /**\n     * WatchableMatchInfo tvWatchPassword.\n     * @member {Uint8Array} tvWatchPassword\n     * @memberof WatchableMatchInfo\n     * @instance\n     */\n    WatchableMatchInfo.prototype.tvWatchPassword = $util.newBuffer([]);\n    /**\n     * WatchableMatchInfo clDecryptdataKey.\n     * @member {number|Long} clDecryptdataKey\n     * @memberof WatchableMatchInfo\n     * @instance\n     */\n    WatchableMatchInfo.prototype.clDecryptdataKey = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * WatchableMatchInfo clDecryptdataKeyPub.\n     * @member {number|Long} clDecryptdataKeyPub\n     * @memberof WatchableMatchInfo\n     * @instance\n     */\n    WatchableMatchInfo.prototype.clDecryptdataKeyPub = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * WatchableMatchInfo gameType.\n     * @member {number} gameType\n     * @memberof WatchableMatchInfo\n     * @instance\n     */\n    WatchableMatchInfo.prototype.gameType = 0;\n    /**\n     * WatchableMatchInfo gameMapgroup.\n     * @member {string} gameMapgroup\n     * @memberof WatchableMatchInfo\n     * @instance\n     */\n    WatchableMatchInfo.prototype.gameMapgroup = \"\";\n    /**\n     * WatchableMatchInfo gameMap.\n     * @member {string} gameMap\n     * @memberof WatchableMatchInfo\n     * @instance\n     */\n    WatchableMatchInfo.prototype.gameMap = \"\";\n    /**\n     * WatchableMatchInfo serverId.\n     * @member {number|Long} serverId\n     * @memberof WatchableMatchInfo\n     * @instance\n     */\n    WatchableMatchInfo.prototype.serverId = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * WatchableMatchInfo matchId.\n     * @member {number|Long} matchId\n     * @memberof WatchableMatchInfo\n     * @instance\n     */\n    WatchableMatchInfo.prototype.matchId = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * WatchableMatchInfo reservationId.\n     * @member {number|Long} reservationId\n     * @memberof WatchableMatchInfo\n     * @instance\n     */\n    WatchableMatchInfo.prototype.reservationId = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * Decodes a WatchableMatchInfo message from the specified reader or buffer.\n     * @function decode\n     * @memberof WatchableMatchInfo\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {WatchableMatchInfo} WatchableMatchInfo\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    WatchableMatchInfo.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.WatchableMatchInfo();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.serverIp = reader.uint32();\n                    break;\n                case 2:\n                    message.tvPort = reader.uint32();\n                    break;\n                case 3:\n                    message.tvSpectators = reader.uint32();\n                    break;\n                case 4:\n                    message.tvTime = reader.uint32();\n                    break;\n                case 5:\n                    message.tvWatchPassword = reader.bytes();\n                    break;\n                case 6:\n                    message.clDecryptdataKey = reader.uint64();\n                    break;\n                case 7:\n                    message.clDecryptdataKeyPub = reader.uint64();\n                    break;\n                case 8:\n                    message.gameType = reader.uint32();\n                    break;\n                case 9:\n                    message.gameMapgroup = reader.string();\n                    break;\n                case 10:\n                    message.gameMap = reader.string();\n                    break;\n                case 11:\n                    message.serverId = reader.uint64();\n                    break;\n                case 12:\n                    message.matchId = reader.uint64();\n                    break;\n                case 13:\n                    message.reservationId = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return WatchableMatchInfo;\n})());\nexports.CMsgGCCStrike15_v2_ClientRequestJoinFriendData = ($root.CMsgGCCStrike15_v2_ClientRequestJoinFriendData = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_ClientRequestJoinFriendData.\n     * @exports ICMsgGCCStrike15_v2_ClientRequestJoinFriendData\n     * @interface ICMsgGCCStrike15_v2_ClientRequestJoinFriendData\n     * @property {number|null} [version] CMsgGCCStrike15_v2_ClientRequestJoinFriendData version\n     * @property {number|null} [accountId] CMsgGCCStrike15_v2_ClientRequestJoinFriendData accountId\n     * @property {number|null} [joinToken] CMsgGCCStrike15_v2_ClientRequestJoinFriendData joinToken\n     * @property {number|null} [joinIpp] CMsgGCCStrike15_v2_ClientRequestJoinFriendData joinIpp\n     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null} [res] CMsgGCCStrike15_v2_ClientRequestJoinFriendData res\n     * @property {string|null} [errormsg] CMsgGCCStrike15_v2_ClientRequestJoinFriendData errormsg\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_ClientRequestJoinFriendData.\n     * @exports CMsgGCCStrike15_v2_ClientRequestJoinFriendData\n     * @classdesc Represents a CMsgGCCStrike15_v2_ClientRequestJoinFriendData.\n     * @implements ICMsgGCCStrike15_v2_ClientRequestJoinFriendData\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_ClientRequestJoinFriendData=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_ClientRequestJoinFriendData(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_ClientRequestJoinFriendData version.\n     * @member {number} version\n     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientRequestJoinFriendData.prototype.version = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientRequestJoinFriendData accountId.\n     * @member {number} accountId\n     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientRequestJoinFriendData.prototype.accountId = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientRequestJoinFriendData joinToken.\n     * @member {number} joinToken\n     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientRequestJoinFriendData.prototype.joinToken = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientRequestJoinFriendData joinIpp.\n     * @member {number} joinIpp\n     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientRequestJoinFriendData.prototype.joinIpp = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientRequestJoinFriendData res.\n     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null|undefined} res\n     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientRequestJoinFriendData.prototype.res = null;\n    /**\n     * CMsgGCCStrike15_v2_ClientRequestJoinFriendData errormsg.\n     * @member {string} errormsg\n     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientRequestJoinFriendData.prototype.errormsg = \"\";\n    /**\n     * Decodes a CMsgGCCStrike15_v2_ClientRequestJoinFriendData message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinFriendData\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_ClientRequestJoinFriendData} CMsgGCCStrike15_v2_ClientRequestJoinFriendData\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_ClientRequestJoinFriendData.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientRequestJoinFriendData();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.version = reader.uint32();\n                    break;\n                case 2:\n                    message.accountId = reader.uint32();\n                    break;\n                case 3:\n                    message.joinToken = reader.uint32();\n                    break;\n                case 4:\n                    message.joinIpp = reader.uint32();\n                    break;\n                case 5:\n                    message.res = $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.decode(reader, reader.uint32());\n                    break;\n                case 6:\n                    message.errormsg = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_ClientRequestJoinFriendData;\n})());\nexports.CMsgGCCStrike15_v2_ClientRequestJoinServerData = ($root.CMsgGCCStrike15_v2_ClientRequestJoinServerData = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_ClientRequestJoinServerData.\n     * @exports ICMsgGCCStrike15_v2_ClientRequestJoinServerData\n     * @interface ICMsgGCCStrike15_v2_ClientRequestJoinServerData\n     * @property {number|null} [version] CMsgGCCStrike15_v2_ClientRequestJoinServerData version\n     * @property {number|null} [accountId] CMsgGCCStrike15_v2_ClientRequestJoinServerData accountId\n     * @property {number|Long|null} [serverid] CMsgGCCStrike15_v2_ClientRequestJoinServerData serverid\n     * @property {number|null} [serverIp] CMsgGCCStrike15_v2_ClientRequestJoinServerData serverIp\n     * @property {number|null} [serverPort] CMsgGCCStrike15_v2_ClientRequestJoinServerData serverPort\n     * @property {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null} [res] CMsgGCCStrike15_v2_ClientRequestJoinServerData res\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_ClientRequestJoinServerData.\n     * @exports CMsgGCCStrike15_v2_ClientRequestJoinServerData\n     * @classdesc Represents a CMsgGCCStrike15_v2_ClientRequestJoinServerData.\n     * @implements ICMsgGCCStrike15_v2_ClientRequestJoinServerData\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_ClientRequestJoinServerData=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_ClientRequestJoinServerData(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_ClientRequestJoinServerData version.\n     * @member {number} version\n     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientRequestJoinServerData.prototype.version = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientRequestJoinServerData accountId.\n     * @member {number} accountId\n     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientRequestJoinServerData.prototype.accountId = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientRequestJoinServerData serverid.\n     * @member {number|Long} serverid\n     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientRequestJoinServerData.prototype.serverid = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientRequestJoinServerData serverIp.\n     * @member {number} serverIp\n     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientRequestJoinServerData.prototype.serverIp = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientRequestJoinServerData serverPort.\n     * @member {number} serverPort\n     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientRequestJoinServerData.prototype.serverPort = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientRequestJoinServerData res.\n     * @member {ICMsgGCCStrike15_v2_MatchmakingGC2ClientReserve|null|undefined} res\n     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientRequestJoinServerData.prototype.res = null;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_ClientRequestJoinServerData message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_ClientRequestJoinServerData\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_ClientRequestJoinServerData} CMsgGCCStrike15_v2_ClientRequestJoinServerData\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_ClientRequestJoinServerData.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientRequestJoinServerData();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.version = reader.uint32();\n                    break;\n                case 2:\n                    message.accountId = reader.uint32();\n                    break;\n                case 3:\n                    message.serverid = reader.uint64();\n                    break;\n                case 4:\n                    message.serverIp = reader.uint32();\n                    break;\n                case 5:\n                    message.serverPort = reader.uint32();\n                    break;\n                case 6:\n                    message.res = $root.CMsgGCCStrike15_v2_MatchmakingGC2ClientReserve.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_ClientRequestJoinServerData;\n})());\nexports.CMsgGCCstrike15_v2_ClientRequestNewMission = ($root.CMsgGCCstrike15_v2_ClientRequestNewMission = (() => {\n    /**\n     * Properties of a CMsgGCCstrike15_v2_ClientRequestNewMission.\n     * @exports ICMsgGCCstrike15_v2_ClientRequestNewMission\n     * @interface ICMsgGCCstrike15_v2_ClientRequestNewMission\n     * @property {number|null} [missionId] CMsgGCCstrike15_v2_ClientRequestNewMission missionId\n     * @property {number|null} [campaignId] CMsgGCCstrike15_v2_ClientRequestNewMission campaignId\n     */\n    /**\n     * Constructs a new CMsgGCCstrike15_v2_ClientRequestNewMission.\n     * @exports CMsgGCCstrike15_v2_ClientRequestNewMission\n     * @classdesc Represents a CMsgGCCstrike15_v2_ClientRequestNewMission.\n     * @implements ICMsgGCCstrike15_v2_ClientRequestNewMission\n     * @constructor\n     * @param {ICMsgGCCstrike15_v2_ClientRequestNewMission=} [properties] Properties to set\n     */\n    function CMsgGCCstrike15_v2_ClientRequestNewMission(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCstrike15_v2_ClientRequestNewMission missionId.\n     * @member {number} missionId\n     * @memberof CMsgGCCstrike15_v2_ClientRequestNewMission\n     * @instance\n     */\n    CMsgGCCstrike15_v2_ClientRequestNewMission.prototype.missionId = 0;\n    /**\n     * CMsgGCCstrike15_v2_ClientRequestNewMission campaignId.\n     * @member {number} campaignId\n     * @memberof CMsgGCCstrike15_v2_ClientRequestNewMission\n     * @instance\n     */\n    CMsgGCCstrike15_v2_ClientRequestNewMission.prototype.campaignId = 0;\n    /**\n     * Decodes a CMsgGCCstrike15_v2_ClientRequestNewMission message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCstrike15_v2_ClientRequestNewMission\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCstrike15_v2_ClientRequestNewMission} CMsgGCCstrike15_v2_ClientRequestNewMission\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCstrike15_v2_ClientRequestNewMission.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCstrike15_v2_ClientRequestNewMission();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 2:\n                    message.missionId = reader.uint32();\n                    break;\n                case 3:\n                    message.campaignId = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCstrike15_v2_ClientRequestNewMission;\n})());\nexports.CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded = ($root.CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded = (() => {\n    /**\n     * Properties of a CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.\n     * @exports ICMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded\n     * @interface ICMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded\n     * @property {Array.<IXpProgressData>|null} [xpProgressData] CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded xpProgressData\n     * @property {number|null} [accountId] CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded accountId\n     * @property {number|null} [currentXp] CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded currentXp\n     * @property {number|null} [currentLevel] CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded currentLevel\n     * @property {number|null} [upgradedDefidx] CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded upgradedDefidx\n     */\n    /**\n     * Constructs a new CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.\n     * @exports CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded\n     * @classdesc Represents a CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.\n     * @implements ICMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded\n     * @constructor\n     * @param {ICMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded=} [properties] Properties to set\n     */\n    function CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded(properties) {\n        this.xpProgressData = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded xpProgressData.\n     * @member {Array.<IXpProgressData>} xpProgressData\n     * @memberof CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded\n     * @instance\n     */\n    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.prototype.xpProgressData =\n        $util.emptyArray;\n    /**\n     * CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded accountId.\n     * @member {number} accountId\n     * @memberof CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded\n     * @instance\n     */\n    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.prototype.accountId = 0;\n    /**\n     * CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded currentXp.\n     * @member {number} currentXp\n     * @memberof CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded\n     * @instance\n     */\n    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.prototype.currentXp = 0;\n    /**\n     * CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded currentLevel.\n     * @member {number} currentLevel\n     * @memberof CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded\n     * @instance\n     */\n    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.prototype.currentLevel = 0;\n    /**\n     * CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded upgradedDefidx.\n     * @member {number} upgradedDefidx\n     * @memberof CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded\n     * @instance\n     */\n    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.prototype.upgradedDefidx = 0;\n    /**\n     * Decodes a CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded} CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.xpProgressData && message.xpProgressData.length))\n                        message.xpProgressData = [];\n                    message.xpProgressData.push($root.XpProgressData.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.accountId = reader.uint32();\n                    break;\n                case 3:\n                    message.currentXp = reader.uint32();\n                    break;\n                case 4:\n                    message.currentLevel = reader.uint32();\n                    break;\n                case 5:\n                    message.upgradedDefidx = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCstrike15_v2_GC2ServerNotifyXPRewarded;\n})());\nexports.CMsgGCCStrike15_v2_WatchInfoUsers = ($root.CMsgGCCStrike15_v2_WatchInfoUsers = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_WatchInfoUsers.\n     * @exports ICMsgGCCStrike15_v2_WatchInfoUsers\n     * @interface ICMsgGCCStrike15_v2_WatchInfoUsers\n     * @property {number|null} [requestId] CMsgGCCStrike15_v2_WatchInfoUsers requestId\n     * @property {Array.<number>|null} [accountIds] CMsgGCCStrike15_v2_WatchInfoUsers accountIds\n     * @property {Array.<IWatchableMatchInfo>|null} [watchableMatchInfos] CMsgGCCStrike15_v2_WatchInfoUsers watchableMatchInfos\n     * @property {number|null} [extendedTimeout] CMsgGCCStrike15_v2_WatchInfoUsers extendedTimeout\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_WatchInfoUsers.\n     * @exports CMsgGCCStrike15_v2_WatchInfoUsers\n     * @classdesc Represents a CMsgGCCStrike15_v2_WatchInfoUsers.\n     * @implements ICMsgGCCStrike15_v2_WatchInfoUsers\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_WatchInfoUsers=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_WatchInfoUsers(properties) {\n        this.accountIds = [];\n        this.watchableMatchInfos = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_WatchInfoUsers requestId.\n     * @member {number} requestId\n     * @memberof CMsgGCCStrike15_v2_WatchInfoUsers\n     * @instance\n     */\n    CMsgGCCStrike15_v2_WatchInfoUsers.prototype.requestId = 0;\n    /**\n     * CMsgGCCStrike15_v2_WatchInfoUsers accountIds.\n     * @member {Array.<number>} accountIds\n     * @memberof CMsgGCCStrike15_v2_WatchInfoUsers\n     * @instance\n     */\n    CMsgGCCStrike15_v2_WatchInfoUsers.prototype.accountIds = $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_WatchInfoUsers watchableMatchInfos.\n     * @member {Array.<IWatchableMatchInfo>} watchableMatchInfos\n     * @memberof CMsgGCCStrike15_v2_WatchInfoUsers\n     * @instance\n     */\n    CMsgGCCStrike15_v2_WatchInfoUsers.prototype.watchableMatchInfos =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_WatchInfoUsers extendedTimeout.\n     * @member {number} extendedTimeout\n     * @memberof CMsgGCCStrike15_v2_WatchInfoUsers\n     * @instance\n     */\n    CMsgGCCStrike15_v2_WatchInfoUsers.prototype.extendedTimeout = 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_WatchInfoUsers message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_WatchInfoUsers\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_WatchInfoUsers} CMsgGCCStrike15_v2_WatchInfoUsers\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_WatchInfoUsers.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_WatchInfoUsers();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requestId = reader.uint32();\n                    break;\n                case 2:\n                    if (!(message.accountIds && message.accountIds.length))\n                        message.accountIds = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.accountIds.push(reader.uint32());\n                    }\n                    else\n                        message.accountIds.push(reader.uint32());\n                    break;\n                case 3:\n                    if (!(message.watchableMatchInfos && message.watchableMatchInfos.length))\n                        message.watchableMatchInfos = [];\n                    message.watchableMatchInfos.push($root.WatchableMatchInfo.decode(reader, reader.uint32()));\n                    break;\n                case 5:\n                    message.extendedTimeout = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_WatchInfoUsers;\n})());\nexports.CMsgGCCStrike15_v2_ClientRequestPlayersProfile = ($root.CMsgGCCStrike15_v2_ClientRequestPlayersProfile = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_ClientRequestPlayersProfile.\n     * @exports ICMsgGCCStrike15_v2_ClientRequestPlayersProfile\n     * @interface ICMsgGCCStrike15_v2_ClientRequestPlayersProfile\n     * @property {number|null} [requestId_Deprecated] CMsgGCCStrike15_v2_ClientRequestPlayersProfile requestId_Deprecated\n     * @property {Array.<number>|null} [accountIds_Deprecated] CMsgGCCStrike15_v2_ClientRequestPlayersProfile accountIds_Deprecated\n     * @property {number|null} [accountId] CMsgGCCStrike15_v2_ClientRequestPlayersProfile accountId\n     * @property {number|null} [requestLevel] CMsgGCCStrike15_v2_ClientRequestPlayersProfile requestLevel\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_ClientRequestPlayersProfile.\n     * @exports CMsgGCCStrike15_v2_ClientRequestPlayersProfile\n     * @classdesc Represents a CMsgGCCStrike15_v2_ClientRequestPlayersProfile.\n     * @implements ICMsgGCCStrike15_v2_ClientRequestPlayersProfile\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_ClientRequestPlayersProfile=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_ClientRequestPlayersProfile(properties) {\n        this.accountIds_Deprecated = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_ClientRequestPlayersProfile requestId_Deprecated.\n     * @member {number} requestId_Deprecated\n     * @memberof CMsgGCCStrike15_v2_ClientRequestPlayersProfile\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientRequestPlayersProfile.prototype.requestId_Deprecated = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientRequestPlayersProfile accountIds_Deprecated.\n     * @member {Array.<number>} accountIds_Deprecated\n     * @memberof CMsgGCCStrike15_v2_ClientRequestPlayersProfile\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientRequestPlayersProfile.prototype.accountIds_Deprecated =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_ClientRequestPlayersProfile accountId.\n     * @member {number} accountId\n     * @memberof CMsgGCCStrike15_v2_ClientRequestPlayersProfile\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientRequestPlayersProfile.prototype.accountId = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientRequestPlayersProfile requestLevel.\n     * @member {number} requestLevel\n     * @memberof CMsgGCCStrike15_v2_ClientRequestPlayersProfile\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientRequestPlayersProfile.prototype.requestLevel = 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_ClientRequestPlayersProfile message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_ClientRequestPlayersProfile\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_ClientRequestPlayersProfile} CMsgGCCStrike15_v2_ClientRequestPlayersProfile\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_ClientRequestPlayersProfile.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientRequestPlayersProfile();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requestId_Deprecated = reader.uint32();\n                    break;\n                case 2:\n                    if (!(message.accountIds_Deprecated &&\n                        message.accountIds_Deprecated.length))\n                        message.accountIds_Deprecated = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.accountIds_Deprecated.push(reader.uint32());\n                    }\n                    else\n                        message.accountIds_Deprecated.push(reader.uint32());\n                    break;\n                case 3:\n                    message.accountId = reader.uint32();\n                    break;\n                case 4:\n                    message.requestLevel = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_ClientRequestPlayersProfile;\n})());\nexports.CMsgGCCStrike15_v2_PlayersProfile = ($root.CMsgGCCStrike15_v2_PlayersProfile = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_PlayersProfile.\n     * @exports ICMsgGCCStrike15_v2_PlayersProfile\n     * @interface ICMsgGCCStrike15_v2_PlayersProfile\n     * @property {number|null} [requestId] CMsgGCCStrike15_v2_PlayersProfile requestId\n     * @property {Array.<ICMsgGCCStrike15_v2_MatchmakingGC2ClientHello>|null} [accountProfiles] CMsgGCCStrike15_v2_PlayersProfile accountProfiles\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_PlayersProfile.\n     * @exports CMsgGCCStrike15_v2_PlayersProfile\n     * @classdesc Represents a CMsgGCCStrike15_v2_PlayersProfile.\n     * @implements ICMsgGCCStrike15_v2_PlayersProfile\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_PlayersProfile=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_PlayersProfile(properties) {\n        this.accountProfiles = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_PlayersProfile requestId.\n     * @member {number} requestId\n     * @memberof CMsgGCCStrike15_v2_PlayersProfile\n     * @instance\n     */\n    CMsgGCCStrike15_v2_PlayersProfile.prototype.requestId = 0;\n    /**\n     * CMsgGCCStrike15_v2_PlayersProfile accountProfiles.\n     * @member {Array.<ICMsgGCCStrike15_v2_MatchmakingGC2ClientHello>} accountProfiles\n     * @memberof CMsgGCCStrike15_v2_PlayersProfile\n     * @instance\n     */\n    CMsgGCCStrike15_v2_PlayersProfile.prototype.accountProfiles =\n        $util.emptyArray;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_PlayersProfile message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_PlayersProfile\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_PlayersProfile} CMsgGCCStrike15_v2_PlayersProfile\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_PlayersProfile.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_PlayersProfile();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requestId = reader.uint32();\n                    break;\n                case 2:\n                    if (!(message.accountProfiles && message.accountProfiles.length))\n                        message.accountProfiles = [];\n                    message.accountProfiles.push($root.CMsgGCCStrike15_v2_MatchmakingGC2ClientHello.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_PlayersProfile;\n})());\nexports.CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate = ($root.CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.\n     * @exports ICMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n     * @interface ICMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n     * @property {number|Long|null} [caseid] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate caseid\n     * @property {number|null} [suspectid] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate suspectid\n     * @property {number|null} [fractionid] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate fractionid\n     * @property {number|null} [rptAimbot] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptAimbot\n     * @property {number|null} [rptWallhack] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptWallhack\n     * @property {number|null} [rptSpeedhack] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptSpeedhack\n     * @property {number|null} [rptTeamharm] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptTeamharm\n     * @property {number|null} [reason] CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate reason\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.\n     * @exports CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n     * @classdesc Represents a CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.\n     * @implements ICMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate caseid.\n     * @member {number|Long} caseid\n     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.caseid = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate suspectid.\n     * @member {number} suspectid\n     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.suspectid = 0;\n    /**\n     * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate fractionid.\n     * @member {number} fractionid\n     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.fractionid = 0;\n    /**\n     * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptAimbot.\n     * @member {number} rptAimbot\n     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.rptAimbot = 0;\n    /**\n     * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptWallhack.\n     * @member {number} rptWallhack\n     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.rptWallhack = 0;\n    /**\n     * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptSpeedhack.\n     * @member {number} rptSpeedhack\n     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.rptSpeedhack = 0;\n    /**\n     * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate rptTeamharm.\n     * @member {number} rptTeamharm\n     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.rptTeamharm = 0;\n    /**\n     * CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate reason.\n     * @member {number} reason\n     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.prototype.reason = 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate} CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.caseid = reader.uint64();\n                    break;\n                case 3:\n                    message.suspectid = reader.uint32();\n                    break;\n                case 4:\n                    message.fractionid = reader.uint32();\n                    break;\n                case 5:\n                    message.rptAimbot = reader.uint32();\n                    break;\n                case 6:\n                    message.rptWallhack = reader.uint32();\n                    break;\n                case 7:\n                    message.rptSpeedhack = reader.uint32();\n                    break;\n                case 8:\n                    message.rptTeamharm = reader.uint32();\n                    break;\n                case 9:\n                    message.reason = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_PlayerOverwatchCaseUpdate;\n})());\nexports.CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment = ($root.CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.\n     * @exports ICMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n     * @interface ICMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n     * @property {number|Long|null} [caseid] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment caseid\n     * @property {string|null} [caseurl] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment caseurl\n     * @property {number|null} [verdict] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment verdict\n     * @property {number|null} [timestamp] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment timestamp\n     * @property {number|null} [throttleseconds] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment throttleseconds\n     * @property {number|null} [suspectid] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment suspectid\n     * @property {number|null} [fractionid] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment fractionid\n     * @property {number|null} [numrounds] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment numrounds\n     * @property {number|null} [fractionrounds] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment fractionrounds\n     * @property {number|null} [streakconvictions] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment streakconvictions\n     * @property {number|null} [reason] CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment reason\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.\n     * @exports CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n     * @classdesc Represents a CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.\n     * @implements ICMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment caseid.\n     * @member {number|Long} caseid\n     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n     * @instance\n     */\n    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.caseid = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment caseurl.\n     * @member {string} caseurl\n     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n     * @instance\n     */\n    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.caseurl = \"\";\n    /**\n     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment verdict.\n     * @member {number} verdict\n     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n     * @instance\n     */\n    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.verdict = 0;\n    /**\n     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment timestamp.\n     * @member {number} timestamp\n     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n     * @instance\n     */\n    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.timestamp = 0;\n    /**\n     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment throttleseconds.\n     * @member {number} throttleseconds\n     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n     * @instance\n     */\n    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.throttleseconds = 0;\n    /**\n     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment suspectid.\n     * @member {number} suspectid\n     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n     * @instance\n     */\n    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.suspectid = 0;\n    /**\n     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment fractionid.\n     * @member {number} fractionid\n     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n     * @instance\n     */\n    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.fractionid = 0;\n    /**\n     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment numrounds.\n     * @member {number} numrounds\n     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n     * @instance\n     */\n    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.numrounds = 0;\n    /**\n     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment fractionrounds.\n     * @member {number} fractionrounds\n     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n     * @instance\n     */\n    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.fractionrounds = 0;\n    /**\n     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment streakconvictions.\n     * @member {number} streakconvictions\n     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n     * @instance\n     */\n    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.streakconvictions = 0;\n    /**\n     * CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment reason.\n     * @member {number} reason\n     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n     * @instance\n     */\n    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.prototype.reason = 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment} CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.caseid = reader.uint64();\n                    break;\n                case 2:\n                    message.caseurl = reader.string();\n                    break;\n                case 3:\n                    message.verdict = reader.uint32();\n                    break;\n                case 4:\n                    message.timestamp = reader.uint32();\n                    break;\n                case 5:\n                    message.throttleseconds = reader.uint32();\n                    break;\n                case 6:\n                    message.suspectid = reader.uint32();\n                    break;\n                case 7:\n                    message.fractionid = reader.uint32();\n                    break;\n                case 8:\n                    message.numrounds = reader.uint32();\n                    break;\n                case 9:\n                    message.fractionrounds = reader.uint32();\n                    break;\n                case 10:\n                    message.streakconvictions = reader.int32();\n                    break;\n                case 11:\n                    message.reason = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_PlayerOverwatchCaseAssignment;\n})());\nexports.CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus = ($root.CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.\n     * @exports ICMsgGCCStrike15_v2_PlayerOverwatchCaseStatus\n     * @interface ICMsgGCCStrike15_v2_PlayerOverwatchCaseStatus\n     * @property {number|Long|null} [caseid] CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus caseid\n     * @property {number|null} [statusid] CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus statusid\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.\n     * @exports CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus\n     * @classdesc Represents a CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.\n     * @implements ICMsgGCCStrike15_v2_PlayerOverwatchCaseStatus\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_PlayerOverwatchCaseStatus=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus caseid.\n     * @member {number|Long} caseid\n     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus\n     * @instance\n     */\n    CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.prototype.caseid = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus statusid.\n     * @member {number} statusid\n     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus\n     * @instance\n     */\n    CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.prototype.statusid = 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus} CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.caseid = reader.uint64();\n                    break;\n                case 2:\n                    message.statusid = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_PlayerOverwatchCaseStatus;\n})());\nexports.CClientHeaderOverwatchEvidence = ($root.CClientHeaderOverwatchEvidence = (() => {\n    /**\n     * Properties of a CClientHeaderOverwatchEvidence.\n     * @exports ICClientHeaderOverwatchEvidence\n     * @interface ICClientHeaderOverwatchEvidence\n     * @property {number|null} [accountid] CClientHeaderOverwatchEvidence accountid\n     * @property {number|Long|null} [caseid] CClientHeaderOverwatchEvidence caseid\n     */\n    /**\n     * Constructs a new CClientHeaderOverwatchEvidence.\n     * @exports CClientHeaderOverwatchEvidence\n     * @classdesc Represents a CClientHeaderOverwatchEvidence.\n     * @implements ICClientHeaderOverwatchEvidence\n     * @constructor\n     * @param {ICClientHeaderOverwatchEvidence=} [properties] Properties to set\n     */\n    function CClientHeaderOverwatchEvidence(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CClientHeaderOverwatchEvidence accountid.\n     * @member {number} accountid\n     * @memberof CClientHeaderOverwatchEvidence\n     * @instance\n     */\n    CClientHeaderOverwatchEvidence.prototype.accountid = 0;\n    /**\n     * CClientHeaderOverwatchEvidence caseid.\n     * @member {number|Long} caseid\n     * @memberof CClientHeaderOverwatchEvidence\n     * @instance\n     */\n    CClientHeaderOverwatchEvidence.prototype.caseid = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * Decodes a CClientHeaderOverwatchEvidence message from the specified reader or buffer.\n     * @function decode\n     * @memberof CClientHeaderOverwatchEvidence\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CClientHeaderOverwatchEvidence} CClientHeaderOverwatchEvidence\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CClientHeaderOverwatchEvidence.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CClientHeaderOverwatchEvidence();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.accountid = reader.uint32();\n                    break;\n                case 2:\n                    message.caseid = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CClientHeaderOverwatchEvidence;\n})());\nexports.CMsgGCCStrike15_v2_GC2ClientTextMsg = ($root.CMsgGCCStrike15_v2_GC2ClientTextMsg = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_GC2ClientTextMsg.\n     * @exports ICMsgGCCStrike15_v2_GC2ClientTextMsg\n     * @interface ICMsgGCCStrike15_v2_GC2ClientTextMsg\n     * @property {number|null} [id] CMsgGCCStrike15_v2_GC2ClientTextMsg id\n     * @property {number|null} [type] CMsgGCCStrike15_v2_GC2ClientTextMsg type\n     * @property {Uint8Array|null} [payload] CMsgGCCStrike15_v2_GC2ClientTextMsg payload\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_GC2ClientTextMsg.\n     * @exports CMsgGCCStrike15_v2_GC2ClientTextMsg\n     * @classdesc Represents a CMsgGCCStrike15_v2_GC2ClientTextMsg.\n     * @implements ICMsgGCCStrike15_v2_GC2ClientTextMsg\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_GC2ClientTextMsg=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_GC2ClientTextMsg(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_GC2ClientTextMsg id.\n     * @member {number} id\n     * @memberof CMsgGCCStrike15_v2_GC2ClientTextMsg\n     * @instance\n     */\n    CMsgGCCStrike15_v2_GC2ClientTextMsg.prototype.id = 0;\n    /**\n     * CMsgGCCStrike15_v2_GC2ClientTextMsg type.\n     * @member {number} type\n     * @memberof CMsgGCCStrike15_v2_GC2ClientTextMsg\n     * @instance\n     */\n    CMsgGCCStrike15_v2_GC2ClientTextMsg.prototype.type = 0;\n    /**\n     * CMsgGCCStrike15_v2_GC2ClientTextMsg payload.\n     * @member {Uint8Array} payload\n     * @memberof CMsgGCCStrike15_v2_GC2ClientTextMsg\n     * @instance\n     */\n    CMsgGCCStrike15_v2_GC2ClientTextMsg.prototype.payload = $util.newBuffer([]);\n    /**\n     * Decodes a CMsgGCCStrike15_v2_GC2ClientTextMsg message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_GC2ClientTextMsg\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_GC2ClientTextMsg} CMsgGCCStrike15_v2_GC2ClientTextMsg\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_GC2ClientTextMsg.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_GC2ClientTextMsg();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.uint32();\n                    break;\n                case 2:\n                    message.type = reader.uint32();\n                    break;\n                case 3:\n                    message.payload = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_GC2ClientTextMsg;\n})());\nexports.CMsgGCCStrike15_v2_Client2GCTextMsg = ($root.CMsgGCCStrike15_v2_Client2GCTextMsg = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_Client2GCTextMsg.\n     * @exports ICMsgGCCStrike15_v2_Client2GCTextMsg\n     * @interface ICMsgGCCStrike15_v2_Client2GCTextMsg\n     * @property {number|null} [id] CMsgGCCStrike15_v2_Client2GCTextMsg id\n     * @property {Array.<Uint8Array>|null} [args] CMsgGCCStrike15_v2_Client2GCTextMsg args\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_Client2GCTextMsg.\n     * @exports CMsgGCCStrike15_v2_Client2GCTextMsg\n     * @classdesc Represents a CMsgGCCStrike15_v2_Client2GCTextMsg.\n     * @implements ICMsgGCCStrike15_v2_Client2GCTextMsg\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_Client2GCTextMsg=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_Client2GCTextMsg(properties) {\n        this.args = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_Client2GCTextMsg id.\n     * @member {number} id\n     * @memberof CMsgGCCStrike15_v2_Client2GCTextMsg\n     * @instance\n     */\n    CMsgGCCStrike15_v2_Client2GCTextMsg.prototype.id = 0;\n    /**\n     * CMsgGCCStrike15_v2_Client2GCTextMsg args.\n     * @member {Array.<Uint8Array>} args\n     * @memberof CMsgGCCStrike15_v2_Client2GCTextMsg\n     * @instance\n     */\n    CMsgGCCStrike15_v2_Client2GCTextMsg.prototype.args = $util.emptyArray;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_Client2GCTextMsg message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_Client2GCTextMsg\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_Client2GCTextMsg} CMsgGCCStrike15_v2_Client2GCTextMsg\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_Client2GCTextMsg.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Client2GCTextMsg();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.uint32();\n                    break;\n                case 2:\n                    if (!(message.args && message.args.length))\n                        message.args = [];\n                    message.args.push(reader.bytes());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_Client2GCTextMsg;\n})());\nexports.CMsgGCCStrike15_v2_MatchEndRunRewardDrops = ($root.CMsgGCCStrike15_v2_MatchEndRunRewardDrops = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_MatchEndRunRewardDrops.\n     * @exports ICMsgGCCStrike15_v2_MatchEndRunRewardDrops\n     * @interface ICMsgGCCStrike15_v2_MatchEndRunRewardDrops\n     * @property {ICMsgGCCStrike15_v2_MatchmakingServerReservationResponse|null} [serverinfo] CMsgGCCStrike15_v2_MatchEndRunRewardDrops serverinfo\n     * @property {ICMsgGC_ServerQuestUpdateData|null} [matchEndQuestData] CMsgGCCStrike15_v2_MatchEndRunRewardDrops matchEndQuestData\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_MatchEndRunRewardDrops.\n     * @exports CMsgGCCStrike15_v2_MatchEndRunRewardDrops\n     * @classdesc Represents a CMsgGCCStrike15_v2_MatchEndRunRewardDrops.\n     * @implements ICMsgGCCStrike15_v2_MatchEndRunRewardDrops\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_MatchEndRunRewardDrops=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_MatchEndRunRewardDrops(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_MatchEndRunRewardDrops serverinfo.\n     * @member {ICMsgGCCStrike15_v2_MatchmakingServerReservationResponse|null|undefined} serverinfo\n     * @memberof CMsgGCCStrike15_v2_MatchEndRunRewardDrops\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchEndRunRewardDrops.prototype.serverinfo = null;\n    /**\n     * CMsgGCCStrike15_v2_MatchEndRunRewardDrops matchEndQuestData.\n     * @member {ICMsgGC_ServerQuestUpdateData|null|undefined} matchEndQuestData\n     * @memberof CMsgGCCStrike15_v2_MatchEndRunRewardDrops\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchEndRunRewardDrops.prototype.matchEndQuestData = null;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_MatchEndRunRewardDrops message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchEndRunRewardDrops\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchEndRunRewardDrops} CMsgGCCStrike15_v2_MatchEndRunRewardDrops\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_MatchEndRunRewardDrops.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchEndRunRewardDrops();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 3:\n                    message.serverinfo = $root.CMsgGCCStrike15_v2_MatchmakingServerReservationResponse.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.matchEndQuestData = $root.CMsgGC_ServerQuestUpdateData.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_MatchEndRunRewardDrops;\n})());\nexports.CEconItemPreviewDataBlock = ($root.CEconItemPreviewDataBlock = (() => {\n    /**\n     * Properties of a CEconItemPreviewDataBlock.\n     * @exports ICEconItemPreviewDataBlock\n     * @interface ICEconItemPreviewDataBlock\n     * @property {number|null} [accountid] CEconItemPreviewDataBlock accountid\n     * @property {number|Long|null} [itemid] CEconItemPreviewDataBlock itemid\n     * @property {number|null} [defindex] CEconItemPreviewDataBlock defindex\n     * @property {number|null} [paintindex] CEconItemPreviewDataBlock paintindex\n     * @property {number|null} [rarity] CEconItemPreviewDataBlock rarity\n     * @property {number|null} [quality] CEconItemPreviewDataBlock quality\n     * @property {number|null} [paintwear] CEconItemPreviewDataBlock paintwear\n     * @property {number|null} [paintseed] CEconItemPreviewDataBlock paintseed\n     * @property {number|null} [killeaterscoretype] CEconItemPreviewDataBlock killeaterscoretype\n     * @property {number|null} [killeatervalue] CEconItemPreviewDataBlock killeatervalue\n     * @property {string|null} [customname] CEconItemPreviewDataBlock customname\n     * @property {Array.<CEconItemPreviewDataBlock.ISticker>|null} [stickers] CEconItemPreviewDataBlock stickers\n     * @property {number|null} [inventory] CEconItemPreviewDataBlock inventory\n     * @property {number|null} [origin] CEconItemPreviewDataBlock origin\n     * @property {number|null} [questid] CEconItemPreviewDataBlock questid\n     * @property {number|null} [dropreason] CEconItemPreviewDataBlock dropreason\n     */\n    /**\n     * Constructs a new CEconItemPreviewDataBlock.\n     * @exports CEconItemPreviewDataBlock\n     * @classdesc Represents a CEconItemPreviewDataBlock.\n     * @implements ICEconItemPreviewDataBlock\n     * @constructor\n     * @param {ICEconItemPreviewDataBlock=} [properties] Properties to set\n     */\n    function CEconItemPreviewDataBlock(properties) {\n        this.stickers = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CEconItemPreviewDataBlock accountid.\n     * @member {number} accountid\n     * @memberof CEconItemPreviewDataBlock\n     * @instance\n     */\n    CEconItemPreviewDataBlock.prototype.accountid = 0;\n    /**\n     * CEconItemPreviewDataBlock itemid.\n     * @member {number|Long} itemid\n     * @memberof CEconItemPreviewDataBlock\n     * @instance\n     */\n    CEconItemPreviewDataBlock.prototype.itemid = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CEconItemPreviewDataBlock defindex.\n     * @member {number} defindex\n     * @memberof CEconItemPreviewDataBlock\n     * @instance\n     */\n    CEconItemPreviewDataBlock.prototype.defindex = 0;\n    /**\n     * CEconItemPreviewDataBlock paintindex.\n     * @member {number} paintindex\n     * @memberof CEconItemPreviewDataBlock\n     * @instance\n     */\n    CEconItemPreviewDataBlock.prototype.paintindex = 0;\n    /**\n     * CEconItemPreviewDataBlock rarity.\n     * @member {number} rarity\n     * @memberof CEconItemPreviewDataBlock\n     * @instance\n     */\n    CEconItemPreviewDataBlock.prototype.rarity = 0;\n    /**\n     * CEconItemPreviewDataBlock quality.\n     * @member {number} quality\n     * @memberof CEconItemPreviewDataBlock\n     * @instance\n     */\n    CEconItemPreviewDataBlock.prototype.quality = 0;\n    /**\n     * CEconItemPreviewDataBlock paintwear.\n     * @member {number} paintwear\n     * @memberof CEconItemPreviewDataBlock\n     * @instance\n     */\n    CEconItemPreviewDataBlock.prototype.paintwear = 0;\n    /**\n     * CEconItemPreviewDataBlock paintseed.\n     * @member {number} paintseed\n     * @memberof CEconItemPreviewDataBlock\n     * @instance\n     */\n    CEconItemPreviewDataBlock.prototype.paintseed = 0;\n    /**\n     * CEconItemPreviewDataBlock killeaterscoretype.\n     * @member {number} killeaterscoretype\n     * @memberof CEconItemPreviewDataBlock\n     * @instance\n     */\n    CEconItemPreviewDataBlock.prototype.killeaterscoretype = 0;\n    /**\n     * CEconItemPreviewDataBlock killeatervalue.\n     * @member {number} killeatervalue\n     * @memberof CEconItemPreviewDataBlock\n     * @instance\n     */\n    CEconItemPreviewDataBlock.prototype.killeatervalue = 0;\n    /**\n     * CEconItemPreviewDataBlock customname.\n     * @member {string} customname\n     * @memberof CEconItemPreviewDataBlock\n     * @instance\n     */\n    CEconItemPreviewDataBlock.prototype.customname = \"\";\n    /**\n     * CEconItemPreviewDataBlock stickers.\n     * @member {Array.<CEconItemPreviewDataBlock.ISticker>} stickers\n     * @memberof CEconItemPreviewDataBlock\n     * @instance\n     */\n    CEconItemPreviewDataBlock.prototype.stickers = $util.emptyArray;\n    /**\n     * CEconItemPreviewDataBlock inventory.\n     * @member {number} inventory\n     * @memberof CEconItemPreviewDataBlock\n     * @instance\n     */\n    CEconItemPreviewDataBlock.prototype.inventory = 0;\n    /**\n     * CEconItemPreviewDataBlock origin.\n     * @member {number} origin\n     * @memberof CEconItemPreviewDataBlock\n     * @instance\n     */\n    CEconItemPreviewDataBlock.prototype.origin = 0;\n    /**\n     * CEconItemPreviewDataBlock questid.\n     * @member {number} questid\n     * @memberof CEconItemPreviewDataBlock\n     * @instance\n     */\n    CEconItemPreviewDataBlock.prototype.questid = 0;\n    /**\n     * CEconItemPreviewDataBlock dropreason.\n     * @member {number} dropreason\n     * @memberof CEconItemPreviewDataBlock\n     * @instance\n     */\n    CEconItemPreviewDataBlock.prototype.dropreason = 0;\n    /**\n     * Decodes a CEconItemPreviewDataBlock message from the specified reader or buffer.\n     * @function decode\n     * @memberof CEconItemPreviewDataBlock\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CEconItemPreviewDataBlock} CEconItemPreviewDataBlock\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CEconItemPreviewDataBlock.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CEconItemPreviewDataBlock();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.accountid = reader.uint32();\n                    break;\n                case 2:\n                    message.itemid = reader.uint64();\n                    break;\n                case 3:\n                    message.defindex = reader.uint32();\n                    break;\n                case 4:\n                    message.paintindex = reader.uint32();\n                    break;\n                case 5:\n                    message.rarity = reader.uint32();\n                    break;\n                case 6:\n                    message.quality = reader.uint32();\n                    break;\n                case 7:\n                    message.paintwear = reader.uint32();\n                    break;\n                case 8:\n                    message.paintseed = reader.uint32();\n                    break;\n                case 9:\n                    message.killeaterscoretype = reader.uint32();\n                    break;\n                case 10:\n                    message.killeatervalue = reader.uint32();\n                    break;\n                case 11:\n                    message.customname = reader.string();\n                    break;\n                case 12:\n                    if (!(message.stickers && message.stickers.length))\n                        message.stickers = [];\n                    message.stickers.push($root.CEconItemPreviewDataBlock.Sticker.decode(reader, reader.uint32()));\n                    break;\n                case 13:\n                    message.inventory = reader.uint32();\n                    break;\n                case 14:\n                    message.origin = reader.uint32();\n                    break;\n                case 15:\n                    message.questid = reader.uint32();\n                    break;\n                case 16:\n                    message.dropreason = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CEconItemPreviewDataBlock.Sticker = (function () {\n        /**\n         * Properties of a Sticker.\n         * @memberof CEconItemPreviewDataBlock\n         * @interface ISticker\n         * @property {number|null} [slot] Sticker slot\n         * @property {number|null} [stickerId] Sticker stickerId\n         * @property {number|null} [wear] Sticker wear\n         * @property {number|null} [scale] Sticker scale\n         * @property {number|null} [rotation] Sticker rotation\n         */\n        /**\n         * Constructs a new Sticker.\n         * @memberof CEconItemPreviewDataBlock\n         * @classdesc Represents a Sticker.\n         * @implements ISticker\n         * @constructor\n         * @param {CEconItemPreviewDataBlock.ISticker=} [properties] Properties to set\n         */\n        function Sticker(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * Sticker slot.\n         * @member {number} slot\n         * @memberof CEconItemPreviewDataBlock.Sticker\n         * @instance\n         */\n        Sticker.prototype.slot = 0;\n        /**\n         * Sticker stickerId.\n         * @member {number} stickerId\n         * @memberof CEconItemPreviewDataBlock.Sticker\n         * @instance\n         */\n        Sticker.prototype.stickerId = 0;\n        /**\n         * Sticker wear.\n         * @member {number} wear\n         * @memberof CEconItemPreviewDataBlock.Sticker\n         * @instance\n         */\n        Sticker.prototype.wear = 0;\n        /**\n         * Sticker scale.\n         * @member {number} scale\n         * @memberof CEconItemPreviewDataBlock.Sticker\n         * @instance\n         */\n        Sticker.prototype.scale = 0;\n        /**\n         * Sticker rotation.\n         * @member {number} rotation\n         * @memberof CEconItemPreviewDataBlock.Sticker\n         * @instance\n         */\n        Sticker.prototype.rotation = 0;\n        /**\n         * Decodes a Sticker message from the specified reader or buffer.\n         * @function decode\n         * @memberof CEconItemPreviewDataBlock.Sticker\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CEconItemPreviewDataBlock.Sticker} Sticker\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Sticker.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CEconItemPreviewDataBlock.Sticker();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.slot = reader.uint32();\n                        break;\n                    case 2:\n                        message.stickerId = reader.uint32();\n                        break;\n                    case 3:\n                        message.wear = reader.float();\n                        break;\n                    case 4:\n                        message.scale = reader.float();\n                        break;\n                    case 5:\n                        message.rotation = reader.float();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return Sticker;\n    })();\n    return CEconItemPreviewDataBlock;\n})());\nexports.CMsgGCCStrike15_v2_MatchEndRewardDropsNotification = ($root.CMsgGCCStrike15_v2_MatchEndRewardDropsNotification = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_MatchEndRewardDropsNotification.\n     * @exports ICMsgGCCStrike15_v2_MatchEndRewardDropsNotification\n     * @interface ICMsgGCCStrike15_v2_MatchEndRewardDropsNotification\n     * @property {ICEconItemPreviewDataBlock|null} [iteminfo] CMsgGCCStrike15_v2_MatchEndRewardDropsNotification iteminfo\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_MatchEndRewardDropsNotification.\n     * @exports CMsgGCCStrike15_v2_MatchEndRewardDropsNotification\n     * @classdesc Represents a CMsgGCCStrike15_v2_MatchEndRewardDropsNotification.\n     * @implements ICMsgGCCStrike15_v2_MatchEndRewardDropsNotification\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_MatchEndRewardDropsNotification=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_MatchEndRewardDropsNotification(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_MatchEndRewardDropsNotification iteminfo.\n     * @member {ICEconItemPreviewDataBlock|null|undefined} iteminfo\n     * @memberof CMsgGCCStrike15_v2_MatchEndRewardDropsNotification\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchEndRewardDropsNotification.prototype.iteminfo = null;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_MatchEndRewardDropsNotification message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchEndRewardDropsNotification\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchEndRewardDropsNotification} CMsgGCCStrike15_v2_MatchEndRewardDropsNotification\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_MatchEndRewardDropsNotification.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchEndRewardDropsNotification();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 6:\n                    message.iteminfo = $root.CEconItemPreviewDataBlock.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_MatchEndRewardDropsNotification;\n})());\nexports.CMsgItemAcknowledged = ($root.CMsgItemAcknowledged = (() => {\n    /**\n     * Properties of a CMsgItemAcknowledged.\n     * @exports ICMsgItemAcknowledged\n     * @interface ICMsgItemAcknowledged\n     * @property {ICEconItemPreviewDataBlock|null} [iteminfo] CMsgItemAcknowledged iteminfo\n     */\n    /**\n     * Constructs a new CMsgItemAcknowledged.\n     * @exports CMsgItemAcknowledged\n     * @classdesc Represents a CMsgItemAcknowledged.\n     * @implements ICMsgItemAcknowledged\n     * @constructor\n     * @param {ICMsgItemAcknowledged=} [properties] Properties to set\n     */\n    function CMsgItemAcknowledged(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgItemAcknowledged iteminfo.\n     * @member {ICEconItemPreviewDataBlock|null|undefined} iteminfo\n     * @memberof CMsgItemAcknowledged\n     * @instance\n     */\n    CMsgItemAcknowledged.prototype.iteminfo = null;\n    /**\n     * Decodes a CMsgItemAcknowledged message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgItemAcknowledged\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgItemAcknowledged} CMsgItemAcknowledged\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgItemAcknowledged.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgItemAcknowledged();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.iteminfo = $root.CEconItemPreviewDataBlock.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgItemAcknowledged;\n})());\nexports.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest = ($root.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.\n     * @exports ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest\n     * @interface ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest\n     * @property {number|Long|null} [paramS] CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramS\n     * @property {number|Long|null} [paramA] CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramA\n     * @property {number|Long|null} [paramD] CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramD\n     * @property {number|Long|null} [paramM] CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramM\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.\n     * @exports CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest\n     * @classdesc Represents a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.\n     * @implements ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramS.\n     * @member {number|Long} paramS\n     * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest\n     * @instance\n     */\n    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.prototype.paramS = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramA.\n     * @member {number|Long} paramA\n     * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest\n     * @instance\n     */\n    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.prototype.paramA = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramD.\n     * @member {number|Long} paramD\n     * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest\n     * @instance\n     */\n    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.prototype.paramD = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest paramM.\n     * @member {number|Long} paramM\n     * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest\n     * @instance\n     */\n    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.prototype.paramM = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest} CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.paramS = reader.uint64();\n                    break;\n                case 2:\n                    message.paramA = reader.uint64();\n                    break;\n                case 3:\n                    message.paramD = reader.uint64();\n                    break;\n                case 4:\n                    message.paramM = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockRequest;\n})());\nexports.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse = ($root.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse.\n     * @exports ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse\n     * @interface ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse\n     * @property {ICEconItemPreviewDataBlock|null} [iteminfo] CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse iteminfo\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse.\n     * @exports CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse\n     * @classdesc Represents a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse.\n     * @implements ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse iteminfo.\n     * @member {ICEconItemPreviewDataBlock|null|undefined} iteminfo\n     * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse\n     * @instance\n     */\n    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse.prototype.iteminfo = null;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse} CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.iteminfo = $root.CEconItemPreviewDataBlock.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_Client2GCEconPreviewDataBlockResponse;\n})());\nexports.CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification = ($root.CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.\n     * @exports ICMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification\n     * @interface ICMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification\n     * @property {number|Long|null} [matchId] CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification matchId\n     * @property {number|null} [defindex] CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification defindex\n     * @property {Array.<number>|null} [accountids] CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification accountids\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.\n     * @exports CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification\n     * @classdesc Represents a CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.\n     * @implements ICMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification(properties) {\n        this.accountids = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification matchId.\n     * @member {number|Long} matchId\n     * @memberof CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification\n     * @instance\n     */\n    CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.prototype.matchId = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification defindex.\n     * @member {number} defindex\n     * @memberof CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification\n     * @instance\n     */\n    CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.prototype.defindex = 0;\n    /**\n     * CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification accountids.\n     * @member {Array.<number>} accountids\n     * @memberof CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification\n     * @instance\n     */\n    CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.prototype.accountids =\n        $util.emptyArray;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification} CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.matchId = reader.uint64();\n                    break;\n                case 2:\n                    message.defindex = reader.uint32();\n                    break;\n                case 3:\n                    if (!(message.accountids && message.accountids.length))\n                        message.accountids = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.accountids.push(reader.uint32());\n                    }\n                    else\n                        message.accountids.push(reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_TournamentMatchRewardDropsNotification;\n})());\nexports.CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames = ($root.CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames.\n     * @exports ICMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames\n     * @interface ICMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames.\n     * @exports CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames\n     * @classdesc Represents a CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames.\n     * @implements ICMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Decodes a CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames} CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_MatchListRequestCurrentLiveGames;\n})());\nexports.CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser = ($root.CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser.\n     * @exports ICMsgGCCStrike15_v2_MatchListRequestLiveGameForUser\n     * @interface ICMsgGCCStrike15_v2_MatchListRequestLiveGameForUser\n     * @property {number|null} [accountid] CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser accountid\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser.\n     * @exports CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser\n     * @classdesc Represents a CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser.\n     * @implements ICMsgGCCStrike15_v2_MatchListRequestLiveGameForUser\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_MatchListRequestLiveGameForUser=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser accountid.\n     * @member {number} accountid\n     * @memberof CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser.prototype.accountid = 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser} CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.accountid = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_MatchListRequestLiveGameForUser;\n})());\nexports.CMsgGCCStrike15_v2_MatchListRequestRecentUserGames = ($root.CMsgGCCStrike15_v2_MatchListRequestRecentUserGames = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_MatchListRequestRecentUserGames.\n     * @exports ICMsgGCCStrike15_v2_MatchListRequestRecentUserGames\n     * @interface ICMsgGCCStrike15_v2_MatchListRequestRecentUserGames\n     * @property {number|null} [accountid] CMsgGCCStrike15_v2_MatchListRequestRecentUserGames accountid\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_MatchListRequestRecentUserGames.\n     * @exports CMsgGCCStrike15_v2_MatchListRequestRecentUserGames\n     * @classdesc Represents a CMsgGCCStrike15_v2_MatchListRequestRecentUserGames.\n     * @implements ICMsgGCCStrike15_v2_MatchListRequestRecentUserGames\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_MatchListRequestRecentUserGames=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_MatchListRequestRecentUserGames(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_MatchListRequestRecentUserGames accountid.\n     * @member {number} accountid\n     * @memberof CMsgGCCStrike15_v2_MatchListRequestRecentUserGames\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchListRequestRecentUserGames.prototype.accountid = 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_MatchListRequestRecentUserGames message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchListRequestRecentUserGames\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchListRequestRecentUserGames} CMsgGCCStrike15_v2_MatchListRequestRecentUserGames\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_MatchListRequestRecentUserGames.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchListRequestRecentUserGames();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.accountid = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_MatchListRequestRecentUserGames;\n})());\nexports.CMsgGCCStrike15_v2_MatchListRequestTournamentGames = ($root.CMsgGCCStrike15_v2_MatchListRequestTournamentGames = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_MatchListRequestTournamentGames.\n     * @exports ICMsgGCCStrike15_v2_MatchListRequestTournamentGames\n     * @interface ICMsgGCCStrike15_v2_MatchListRequestTournamentGames\n     * @property {number|null} [eventid] CMsgGCCStrike15_v2_MatchListRequestTournamentGames eventid\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_MatchListRequestTournamentGames.\n     * @exports CMsgGCCStrike15_v2_MatchListRequestTournamentGames\n     * @classdesc Represents a CMsgGCCStrike15_v2_MatchListRequestTournamentGames.\n     * @implements ICMsgGCCStrike15_v2_MatchListRequestTournamentGames\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_MatchListRequestTournamentGames=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_MatchListRequestTournamentGames(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_MatchListRequestTournamentGames eventid.\n     * @member {number} eventid\n     * @memberof CMsgGCCStrike15_v2_MatchListRequestTournamentGames\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchListRequestTournamentGames.prototype.eventid = 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_MatchListRequestTournamentGames message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchListRequestTournamentGames\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchListRequestTournamentGames} CMsgGCCStrike15_v2_MatchListRequestTournamentGames\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_MatchListRequestTournamentGames.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchListRequestTournamentGames();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.eventid = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_MatchListRequestTournamentGames;\n})());\nexports.CMsgGCCStrike15_v2_MatchListRequestFullGameInfo = ($root.CMsgGCCStrike15_v2_MatchListRequestFullGameInfo = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.\n     * @exports ICMsgGCCStrike15_v2_MatchListRequestFullGameInfo\n     * @interface ICMsgGCCStrike15_v2_MatchListRequestFullGameInfo\n     * @property {number|Long|null} [matchid] CMsgGCCStrike15_v2_MatchListRequestFullGameInfo matchid\n     * @property {number|Long|null} [outcomeid] CMsgGCCStrike15_v2_MatchListRequestFullGameInfo outcomeid\n     * @property {number|null} [token] CMsgGCCStrike15_v2_MatchListRequestFullGameInfo token\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.\n     * @exports CMsgGCCStrike15_v2_MatchListRequestFullGameInfo\n     * @classdesc Represents a CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.\n     * @implements ICMsgGCCStrike15_v2_MatchListRequestFullGameInfo\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_MatchListRequestFullGameInfo=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_MatchListRequestFullGameInfo(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_MatchListRequestFullGameInfo matchid.\n     * @member {number|Long} matchid\n     * @memberof CMsgGCCStrike15_v2_MatchListRequestFullGameInfo\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.prototype.matchid = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchListRequestFullGameInfo outcomeid.\n     * @member {number|Long} outcomeid\n     * @memberof CMsgGCCStrike15_v2_MatchListRequestFullGameInfo\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.prototype.outcomeid = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchListRequestFullGameInfo token.\n     * @member {number} token\n     * @memberof CMsgGCCStrike15_v2_MatchListRequestFullGameInfo\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.prototype.token = 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_MatchListRequestFullGameInfo message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchListRequestFullGameInfo\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchListRequestFullGameInfo} CMsgGCCStrike15_v2_MatchListRequestFullGameInfo\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_MatchListRequestFullGameInfo.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchListRequestFullGameInfo();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.matchid = reader.uint64();\n                    break;\n                case 2:\n                    message.outcomeid = reader.uint64();\n                    break;\n                case 3:\n                    message.token = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_MatchListRequestFullGameInfo;\n})());\nexports.CDataGCCStrike15_v2_MatchInfo = ($root.CDataGCCStrike15_v2_MatchInfo = (() => {\n    /**\n     * Properties of a CDataGCCStrike15_v2_MatchInfo.\n     * @exports ICDataGCCStrike15_v2_MatchInfo\n     * @interface ICDataGCCStrike15_v2_MatchInfo\n     * @property {number|Long|null} [matchid] CDataGCCStrike15_v2_MatchInfo matchid\n     * @property {number|null} [matchtime] CDataGCCStrike15_v2_MatchInfo matchtime\n     * @property {IWatchableMatchInfo|null} [watchablematchinfo] CDataGCCStrike15_v2_MatchInfo watchablematchinfo\n     * @property {ICMsgGCCStrike15_v2_MatchmakingServerRoundStats|null} [roundstatsLegacy] CDataGCCStrike15_v2_MatchInfo roundstatsLegacy\n     * @property {Array.<ICMsgGCCStrike15_v2_MatchmakingServerRoundStats>|null} [roundstatsall] CDataGCCStrike15_v2_MatchInfo roundstatsall\n     */\n    /**\n     * Constructs a new CDataGCCStrike15_v2_MatchInfo.\n     * @exports CDataGCCStrike15_v2_MatchInfo\n     * @classdesc Represents a CDataGCCStrike15_v2_MatchInfo.\n     * @implements ICDataGCCStrike15_v2_MatchInfo\n     * @constructor\n     * @param {ICDataGCCStrike15_v2_MatchInfo=} [properties] Properties to set\n     */\n    function CDataGCCStrike15_v2_MatchInfo(properties) {\n        this.roundstatsall = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CDataGCCStrike15_v2_MatchInfo matchid.\n     * @member {number|Long} matchid\n     * @memberof CDataGCCStrike15_v2_MatchInfo\n     * @instance\n     */\n    CDataGCCStrike15_v2_MatchInfo.prototype.matchid = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CDataGCCStrike15_v2_MatchInfo matchtime.\n     * @member {number} matchtime\n     * @memberof CDataGCCStrike15_v2_MatchInfo\n     * @instance\n     */\n    CDataGCCStrike15_v2_MatchInfo.prototype.matchtime = 0;\n    /**\n     * CDataGCCStrike15_v2_MatchInfo watchablematchinfo.\n     * @member {IWatchableMatchInfo|null|undefined} watchablematchinfo\n     * @memberof CDataGCCStrike15_v2_MatchInfo\n     * @instance\n     */\n    CDataGCCStrike15_v2_MatchInfo.prototype.watchablematchinfo = null;\n    /**\n     * CDataGCCStrike15_v2_MatchInfo roundstatsLegacy.\n     * @member {ICMsgGCCStrike15_v2_MatchmakingServerRoundStats|null|undefined} roundstatsLegacy\n     * @memberof CDataGCCStrike15_v2_MatchInfo\n     * @instance\n     */\n    CDataGCCStrike15_v2_MatchInfo.prototype.roundstatsLegacy = null;\n    /**\n     * CDataGCCStrike15_v2_MatchInfo roundstatsall.\n     * @member {Array.<ICMsgGCCStrike15_v2_MatchmakingServerRoundStats>} roundstatsall\n     * @memberof CDataGCCStrike15_v2_MatchInfo\n     * @instance\n     */\n    CDataGCCStrike15_v2_MatchInfo.prototype.roundstatsall = $util.emptyArray;\n    /**\n     * Decodes a CDataGCCStrike15_v2_MatchInfo message from the specified reader or buffer.\n     * @function decode\n     * @memberof CDataGCCStrike15_v2_MatchInfo\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CDataGCCStrike15_v2_MatchInfo} CDataGCCStrike15_v2_MatchInfo\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CDataGCCStrike15_v2_MatchInfo.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDataGCCStrike15_v2_MatchInfo();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.matchid = reader.uint64();\n                    break;\n                case 2:\n                    message.matchtime = reader.uint32();\n                    break;\n                case 3:\n                    message.watchablematchinfo = $root.WatchableMatchInfo.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.roundstatsLegacy = $root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    if (!(message.roundstatsall && message.roundstatsall.length))\n                        message.roundstatsall = [];\n                    message.roundstatsall.push($root.CMsgGCCStrike15_v2_MatchmakingServerRoundStats.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CDataGCCStrike15_v2_MatchInfo;\n})());\nexports.CDataGCCStrike15_v2_TournamentGroupTeam = ($root.CDataGCCStrike15_v2_TournamentGroupTeam = (() => {\n    /**\n     * Properties of a CDataGCCStrike15_v2_TournamentGroupTeam.\n     * @exports ICDataGCCStrike15_v2_TournamentGroupTeam\n     * @interface ICDataGCCStrike15_v2_TournamentGroupTeam\n     * @property {number|null} [teamId] CDataGCCStrike15_v2_TournamentGroupTeam teamId\n     * @property {number|null} [score] CDataGCCStrike15_v2_TournamentGroupTeam score\n     * @property {boolean|null} [correctpick] CDataGCCStrike15_v2_TournamentGroupTeam correctpick\n     */\n    /**\n     * Constructs a new CDataGCCStrike15_v2_TournamentGroupTeam.\n     * @exports CDataGCCStrike15_v2_TournamentGroupTeam\n     * @classdesc Represents a CDataGCCStrike15_v2_TournamentGroupTeam.\n     * @implements ICDataGCCStrike15_v2_TournamentGroupTeam\n     * @constructor\n     * @param {ICDataGCCStrike15_v2_TournamentGroupTeam=} [properties] Properties to set\n     */\n    function CDataGCCStrike15_v2_TournamentGroupTeam(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CDataGCCStrike15_v2_TournamentGroupTeam teamId.\n     * @member {number} teamId\n     * @memberof CDataGCCStrike15_v2_TournamentGroupTeam\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentGroupTeam.prototype.teamId = 0;\n    /**\n     * CDataGCCStrike15_v2_TournamentGroupTeam score.\n     * @member {number} score\n     * @memberof CDataGCCStrike15_v2_TournamentGroupTeam\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentGroupTeam.prototype.score = 0;\n    /**\n     * CDataGCCStrike15_v2_TournamentGroupTeam correctpick.\n     * @member {boolean} correctpick\n     * @memberof CDataGCCStrike15_v2_TournamentGroupTeam\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentGroupTeam.prototype.correctpick = false;\n    /**\n     * Decodes a CDataGCCStrike15_v2_TournamentGroupTeam message from the specified reader or buffer.\n     * @function decode\n     * @memberof CDataGCCStrike15_v2_TournamentGroupTeam\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CDataGCCStrike15_v2_TournamentGroupTeam} CDataGCCStrike15_v2_TournamentGroupTeam\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CDataGCCStrike15_v2_TournamentGroupTeam.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDataGCCStrike15_v2_TournamentGroupTeam();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.teamId = reader.int32();\n                    break;\n                case 2:\n                    message.score = reader.int32();\n                    break;\n                case 3:\n                    message.correctpick = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CDataGCCStrike15_v2_TournamentGroupTeam;\n})());\nexports.CDataGCCStrike15_v2_TournamentGroup = ($root.CDataGCCStrike15_v2_TournamentGroup = (() => {\n    /**\n     * Properties of a CDataGCCStrike15_v2_TournamentGroup.\n     * @exports ICDataGCCStrike15_v2_TournamentGroup\n     * @interface ICDataGCCStrike15_v2_TournamentGroup\n     * @property {number|null} [groupid] CDataGCCStrike15_v2_TournamentGroup groupid\n     * @property {string|null} [name] CDataGCCStrike15_v2_TournamentGroup name\n     * @property {string|null} [desc] CDataGCCStrike15_v2_TournamentGroup desc\n     * @property {number|null} [picks_Deprecated] CDataGCCStrike15_v2_TournamentGroup picks_Deprecated\n     * @property {Array.<ICDataGCCStrike15_v2_TournamentGroupTeam>|null} [teams] CDataGCCStrike15_v2_TournamentGroup teams\n     * @property {Array.<number>|null} [stageIds] CDataGCCStrike15_v2_TournamentGroup stageIds\n     * @property {number|null} [picklockuntiltime] CDataGCCStrike15_v2_TournamentGroup picklockuntiltime\n     * @property {number|null} [pickableteams] CDataGCCStrike15_v2_TournamentGroup pickableteams\n     * @property {number|null} [pointsPerPick] CDataGCCStrike15_v2_TournamentGroup pointsPerPick\n     * @property {Array.<CDataGCCStrike15_v2_TournamentGroup.IPicks>|null} [picks] CDataGCCStrike15_v2_TournamentGroup picks\n     */\n    /**\n     * Constructs a new CDataGCCStrike15_v2_TournamentGroup.\n     * @exports CDataGCCStrike15_v2_TournamentGroup\n     * @classdesc Represents a CDataGCCStrike15_v2_TournamentGroup.\n     * @implements ICDataGCCStrike15_v2_TournamentGroup\n     * @constructor\n     * @param {ICDataGCCStrike15_v2_TournamentGroup=} [properties] Properties to set\n     */\n    function CDataGCCStrike15_v2_TournamentGroup(properties) {\n        this.teams = [];\n        this.stageIds = [];\n        this.picks = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CDataGCCStrike15_v2_TournamentGroup groupid.\n     * @member {number} groupid\n     * @memberof CDataGCCStrike15_v2_TournamentGroup\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentGroup.prototype.groupid = 0;\n    /**\n     * CDataGCCStrike15_v2_TournamentGroup name.\n     * @member {string} name\n     * @memberof CDataGCCStrike15_v2_TournamentGroup\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentGroup.prototype.name = \"\";\n    /**\n     * CDataGCCStrike15_v2_TournamentGroup desc.\n     * @member {string} desc\n     * @memberof CDataGCCStrike15_v2_TournamentGroup\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentGroup.prototype.desc = \"\";\n    /**\n     * CDataGCCStrike15_v2_TournamentGroup picks_Deprecated.\n     * @member {number} picks_Deprecated\n     * @memberof CDataGCCStrike15_v2_TournamentGroup\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentGroup.prototype.picks_Deprecated = 0;\n    /**\n     * CDataGCCStrike15_v2_TournamentGroup teams.\n     * @member {Array.<ICDataGCCStrike15_v2_TournamentGroupTeam>} teams\n     * @memberof CDataGCCStrike15_v2_TournamentGroup\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentGroup.prototype.teams = $util.emptyArray;\n    /**\n     * CDataGCCStrike15_v2_TournamentGroup stageIds.\n     * @member {Array.<number>} stageIds\n     * @memberof CDataGCCStrike15_v2_TournamentGroup\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentGroup.prototype.stageIds = $util.emptyArray;\n    /**\n     * CDataGCCStrike15_v2_TournamentGroup picklockuntiltime.\n     * @member {number} picklockuntiltime\n     * @memberof CDataGCCStrike15_v2_TournamentGroup\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentGroup.prototype.picklockuntiltime = 0;\n    /**\n     * CDataGCCStrike15_v2_TournamentGroup pickableteams.\n     * @member {number} pickableteams\n     * @memberof CDataGCCStrike15_v2_TournamentGroup\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentGroup.prototype.pickableteams = 0;\n    /**\n     * CDataGCCStrike15_v2_TournamentGroup pointsPerPick.\n     * @member {number} pointsPerPick\n     * @memberof CDataGCCStrike15_v2_TournamentGroup\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentGroup.prototype.pointsPerPick = 0;\n    /**\n     * CDataGCCStrike15_v2_TournamentGroup picks.\n     * @member {Array.<CDataGCCStrike15_v2_TournamentGroup.IPicks>} picks\n     * @memberof CDataGCCStrike15_v2_TournamentGroup\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentGroup.prototype.picks = $util.emptyArray;\n    /**\n     * Decodes a CDataGCCStrike15_v2_TournamentGroup message from the specified reader or buffer.\n     * @function decode\n     * @memberof CDataGCCStrike15_v2_TournamentGroup\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CDataGCCStrike15_v2_TournamentGroup} CDataGCCStrike15_v2_TournamentGroup\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CDataGCCStrike15_v2_TournamentGroup.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDataGCCStrike15_v2_TournamentGroup();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.groupid = reader.uint32();\n                    break;\n                case 2:\n                    message.name = reader.string();\n                    break;\n                case 3:\n                    message.desc = reader.string();\n                    break;\n                case 4:\n                    message.picks_Deprecated = reader.uint32();\n                    break;\n                case 5:\n                    if (!(message.teams && message.teams.length))\n                        message.teams = [];\n                    message.teams.push($root.CDataGCCStrike15_v2_TournamentGroupTeam.decode(reader, reader.uint32()));\n                    break;\n                case 6:\n                    if (!(message.stageIds && message.stageIds.length))\n                        message.stageIds = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.stageIds.push(reader.int32());\n                    }\n                    else\n                        message.stageIds.push(reader.int32());\n                    break;\n                case 7:\n                    message.picklockuntiltime = reader.uint32();\n                    break;\n                case 8:\n                    message.pickableteams = reader.uint32();\n                    break;\n                case 9:\n                    message.pointsPerPick = reader.uint32();\n                    break;\n                case 10:\n                    if (!(message.picks && message.picks.length))\n                        message.picks = [];\n                    message.picks.push($root.CDataGCCStrike15_v2_TournamentGroup.Picks.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CDataGCCStrike15_v2_TournamentGroup.Picks = (function () {\n        /**\n         * Properties of a Picks.\n         * @memberof CDataGCCStrike15_v2_TournamentGroup\n         * @interface IPicks\n         * @property {Array.<number>|null} [pickids] Picks pickids\n         */\n        /**\n         * Constructs a new Picks.\n         * @memberof CDataGCCStrike15_v2_TournamentGroup\n         * @classdesc Represents a Picks.\n         * @implements IPicks\n         * @constructor\n         * @param {CDataGCCStrike15_v2_TournamentGroup.IPicks=} [properties] Properties to set\n         */\n        function Picks(properties) {\n            this.pickids = [];\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * Picks pickids.\n         * @member {Array.<number>} pickids\n         * @memberof CDataGCCStrike15_v2_TournamentGroup.Picks\n         * @instance\n         */\n        Picks.prototype.pickids = $util.emptyArray;\n        /**\n         * Decodes a Picks message from the specified reader or buffer.\n         * @function decode\n         * @memberof CDataGCCStrike15_v2_TournamentGroup.Picks\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CDataGCCStrike15_v2_TournamentGroup.Picks} Picks\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Picks.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDataGCCStrike15_v2_TournamentGroup.Picks();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        if (!(message.pickids && message.pickids.length))\n                            message.pickids = [];\n                        if ((tag & 7) === 2) {\n                            let end2 = reader.uint32() + reader.pos;\n                            while (reader.pos < end2)\n                                message.pickids.push(reader.int32());\n                        }\n                        else\n                            message.pickids.push(reader.int32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return Picks;\n    })();\n    return CDataGCCStrike15_v2_TournamentGroup;\n})());\nexports.CDataGCCStrike15_v2_TournamentSection = ($root.CDataGCCStrike15_v2_TournamentSection = (() => {\n    /**\n     * Properties of a CDataGCCStrike15_v2_TournamentSection.\n     * @exports ICDataGCCStrike15_v2_TournamentSection\n     * @interface ICDataGCCStrike15_v2_TournamentSection\n     * @property {number|null} [sectionid] CDataGCCStrike15_v2_TournamentSection sectionid\n     * @property {string|null} [name] CDataGCCStrike15_v2_TournamentSection name\n     * @property {string|null} [desc] CDataGCCStrike15_v2_TournamentSection desc\n     * @property {Array.<ICDataGCCStrike15_v2_TournamentGroup>|null} [groups] CDataGCCStrike15_v2_TournamentSection groups\n     */\n    /**\n     * Constructs a new CDataGCCStrike15_v2_TournamentSection.\n     * @exports CDataGCCStrike15_v2_TournamentSection\n     * @classdesc Represents a CDataGCCStrike15_v2_TournamentSection.\n     * @implements ICDataGCCStrike15_v2_TournamentSection\n     * @constructor\n     * @param {ICDataGCCStrike15_v2_TournamentSection=} [properties] Properties to set\n     */\n    function CDataGCCStrike15_v2_TournamentSection(properties) {\n        this.groups = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CDataGCCStrike15_v2_TournamentSection sectionid.\n     * @member {number} sectionid\n     * @memberof CDataGCCStrike15_v2_TournamentSection\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentSection.prototype.sectionid = 0;\n    /**\n     * CDataGCCStrike15_v2_TournamentSection name.\n     * @member {string} name\n     * @memberof CDataGCCStrike15_v2_TournamentSection\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentSection.prototype.name = \"\";\n    /**\n     * CDataGCCStrike15_v2_TournamentSection desc.\n     * @member {string} desc\n     * @memberof CDataGCCStrike15_v2_TournamentSection\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentSection.prototype.desc = \"\";\n    /**\n     * CDataGCCStrike15_v2_TournamentSection groups.\n     * @member {Array.<ICDataGCCStrike15_v2_TournamentGroup>} groups\n     * @memberof CDataGCCStrike15_v2_TournamentSection\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentSection.prototype.groups = $util.emptyArray;\n    /**\n     * Decodes a CDataGCCStrike15_v2_TournamentSection message from the specified reader or buffer.\n     * @function decode\n     * @memberof CDataGCCStrike15_v2_TournamentSection\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CDataGCCStrike15_v2_TournamentSection} CDataGCCStrike15_v2_TournamentSection\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CDataGCCStrike15_v2_TournamentSection.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDataGCCStrike15_v2_TournamentSection();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.sectionid = reader.uint32();\n                    break;\n                case 2:\n                    message.name = reader.string();\n                    break;\n                case 3:\n                    message.desc = reader.string();\n                    break;\n                case 4:\n                    if (!(message.groups && message.groups.length))\n                        message.groups = [];\n                    message.groups.push($root.CDataGCCStrike15_v2_TournamentGroup.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CDataGCCStrike15_v2_TournamentSection;\n})());\nexports.CDataGCCStrike15_v2_TournamentInfo = ($root.CDataGCCStrike15_v2_TournamentInfo = (() => {\n    /**\n     * Properties of a CDataGCCStrike15_v2_TournamentInfo.\n     * @exports ICDataGCCStrike15_v2_TournamentInfo\n     * @interface ICDataGCCStrike15_v2_TournamentInfo\n     * @property {Array.<ICDataGCCStrike15_v2_TournamentSection>|null} [sections] CDataGCCStrike15_v2_TournamentInfo sections\n     * @property {ITournamentEvent|null} [tournamentEvent] CDataGCCStrike15_v2_TournamentInfo tournamentEvent\n     * @property {Array.<ITournamentTeam>|null} [tournamentTeams] CDataGCCStrike15_v2_TournamentInfo tournamentTeams\n     */\n    /**\n     * Constructs a new CDataGCCStrike15_v2_TournamentInfo.\n     * @exports CDataGCCStrike15_v2_TournamentInfo\n     * @classdesc Represents a CDataGCCStrike15_v2_TournamentInfo.\n     * @implements ICDataGCCStrike15_v2_TournamentInfo\n     * @constructor\n     * @param {ICDataGCCStrike15_v2_TournamentInfo=} [properties] Properties to set\n     */\n    function CDataGCCStrike15_v2_TournamentInfo(properties) {\n        this.sections = [];\n        this.tournamentTeams = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CDataGCCStrike15_v2_TournamentInfo sections.\n     * @member {Array.<ICDataGCCStrike15_v2_TournamentSection>} sections\n     * @memberof CDataGCCStrike15_v2_TournamentInfo\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentInfo.prototype.sections = $util.emptyArray;\n    /**\n     * CDataGCCStrike15_v2_TournamentInfo tournamentEvent.\n     * @member {ITournamentEvent|null|undefined} tournamentEvent\n     * @memberof CDataGCCStrike15_v2_TournamentInfo\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentInfo.prototype.tournamentEvent = null;\n    /**\n     * CDataGCCStrike15_v2_TournamentInfo tournamentTeams.\n     * @member {Array.<ITournamentTeam>} tournamentTeams\n     * @memberof CDataGCCStrike15_v2_TournamentInfo\n     * @instance\n     */\n    CDataGCCStrike15_v2_TournamentInfo.prototype.tournamentTeams =\n        $util.emptyArray;\n    /**\n     * Decodes a CDataGCCStrike15_v2_TournamentInfo message from the specified reader or buffer.\n     * @function decode\n     * @memberof CDataGCCStrike15_v2_TournamentInfo\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CDataGCCStrike15_v2_TournamentInfo} CDataGCCStrike15_v2_TournamentInfo\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CDataGCCStrike15_v2_TournamentInfo.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CDataGCCStrike15_v2_TournamentInfo();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.sections && message.sections.length))\n                        message.sections = [];\n                    message.sections.push($root.CDataGCCStrike15_v2_TournamentSection.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.tournamentEvent = $root.TournamentEvent.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    if (!(message.tournamentTeams && message.tournamentTeams.length))\n                        message.tournamentTeams = [];\n                    message.tournamentTeams.push($root.TournamentTeam.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CDataGCCStrike15_v2_TournamentInfo;\n})());\nexports.CMsgGCCStrike15_v2_MatchList = ($root.CMsgGCCStrike15_v2_MatchList = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_MatchList.\n     * @exports ICMsgGCCStrike15_v2_MatchList\n     * @interface ICMsgGCCStrike15_v2_MatchList\n     * @property {number|null} [msgrequestid] CMsgGCCStrike15_v2_MatchList msgrequestid\n     * @property {number|null} [accountid] CMsgGCCStrike15_v2_MatchList accountid\n     * @property {number|null} [servertime] CMsgGCCStrike15_v2_MatchList servertime\n     * @property {Array.<ICDataGCCStrike15_v2_MatchInfo>|null} [matches] CMsgGCCStrike15_v2_MatchList matches\n     * @property {Array.<ITournamentTeam>|null} [streams] CMsgGCCStrike15_v2_MatchList streams\n     * @property {ICDataGCCStrike15_v2_TournamentInfo|null} [tournamentinfo] CMsgGCCStrike15_v2_MatchList tournamentinfo\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_MatchList.\n     * @exports CMsgGCCStrike15_v2_MatchList\n     * @classdesc Represents a CMsgGCCStrike15_v2_MatchList.\n     * @implements ICMsgGCCStrike15_v2_MatchList\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_MatchList=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_MatchList(properties) {\n        this.matches = [];\n        this.streams = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_MatchList msgrequestid.\n     * @member {number} msgrequestid\n     * @memberof CMsgGCCStrike15_v2_MatchList\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchList.prototype.msgrequestid = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchList accountid.\n     * @member {number} accountid\n     * @memberof CMsgGCCStrike15_v2_MatchList\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchList.prototype.accountid = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchList servertime.\n     * @member {number} servertime\n     * @memberof CMsgGCCStrike15_v2_MatchList\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchList.prototype.servertime = 0;\n    /**\n     * CMsgGCCStrike15_v2_MatchList matches.\n     * @member {Array.<ICDataGCCStrike15_v2_MatchInfo>} matches\n     * @memberof CMsgGCCStrike15_v2_MatchList\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchList.prototype.matches = $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchList streams.\n     * @member {Array.<ITournamentTeam>} streams\n     * @memberof CMsgGCCStrike15_v2_MatchList\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchList.prototype.streams = $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_MatchList tournamentinfo.\n     * @member {ICDataGCCStrike15_v2_TournamentInfo|null|undefined} tournamentinfo\n     * @memberof CMsgGCCStrike15_v2_MatchList\n     * @instance\n     */\n    CMsgGCCStrike15_v2_MatchList.prototype.tournamentinfo = null;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_MatchList message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_MatchList\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_MatchList} CMsgGCCStrike15_v2_MatchList\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_MatchList.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_MatchList();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.msgrequestid = reader.uint32();\n                    break;\n                case 2:\n                    message.accountid = reader.uint32();\n                    break;\n                case 3:\n                    message.servertime = reader.uint32();\n                    break;\n                case 4:\n                    if (!(message.matches && message.matches.length))\n                        message.matches = [];\n                    message.matches.push($root.CDataGCCStrike15_v2_MatchInfo.decode(reader, reader.uint32()));\n                    break;\n                case 5:\n                    if (!(message.streams && message.streams.length))\n                        message.streams = [];\n                    message.streams.push($root.TournamentTeam.decode(reader, reader.uint32()));\n                    break;\n                case 6:\n                    message.tournamentinfo = $root.CDataGCCStrike15_v2_TournamentInfo.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_MatchList;\n})());\nexports.CMsgGCCStrike15_v2_Predictions = ($root.CMsgGCCStrike15_v2_Predictions = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_Predictions.\n     * @exports ICMsgGCCStrike15_v2_Predictions\n     * @interface ICMsgGCCStrike15_v2_Predictions\n     * @property {number|null} [eventId] CMsgGCCStrike15_v2_Predictions eventId\n     * @property {Array.<CMsgGCCStrike15_v2_Predictions.IGroupMatchTeamPick>|null} [groupMatchTeamPicks] CMsgGCCStrike15_v2_Predictions groupMatchTeamPicks\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_Predictions.\n     * @exports CMsgGCCStrike15_v2_Predictions\n     * @classdesc Represents a CMsgGCCStrike15_v2_Predictions.\n     * @implements ICMsgGCCStrike15_v2_Predictions\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_Predictions=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_Predictions(properties) {\n        this.groupMatchTeamPicks = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_Predictions eventId.\n     * @member {number} eventId\n     * @memberof CMsgGCCStrike15_v2_Predictions\n     * @instance\n     */\n    CMsgGCCStrike15_v2_Predictions.prototype.eventId = 0;\n    /**\n     * CMsgGCCStrike15_v2_Predictions groupMatchTeamPicks.\n     * @member {Array.<CMsgGCCStrike15_v2_Predictions.IGroupMatchTeamPick>} groupMatchTeamPicks\n     * @memberof CMsgGCCStrike15_v2_Predictions\n     * @instance\n     */\n    CMsgGCCStrike15_v2_Predictions.prototype.groupMatchTeamPicks =\n        $util.emptyArray;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_Predictions message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_Predictions\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_Predictions} CMsgGCCStrike15_v2_Predictions\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_Predictions.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Predictions();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.eventId = reader.uint32();\n                    break;\n                case 2:\n                    if (!(message.groupMatchTeamPicks && message.groupMatchTeamPicks.length))\n                        message.groupMatchTeamPicks = [];\n                    message.groupMatchTeamPicks.push($root.CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick = (function () {\n        /**\n         * Properties of a GroupMatchTeamPick.\n         * @memberof CMsgGCCStrike15_v2_Predictions\n         * @interface IGroupMatchTeamPick\n         * @property {number|null} [sectionid] GroupMatchTeamPick sectionid\n         * @property {number|null} [groupid] GroupMatchTeamPick groupid\n         * @property {number|null} [index] GroupMatchTeamPick index\n         * @property {number|null} [teamid] GroupMatchTeamPick teamid\n         * @property {number|Long|null} [itemid] GroupMatchTeamPick itemid\n         */\n        /**\n         * Constructs a new GroupMatchTeamPick.\n         * @memberof CMsgGCCStrike15_v2_Predictions\n         * @classdesc Represents a GroupMatchTeamPick.\n         * @implements IGroupMatchTeamPick\n         * @constructor\n         * @param {CMsgGCCStrike15_v2_Predictions.IGroupMatchTeamPick=} [properties] Properties to set\n         */\n        function GroupMatchTeamPick(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * GroupMatchTeamPick sectionid.\n         * @member {number} sectionid\n         * @memberof CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick\n         * @instance\n         */\n        GroupMatchTeamPick.prototype.sectionid = 0;\n        /**\n         * GroupMatchTeamPick groupid.\n         * @member {number} groupid\n         * @memberof CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick\n         * @instance\n         */\n        GroupMatchTeamPick.prototype.groupid = 0;\n        /**\n         * GroupMatchTeamPick index.\n         * @member {number} index\n         * @memberof CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick\n         * @instance\n         */\n        GroupMatchTeamPick.prototype.index = 0;\n        /**\n         * GroupMatchTeamPick teamid.\n         * @member {number} teamid\n         * @memberof CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick\n         * @instance\n         */\n        GroupMatchTeamPick.prototype.teamid = 0;\n        /**\n         * GroupMatchTeamPick itemid.\n         * @member {number|Long} itemid\n         * @memberof CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick\n         * @instance\n         */\n        GroupMatchTeamPick.prototype.itemid = $util.Long\n            ? $util.Long.fromBits(0, 0, true)\n            : 0;\n        /**\n         * Decodes a GroupMatchTeamPick message from the specified reader or buffer.\n         * @function decode\n         * @memberof CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick} GroupMatchTeamPick\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        GroupMatchTeamPick.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Predictions.GroupMatchTeamPick();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.sectionid = reader.int32();\n                        break;\n                    case 2:\n                        message.groupid = reader.int32();\n                        break;\n                    case 3:\n                        message.index = reader.int32();\n                        break;\n                    case 4:\n                        message.teamid = reader.int32();\n                        break;\n                    case 5:\n                        message.itemid = reader.uint64();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return GroupMatchTeamPick;\n    })();\n    return CMsgGCCStrike15_v2_Predictions;\n})());\nexports.CMsgGCCStrike15_v2_Fantasy = ($root.CMsgGCCStrike15_v2_Fantasy = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_Fantasy.\n     * @exports ICMsgGCCStrike15_v2_Fantasy\n     * @interface ICMsgGCCStrike15_v2_Fantasy\n     * @property {number|null} [eventId] CMsgGCCStrike15_v2_Fantasy eventId\n     * @property {Array.<CMsgGCCStrike15_v2_Fantasy.IFantasyTeam>|null} [teams] CMsgGCCStrike15_v2_Fantasy teams\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_Fantasy.\n     * @exports CMsgGCCStrike15_v2_Fantasy\n     * @classdesc Represents a CMsgGCCStrike15_v2_Fantasy.\n     * @implements ICMsgGCCStrike15_v2_Fantasy\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_Fantasy=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_Fantasy(properties) {\n        this.teams = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_Fantasy eventId.\n     * @member {number} eventId\n     * @memberof CMsgGCCStrike15_v2_Fantasy\n     * @instance\n     */\n    CMsgGCCStrike15_v2_Fantasy.prototype.eventId = 0;\n    /**\n     * CMsgGCCStrike15_v2_Fantasy teams.\n     * @member {Array.<CMsgGCCStrike15_v2_Fantasy.IFantasyTeam>} teams\n     * @memberof CMsgGCCStrike15_v2_Fantasy\n     * @instance\n     */\n    CMsgGCCStrike15_v2_Fantasy.prototype.teams = $util.emptyArray;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_Fantasy message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_Fantasy\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_Fantasy} CMsgGCCStrike15_v2_Fantasy\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_Fantasy.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Fantasy();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.eventId = reader.uint32();\n                    break;\n                case 2:\n                    if (!(message.teams && message.teams.length))\n                        message.teams = [];\n                    message.teams.push($root.CMsgGCCStrike15_v2_Fantasy.FantasyTeam.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CMsgGCCStrike15_v2_Fantasy.FantasySlot = (function () {\n        /**\n         * Properties of a FantasySlot.\n         * @memberof CMsgGCCStrike15_v2_Fantasy\n         * @interface IFantasySlot\n         * @property {number|null} [type] FantasySlot type\n         * @property {number|null} [pick] FantasySlot pick\n         * @property {number|Long|null} [itemid] FantasySlot itemid\n         */\n        /**\n         * Constructs a new FantasySlot.\n         * @memberof CMsgGCCStrike15_v2_Fantasy\n         * @classdesc Represents a FantasySlot.\n         * @implements IFantasySlot\n         * @constructor\n         * @param {CMsgGCCStrike15_v2_Fantasy.IFantasySlot=} [properties] Properties to set\n         */\n        function FantasySlot(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * FantasySlot type.\n         * @member {number} type\n         * @memberof CMsgGCCStrike15_v2_Fantasy.FantasySlot\n         * @instance\n         */\n        FantasySlot.prototype.type = 0;\n        /**\n         * FantasySlot pick.\n         * @member {number} pick\n         * @memberof CMsgGCCStrike15_v2_Fantasy.FantasySlot\n         * @instance\n         */\n        FantasySlot.prototype.pick = 0;\n        /**\n         * FantasySlot itemid.\n         * @member {number|Long} itemid\n         * @memberof CMsgGCCStrike15_v2_Fantasy.FantasySlot\n         * @instance\n         */\n        FantasySlot.prototype.itemid = $util.Long\n            ? $util.Long.fromBits(0, 0, true)\n            : 0;\n        /**\n         * Decodes a FantasySlot message from the specified reader or buffer.\n         * @function decode\n         * @memberof CMsgGCCStrike15_v2_Fantasy.FantasySlot\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CMsgGCCStrike15_v2_Fantasy.FantasySlot} FantasySlot\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        FantasySlot.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Fantasy.FantasySlot();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.type = reader.int32();\n                        break;\n                    case 2:\n                        message.pick = reader.int32();\n                        break;\n                    case 3:\n                        message.itemid = reader.uint64();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return FantasySlot;\n    })();\n    CMsgGCCStrike15_v2_Fantasy.FantasyTeam = (function () {\n        /**\n         * Properties of a FantasyTeam.\n         * @memberof CMsgGCCStrike15_v2_Fantasy\n         * @interface IFantasyTeam\n         * @property {number|null} [sectionid] FantasyTeam sectionid\n         * @property {Array.<CMsgGCCStrike15_v2_Fantasy.IFantasySlot>|null} [slots] FantasyTeam slots\n         */\n        /**\n         * Constructs a new FantasyTeam.\n         * @memberof CMsgGCCStrike15_v2_Fantasy\n         * @classdesc Represents a FantasyTeam.\n         * @implements IFantasyTeam\n         * @constructor\n         * @param {CMsgGCCStrike15_v2_Fantasy.IFantasyTeam=} [properties] Properties to set\n         */\n        function FantasyTeam(properties) {\n            this.slots = [];\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * FantasyTeam sectionid.\n         * @member {number} sectionid\n         * @memberof CMsgGCCStrike15_v2_Fantasy.FantasyTeam\n         * @instance\n         */\n        FantasyTeam.prototype.sectionid = 0;\n        /**\n         * FantasyTeam slots.\n         * @member {Array.<CMsgGCCStrike15_v2_Fantasy.IFantasySlot>} slots\n         * @memberof CMsgGCCStrike15_v2_Fantasy.FantasyTeam\n         * @instance\n         */\n        FantasyTeam.prototype.slots = $util.emptyArray;\n        /**\n         * Decodes a FantasyTeam message from the specified reader or buffer.\n         * @function decode\n         * @memberof CMsgGCCStrike15_v2_Fantasy.FantasyTeam\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CMsgGCCStrike15_v2_Fantasy.FantasyTeam} FantasyTeam\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        FantasyTeam.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Fantasy.FantasyTeam();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.sectionid = reader.int32();\n                        break;\n                    case 2:\n                        if (!(message.slots && message.slots.length))\n                            message.slots = [];\n                        message.slots.push($root.CMsgGCCStrike15_v2_Fantasy.FantasySlot.decode(reader, reader.uint32()));\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return FantasyTeam;\n    })();\n    return CMsgGCCStrike15_v2_Fantasy;\n})());\nexports.CAttribute_String = ($root.CAttribute_String = (() => {\n    /**\n     * Properties of a CAttribute_String.\n     * @exports ICAttribute_String\n     * @interface ICAttribute_String\n     * @property {string|null} [value] CAttribute_String value\n     */\n    /**\n     * Constructs a new CAttribute_String.\n     * @exports CAttribute_String\n     * @classdesc Represents a CAttribute_String.\n     * @implements ICAttribute_String\n     * @constructor\n     * @param {ICAttribute_String=} [properties] Properties to set\n     */\n    function CAttribute_String(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CAttribute_String value.\n     * @member {string} value\n     * @memberof CAttribute_String\n     * @instance\n     */\n    CAttribute_String.prototype.value = \"\";\n    /**\n     * Decodes a CAttribute_String message from the specified reader or buffer.\n     * @function decode\n     * @memberof CAttribute_String\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CAttribute_String} CAttribute_String\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CAttribute_String.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CAttribute_String();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.value = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CAttribute_String;\n})());\nexports.CMsgGCToGCReloadVersions = ($root.CMsgGCToGCReloadVersions = (() => {\n    /**\n     * Properties of a CMsgGCToGCReloadVersions.\n     * @exports ICMsgGCToGCReloadVersions\n     * @interface ICMsgGCToGCReloadVersions\n     */\n    /**\n     * Constructs a new CMsgGCToGCReloadVersions.\n     * @exports CMsgGCToGCReloadVersions\n     * @classdesc Represents a CMsgGCToGCReloadVersions.\n     * @implements ICMsgGCToGCReloadVersions\n     * @constructor\n     * @param {ICMsgGCToGCReloadVersions=} [properties] Properties to set\n     */\n    function CMsgGCToGCReloadVersions(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Decodes a CMsgGCToGCReloadVersions message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCToGCReloadVersions\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCToGCReloadVersions} CMsgGCToGCReloadVersions\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCToGCReloadVersions.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCToGCReloadVersions();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCToGCReloadVersions;\n})());\nexports.CMsgCStrike15Welcome = ($root.CMsgCStrike15Welcome = (() => {\n    /**\n     * Properties of a CMsgCStrike15Welcome.\n     * @exports ICMsgCStrike15Welcome\n     * @interface ICMsgCStrike15Welcome\n     * @property {number|null} [storeItemHash] CMsgCStrike15Welcome storeItemHash\n     * @property {number|null} [timeplayedconsecutively] CMsgCStrike15Welcome timeplayedconsecutively\n     * @property {number|null} [timeFirstPlayed] CMsgCStrike15Welcome timeFirstPlayed\n     * @property {number|null} [lastTimePlayed] CMsgCStrike15Welcome lastTimePlayed\n     * @property {number|null} [lastIpAddress] CMsgCStrike15Welcome lastIpAddress\n     * @property {number|Long|null} [gscookieid] CMsgCStrike15Welcome gscookieid\n     * @property {number|Long|null} [uniqueid] CMsgCStrike15Welcome uniqueid\n     */\n    /**\n     * Constructs a new CMsgCStrike15Welcome.\n     * @exports CMsgCStrike15Welcome\n     * @classdesc Represents a CMsgCStrike15Welcome.\n     * @implements ICMsgCStrike15Welcome\n     * @constructor\n     * @param {ICMsgCStrike15Welcome=} [properties] Properties to set\n     */\n    function CMsgCStrike15Welcome(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgCStrike15Welcome storeItemHash.\n     * @member {number} storeItemHash\n     * @memberof CMsgCStrike15Welcome\n     * @instance\n     */\n    CMsgCStrike15Welcome.prototype.storeItemHash = 0;\n    /**\n     * CMsgCStrike15Welcome timeplayedconsecutively.\n     * @member {number} timeplayedconsecutively\n     * @memberof CMsgCStrike15Welcome\n     * @instance\n     */\n    CMsgCStrike15Welcome.prototype.timeplayedconsecutively = 0;\n    /**\n     * CMsgCStrike15Welcome timeFirstPlayed.\n     * @member {number} timeFirstPlayed\n     * @memberof CMsgCStrike15Welcome\n     * @instance\n     */\n    CMsgCStrike15Welcome.prototype.timeFirstPlayed = 0;\n    /**\n     * CMsgCStrike15Welcome lastTimePlayed.\n     * @member {number} lastTimePlayed\n     * @memberof CMsgCStrike15Welcome\n     * @instance\n     */\n    CMsgCStrike15Welcome.prototype.lastTimePlayed = 0;\n    /**\n     * CMsgCStrike15Welcome lastIpAddress.\n     * @member {number} lastIpAddress\n     * @memberof CMsgCStrike15Welcome\n     * @instance\n     */\n    CMsgCStrike15Welcome.prototype.lastIpAddress = 0;\n    /**\n     * CMsgCStrike15Welcome gscookieid.\n     * @member {number|Long} gscookieid\n     * @memberof CMsgCStrike15Welcome\n     * @instance\n     */\n    CMsgCStrike15Welcome.prototype.gscookieid = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgCStrike15Welcome uniqueid.\n     * @member {number|Long} uniqueid\n     * @memberof CMsgCStrike15Welcome\n     * @instance\n     */\n    CMsgCStrike15Welcome.prototype.uniqueid = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * Decodes a CMsgCStrike15Welcome message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgCStrike15Welcome\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgCStrike15Welcome} CMsgCStrike15Welcome\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgCStrike15Welcome.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgCStrike15Welcome();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 5:\n                    message.storeItemHash = reader.uint32();\n                    break;\n                case 6:\n                    message.timeplayedconsecutively = reader.uint32();\n                    break;\n                case 10:\n                    message.timeFirstPlayed = reader.uint32();\n                    break;\n                case 12:\n                    message.lastTimePlayed = reader.uint32();\n                    break;\n                case 13:\n                    message.lastIpAddress = reader.uint32();\n                    break;\n                case 18:\n                    message.gscookieid = reader.uint64();\n                    break;\n                case 19:\n                    message.uniqueid = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgCStrike15Welcome;\n})());\nexports.CMsgGCCStrike15_v2_ClientVarValueNotificationInfo = ($root.CMsgGCCStrike15_v2_ClientVarValueNotificationInfo = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.\n     * @exports ICMsgGCCStrike15_v2_ClientVarValueNotificationInfo\n     * @interface ICMsgGCCStrike15_v2_ClientVarValueNotificationInfo\n     * @property {string|null} [valueName] CMsgGCCStrike15_v2_ClientVarValueNotificationInfo valueName\n     * @property {number|null} [valueInt] CMsgGCCStrike15_v2_ClientVarValueNotificationInfo valueInt\n     * @property {number|null} [serverAddr] CMsgGCCStrike15_v2_ClientVarValueNotificationInfo serverAddr\n     * @property {number|null} [serverPort] CMsgGCCStrike15_v2_ClientVarValueNotificationInfo serverPort\n     * @property {Array.<string>|null} [chokedBlocks] CMsgGCCStrike15_v2_ClientVarValueNotificationInfo chokedBlocks\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.\n     * @exports CMsgGCCStrike15_v2_ClientVarValueNotificationInfo\n     * @classdesc Represents a CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.\n     * @implements ICMsgGCCStrike15_v2_ClientVarValueNotificationInfo\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_ClientVarValueNotificationInfo=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_ClientVarValueNotificationInfo(properties) {\n        this.chokedBlocks = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_ClientVarValueNotificationInfo valueName.\n     * @member {string} valueName\n     * @memberof CMsgGCCStrike15_v2_ClientVarValueNotificationInfo\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.prototype.valueName = \"\";\n    /**\n     * CMsgGCCStrike15_v2_ClientVarValueNotificationInfo valueInt.\n     * @member {number} valueInt\n     * @memberof CMsgGCCStrike15_v2_ClientVarValueNotificationInfo\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.prototype.valueInt = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientVarValueNotificationInfo serverAddr.\n     * @member {number} serverAddr\n     * @memberof CMsgGCCStrike15_v2_ClientVarValueNotificationInfo\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.prototype.serverAddr = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientVarValueNotificationInfo serverPort.\n     * @member {number} serverPort\n     * @memberof CMsgGCCStrike15_v2_ClientVarValueNotificationInfo\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.prototype.serverPort = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientVarValueNotificationInfo chokedBlocks.\n     * @member {Array.<string>} chokedBlocks\n     * @memberof CMsgGCCStrike15_v2_ClientVarValueNotificationInfo\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.prototype.chokedBlocks =\n        $util.emptyArray;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_ClientVarValueNotificationInfo message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_ClientVarValueNotificationInfo\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_ClientVarValueNotificationInfo} CMsgGCCStrike15_v2_ClientVarValueNotificationInfo\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_ClientVarValueNotificationInfo.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientVarValueNotificationInfo();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.valueName = reader.string();\n                    break;\n                case 2:\n                    message.valueInt = reader.int32();\n                    break;\n                case 3:\n                    message.serverAddr = reader.uint32();\n                    break;\n                case 4:\n                    message.serverPort = reader.uint32();\n                    break;\n                case 5:\n                    if (!(message.chokedBlocks && message.chokedBlocks.length))\n                        message.chokedBlocks = [];\n                    message.chokedBlocks.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_ClientVarValueNotificationInfo;\n})());\nexports.CMsgGCCStrike15_v2_ServerVarValueNotificationInfo = ($root.CMsgGCCStrike15_v2_ServerVarValueNotificationInfo = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.\n     * @exports ICMsgGCCStrike15_v2_ServerVarValueNotificationInfo\n     * @interface ICMsgGCCStrike15_v2_ServerVarValueNotificationInfo\n     * @property {number|null} [accountid] CMsgGCCStrike15_v2_ServerVarValueNotificationInfo accountid\n     * @property {Array.<number>|null} [viewangles] CMsgGCCStrike15_v2_ServerVarValueNotificationInfo viewangles\n     * @property {number|null} [type] CMsgGCCStrike15_v2_ServerVarValueNotificationInfo type\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.\n     * @exports CMsgGCCStrike15_v2_ServerVarValueNotificationInfo\n     * @classdesc Represents a CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.\n     * @implements ICMsgGCCStrike15_v2_ServerVarValueNotificationInfo\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_ServerVarValueNotificationInfo=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_ServerVarValueNotificationInfo(properties) {\n        this.viewangles = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_ServerVarValueNotificationInfo accountid.\n     * @member {number} accountid\n     * @memberof CMsgGCCStrike15_v2_ServerVarValueNotificationInfo\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.prototype.accountid = 0;\n    /**\n     * CMsgGCCStrike15_v2_ServerVarValueNotificationInfo viewangles.\n     * @member {Array.<number>} viewangles\n     * @memberof CMsgGCCStrike15_v2_ServerVarValueNotificationInfo\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.prototype.viewangles =\n        $util.emptyArray;\n    /**\n     * CMsgGCCStrike15_v2_ServerVarValueNotificationInfo type.\n     * @member {number} type\n     * @memberof CMsgGCCStrike15_v2_ServerVarValueNotificationInfo\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.prototype.type = 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_ServerVarValueNotificationInfo message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_ServerVarValueNotificationInfo\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_ServerVarValueNotificationInfo} CMsgGCCStrike15_v2_ServerVarValueNotificationInfo\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_ServerVarValueNotificationInfo.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ServerVarValueNotificationInfo();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.accountid = reader.uint32();\n                    break;\n                case 2:\n                    if (!(message.viewangles && message.viewangles.length))\n                        message.viewangles = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.viewangles.push(reader.uint32());\n                    }\n                    else\n                        message.viewangles.push(reader.uint32());\n                    break;\n                case 3:\n                    message.type = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_ServerVarValueNotificationInfo;\n})());\nexports.CMsgGCCStrike15_v2_GiftsLeaderboardRequest = ($root.CMsgGCCStrike15_v2_GiftsLeaderboardRequest = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_GiftsLeaderboardRequest.\n     * @exports ICMsgGCCStrike15_v2_GiftsLeaderboardRequest\n     * @interface ICMsgGCCStrike15_v2_GiftsLeaderboardRequest\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_GiftsLeaderboardRequest.\n     * @exports CMsgGCCStrike15_v2_GiftsLeaderboardRequest\n     * @classdesc Represents a CMsgGCCStrike15_v2_GiftsLeaderboardRequest.\n     * @implements ICMsgGCCStrike15_v2_GiftsLeaderboardRequest\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_GiftsLeaderboardRequest=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_GiftsLeaderboardRequest(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Decodes a CMsgGCCStrike15_v2_GiftsLeaderboardRequest message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardRequest\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_GiftsLeaderboardRequest} CMsgGCCStrike15_v2_GiftsLeaderboardRequest\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_GiftsLeaderboardRequest.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_GiftsLeaderboardRequest();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_GiftsLeaderboardRequest;\n})());\nexports.CMsgGCCStrike15_v2_GiftsLeaderboardResponse = ($root.CMsgGCCStrike15_v2_GiftsLeaderboardResponse = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_GiftsLeaderboardResponse.\n     * @exports ICMsgGCCStrike15_v2_GiftsLeaderboardResponse\n     * @interface ICMsgGCCStrike15_v2_GiftsLeaderboardResponse\n     * @property {number|null} [servertime] CMsgGCCStrike15_v2_GiftsLeaderboardResponse servertime\n     * @property {number|null} [timePeriodSeconds] CMsgGCCStrike15_v2_GiftsLeaderboardResponse timePeriodSeconds\n     * @property {number|null} [totalGiftsGiven] CMsgGCCStrike15_v2_GiftsLeaderboardResponse totalGiftsGiven\n     * @property {number|null} [totalGivers] CMsgGCCStrike15_v2_GiftsLeaderboardResponse totalGivers\n     * @property {Array.<CMsgGCCStrike15_v2_GiftsLeaderboardResponse.IGiftLeaderboardEntry>|null} [entries] CMsgGCCStrike15_v2_GiftsLeaderboardResponse entries\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_GiftsLeaderboardResponse.\n     * @exports CMsgGCCStrike15_v2_GiftsLeaderboardResponse\n     * @classdesc Represents a CMsgGCCStrike15_v2_GiftsLeaderboardResponse.\n     * @implements ICMsgGCCStrike15_v2_GiftsLeaderboardResponse\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_GiftsLeaderboardResponse=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_GiftsLeaderboardResponse(properties) {\n        this.entries = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_GiftsLeaderboardResponse servertime.\n     * @member {number} servertime\n     * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse\n     * @instance\n     */\n    CMsgGCCStrike15_v2_GiftsLeaderboardResponse.prototype.servertime = 0;\n    /**\n     * CMsgGCCStrike15_v2_GiftsLeaderboardResponse timePeriodSeconds.\n     * @member {number} timePeriodSeconds\n     * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse\n     * @instance\n     */\n    CMsgGCCStrike15_v2_GiftsLeaderboardResponse.prototype.timePeriodSeconds = 0;\n    /**\n     * CMsgGCCStrike15_v2_GiftsLeaderboardResponse totalGiftsGiven.\n     * @member {number} totalGiftsGiven\n     * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse\n     * @instance\n     */\n    CMsgGCCStrike15_v2_GiftsLeaderboardResponse.prototype.totalGiftsGiven = 0;\n    /**\n     * CMsgGCCStrike15_v2_GiftsLeaderboardResponse totalGivers.\n     * @member {number} totalGivers\n     * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse\n     * @instance\n     */\n    CMsgGCCStrike15_v2_GiftsLeaderboardResponse.prototype.totalGivers = 0;\n    /**\n     * CMsgGCCStrike15_v2_GiftsLeaderboardResponse entries.\n     * @member {Array.<CMsgGCCStrike15_v2_GiftsLeaderboardResponse.IGiftLeaderboardEntry>} entries\n     * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse\n     * @instance\n     */\n    CMsgGCCStrike15_v2_GiftsLeaderboardResponse.prototype.entries =\n        $util.emptyArray;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_GiftsLeaderboardResponse message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_GiftsLeaderboardResponse} CMsgGCCStrike15_v2_GiftsLeaderboardResponse\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_GiftsLeaderboardResponse.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_GiftsLeaderboardResponse();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.servertime = reader.uint32();\n                    break;\n                case 2:\n                    message.timePeriodSeconds = reader.uint32();\n                    break;\n                case 3:\n                    message.totalGiftsGiven = reader.uint32();\n                    break;\n                case 4:\n                    message.totalGivers = reader.uint32();\n                    break;\n                case 5:\n                    if (!(message.entries && message.entries.length))\n                        message.entries = [];\n                    message.entries.push($root.CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry = (function () {\n        /**\n         * Properties of a GiftLeaderboardEntry.\n         * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse\n         * @interface IGiftLeaderboardEntry\n         * @property {number|null} [accountid] GiftLeaderboardEntry accountid\n         * @property {number|null} [gifts] GiftLeaderboardEntry gifts\n         */\n        /**\n         * Constructs a new GiftLeaderboardEntry.\n         * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse\n         * @classdesc Represents a GiftLeaderboardEntry.\n         * @implements IGiftLeaderboardEntry\n         * @constructor\n         * @param {CMsgGCCStrike15_v2_GiftsLeaderboardResponse.IGiftLeaderboardEntry=} [properties] Properties to set\n         */\n        function GiftLeaderboardEntry(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * GiftLeaderboardEntry accountid.\n         * @member {number} accountid\n         * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry\n         * @instance\n         */\n        GiftLeaderboardEntry.prototype.accountid = 0;\n        /**\n         * GiftLeaderboardEntry gifts.\n         * @member {number} gifts\n         * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry\n         * @instance\n         */\n        GiftLeaderboardEntry.prototype.gifts = 0;\n        /**\n         * Decodes a GiftLeaderboardEntry message from the specified reader or buffer.\n         * @function decode\n         * @memberof CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry} GiftLeaderboardEntry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        GiftLeaderboardEntry.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_GiftsLeaderboardResponse.GiftLeaderboardEntry();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.accountid = reader.uint32();\n                        break;\n                    case 2:\n                        message.gifts = reader.uint32();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return GiftLeaderboardEntry;\n    })();\n    return CMsgGCCStrike15_v2_GiftsLeaderboardResponse;\n})());\nexports.CMsgGCCStrike15_v2_ClientSubmitSurveyVote = ($root.CMsgGCCStrike15_v2_ClientSubmitSurveyVote = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_ClientSubmitSurveyVote.\n     * @exports ICMsgGCCStrike15_v2_ClientSubmitSurveyVote\n     * @interface ICMsgGCCStrike15_v2_ClientSubmitSurveyVote\n     * @property {number|null} [surveyId] CMsgGCCStrike15_v2_ClientSubmitSurveyVote surveyId\n     * @property {number|null} [vote] CMsgGCCStrike15_v2_ClientSubmitSurveyVote vote\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_ClientSubmitSurveyVote.\n     * @exports CMsgGCCStrike15_v2_ClientSubmitSurveyVote\n     * @classdesc Represents a CMsgGCCStrike15_v2_ClientSubmitSurveyVote.\n     * @implements ICMsgGCCStrike15_v2_ClientSubmitSurveyVote\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_ClientSubmitSurveyVote=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_ClientSubmitSurveyVote(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_ClientSubmitSurveyVote surveyId.\n     * @member {number} surveyId\n     * @memberof CMsgGCCStrike15_v2_ClientSubmitSurveyVote\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientSubmitSurveyVote.prototype.surveyId = 0;\n    /**\n     * CMsgGCCStrike15_v2_ClientSubmitSurveyVote vote.\n     * @member {number} vote\n     * @memberof CMsgGCCStrike15_v2_ClientSubmitSurveyVote\n     * @instance\n     */\n    CMsgGCCStrike15_v2_ClientSubmitSurveyVote.prototype.vote = 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_ClientSubmitSurveyVote message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_ClientSubmitSurveyVote\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_ClientSubmitSurveyVote} CMsgGCCStrike15_v2_ClientSubmitSurveyVote\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_ClientSubmitSurveyVote.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_ClientSubmitSurveyVote();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.surveyId = reader.uint32();\n                    break;\n                case 2:\n                    message.vote = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_ClientSubmitSurveyVote;\n})());\nexports.CMsgGCCStrike15_v2_Server2GCClientValidate = ($root.CMsgGCCStrike15_v2_Server2GCClientValidate = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_Server2GCClientValidate.\n     * @exports ICMsgGCCStrike15_v2_Server2GCClientValidate\n     * @interface ICMsgGCCStrike15_v2_Server2GCClientValidate\n     * @property {number|null} [accountid] CMsgGCCStrike15_v2_Server2GCClientValidate accountid\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_Server2GCClientValidate.\n     * @exports CMsgGCCStrike15_v2_Server2GCClientValidate\n     * @classdesc Represents a CMsgGCCStrike15_v2_Server2GCClientValidate.\n     * @implements ICMsgGCCStrike15_v2_Server2GCClientValidate\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_Server2GCClientValidate=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_Server2GCClientValidate(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_Server2GCClientValidate accountid.\n     * @member {number} accountid\n     * @memberof CMsgGCCStrike15_v2_Server2GCClientValidate\n     * @instance\n     */\n    CMsgGCCStrike15_v2_Server2GCClientValidate.prototype.accountid = 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_Server2GCClientValidate message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_Server2GCClientValidate\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_Server2GCClientValidate} CMsgGCCStrike15_v2_Server2GCClientValidate\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_Server2GCClientValidate.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Server2GCClientValidate();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.accountid = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_Server2GCClientValidate;\n})());\nexports.CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure = ($root.CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.\n     * @exports ICMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n     * @interface ICMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n     * @property {number|null} [accountid] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure accountid\n     * @property {string|null} [path] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure path\n     * @property {string|null} [file] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure file\n     * @property {number|null} [crc] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure crc\n     * @property {number|null} [hash] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure hash\n     * @property {number|null} [len] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure len\n     * @property {number|null} [packNumber] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure packNumber\n     * @property {number|null} [packFileId] CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure packFileId\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.\n     * @exports CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n     * @classdesc Represents a CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.\n     * @implements ICMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_Server2GCPureServerValidationFailure=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure accountid.\n     * @member {number} accountid\n     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n     * @instance\n     */\n    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.accountid = 0;\n    /**\n     * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure path.\n     * @member {string} path\n     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n     * @instance\n     */\n    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.path = \"\";\n    /**\n     * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure file.\n     * @member {string} file\n     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n     * @instance\n     */\n    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.file = \"\";\n    /**\n     * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure crc.\n     * @member {number} crc\n     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n     * @instance\n     */\n    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.crc = 0;\n    /**\n     * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure hash.\n     * @member {number} hash\n     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n     * @instance\n     */\n    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.hash = 0;\n    /**\n     * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure len.\n     * @member {number} len\n     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n     * @instance\n     */\n    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.len = 0;\n    /**\n     * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure packNumber.\n     * @member {number} packNumber\n     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n     * @instance\n     */\n    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.packNumber = 0;\n    /**\n     * CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure packFileId.\n     * @member {number} packFileId\n     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n     * @instance\n     */\n    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.prototype.packFileId = 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure} CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.accountid = reader.uint32();\n                    break;\n                case 2:\n                    message.path = reader.string();\n                    break;\n                case 3:\n                    message.file = reader.string();\n                    break;\n                case 4:\n                    message.crc = reader.uint32();\n                    break;\n                case 5:\n                    message.hash = reader.int32();\n                    break;\n                case 6:\n                    message.len = reader.int32();\n                    break;\n                case 7:\n                    message.packNumber = reader.int32();\n                    break;\n                case 8:\n                    message.packFileId = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_Server2GCPureServerValidationFailure;\n})());\nexports.CMsgGCCStrike15_v2_GC2ClientTournamentInfo = ($root.CMsgGCCStrike15_v2_GC2ClientTournamentInfo = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_GC2ClientTournamentInfo.\n     * @exports ICMsgGCCStrike15_v2_GC2ClientTournamentInfo\n     * @interface ICMsgGCCStrike15_v2_GC2ClientTournamentInfo\n     * @property {number|null} [eventid] CMsgGCCStrike15_v2_GC2ClientTournamentInfo eventid\n     * @property {number|null} [stageid] CMsgGCCStrike15_v2_GC2ClientTournamentInfo stageid\n     * @property {number|null} [gameType] CMsgGCCStrike15_v2_GC2ClientTournamentInfo gameType\n     * @property {Array.<number>|null} [teamids] CMsgGCCStrike15_v2_GC2ClientTournamentInfo teamids\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_GC2ClientTournamentInfo.\n     * @exports CMsgGCCStrike15_v2_GC2ClientTournamentInfo\n     * @classdesc Represents a CMsgGCCStrike15_v2_GC2ClientTournamentInfo.\n     * @implements ICMsgGCCStrike15_v2_GC2ClientTournamentInfo\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_GC2ClientTournamentInfo=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_GC2ClientTournamentInfo(properties) {\n        this.teamids = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_GC2ClientTournamentInfo eventid.\n     * @member {number} eventid\n     * @memberof CMsgGCCStrike15_v2_GC2ClientTournamentInfo\n     * @instance\n     */\n    CMsgGCCStrike15_v2_GC2ClientTournamentInfo.prototype.eventid = 0;\n    /**\n     * CMsgGCCStrike15_v2_GC2ClientTournamentInfo stageid.\n     * @member {number} stageid\n     * @memberof CMsgGCCStrike15_v2_GC2ClientTournamentInfo\n     * @instance\n     */\n    CMsgGCCStrike15_v2_GC2ClientTournamentInfo.prototype.stageid = 0;\n    /**\n     * CMsgGCCStrike15_v2_GC2ClientTournamentInfo gameType.\n     * @member {number} gameType\n     * @memberof CMsgGCCStrike15_v2_GC2ClientTournamentInfo\n     * @instance\n     */\n    CMsgGCCStrike15_v2_GC2ClientTournamentInfo.prototype.gameType = 0;\n    /**\n     * CMsgGCCStrike15_v2_GC2ClientTournamentInfo teamids.\n     * @member {Array.<number>} teamids\n     * @memberof CMsgGCCStrike15_v2_GC2ClientTournamentInfo\n     * @instance\n     */\n    CMsgGCCStrike15_v2_GC2ClientTournamentInfo.prototype.teamids =\n        $util.emptyArray;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_GC2ClientTournamentInfo message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_GC2ClientTournamentInfo\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_GC2ClientTournamentInfo} CMsgGCCStrike15_v2_GC2ClientTournamentInfo\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_GC2ClientTournamentInfo.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_GC2ClientTournamentInfo();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.eventid = reader.uint32();\n                    break;\n                case 2:\n                    message.stageid = reader.uint32();\n                    break;\n                case 3:\n                    message.gameType = reader.uint32();\n                    break;\n                case 4:\n                    if (!(message.teamids && message.teamids.length))\n                        message.teamids = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.teamids.push(reader.uint32());\n                    }\n                    else\n                        message.teamids.push(reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_GC2ClientTournamentInfo;\n})());\nexports.CSOEconCoupon = ($root.CSOEconCoupon = (() => {\n    /**\n     * Properties of a CSOEconCoupon.\n     * @exports ICSOEconCoupon\n     * @interface ICSOEconCoupon\n     * @property {number|null} [entryid] CSOEconCoupon entryid\n     * @property {number|null} [defidx] CSOEconCoupon defidx\n     * @property {number|null} [expirationDate] CSOEconCoupon expirationDate\n     */\n    /**\n     * Constructs a new CSOEconCoupon.\n     * @exports CSOEconCoupon\n     * @classdesc Represents a CSOEconCoupon.\n     * @implements ICSOEconCoupon\n     * @constructor\n     * @param {ICSOEconCoupon=} [properties] Properties to set\n     */\n    function CSOEconCoupon(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSOEconCoupon entryid.\n     * @member {number} entryid\n     * @memberof CSOEconCoupon\n     * @instance\n     */\n    CSOEconCoupon.prototype.entryid = 0;\n    /**\n     * CSOEconCoupon defidx.\n     * @member {number} defidx\n     * @memberof CSOEconCoupon\n     * @instance\n     */\n    CSOEconCoupon.prototype.defidx = 0;\n    /**\n     * CSOEconCoupon expirationDate.\n     * @member {number} expirationDate\n     * @memberof CSOEconCoupon\n     * @instance\n     */\n    CSOEconCoupon.prototype.expirationDate = 0;\n    /**\n     * Decodes a CSOEconCoupon message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSOEconCoupon\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSOEconCoupon} CSOEconCoupon\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSOEconCoupon.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSOEconCoupon();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.entryid = reader.uint32();\n                    break;\n                case 2:\n                    message.defidx = reader.uint32();\n                    break;\n                case 3:\n                    message.expirationDate = reader.fixed32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CSOEconCoupon;\n})());\nexports.CSOQuestProgress = ($root.CSOQuestProgress = (() => {\n    /**\n     * Properties of a CSOQuestProgress.\n     * @exports ICSOQuestProgress\n     * @interface ICSOQuestProgress\n     * @property {number|null} [questid] CSOQuestProgress questid\n     * @property {number|null} [pointsRemaining] CSOQuestProgress pointsRemaining\n     * @property {number|null} [bonusPoints] CSOQuestProgress bonusPoints\n     */\n    /**\n     * Constructs a new CSOQuestProgress.\n     * @exports CSOQuestProgress\n     * @classdesc Represents a CSOQuestProgress.\n     * @implements ICSOQuestProgress\n     * @constructor\n     * @param {ICSOQuestProgress=} [properties] Properties to set\n     */\n    function CSOQuestProgress(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSOQuestProgress questid.\n     * @member {number} questid\n     * @memberof CSOQuestProgress\n     * @instance\n     */\n    CSOQuestProgress.prototype.questid = 0;\n    /**\n     * CSOQuestProgress pointsRemaining.\n     * @member {number} pointsRemaining\n     * @memberof CSOQuestProgress\n     * @instance\n     */\n    CSOQuestProgress.prototype.pointsRemaining = 0;\n    /**\n     * CSOQuestProgress bonusPoints.\n     * @member {number} bonusPoints\n     * @memberof CSOQuestProgress\n     * @instance\n     */\n    CSOQuestProgress.prototype.bonusPoints = 0;\n    /**\n     * Decodes a CSOQuestProgress message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSOQuestProgress\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSOQuestProgress} CSOQuestProgress\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSOQuestProgress.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSOQuestProgress();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.questid = reader.uint32();\n                    break;\n                case 2:\n                    message.pointsRemaining = reader.uint32();\n                    break;\n                case 3:\n                    message.bonusPoints = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CSOQuestProgress;\n})());\nexports.CSOPersonaDataPublic = ($root.CSOPersonaDataPublic = (() => {\n    /**\n     * Properties of a CSOPersonaDataPublic.\n     * @exports ICSOPersonaDataPublic\n     * @interface ICSOPersonaDataPublic\n     * @property {number|null} [playerLevel] CSOPersonaDataPublic playerLevel\n     * @property {IPlayerCommendationInfo|null} [commendation] CSOPersonaDataPublic commendation\n     */\n    /**\n     * Constructs a new CSOPersonaDataPublic.\n     * @exports CSOPersonaDataPublic\n     * @classdesc Represents a CSOPersonaDataPublic.\n     * @implements ICSOPersonaDataPublic\n     * @constructor\n     * @param {ICSOPersonaDataPublic=} [properties] Properties to set\n     */\n    function CSOPersonaDataPublic(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CSOPersonaDataPublic playerLevel.\n     * @member {number} playerLevel\n     * @memberof CSOPersonaDataPublic\n     * @instance\n     */\n    CSOPersonaDataPublic.prototype.playerLevel = 0;\n    /**\n     * CSOPersonaDataPublic commendation.\n     * @member {IPlayerCommendationInfo|null|undefined} commendation\n     * @memberof CSOPersonaDataPublic\n     * @instance\n     */\n    CSOPersonaDataPublic.prototype.commendation = null;\n    /**\n     * Decodes a CSOPersonaDataPublic message from the specified reader or buffer.\n     * @function decode\n     * @memberof CSOPersonaDataPublic\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CSOPersonaDataPublic} CSOPersonaDataPublic\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CSOPersonaDataPublic.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CSOPersonaDataPublic();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.playerLevel = reader.int32();\n                    break;\n                case 2:\n                    message.commendation = $root.PlayerCommendationInfo.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CSOPersonaDataPublic;\n})());\nexports.CMsgGC_GlobalGame_Subscribe = ($root.CMsgGC_GlobalGame_Subscribe = (() => {\n    /**\n     * Properties of a CMsgGC_GlobalGame_Subscribe.\n     * @exports ICMsgGC_GlobalGame_Subscribe\n     * @interface ICMsgGC_GlobalGame_Subscribe\n     * @property {number|Long|null} [ticket] CMsgGC_GlobalGame_Subscribe ticket\n     */\n    /**\n     * Constructs a new CMsgGC_GlobalGame_Subscribe.\n     * @exports CMsgGC_GlobalGame_Subscribe\n     * @classdesc Represents a CMsgGC_GlobalGame_Subscribe.\n     * @implements ICMsgGC_GlobalGame_Subscribe\n     * @constructor\n     * @param {ICMsgGC_GlobalGame_Subscribe=} [properties] Properties to set\n     */\n    function CMsgGC_GlobalGame_Subscribe(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGC_GlobalGame_Subscribe ticket.\n     * @member {number|Long} ticket\n     * @memberof CMsgGC_GlobalGame_Subscribe\n     * @instance\n     */\n    CMsgGC_GlobalGame_Subscribe.prototype.ticket = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * Decodes a CMsgGC_GlobalGame_Subscribe message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGC_GlobalGame_Subscribe\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGC_GlobalGame_Subscribe} CMsgGC_GlobalGame_Subscribe\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGC_GlobalGame_Subscribe.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGC_GlobalGame_Subscribe();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.ticket = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGC_GlobalGame_Subscribe;\n})());\nexports.CMsgGC_GlobalGame_Unsubscribe = ($root.CMsgGC_GlobalGame_Unsubscribe = (() => {\n    /**\n     * Properties of a CMsgGC_GlobalGame_Unsubscribe.\n     * @exports ICMsgGC_GlobalGame_Unsubscribe\n     * @interface ICMsgGC_GlobalGame_Unsubscribe\n     * @property {number|null} [timeleft] CMsgGC_GlobalGame_Unsubscribe timeleft\n     */\n    /**\n     * Constructs a new CMsgGC_GlobalGame_Unsubscribe.\n     * @exports CMsgGC_GlobalGame_Unsubscribe\n     * @classdesc Represents a CMsgGC_GlobalGame_Unsubscribe.\n     * @implements ICMsgGC_GlobalGame_Unsubscribe\n     * @constructor\n     * @param {ICMsgGC_GlobalGame_Unsubscribe=} [properties] Properties to set\n     */\n    function CMsgGC_GlobalGame_Unsubscribe(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGC_GlobalGame_Unsubscribe timeleft.\n     * @member {number} timeleft\n     * @memberof CMsgGC_GlobalGame_Unsubscribe\n     * @instance\n     */\n    CMsgGC_GlobalGame_Unsubscribe.prototype.timeleft = 0;\n    /**\n     * Decodes a CMsgGC_GlobalGame_Unsubscribe message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGC_GlobalGame_Unsubscribe\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGC_GlobalGame_Unsubscribe} CMsgGC_GlobalGame_Unsubscribe\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGC_GlobalGame_Unsubscribe.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGC_GlobalGame_Unsubscribe();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.timeleft = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGC_GlobalGame_Unsubscribe;\n})());\nexports.CMsgGC_GlobalGame_Play = ($root.CMsgGC_GlobalGame_Play = (() => {\n    /**\n     * Properties of a CMsgGC_GlobalGame_Play.\n     * @exports ICMsgGC_GlobalGame_Play\n     * @interface ICMsgGC_GlobalGame_Play\n     * @property {number|Long|null} [ticket] CMsgGC_GlobalGame_Play ticket\n     * @property {number|null} [gametimems] CMsgGC_GlobalGame_Play gametimems\n     * @property {number|null} [msperpoint] CMsgGC_GlobalGame_Play msperpoint\n     */\n    /**\n     * Constructs a new CMsgGC_GlobalGame_Play.\n     * @exports CMsgGC_GlobalGame_Play\n     * @classdesc Represents a CMsgGC_GlobalGame_Play.\n     * @implements ICMsgGC_GlobalGame_Play\n     * @constructor\n     * @param {ICMsgGC_GlobalGame_Play=} [properties] Properties to set\n     */\n    function CMsgGC_GlobalGame_Play(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGC_GlobalGame_Play ticket.\n     * @member {number|Long} ticket\n     * @memberof CMsgGC_GlobalGame_Play\n     * @instance\n     */\n    CMsgGC_GlobalGame_Play.prototype.ticket = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgGC_GlobalGame_Play gametimems.\n     * @member {number} gametimems\n     * @memberof CMsgGC_GlobalGame_Play\n     * @instance\n     */\n    CMsgGC_GlobalGame_Play.prototype.gametimems = 0;\n    /**\n     * CMsgGC_GlobalGame_Play msperpoint.\n     * @member {number} msperpoint\n     * @memberof CMsgGC_GlobalGame_Play\n     * @instance\n     */\n    CMsgGC_GlobalGame_Play.prototype.msperpoint = 0;\n    /**\n     * Decodes a CMsgGC_GlobalGame_Play message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGC_GlobalGame_Play\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGC_GlobalGame_Play} CMsgGC_GlobalGame_Play\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGC_GlobalGame_Play.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGC_GlobalGame_Play();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.ticket = reader.uint64();\n                    break;\n                case 2:\n                    message.gametimems = reader.uint32();\n                    break;\n                case 3:\n                    message.msperpoint = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGC_GlobalGame_Play;\n})());\nexports.CMsgGCCStrike15_v2_AcknowledgePenalty = ($root.CMsgGCCStrike15_v2_AcknowledgePenalty = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_AcknowledgePenalty.\n     * @exports ICMsgGCCStrike15_v2_AcknowledgePenalty\n     * @interface ICMsgGCCStrike15_v2_AcknowledgePenalty\n     * @property {number|null} [acknowledged] CMsgGCCStrike15_v2_AcknowledgePenalty acknowledged\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_AcknowledgePenalty.\n     * @exports CMsgGCCStrike15_v2_AcknowledgePenalty\n     * @classdesc Represents a CMsgGCCStrike15_v2_AcknowledgePenalty.\n     * @implements ICMsgGCCStrike15_v2_AcknowledgePenalty\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_AcknowledgePenalty=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_AcknowledgePenalty(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_AcknowledgePenalty acknowledged.\n     * @member {number} acknowledged\n     * @memberof CMsgGCCStrike15_v2_AcknowledgePenalty\n     * @instance\n     */\n    CMsgGCCStrike15_v2_AcknowledgePenalty.prototype.acknowledged = 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_AcknowledgePenalty message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_AcknowledgePenalty\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_AcknowledgePenalty} CMsgGCCStrike15_v2_AcknowledgePenalty\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_AcknowledgePenalty.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_AcknowledgePenalty();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.acknowledged = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_AcknowledgePenalty;\n})());\nexports.CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin = ($root.CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin.\n     * @exports ICMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin\n     * @interface ICMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin.\n     * @exports CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin\n     * @classdesc Represents a CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin.\n     * @implements ICMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Decodes a CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin} CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_Client2GCRequestPrestigeCoin;\n})());\nexports.CMsgGCCStrike15_v2_Client2GCStreamUnlock = ($root.CMsgGCCStrike15_v2_Client2GCStreamUnlock = (() => {\n    /**\n     * Properties of a CMsgGCCStrike15_v2_Client2GCStreamUnlock.\n     * @exports ICMsgGCCStrike15_v2_Client2GCStreamUnlock\n     * @interface ICMsgGCCStrike15_v2_Client2GCStreamUnlock\n     * @property {number|Long|null} [ticket] CMsgGCCStrike15_v2_Client2GCStreamUnlock ticket\n     * @property {number|null} [os] CMsgGCCStrike15_v2_Client2GCStreamUnlock os\n     */\n    /**\n     * Constructs a new CMsgGCCStrike15_v2_Client2GCStreamUnlock.\n     * @exports CMsgGCCStrike15_v2_Client2GCStreamUnlock\n     * @classdesc Represents a CMsgGCCStrike15_v2_Client2GCStreamUnlock.\n     * @implements ICMsgGCCStrike15_v2_Client2GCStreamUnlock\n     * @constructor\n     * @param {ICMsgGCCStrike15_v2_Client2GCStreamUnlock=} [properties] Properties to set\n     */\n    function CMsgGCCStrike15_v2_Client2GCStreamUnlock(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCStrike15_v2_Client2GCStreamUnlock ticket.\n     * @member {number|Long} ticket\n     * @memberof CMsgGCCStrike15_v2_Client2GCStreamUnlock\n     * @instance\n     */\n    CMsgGCCStrike15_v2_Client2GCStreamUnlock.prototype.ticket = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CMsgGCCStrike15_v2_Client2GCStreamUnlock os.\n     * @member {number} os\n     * @memberof CMsgGCCStrike15_v2_Client2GCStreamUnlock\n     * @instance\n     */\n    CMsgGCCStrike15_v2_Client2GCStreamUnlock.prototype.os = 0;\n    /**\n     * Decodes a CMsgGCCStrike15_v2_Client2GCStreamUnlock message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCStrike15_v2_Client2GCStreamUnlock\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCStrike15_v2_Client2GCStreamUnlock} CMsgGCCStrike15_v2_Client2GCStreamUnlock\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCStrike15_v2_Client2GCStreamUnlock.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCStrike15_v2_Client2GCStreamUnlock();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.ticket = reader.uint64();\n                    break;\n                case 2:\n                    message.os = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCStrike15_v2_Client2GCStreamUnlock;\n})());\n/**\n * GCProtoBufMsgSrc enum.\n * @exports GCProtoBufMsgSrc\n * @enum {string}\n * @property {number} GCProtoBufMsgSrc_Unspecified=0 GCProtoBufMsgSrc_Unspecified value\n * @property {number} GCProtoBufMsgSrc_FromSystem=1 GCProtoBufMsgSrc_FromSystem value\n * @property {number} GCProtoBufMsgSrc_FromSteamID=2 GCProtoBufMsgSrc_FromSteamID value\n * @property {number} GCProtoBufMsgSrc_FromGC=3 GCProtoBufMsgSrc_FromGC value\n * @property {number} GCProtoBufMsgSrc_ReplySystem=4 GCProtoBufMsgSrc_ReplySystem value\n */\n$root.GCProtoBufMsgSrc = (function () {\n    const valuesById = {}, values = Object.create(valuesById);\n    values[(valuesById[0] = \"GCProtoBufMsgSrc_Unspecified\")] = 0;\n    values[(valuesById[1] = \"GCProtoBufMsgSrc_FromSystem\")] = 1;\n    values[(valuesById[2] = \"GCProtoBufMsgSrc_FromSteamID\")] = 2;\n    values[(valuesById[3] = \"GCProtoBufMsgSrc_FromGC\")] = 3;\n    values[(valuesById[4] = \"GCProtoBufMsgSrc_ReplySystem\")] = 4;\n    return values;\n})();\nexports.CMsgProtoBufHeader = ($root.CMsgProtoBufHeader = (() => {\n    /**\n     * Properties of a CMsgProtoBufHeader.\n     * @exports ICMsgProtoBufHeader\n     * @interface ICMsgProtoBufHeader\n     * @property {number|Long|null} [clientSteamId] CMsgProtoBufHeader clientSteamId\n     * @property {number|null} [clientSessionId] CMsgProtoBufHeader clientSessionId\n     * @property {number|null} [sourceAppId] CMsgProtoBufHeader sourceAppId\n     * @property {number|Long|null} [jobIdSource] CMsgProtoBufHeader jobIdSource\n     * @property {number|Long|null} [jobIdTarget] CMsgProtoBufHeader jobIdTarget\n     * @property {string|null} [targetJobName] CMsgProtoBufHeader targetJobName\n     * @property {number|null} [eresult] CMsgProtoBufHeader eresult\n     * @property {string|null} [errorMessage] CMsgProtoBufHeader errorMessage\n     * @property {GCProtoBufMsgSrc|null} [gcMsgSrc] CMsgProtoBufHeader gcMsgSrc\n     * @property {number|null} [gcDirIndexSource] CMsgProtoBufHeader gcDirIndexSource\n     */\n    /**\n     * Constructs a new CMsgProtoBufHeader.\n     * @exports CMsgProtoBufHeader\n     * @classdesc Represents a CMsgProtoBufHeader.\n     * @implements ICMsgProtoBufHeader\n     * @constructor\n     * @param {ICMsgProtoBufHeader=} [properties] Properties to set\n     */\n    function CMsgProtoBufHeader(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgProtoBufHeader clientSteamId.\n     * @member {number|Long} clientSteamId\n     * @memberof CMsgProtoBufHeader\n     * @instance\n     */\n    CMsgProtoBufHeader.prototype.clientSteamId = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0;\n    /**\n     * CMsgProtoBufHeader clientSessionId.\n     * @member {number} clientSessionId\n     * @memberof CMsgProtoBufHeader\n     * @instance\n     */\n    CMsgProtoBufHeader.prototype.clientSessionId = 0;\n    /**\n     * CMsgProtoBufHeader sourceAppId.\n     * @member {number} sourceAppId\n     * @memberof CMsgProtoBufHeader\n     * @instance\n     */\n    CMsgProtoBufHeader.prototype.sourceAppId = 0;\n    /**\n     * CMsgProtoBufHeader jobIdSource.\n     * @member {number|Long} jobIdSource\n     * @memberof CMsgProtoBufHeader\n     * @instance\n     */\n    CMsgProtoBufHeader.prototype.jobIdSource = $util.Long\n        ? $util.Long.fromBits(-1, 2147483647, false)\n        : 9223372036854776000;\n    /**\n     * CMsgProtoBufHeader jobIdTarget.\n     * @member {number|Long} jobIdTarget\n     * @memberof CMsgProtoBufHeader\n     * @instance\n     */\n    CMsgProtoBufHeader.prototype.jobIdTarget = $util.Long\n        ? $util.Long.fromBits(-1, 2147483647, false)\n        : 9223372036854776000;\n    /**\n     * CMsgProtoBufHeader targetJobName.\n     * @member {string} targetJobName\n     * @memberof CMsgProtoBufHeader\n     * @instance\n     */\n    CMsgProtoBufHeader.prototype.targetJobName = \"\";\n    /**\n     * CMsgProtoBufHeader eresult.\n     * @member {number} eresult\n     * @memberof CMsgProtoBufHeader\n     * @instance\n     */\n    CMsgProtoBufHeader.prototype.eresult = 2;\n    /**\n     * CMsgProtoBufHeader errorMessage.\n     * @member {string} errorMessage\n     * @memberof CMsgProtoBufHeader\n     * @instance\n     */\n    CMsgProtoBufHeader.prototype.errorMessage = \"\";\n    /**\n     * CMsgProtoBufHeader gcMsgSrc.\n     * @member {GCProtoBufMsgSrc} gcMsgSrc\n     * @memberof CMsgProtoBufHeader\n     * @instance\n     */\n    CMsgProtoBufHeader.prototype.gcMsgSrc = 0;\n    /**\n     * CMsgProtoBufHeader gcDirIndexSource.\n     * @member {number} gcDirIndexSource\n     * @memberof CMsgProtoBufHeader\n     * @instance\n     */\n    CMsgProtoBufHeader.prototype.gcDirIndexSource = 0;\n    /**\n     * Decodes a CMsgProtoBufHeader message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgProtoBufHeader\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgProtoBufHeader} CMsgProtoBufHeader\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgProtoBufHeader.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgProtoBufHeader();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.clientSteamId = reader.fixed64();\n                    break;\n                case 2:\n                    message.clientSessionId = reader.int32();\n                    break;\n                case 3:\n                    message.sourceAppId = reader.uint32();\n                    break;\n                case 10:\n                    message.jobIdSource = reader.fixed64();\n                    break;\n                case 11:\n                    message.jobIdTarget = reader.fixed64();\n                    break;\n                case 12:\n                    message.targetJobName = reader.string();\n                    break;\n                case 13:\n                    message.eresult = reader.int32();\n                    break;\n                case 14:\n                    message.errorMessage = reader.string();\n                    break;\n                case 200:\n                    message.gcMsgSrc = reader.int32();\n                    break;\n                case 201:\n                    message.gcDirIndexSource = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgProtoBufHeader;\n})());\nexports.CMsgWebAPIKey = ($root.CMsgWebAPIKey = (() => {\n    /**\n     * Properties of a CMsgWebAPIKey.\n     * @exports ICMsgWebAPIKey\n     * @interface ICMsgWebAPIKey\n     * @property {number|null} [status] CMsgWebAPIKey status\n     * @property {number|null} [accountId] CMsgWebAPIKey accountId\n     * @property {number|null} [publisherGroupId] CMsgWebAPIKey publisherGroupId\n     * @property {number|null} [keyId] CMsgWebAPIKey keyId\n     * @property {string|null} [domain] CMsgWebAPIKey domain\n     */\n    /**\n     * Constructs a new CMsgWebAPIKey.\n     * @exports CMsgWebAPIKey\n     * @classdesc Represents a CMsgWebAPIKey.\n     * @implements ICMsgWebAPIKey\n     * @constructor\n     * @param {ICMsgWebAPIKey=} [properties] Properties to set\n     */\n    function CMsgWebAPIKey(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgWebAPIKey status.\n     * @member {number} status\n     * @memberof CMsgWebAPIKey\n     * @instance\n     */\n    CMsgWebAPIKey.prototype.status = 255;\n    /**\n     * CMsgWebAPIKey accountId.\n     * @member {number} accountId\n     * @memberof CMsgWebAPIKey\n     * @instance\n     */\n    CMsgWebAPIKey.prototype.accountId = 0;\n    /**\n     * CMsgWebAPIKey publisherGroupId.\n     * @member {number} publisherGroupId\n     * @memberof CMsgWebAPIKey\n     * @instance\n     */\n    CMsgWebAPIKey.prototype.publisherGroupId = 0;\n    /**\n     * CMsgWebAPIKey keyId.\n     * @member {number} keyId\n     * @memberof CMsgWebAPIKey\n     * @instance\n     */\n    CMsgWebAPIKey.prototype.keyId = 0;\n    /**\n     * CMsgWebAPIKey domain.\n     * @member {string} domain\n     * @memberof CMsgWebAPIKey\n     * @instance\n     */\n    CMsgWebAPIKey.prototype.domain = \"\";\n    /**\n     * Decodes a CMsgWebAPIKey message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgWebAPIKey\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgWebAPIKey} CMsgWebAPIKey\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgWebAPIKey.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgWebAPIKey();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.status = reader.uint32();\n                    break;\n                case 2:\n                    message.accountId = reader.uint32();\n                    break;\n                case 3:\n                    message.publisherGroupId = reader.uint32();\n                    break;\n                case 4:\n                    message.keyId = reader.uint32();\n                    break;\n                case 5:\n                    message.domain = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgWebAPIKey;\n})());\nexports.CMsgHttpRequest = ($root.CMsgHttpRequest = (() => {\n    /**\n     * Properties of a CMsgHttpRequest.\n     * @exports ICMsgHttpRequest\n     * @interface ICMsgHttpRequest\n     * @property {number|null} [requestMethod] CMsgHttpRequest requestMethod\n     * @property {string|null} [hostname] CMsgHttpRequest hostname\n     * @property {string|null} [url] CMsgHttpRequest url\n     * @property {Array.<CMsgHttpRequest.IRequestHeader>|null} [headers] CMsgHttpRequest headers\n     * @property {Array.<CMsgHttpRequest.IQueryParam>|null} [getParams] CMsgHttpRequest getParams\n     * @property {Array.<CMsgHttpRequest.IQueryParam>|null} [postParams] CMsgHttpRequest postParams\n     * @property {Uint8Array|null} [body] CMsgHttpRequest body\n     * @property {number|null} [absoluteTimeout] CMsgHttpRequest absoluteTimeout\n     */\n    /**\n     * Constructs a new CMsgHttpRequest.\n     * @exports CMsgHttpRequest\n     * @classdesc Represents a CMsgHttpRequest.\n     * @implements ICMsgHttpRequest\n     * @constructor\n     * @param {ICMsgHttpRequest=} [properties] Properties to set\n     */\n    function CMsgHttpRequest(properties) {\n        this.headers = [];\n        this.getParams = [];\n        this.postParams = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgHttpRequest requestMethod.\n     * @member {number} requestMethod\n     * @memberof CMsgHttpRequest\n     * @instance\n     */\n    CMsgHttpRequest.prototype.requestMethod = 0;\n    /**\n     * CMsgHttpRequest hostname.\n     * @member {string} hostname\n     * @memberof CMsgHttpRequest\n     * @instance\n     */\n    CMsgHttpRequest.prototype.hostname = \"\";\n    /**\n     * CMsgHttpRequest url.\n     * @member {string} url\n     * @memberof CMsgHttpRequest\n     * @instance\n     */\n    CMsgHttpRequest.prototype.url = \"\";\n    /**\n     * CMsgHttpRequest headers.\n     * @member {Array.<CMsgHttpRequest.IRequestHeader>} headers\n     * @memberof CMsgHttpRequest\n     * @instance\n     */\n    CMsgHttpRequest.prototype.headers = $util.emptyArray;\n    /**\n     * CMsgHttpRequest getParams.\n     * @member {Array.<CMsgHttpRequest.IQueryParam>} getParams\n     * @memberof CMsgHttpRequest\n     * @instance\n     */\n    CMsgHttpRequest.prototype.getParams = $util.emptyArray;\n    /**\n     * CMsgHttpRequest postParams.\n     * @member {Array.<CMsgHttpRequest.IQueryParam>} postParams\n     * @memberof CMsgHttpRequest\n     * @instance\n     */\n    CMsgHttpRequest.prototype.postParams = $util.emptyArray;\n    /**\n     * CMsgHttpRequest body.\n     * @member {Uint8Array} body\n     * @memberof CMsgHttpRequest\n     * @instance\n     */\n    CMsgHttpRequest.prototype.body = $util.newBuffer([]);\n    /**\n     * CMsgHttpRequest absoluteTimeout.\n     * @member {number} absoluteTimeout\n     * @memberof CMsgHttpRequest\n     * @instance\n     */\n    CMsgHttpRequest.prototype.absoluteTimeout = 0;\n    /**\n     * Decodes a CMsgHttpRequest message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgHttpRequest\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgHttpRequest} CMsgHttpRequest\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgHttpRequest.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgHttpRequest();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.requestMethod = reader.uint32();\n                    break;\n                case 2:\n                    message.hostname = reader.string();\n                    break;\n                case 3:\n                    message.url = reader.string();\n                    break;\n                case 4:\n                    if (!(message.headers && message.headers.length))\n                        message.headers = [];\n                    message.headers.push($root.CMsgHttpRequest.RequestHeader.decode(reader, reader.uint32()));\n                    break;\n                case 5:\n                    if (!(message.getParams && message.getParams.length))\n                        message.getParams = [];\n                    message.getParams.push($root.CMsgHttpRequest.QueryParam.decode(reader, reader.uint32()));\n                    break;\n                case 6:\n                    if (!(message.postParams && message.postParams.length))\n                        message.postParams = [];\n                    message.postParams.push($root.CMsgHttpRequest.QueryParam.decode(reader, reader.uint32()));\n                    break;\n                case 7:\n                    message.body = reader.bytes();\n                    break;\n                case 8:\n                    message.absoluteTimeout = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CMsgHttpRequest.RequestHeader = (function () {\n        /**\n         * Properties of a RequestHeader.\n         * @memberof CMsgHttpRequest\n         * @interface IRequestHeader\n         * @property {string|null} [name] RequestHeader name\n         * @property {string|null} [value] RequestHeader value\n         */\n        /**\n         * Constructs a new RequestHeader.\n         * @memberof CMsgHttpRequest\n         * @classdesc Represents a RequestHeader.\n         * @implements IRequestHeader\n         * @constructor\n         * @param {CMsgHttpRequest.IRequestHeader=} [properties] Properties to set\n         */\n        function RequestHeader(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * RequestHeader name.\n         * @member {string} name\n         * @memberof CMsgHttpRequest.RequestHeader\n         * @instance\n         */\n        RequestHeader.prototype.name = \"\";\n        /**\n         * RequestHeader value.\n         * @member {string} value\n         * @memberof CMsgHttpRequest.RequestHeader\n         * @instance\n         */\n        RequestHeader.prototype.value = \"\";\n        /**\n         * Decodes a RequestHeader message from the specified reader or buffer.\n         * @function decode\n         * @memberof CMsgHttpRequest.RequestHeader\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CMsgHttpRequest.RequestHeader} RequestHeader\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        RequestHeader.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgHttpRequest.RequestHeader();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.name = reader.string();\n                        break;\n                    case 2:\n                        message.value = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return RequestHeader;\n    })();\n    CMsgHttpRequest.QueryParam = (function () {\n        /**\n         * Properties of a QueryParam.\n         * @memberof CMsgHttpRequest\n         * @interface IQueryParam\n         * @property {string|null} [name] QueryParam name\n         * @property {Uint8Array|null} [value] QueryParam value\n         */\n        /**\n         * Constructs a new QueryParam.\n         * @memberof CMsgHttpRequest\n         * @classdesc Represents a QueryParam.\n         * @implements IQueryParam\n         * @constructor\n         * @param {CMsgHttpRequest.IQueryParam=} [properties] Properties to set\n         */\n        function QueryParam(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * QueryParam name.\n         * @member {string} name\n         * @memberof CMsgHttpRequest.QueryParam\n         * @instance\n         */\n        QueryParam.prototype.name = \"\";\n        /**\n         * QueryParam value.\n         * @member {Uint8Array} value\n         * @memberof CMsgHttpRequest.QueryParam\n         * @instance\n         */\n        QueryParam.prototype.value = $util.newBuffer([]);\n        /**\n         * Decodes a QueryParam message from the specified reader or buffer.\n         * @function decode\n         * @memberof CMsgHttpRequest.QueryParam\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CMsgHttpRequest.QueryParam} QueryParam\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        QueryParam.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgHttpRequest.QueryParam();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.name = reader.string();\n                        break;\n                    case 2:\n                        message.value = reader.bytes();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return QueryParam;\n    })();\n    return CMsgHttpRequest;\n})());\nexports.CMsgWebAPIRequest = ($root.CMsgWebAPIRequest = (() => {\n    /**\n     * Properties of a CMsgWebAPIRequest.\n     * @exports ICMsgWebAPIRequest\n     * @interface ICMsgWebAPIRequest\n     * @property {string|null} [UNUSEDJobName] CMsgWebAPIRequest UNUSEDJobName\n     * @property {string|null} [interfaceName] CMsgWebAPIRequest interfaceName\n     * @property {string|null} [methodName] CMsgWebAPIRequest methodName\n     * @property {number|null} [version] CMsgWebAPIRequest version\n     * @property {ICMsgWebAPIKey|null} [apiKey] CMsgWebAPIRequest apiKey\n     * @property {ICMsgHttpRequest|null} [request] CMsgWebAPIRequest request\n     * @property {number|null} [routingAppId] CMsgWebAPIRequest routingAppId\n     */\n    /**\n     * Constructs a new CMsgWebAPIRequest.\n     * @exports CMsgWebAPIRequest\n     * @classdesc Represents a CMsgWebAPIRequest.\n     * @implements ICMsgWebAPIRequest\n     * @constructor\n     * @param {ICMsgWebAPIRequest=} [properties] Properties to set\n     */\n    function CMsgWebAPIRequest(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgWebAPIRequest UNUSEDJobName.\n     * @member {string} UNUSEDJobName\n     * @memberof CMsgWebAPIRequest\n     * @instance\n     */\n    CMsgWebAPIRequest.prototype.UNUSEDJobName = \"\";\n    /**\n     * CMsgWebAPIRequest interfaceName.\n     * @member {string} interfaceName\n     * @memberof CMsgWebAPIRequest\n     * @instance\n     */\n    CMsgWebAPIRequest.prototype.interfaceName = \"\";\n    /**\n     * CMsgWebAPIRequest methodName.\n     * @member {string} methodName\n     * @memberof CMsgWebAPIRequest\n     * @instance\n     */\n    CMsgWebAPIRequest.prototype.methodName = \"\";\n    /**\n     * CMsgWebAPIRequest version.\n     * @member {number} version\n     * @memberof CMsgWebAPIRequest\n     * @instance\n     */\n    CMsgWebAPIRequest.prototype.version = 0;\n    /**\n     * CMsgWebAPIRequest apiKey.\n     * @member {ICMsgWebAPIKey|null|undefined} apiKey\n     * @memberof CMsgWebAPIRequest\n     * @instance\n     */\n    CMsgWebAPIRequest.prototype.apiKey = null;\n    /**\n     * CMsgWebAPIRequest request.\n     * @member {ICMsgHttpRequest|null|undefined} request\n     * @memberof CMsgWebAPIRequest\n     * @instance\n     */\n    CMsgWebAPIRequest.prototype.request = null;\n    /**\n     * CMsgWebAPIRequest routingAppId.\n     * @member {number} routingAppId\n     * @memberof CMsgWebAPIRequest\n     * @instance\n     */\n    CMsgWebAPIRequest.prototype.routingAppId = 0;\n    /**\n     * Decodes a CMsgWebAPIRequest message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgWebAPIRequest\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgWebAPIRequest} CMsgWebAPIRequest\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgWebAPIRequest.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgWebAPIRequest();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.UNUSEDJobName = reader.string();\n                    break;\n                case 2:\n                    message.interfaceName = reader.string();\n                    break;\n                case 3:\n                    message.methodName = reader.string();\n                    break;\n                case 4:\n                    message.version = reader.uint32();\n                    break;\n                case 5:\n                    message.apiKey = $root.CMsgWebAPIKey.decode(reader, reader.uint32());\n                    break;\n                case 6:\n                    message.request = $root.CMsgHttpRequest.decode(reader, reader.uint32());\n                    break;\n                case 7:\n                    message.routingAppId = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgWebAPIRequest;\n})());\nexports.CMsgHttpResponse = ($root.CMsgHttpResponse = (() => {\n    /**\n     * Properties of a CMsgHttpResponse.\n     * @exports ICMsgHttpResponse\n     * @interface ICMsgHttpResponse\n     * @property {number|null} [statusCode] CMsgHttpResponse statusCode\n     * @property {Array.<CMsgHttpResponse.IResponseHeader>|null} [headers] CMsgHttpResponse headers\n     * @property {Uint8Array|null} [body] CMsgHttpResponse body\n     */\n    /**\n     * Constructs a new CMsgHttpResponse.\n     * @exports CMsgHttpResponse\n     * @classdesc Represents a CMsgHttpResponse.\n     * @implements ICMsgHttpResponse\n     * @constructor\n     * @param {ICMsgHttpResponse=} [properties] Properties to set\n     */\n    function CMsgHttpResponse(properties) {\n        this.headers = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgHttpResponse statusCode.\n     * @member {number} statusCode\n     * @memberof CMsgHttpResponse\n     * @instance\n     */\n    CMsgHttpResponse.prototype.statusCode = 0;\n    /**\n     * CMsgHttpResponse headers.\n     * @member {Array.<CMsgHttpResponse.IResponseHeader>} headers\n     * @memberof CMsgHttpResponse\n     * @instance\n     */\n    CMsgHttpResponse.prototype.headers = $util.emptyArray;\n    /**\n     * CMsgHttpResponse body.\n     * @member {Uint8Array} body\n     * @memberof CMsgHttpResponse\n     * @instance\n     */\n    CMsgHttpResponse.prototype.body = $util.newBuffer([]);\n    /**\n     * Decodes a CMsgHttpResponse message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgHttpResponse\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgHttpResponse} CMsgHttpResponse\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgHttpResponse.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgHttpResponse();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.statusCode = reader.uint32();\n                    break;\n                case 2:\n                    if (!(message.headers && message.headers.length))\n                        message.headers = [];\n                    message.headers.push($root.CMsgHttpResponse.ResponseHeader.decode(reader, reader.uint32()));\n                    break;\n                case 3:\n                    message.body = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CMsgHttpResponse.ResponseHeader = (function () {\n        /**\n         * Properties of a ResponseHeader.\n         * @memberof CMsgHttpResponse\n         * @interface IResponseHeader\n         * @property {string|null} [name] ResponseHeader name\n         * @property {string|null} [value] ResponseHeader value\n         */\n        /**\n         * Constructs a new ResponseHeader.\n         * @memberof CMsgHttpResponse\n         * @classdesc Represents a ResponseHeader.\n         * @implements IResponseHeader\n         * @constructor\n         * @param {CMsgHttpResponse.IResponseHeader=} [properties] Properties to set\n         */\n        function ResponseHeader(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * ResponseHeader name.\n         * @member {string} name\n         * @memberof CMsgHttpResponse.ResponseHeader\n         * @instance\n         */\n        ResponseHeader.prototype.name = \"\";\n        /**\n         * ResponseHeader value.\n         * @member {string} value\n         * @memberof CMsgHttpResponse.ResponseHeader\n         * @instance\n         */\n        ResponseHeader.prototype.value = \"\";\n        /**\n         * Decodes a ResponseHeader message from the specified reader or buffer.\n         * @function decode\n         * @memberof CMsgHttpResponse.ResponseHeader\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CMsgHttpResponse.ResponseHeader} ResponseHeader\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ResponseHeader.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgHttpResponse.ResponseHeader();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.name = reader.string();\n                        break;\n                    case 2:\n                        message.value = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return ResponseHeader;\n    })();\n    return CMsgHttpResponse;\n})());\nexports.CMsgAMFindAccounts = ($root.CMsgAMFindAccounts = (() => {\n    /**\n     * Properties of a CMsgAMFindAccounts.\n     * @exports ICMsgAMFindAccounts\n     * @interface ICMsgAMFindAccounts\n     * @property {number|null} [searchType] CMsgAMFindAccounts searchType\n     * @property {string|null} [searchString] CMsgAMFindAccounts searchString\n     */\n    /**\n     * Constructs a new CMsgAMFindAccounts.\n     * @exports CMsgAMFindAccounts\n     * @classdesc Represents a CMsgAMFindAccounts.\n     * @implements ICMsgAMFindAccounts\n     * @constructor\n     * @param {ICMsgAMFindAccounts=} [properties] Properties to set\n     */\n    function CMsgAMFindAccounts(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgAMFindAccounts searchType.\n     * @member {number} searchType\n     * @memberof CMsgAMFindAccounts\n     * @instance\n     */\n    CMsgAMFindAccounts.prototype.searchType = 0;\n    /**\n     * CMsgAMFindAccounts searchString.\n     * @member {string} searchString\n     * @memberof CMsgAMFindAccounts\n     * @instance\n     */\n    CMsgAMFindAccounts.prototype.searchString = \"\";\n    /**\n     * Decodes a CMsgAMFindAccounts message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgAMFindAccounts\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgAMFindAccounts} CMsgAMFindAccounts\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgAMFindAccounts.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMFindAccounts();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.searchType = reader.uint32();\n                    break;\n                case 2:\n                    message.searchString = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgAMFindAccounts;\n})());\nexports.CMsgAMFindAccountsResponse = ($root.CMsgAMFindAccountsResponse = (() => {\n    /**\n     * Properties of a CMsgAMFindAccountsResponse.\n     * @exports ICMsgAMFindAccountsResponse\n     * @interface ICMsgAMFindAccountsResponse\n     * @property {Array.<number|Long>|null} [steamId] CMsgAMFindAccountsResponse steamId\n     */\n    /**\n     * Constructs a new CMsgAMFindAccountsResponse.\n     * @exports CMsgAMFindAccountsResponse\n     * @classdesc Represents a CMsgAMFindAccountsResponse.\n     * @implements ICMsgAMFindAccountsResponse\n     * @constructor\n     * @param {ICMsgAMFindAccountsResponse=} [properties] Properties to set\n     */\n    function CMsgAMFindAccountsResponse(properties) {\n        this.steamId = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgAMFindAccountsResponse steamId.\n     * @member {Array.<number|Long>} steamId\n     * @memberof CMsgAMFindAccountsResponse\n     * @instance\n     */\n    CMsgAMFindAccountsResponse.prototype.steamId = $util.emptyArray;\n    /**\n     * Decodes a CMsgAMFindAccountsResponse message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgAMFindAccountsResponse\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgAMFindAccountsResponse} CMsgAMFindAccountsResponse\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgAMFindAccountsResponse.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMFindAccountsResponse();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.steamId && message.steamId.length))\n                        message.steamId = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.steamId.push(reader.fixed64());\n                    }\n                    else\n                        message.steamId.push(reader.fixed64());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgAMFindAccountsResponse;\n})());\nexports.CMsgNotifyWatchdog = ($root.CMsgNotifyWatchdog = (() => {\n    /**\n     * Properties of a CMsgNotifyWatchdog.\n     * @exports ICMsgNotifyWatchdog\n     * @interface ICMsgNotifyWatchdog\n     * @property {number|null} [source] CMsgNotifyWatchdog source\n     * @property {number|null} [alertType] CMsgNotifyWatchdog alertType\n     * @property {number|null} [alertDestination] CMsgNotifyWatchdog alertDestination\n     * @property {boolean|null} [critical] CMsgNotifyWatchdog critical\n     * @property {number|null} [time] CMsgNotifyWatchdog time\n     * @property {number|null} [appid] CMsgNotifyWatchdog appid\n     * @property {string|null} [text] CMsgNotifyWatchdog text\n     */\n    /**\n     * Constructs a new CMsgNotifyWatchdog.\n     * @exports CMsgNotifyWatchdog\n     * @classdesc Represents a CMsgNotifyWatchdog.\n     * @implements ICMsgNotifyWatchdog\n     * @constructor\n     * @param {ICMsgNotifyWatchdog=} [properties] Properties to set\n     */\n    function CMsgNotifyWatchdog(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgNotifyWatchdog source.\n     * @member {number} source\n     * @memberof CMsgNotifyWatchdog\n     * @instance\n     */\n    CMsgNotifyWatchdog.prototype.source = 0;\n    /**\n     * CMsgNotifyWatchdog alertType.\n     * @member {number} alertType\n     * @memberof CMsgNotifyWatchdog\n     * @instance\n     */\n    CMsgNotifyWatchdog.prototype.alertType = 0;\n    /**\n     * CMsgNotifyWatchdog alertDestination.\n     * @member {number} alertDestination\n     * @memberof CMsgNotifyWatchdog\n     * @instance\n     */\n    CMsgNotifyWatchdog.prototype.alertDestination = 0;\n    /**\n     * CMsgNotifyWatchdog critical.\n     * @member {boolean} critical\n     * @memberof CMsgNotifyWatchdog\n     * @instance\n     */\n    CMsgNotifyWatchdog.prototype.critical = false;\n    /**\n     * CMsgNotifyWatchdog time.\n     * @member {number} time\n     * @memberof CMsgNotifyWatchdog\n     * @instance\n     */\n    CMsgNotifyWatchdog.prototype.time = 0;\n    /**\n     * CMsgNotifyWatchdog appid.\n     * @member {number} appid\n     * @memberof CMsgNotifyWatchdog\n     * @instance\n     */\n    CMsgNotifyWatchdog.prototype.appid = 0;\n    /**\n     * CMsgNotifyWatchdog text.\n     * @member {string} text\n     * @memberof CMsgNotifyWatchdog\n     * @instance\n     */\n    CMsgNotifyWatchdog.prototype.text = \"\";\n    /**\n     * Decodes a CMsgNotifyWatchdog message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgNotifyWatchdog\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgNotifyWatchdog} CMsgNotifyWatchdog\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgNotifyWatchdog.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgNotifyWatchdog();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.source = reader.uint32();\n                    break;\n                case 2:\n                    message.alertType = reader.uint32();\n                    break;\n                case 3:\n                    message.alertDestination = reader.uint32();\n                    break;\n                case 4:\n                    message.critical = reader.bool();\n                    break;\n                case 5:\n                    message.time = reader.uint32();\n                    break;\n                case 6:\n                    message.appid = reader.uint32();\n                    break;\n                case 7:\n                    message.text = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgNotifyWatchdog;\n})());\nexports.CMsgAMGetLicenses = ($root.CMsgAMGetLicenses = (() => {\n    /**\n     * Properties of a CMsgAMGetLicenses.\n     * @exports ICMsgAMGetLicenses\n     * @interface ICMsgAMGetLicenses\n     * @property {number|Long|null} [steamid] CMsgAMGetLicenses steamid\n     */\n    /**\n     * Constructs a new CMsgAMGetLicenses.\n     * @exports CMsgAMGetLicenses\n     * @classdesc Represents a CMsgAMGetLicenses.\n     * @implements ICMsgAMGetLicenses\n     * @constructor\n     * @param {ICMsgAMGetLicenses=} [properties] Properties to set\n     */\n    function CMsgAMGetLicenses(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgAMGetLicenses steamid.\n     * @member {number|Long} steamid\n     * @memberof CMsgAMGetLicenses\n     * @instance\n     */\n    CMsgAMGetLicenses.prototype.steamid = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0;\n    /**\n     * Decodes a CMsgAMGetLicenses message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgAMGetLicenses\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgAMGetLicenses} CMsgAMGetLicenses\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgAMGetLicenses.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMGetLicenses();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.steamid = reader.fixed64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgAMGetLicenses;\n})());\nexports.CMsgPackageLicense = ($root.CMsgPackageLicense = (() => {\n    /**\n     * Properties of a CMsgPackageLicense.\n     * @exports ICMsgPackageLicense\n     * @interface ICMsgPackageLicense\n     * @property {number|null} [packageId] CMsgPackageLicense packageId\n     * @property {number|null} [timeCreated] CMsgPackageLicense timeCreated\n     * @property {number|null} [ownerId] CMsgPackageLicense ownerId\n     */\n    /**\n     * Constructs a new CMsgPackageLicense.\n     * @exports CMsgPackageLicense\n     * @classdesc Represents a CMsgPackageLicense.\n     * @implements ICMsgPackageLicense\n     * @constructor\n     * @param {ICMsgPackageLicense=} [properties] Properties to set\n     */\n    function CMsgPackageLicense(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgPackageLicense packageId.\n     * @member {number} packageId\n     * @memberof CMsgPackageLicense\n     * @instance\n     */\n    CMsgPackageLicense.prototype.packageId = 0;\n    /**\n     * CMsgPackageLicense timeCreated.\n     * @member {number} timeCreated\n     * @memberof CMsgPackageLicense\n     * @instance\n     */\n    CMsgPackageLicense.prototype.timeCreated = 0;\n    /**\n     * CMsgPackageLicense ownerId.\n     * @member {number} ownerId\n     * @memberof CMsgPackageLicense\n     * @instance\n     */\n    CMsgPackageLicense.prototype.ownerId = 0;\n    /**\n     * Decodes a CMsgPackageLicense message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgPackageLicense\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgPackageLicense} CMsgPackageLicense\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgPackageLicense.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgPackageLicense();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.packageId = reader.uint32();\n                    break;\n                case 2:\n                    message.timeCreated = reader.uint32();\n                    break;\n                case 3:\n                    message.ownerId = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgPackageLicense;\n})());\nexports.CMsgAMGetLicensesResponse = ($root.CMsgAMGetLicensesResponse = (() => {\n    /**\n     * Properties of a CMsgAMGetLicensesResponse.\n     * @exports ICMsgAMGetLicensesResponse\n     * @interface ICMsgAMGetLicensesResponse\n     * @property {Array.<ICMsgPackageLicense>|null} [license] CMsgAMGetLicensesResponse license\n     * @property {number|null} [result] CMsgAMGetLicensesResponse result\n     */\n    /**\n     * Constructs a new CMsgAMGetLicensesResponse.\n     * @exports CMsgAMGetLicensesResponse\n     * @classdesc Represents a CMsgAMGetLicensesResponse.\n     * @implements ICMsgAMGetLicensesResponse\n     * @constructor\n     * @param {ICMsgAMGetLicensesResponse=} [properties] Properties to set\n     */\n    function CMsgAMGetLicensesResponse(properties) {\n        this.license = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgAMGetLicensesResponse license.\n     * @member {Array.<ICMsgPackageLicense>} license\n     * @memberof CMsgAMGetLicensesResponse\n     * @instance\n     */\n    CMsgAMGetLicensesResponse.prototype.license = $util.emptyArray;\n    /**\n     * CMsgAMGetLicensesResponse result.\n     * @member {number} result\n     * @memberof CMsgAMGetLicensesResponse\n     * @instance\n     */\n    CMsgAMGetLicensesResponse.prototype.result = 0;\n    /**\n     * Decodes a CMsgAMGetLicensesResponse message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgAMGetLicensesResponse\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgAMGetLicensesResponse} CMsgAMGetLicensesResponse\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgAMGetLicensesResponse.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMGetLicensesResponse();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.license && message.license.length))\n                        message.license = [];\n                    message.license.push($root.CMsgPackageLicense.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.result = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgAMGetLicensesResponse;\n})());\nexports.CMsgAMGetUserGameStats = ($root.CMsgAMGetUserGameStats = (() => {\n    /**\n     * Properties of a CMsgAMGetUserGameStats.\n     * @exports ICMsgAMGetUserGameStats\n     * @interface ICMsgAMGetUserGameStats\n     * @property {number|Long|null} [steamId] CMsgAMGetUserGameStats steamId\n     * @property {number|Long|null} [gameId] CMsgAMGetUserGameStats gameId\n     * @property {Array.<number>|null} [stats] CMsgAMGetUserGameStats stats\n     */\n    /**\n     * Constructs a new CMsgAMGetUserGameStats.\n     * @exports CMsgAMGetUserGameStats\n     * @classdesc Represents a CMsgAMGetUserGameStats.\n     * @implements ICMsgAMGetUserGameStats\n     * @constructor\n     * @param {ICMsgAMGetUserGameStats=} [properties] Properties to set\n     */\n    function CMsgAMGetUserGameStats(properties) {\n        this.stats = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgAMGetUserGameStats steamId.\n     * @member {number|Long} steamId\n     * @memberof CMsgAMGetUserGameStats\n     * @instance\n     */\n    CMsgAMGetUserGameStats.prototype.steamId = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0;\n    /**\n     * CMsgAMGetUserGameStats gameId.\n     * @member {number|Long} gameId\n     * @memberof CMsgAMGetUserGameStats\n     * @instance\n     */\n    CMsgAMGetUserGameStats.prototype.gameId = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0;\n    /**\n     * CMsgAMGetUserGameStats stats.\n     * @member {Array.<number>} stats\n     * @memberof CMsgAMGetUserGameStats\n     * @instance\n     */\n    CMsgAMGetUserGameStats.prototype.stats = $util.emptyArray;\n    /**\n     * Decodes a CMsgAMGetUserGameStats message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgAMGetUserGameStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgAMGetUserGameStats} CMsgAMGetUserGameStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgAMGetUserGameStats.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMGetUserGameStats();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.steamId = reader.fixed64();\n                    break;\n                case 2:\n                    message.gameId = reader.fixed64();\n                    break;\n                case 3:\n                    if (!(message.stats && message.stats.length))\n                        message.stats = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.stats.push(reader.uint32());\n                    }\n                    else\n                        message.stats.push(reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgAMGetUserGameStats;\n})());\nexports.CMsgAMGetUserGameStatsResponse = ($root.CMsgAMGetUserGameStatsResponse = (() => {\n    /**\n     * Properties of a CMsgAMGetUserGameStatsResponse.\n     * @exports ICMsgAMGetUserGameStatsResponse\n     * @interface ICMsgAMGetUserGameStatsResponse\n     * @property {number|Long|null} [steamId] CMsgAMGetUserGameStatsResponse steamId\n     * @property {number|Long|null} [gameId] CMsgAMGetUserGameStatsResponse gameId\n     * @property {number|null} [eresult] CMsgAMGetUserGameStatsResponse eresult\n     * @property {Array.<CMsgAMGetUserGameStatsResponse.IStats>|null} [stats] CMsgAMGetUserGameStatsResponse stats\n     * @property {Array.<CMsgAMGetUserGameStatsResponse.IAchievement_Blocks>|null} [achievementBlocks] CMsgAMGetUserGameStatsResponse achievementBlocks\n     */\n    /**\n     * Constructs a new CMsgAMGetUserGameStatsResponse.\n     * @exports CMsgAMGetUserGameStatsResponse\n     * @classdesc Represents a CMsgAMGetUserGameStatsResponse.\n     * @implements ICMsgAMGetUserGameStatsResponse\n     * @constructor\n     * @param {ICMsgAMGetUserGameStatsResponse=} [properties] Properties to set\n     */\n    function CMsgAMGetUserGameStatsResponse(properties) {\n        this.stats = [];\n        this.achievementBlocks = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgAMGetUserGameStatsResponse steamId.\n     * @member {number|Long} steamId\n     * @memberof CMsgAMGetUserGameStatsResponse\n     * @instance\n     */\n    CMsgAMGetUserGameStatsResponse.prototype.steamId = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0;\n    /**\n     * CMsgAMGetUserGameStatsResponse gameId.\n     * @member {number|Long} gameId\n     * @memberof CMsgAMGetUserGameStatsResponse\n     * @instance\n     */\n    CMsgAMGetUserGameStatsResponse.prototype.gameId = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0;\n    /**\n     * CMsgAMGetUserGameStatsResponse eresult.\n     * @member {number} eresult\n     * @memberof CMsgAMGetUserGameStatsResponse\n     * @instance\n     */\n    CMsgAMGetUserGameStatsResponse.prototype.eresult = 2;\n    /**\n     * CMsgAMGetUserGameStatsResponse stats.\n     * @member {Array.<CMsgAMGetUserGameStatsResponse.IStats>} stats\n     * @memberof CMsgAMGetUserGameStatsResponse\n     * @instance\n     */\n    CMsgAMGetUserGameStatsResponse.prototype.stats = $util.emptyArray;\n    /**\n     * CMsgAMGetUserGameStatsResponse achievementBlocks.\n     * @member {Array.<CMsgAMGetUserGameStatsResponse.IAchievement_Blocks>} achievementBlocks\n     * @memberof CMsgAMGetUserGameStatsResponse\n     * @instance\n     */\n    CMsgAMGetUserGameStatsResponse.prototype.achievementBlocks = $util.emptyArray;\n    /**\n     * Decodes a CMsgAMGetUserGameStatsResponse message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgAMGetUserGameStatsResponse\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgAMGetUserGameStatsResponse} CMsgAMGetUserGameStatsResponse\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgAMGetUserGameStatsResponse.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMGetUserGameStatsResponse();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.steamId = reader.fixed64();\n                    break;\n                case 2:\n                    message.gameId = reader.fixed64();\n                    break;\n                case 3:\n                    message.eresult = reader.int32();\n                    break;\n                case 4:\n                    if (!(message.stats && message.stats.length))\n                        message.stats = [];\n                    message.stats.push($root.CMsgAMGetUserGameStatsResponse.Stats.decode(reader, reader.uint32()));\n                    break;\n                case 5:\n                    if (!(message.achievementBlocks && message.achievementBlocks.length))\n                        message.achievementBlocks = [];\n                    message.achievementBlocks.push($root.CMsgAMGetUserGameStatsResponse.Achievement_Blocks.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CMsgAMGetUserGameStatsResponse.Stats = (function () {\n        /**\n         * Properties of a Stats.\n         * @memberof CMsgAMGetUserGameStatsResponse\n         * @interface IStats\n         * @property {number|null} [statId] Stats statId\n         * @property {number|null} [statValue] Stats statValue\n         */\n        /**\n         * Constructs a new Stats.\n         * @memberof CMsgAMGetUserGameStatsResponse\n         * @classdesc Represents a Stats.\n         * @implements IStats\n         * @constructor\n         * @param {CMsgAMGetUserGameStatsResponse.IStats=} [properties] Properties to set\n         */\n        function Stats(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * Stats statId.\n         * @member {number} statId\n         * @memberof CMsgAMGetUserGameStatsResponse.Stats\n         * @instance\n         */\n        Stats.prototype.statId = 0;\n        /**\n         * Stats statValue.\n         * @member {number} statValue\n         * @memberof CMsgAMGetUserGameStatsResponse.Stats\n         * @instance\n         */\n        Stats.prototype.statValue = 0;\n        /**\n         * Decodes a Stats message from the specified reader or buffer.\n         * @function decode\n         * @memberof CMsgAMGetUserGameStatsResponse.Stats\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CMsgAMGetUserGameStatsResponse.Stats} Stats\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Stats.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMGetUserGameStatsResponse.Stats();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.statId = reader.uint32();\n                        break;\n                    case 2:\n                        message.statValue = reader.uint32();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return Stats;\n    })();\n    CMsgAMGetUserGameStatsResponse.Achievement_Blocks = (function () {\n        /**\n         * Properties of an Achievement_Blocks.\n         * @memberof CMsgAMGetUserGameStatsResponse\n         * @interface IAchievement_Blocks\n         * @property {number|null} [achievementId] Achievement_Blocks achievementId\n         * @property {number|null} [achievementBitId] Achievement_Blocks achievementBitId\n         * @property {number|null} [unlockTime] Achievement_Blocks unlockTime\n         */\n        /**\n         * Constructs a new Achievement_Blocks.\n         * @memberof CMsgAMGetUserGameStatsResponse\n         * @classdesc Represents an Achievement_Blocks.\n         * @implements IAchievement_Blocks\n         * @constructor\n         * @param {CMsgAMGetUserGameStatsResponse.IAchievement_Blocks=} [properties] Properties to set\n         */\n        function Achievement_Blocks(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * Achievement_Blocks achievementId.\n         * @member {number} achievementId\n         * @memberof CMsgAMGetUserGameStatsResponse.Achievement_Blocks\n         * @instance\n         */\n        Achievement_Blocks.prototype.achievementId = 0;\n        /**\n         * Achievement_Blocks achievementBitId.\n         * @member {number} achievementBitId\n         * @memberof CMsgAMGetUserGameStatsResponse.Achievement_Blocks\n         * @instance\n         */\n        Achievement_Blocks.prototype.achievementBitId = 0;\n        /**\n         * Achievement_Blocks unlockTime.\n         * @member {number} unlockTime\n         * @memberof CMsgAMGetUserGameStatsResponse.Achievement_Blocks\n         * @instance\n         */\n        Achievement_Blocks.prototype.unlockTime = 0;\n        /**\n         * Decodes an Achievement_Blocks message from the specified reader or buffer.\n         * @function decode\n         * @memberof CMsgAMGetUserGameStatsResponse.Achievement_Blocks\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CMsgAMGetUserGameStatsResponse.Achievement_Blocks} Achievement_Blocks\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Achievement_Blocks.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMGetUserGameStatsResponse.Achievement_Blocks();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.achievementId = reader.uint32();\n                        break;\n                    case 2:\n                        message.achievementBitId = reader.uint32();\n                        break;\n                    case 3:\n                        message.unlockTime = reader.fixed32();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return Achievement_Blocks;\n    })();\n    return CMsgAMGetUserGameStatsResponse;\n})());\nexports.CMsgGCGetCommandList = ($root.CMsgGCGetCommandList = (() => {\n    /**\n     * Properties of a CMsgGCGetCommandList.\n     * @exports ICMsgGCGetCommandList\n     * @interface ICMsgGCGetCommandList\n     * @property {number|null} [appId] CMsgGCGetCommandList appId\n     * @property {string|null} [commandPrefix] CMsgGCGetCommandList commandPrefix\n     */\n    /**\n     * Constructs a new CMsgGCGetCommandList.\n     * @exports CMsgGCGetCommandList\n     * @classdesc Represents a CMsgGCGetCommandList.\n     * @implements ICMsgGCGetCommandList\n     * @constructor\n     * @param {ICMsgGCGetCommandList=} [properties] Properties to set\n     */\n    function CMsgGCGetCommandList(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCGetCommandList appId.\n     * @member {number} appId\n     * @memberof CMsgGCGetCommandList\n     * @instance\n     */\n    CMsgGCGetCommandList.prototype.appId = 0;\n    /**\n     * CMsgGCGetCommandList commandPrefix.\n     * @member {string} commandPrefix\n     * @memberof CMsgGCGetCommandList\n     * @instance\n     */\n    CMsgGCGetCommandList.prototype.commandPrefix = \"\";\n    /**\n     * Decodes a CMsgGCGetCommandList message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCGetCommandList\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCGetCommandList} CMsgGCGetCommandList\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCGetCommandList.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetCommandList();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.appId = reader.uint32();\n                    break;\n                case 2:\n                    message.commandPrefix = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCGetCommandList;\n})());\nexports.CMsgGCGetCommandListResponse = ($root.CMsgGCGetCommandListResponse = (() => {\n    /**\n     * Properties of a CMsgGCGetCommandListResponse.\n     * @exports ICMsgGCGetCommandListResponse\n     * @interface ICMsgGCGetCommandListResponse\n     * @property {Array.<string>|null} [commandName] CMsgGCGetCommandListResponse commandName\n     */\n    /**\n     * Constructs a new CMsgGCGetCommandListResponse.\n     * @exports CMsgGCGetCommandListResponse\n     * @classdesc Represents a CMsgGCGetCommandListResponse.\n     * @implements ICMsgGCGetCommandListResponse\n     * @constructor\n     * @param {ICMsgGCGetCommandListResponse=} [properties] Properties to set\n     */\n    function CMsgGCGetCommandListResponse(properties) {\n        this.commandName = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCGetCommandListResponse commandName.\n     * @member {Array.<string>} commandName\n     * @memberof CMsgGCGetCommandListResponse\n     * @instance\n     */\n    CMsgGCGetCommandListResponse.prototype.commandName = $util.emptyArray;\n    /**\n     * Decodes a CMsgGCGetCommandListResponse message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCGetCommandListResponse\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCGetCommandListResponse} CMsgGCGetCommandListResponse\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCGetCommandListResponse.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetCommandListResponse();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.commandName && message.commandName.length))\n                        message.commandName = [];\n                    message.commandName.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCGetCommandListResponse;\n})());\nexports.CGCMsgMemCachedGet = ($root.CGCMsgMemCachedGet = (() => {\n    /**\n     * Properties of a CGCMsgMemCachedGet.\n     * @exports ICGCMsgMemCachedGet\n     * @interface ICGCMsgMemCachedGet\n     * @property {Array.<string>|null} [keys] CGCMsgMemCachedGet keys\n     */\n    /**\n     * Constructs a new CGCMsgMemCachedGet.\n     * @exports CGCMsgMemCachedGet\n     * @classdesc Represents a CGCMsgMemCachedGet.\n     * @implements ICGCMsgMemCachedGet\n     * @constructor\n     * @param {ICGCMsgMemCachedGet=} [properties] Properties to set\n     */\n    function CGCMsgMemCachedGet(properties) {\n        this.keys = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CGCMsgMemCachedGet keys.\n     * @member {Array.<string>} keys\n     * @memberof CGCMsgMemCachedGet\n     * @instance\n     */\n    CGCMsgMemCachedGet.prototype.keys = $util.emptyArray;\n    /**\n     * Decodes a CGCMsgMemCachedGet message from the specified reader or buffer.\n     * @function decode\n     * @memberof CGCMsgMemCachedGet\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CGCMsgMemCachedGet} CGCMsgMemCachedGet\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CGCMsgMemCachedGet.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgMemCachedGet();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.keys && message.keys.length))\n                        message.keys = [];\n                    message.keys.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CGCMsgMemCachedGet;\n})());\nexports.CGCMsgMemCachedGetResponse = ($root.CGCMsgMemCachedGetResponse = (() => {\n    /**\n     * Properties of a CGCMsgMemCachedGetResponse.\n     * @exports ICGCMsgMemCachedGetResponse\n     * @interface ICGCMsgMemCachedGetResponse\n     * @property {Array.<CGCMsgMemCachedGetResponse.IValueTag>|null} [values] CGCMsgMemCachedGetResponse values\n     */\n    /**\n     * Constructs a new CGCMsgMemCachedGetResponse.\n     * @exports CGCMsgMemCachedGetResponse\n     * @classdesc Represents a CGCMsgMemCachedGetResponse.\n     * @implements ICGCMsgMemCachedGetResponse\n     * @constructor\n     * @param {ICGCMsgMemCachedGetResponse=} [properties] Properties to set\n     */\n    function CGCMsgMemCachedGetResponse(properties) {\n        this.values = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CGCMsgMemCachedGetResponse values.\n     * @member {Array.<CGCMsgMemCachedGetResponse.IValueTag>} values\n     * @memberof CGCMsgMemCachedGetResponse\n     * @instance\n     */\n    CGCMsgMemCachedGetResponse.prototype.values = $util.emptyArray;\n    /**\n     * Decodes a CGCMsgMemCachedGetResponse message from the specified reader or buffer.\n     * @function decode\n     * @memberof CGCMsgMemCachedGetResponse\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CGCMsgMemCachedGetResponse} CGCMsgMemCachedGetResponse\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CGCMsgMemCachedGetResponse.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgMemCachedGetResponse();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.values && message.values.length))\n                        message.values = [];\n                    message.values.push($root.CGCMsgMemCachedGetResponse.ValueTag.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CGCMsgMemCachedGetResponse.ValueTag = (function () {\n        /**\n         * Properties of a ValueTag.\n         * @memberof CGCMsgMemCachedGetResponse\n         * @interface IValueTag\n         * @property {boolean|null} [found] ValueTag found\n         * @property {Uint8Array|null} [value] ValueTag value\n         */\n        /**\n         * Constructs a new ValueTag.\n         * @memberof CGCMsgMemCachedGetResponse\n         * @classdesc Represents a ValueTag.\n         * @implements IValueTag\n         * @constructor\n         * @param {CGCMsgMemCachedGetResponse.IValueTag=} [properties] Properties to set\n         */\n        function ValueTag(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * ValueTag found.\n         * @member {boolean} found\n         * @memberof CGCMsgMemCachedGetResponse.ValueTag\n         * @instance\n         */\n        ValueTag.prototype.found = false;\n        /**\n         * ValueTag value.\n         * @member {Uint8Array} value\n         * @memberof CGCMsgMemCachedGetResponse.ValueTag\n         * @instance\n         */\n        ValueTag.prototype.value = $util.newBuffer([]);\n        /**\n         * Decodes a ValueTag message from the specified reader or buffer.\n         * @function decode\n         * @memberof CGCMsgMemCachedGetResponse.ValueTag\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CGCMsgMemCachedGetResponse.ValueTag} ValueTag\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ValueTag.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgMemCachedGetResponse.ValueTag();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.found = reader.bool();\n                        break;\n                    case 2:\n                        message.value = reader.bytes();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return ValueTag;\n    })();\n    return CGCMsgMemCachedGetResponse;\n})());\nexports.CGCMsgMemCachedSet = ($root.CGCMsgMemCachedSet = (() => {\n    /**\n     * Properties of a CGCMsgMemCachedSet.\n     * @exports ICGCMsgMemCachedSet\n     * @interface ICGCMsgMemCachedSet\n     * @property {Array.<CGCMsgMemCachedSet.IKeyPair>|null} [keys] CGCMsgMemCachedSet keys\n     */\n    /**\n     * Constructs a new CGCMsgMemCachedSet.\n     * @exports CGCMsgMemCachedSet\n     * @classdesc Represents a CGCMsgMemCachedSet.\n     * @implements ICGCMsgMemCachedSet\n     * @constructor\n     * @param {ICGCMsgMemCachedSet=} [properties] Properties to set\n     */\n    function CGCMsgMemCachedSet(properties) {\n        this.keys = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CGCMsgMemCachedSet keys.\n     * @member {Array.<CGCMsgMemCachedSet.IKeyPair>} keys\n     * @memberof CGCMsgMemCachedSet\n     * @instance\n     */\n    CGCMsgMemCachedSet.prototype.keys = $util.emptyArray;\n    /**\n     * Decodes a CGCMsgMemCachedSet message from the specified reader or buffer.\n     * @function decode\n     * @memberof CGCMsgMemCachedSet\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CGCMsgMemCachedSet} CGCMsgMemCachedSet\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CGCMsgMemCachedSet.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgMemCachedSet();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.keys && message.keys.length))\n                        message.keys = [];\n                    message.keys.push($root.CGCMsgMemCachedSet.KeyPair.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CGCMsgMemCachedSet.KeyPair = (function () {\n        /**\n         * Properties of a KeyPair.\n         * @memberof CGCMsgMemCachedSet\n         * @interface IKeyPair\n         * @property {string|null} [name] KeyPair name\n         * @property {Uint8Array|null} [value] KeyPair value\n         */\n        /**\n         * Constructs a new KeyPair.\n         * @memberof CGCMsgMemCachedSet\n         * @classdesc Represents a KeyPair.\n         * @implements IKeyPair\n         * @constructor\n         * @param {CGCMsgMemCachedSet.IKeyPair=} [properties] Properties to set\n         */\n        function KeyPair(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * KeyPair name.\n         * @member {string} name\n         * @memberof CGCMsgMemCachedSet.KeyPair\n         * @instance\n         */\n        KeyPair.prototype.name = \"\";\n        /**\n         * KeyPair value.\n         * @member {Uint8Array} value\n         * @memberof CGCMsgMemCachedSet.KeyPair\n         * @instance\n         */\n        KeyPair.prototype.value = $util.newBuffer([]);\n        /**\n         * Decodes a KeyPair message from the specified reader or buffer.\n         * @function decode\n         * @memberof CGCMsgMemCachedSet.KeyPair\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CGCMsgMemCachedSet.KeyPair} KeyPair\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        KeyPair.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgMemCachedSet.KeyPair();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.name = reader.string();\n                        break;\n                    case 2:\n                        message.value = reader.bytes();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return KeyPair;\n    })();\n    return CGCMsgMemCachedSet;\n})());\nexports.CGCMsgMemCachedDelete = ($root.CGCMsgMemCachedDelete = (() => {\n    /**\n     * Properties of a CGCMsgMemCachedDelete.\n     * @exports ICGCMsgMemCachedDelete\n     * @interface ICGCMsgMemCachedDelete\n     * @property {Array.<string>|null} [keys] CGCMsgMemCachedDelete keys\n     */\n    /**\n     * Constructs a new CGCMsgMemCachedDelete.\n     * @exports CGCMsgMemCachedDelete\n     * @classdesc Represents a CGCMsgMemCachedDelete.\n     * @implements ICGCMsgMemCachedDelete\n     * @constructor\n     * @param {ICGCMsgMemCachedDelete=} [properties] Properties to set\n     */\n    function CGCMsgMemCachedDelete(properties) {\n        this.keys = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CGCMsgMemCachedDelete keys.\n     * @member {Array.<string>} keys\n     * @memberof CGCMsgMemCachedDelete\n     * @instance\n     */\n    CGCMsgMemCachedDelete.prototype.keys = $util.emptyArray;\n    /**\n     * Decodes a CGCMsgMemCachedDelete message from the specified reader or buffer.\n     * @function decode\n     * @memberof CGCMsgMemCachedDelete\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CGCMsgMemCachedDelete} CGCMsgMemCachedDelete\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CGCMsgMemCachedDelete.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgMemCachedDelete();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.keys && message.keys.length))\n                        message.keys = [];\n                    message.keys.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CGCMsgMemCachedDelete;\n})());\nexports.CGCMsgMemCachedStats = ($root.CGCMsgMemCachedStats = (() => {\n    /**\n     * Properties of a CGCMsgMemCachedStats.\n     * @exports ICGCMsgMemCachedStats\n     * @interface ICGCMsgMemCachedStats\n     */\n    /**\n     * Constructs a new CGCMsgMemCachedStats.\n     * @exports CGCMsgMemCachedStats\n     * @classdesc Represents a CGCMsgMemCachedStats.\n     * @implements ICGCMsgMemCachedStats\n     * @constructor\n     * @param {ICGCMsgMemCachedStats=} [properties] Properties to set\n     */\n    function CGCMsgMemCachedStats(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Decodes a CGCMsgMemCachedStats message from the specified reader or buffer.\n     * @function decode\n     * @memberof CGCMsgMemCachedStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CGCMsgMemCachedStats} CGCMsgMemCachedStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CGCMsgMemCachedStats.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgMemCachedStats();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CGCMsgMemCachedStats;\n})());\nexports.CGCMsgMemCachedStatsResponse = ($root.CGCMsgMemCachedStatsResponse = (() => {\n    /**\n     * Properties of a CGCMsgMemCachedStatsResponse.\n     * @exports ICGCMsgMemCachedStatsResponse\n     * @interface ICGCMsgMemCachedStatsResponse\n     * @property {number|Long|null} [currConnections] CGCMsgMemCachedStatsResponse currConnections\n     * @property {number|Long|null} [cmdGet] CGCMsgMemCachedStatsResponse cmdGet\n     * @property {number|Long|null} [cmdSet] CGCMsgMemCachedStatsResponse cmdSet\n     * @property {number|Long|null} [cmdFlush] CGCMsgMemCachedStatsResponse cmdFlush\n     * @property {number|Long|null} [getHits] CGCMsgMemCachedStatsResponse getHits\n     * @property {number|Long|null} [getMisses] CGCMsgMemCachedStatsResponse getMisses\n     * @property {number|Long|null} [deleteHits] CGCMsgMemCachedStatsResponse deleteHits\n     * @property {number|Long|null} [deleteMisses] CGCMsgMemCachedStatsResponse deleteMisses\n     * @property {number|Long|null} [bytesRead] CGCMsgMemCachedStatsResponse bytesRead\n     * @property {number|Long|null} [bytesWritten] CGCMsgMemCachedStatsResponse bytesWritten\n     * @property {number|Long|null} [limitMaxbytes] CGCMsgMemCachedStatsResponse limitMaxbytes\n     * @property {number|Long|null} [currItems] CGCMsgMemCachedStatsResponse currItems\n     * @property {number|Long|null} [evictions] CGCMsgMemCachedStatsResponse evictions\n     * @property {number|Long|null} [bytes] CGCMsgMemCachedStatsResponse bytes\n     */\n    /**\n     * Constructs a new CGCMsgMemCachedStatsResponse.\n     * @exports CGCMsgMemCachedStatsResponse\n     * @classdesc Represents a CGCMsgMemCachedStatsResponse.\n     * @implements ICGCMsgMemCachedStatsResponse\n     * @constructor\n     * @param {ICGCMsgMemCachedStatsResponse=} [properties] Properties to set\n     */\n    function CGCMsgMemCachedStatsResponse(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CGCMsgMemCachedStatsResponse currConnections.\n     * @member {number|Long} currConnections\n     * @memberof CGCMsgMemCachedStatsResponse\n     * @instance\n     */\n    CGCMsgMemCachedStatsResponse.prototype.currConnections = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CGCMsgMemCachedStatsResponse cmdGet.\n     * @member {number|Long} cmdGet\n     * @memberof CGCMsgMemCachedStatsResponse\n     * @instance\n     */\n    CGCMsgMemCachedStatsResponse.prototype.cmdGet = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CGCMsgMemCachedStatsResponse cmdSet.\n     * @member {number|Long} cmdSet\n     * @memberof CGCMsgMemCachedStatsResponse\n     * @instance\n     */\n    CGCMsgMemCachedStatsResponse.prototype.cmdSet = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CGCMsgMemCachedStatsResponse cmdFlush.\n     * @member {number|Long} cmdFlush\n     * @memberof CGCMsgMemCachedStatsResponse\n     * @instance\n     */\n    CGCMsgMemCachedStatsResponse.prototype.cmdFlush = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CGCMsgMemCachedStatsResponse getHits.\n     * @member {number|Long} getHits\n     * @memberof CGCMsgMemCachedStatsResponse\n     * @instance\n     */\n    CGCMsgMemCachedStatsResponse.prototype.getHits = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CGCMsgMemCachedStatsResponse getMisses.\n     * @member {number|Long} getMisses\n     * @memberof CGCMsgMemCachedStatsResponse\n     * @instance\n     */\n    CGCMsgMemCachedStatsResponse.prototype.getMisses = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CGCMsgMemCachedStatsResponse deleteHits.\n     * @member {number|Long} deleteHits\n     * @memberof CGCMsgMemCachedStatsResponse\n     * @instance\n     */\n    CGCMsgMemCachedStatsResponse.prototype.deleteHits = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CGCMsgMemCachedStatsResponse deleteMisses.\n     * @member {number|Long} deleteMisses\n     * @memberof CGCMsgMemCachedStatsResponse\n     * @instance\n     */\n    CGCMsgMemCachedStatsResponse.prototype.deleteMisses = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CGCMsgMemCachedStatsResponse bytesRead.\n     * @member {number|Long} bytesRead\n     * @memberof CGCMsgMemCachedStatsResponse\n     * @instance\n     */\n    CGCMsgMemCachedStatsResponse.prototype.bytesRead = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CGCMsgMemCachedStatsResponse bytesWritten.\n     * @member {number|Long} bytesWritten\n     * @memberof CGCMsgMemCachedStatsResponse\n     * @instance\n     */\n    CGCMsgMemCachedStatsResponse.prototype.bytesWritten = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CGCMsgMemCachedStatsResponse limitMaxbytes.\n     * @member {number|Long} limitMaxbytes\n     * @memberof CGCMsgMemCachedStatsResponse\n     * @instance\n     */\n    CGCMsgMemCachedStatsResponse.prototype.limitMaxbytes = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CGCMsgMemCachedStatsResponse currItems.\n     * @member {number|Long} currItems\n     * @memberof CGCMsgMemCachedStatsResponse\n     * @instance\n     */\n    CGCMsgMemCachedStatsResponse.prototype.currItems = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CGCMsgMemCachedStatsResponse evictions.\n     * @member {number|Long} evictions\n     * @memberof CGCMsgMemCachedStatsResponse\n     * @instance\n     */\n    CGCMsgMemCachedStatsResponse.prototype.evictions = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * CGCMsgMemCachedStatsResponse bytes.\n     * @member {number|Long} bytes\n     * @memberof CGCMsgMemCachedStatsResponse\n     * @instance\n     */\n    CGCMsgMemCachedStatsResponse.prototype.bytes = $util.Long\n        ? $util.Long.fromBits(0, 0, true)\n        : 0;\n    /**\n     * Decodes a CGCMsgMemCachedStatsResponse message from the specified reader or buffer.\n     * @function decode\n     * @memberof CGCMsgMemCachedStatsResponse\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CGCMsgMemCachedStatsResponse} CGCMsgMemCachedStatsResponse\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CGCMsgMemCachedStatsResponse.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgMemCachedStatsResponse();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.currConnections = reader.uint64();\n                    break;\n                case 2:\n                    message.cmdGet = reader.uint64();\n                    break;\n                case 3:\n                    message.cmdSet = reader.uint64();\n                    break;\n                case 4:\n                    message.cmdFlush = reader.uint64();\n                    break;\n                case 5:\n                    message.getHits = reader.uint64();\n                    break;\n                case 6:\n                    message.getMisses = reader.uint64();\n                    break;\n                case 7:\n                    message.deleteHits = reader.uint64();\n                    break;\n                case 8:\n                    message.deleteMisses = reader.uint64();\n                    break;\n                case 9:\n                    message.bytesRead = reader.uint64();\n                    break;\n                case 10:\n                    message.bytesWritten = reader.uint64();\n                    break;\n                case 11:\n                    message.limitMaxbytes = reader.uint64();\n                    break;\n                case 12:\n                    message.currItems = reader.uint64();\n                    break;\n                case 13:\n                    message.evictions = reader.uint64();\n                    break;\n                case 14:\n                    message.bytes = reader.uint64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CGCMsgMemCachedStatsResponse;\n})());\nexports.CGCMsgSQLStats = ($root.CGCMsgSQLStats = (() => {\n    /**\n     * Properties of a CGCMsgSQLStats.\n     * @exports ICGCMsgSQLStats\n     * @interface ICGCMsgSQLStats\n     * @property {number|null} [schemaCatalog] CGCMsgSQLStats schemaCatalog\n     */\n    /**\n     * Constructs a new CGCMsgSQLStats.\n     * @exports CGCMsgSQLStats\n     * @classdesc Represents a CGCMsgSQLStats.\n     * @implements ICGCMsgSQLStats\n     * @constructor\n     * @param {ICGCMsgSQLStats=} [properties] Properties to set\n     */\n    function CGCMsgSQLStats(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CGCMsgSQLStats schemaCatalog.\n     * @member {number} schemaCatalog\n     * @memberof CGCMsgSQLStats\n     * @instance\n     */\n    CGCMsgSQLStats.prototype.schemaCatalog = 0;\n    /**\n     * Decodes a CGCMsgSQLStats message from the specified reader or buffer.\n     * @function decode\n     * @memberof CGCMsgSQLStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CGCMsgSQLStats} CGCMsgSQLStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CGCMsgSQLStats.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgSQLStats();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.schemaCatalog = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CGCMsgSQLStats;\n})());\nexports.CGCMsgSQLStatsResponse = ($root.CGCMsgSQLStatsResponse = (() => {\n    /**\n     * Properties of a CGCMsgSQLStatsResponse.\n     * @exports ICGCMsgSQLStatsResponse\n     * @interface ICGCMsgSQLStatsResponse\n     * @property {number|null} [threads] CGCMsgSQLStatsResponse threads\n     * @property {number|null} [threadsConnected] CGCMsgSQLStatsResponse threadsConnected\n     * @property {number|null} [threadsActive] CGCMsgSQLStatsResponse threadsActive\n     * @property {number|null} [operationsSubmitted] CGCMsgSQLStatsResponse operationsSubmitted\n     * @property {number|null} [preparedStatementsExecuted] CGCMsgSQLStatsResponse preparedStatementsExecuted\n     * @property {number|null} [nonPreparedStatementsExecuted] CGCMsgSQLStatsResponse nonPreparedStatementsExecuted\n     * @property {number|null} [deadlockRetries] CGCMsgSQLStatsResponse deadlockRetries\n     * @property {number|null} [operationsTimedOutInQueue] CGCMsgSQLStatsResponse operationsTimedOutInQueue\n     * @property {number|null} [errors] CGCMsgSQLStatsResponse errors\n     */\n    /**\n     * Constructs a new CGCMsgSQLStatsResponse.\n     * @exports CGCMsgSQLStatsResponse\n     * @classdesc Represents a CGCMsgSQLStatsResponse.\n     * @implements ICGCMsgSQLStatsResponse\n     * @constructor\n     * @param {ICGCMsgSQLStatsResponse=} [properties] Properties to set\n     */\n    function CGCMsgSQLStatsResponse(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CGCMsgSQLStatsResponse threads.\n     * @member {number} threads\n     * @memberof CGCMsgSQLStatsResponse\n     * @instance\n     */\n    CGCMsgSQLStatsResponse.prototype.threads = 0;\n    /**\n     * CGCMsgSQLStatsResponse threadsConnected.\n     * @member {number} threadsConnected\n     * @memberof CGCMsgSQLStatsResponse\n     * @instance\n     */\n    CGCMsgSQLStatsResponse.prototype.threadsConnected = 0;\n    /**\n     * CGCMsgSQLStatsResponse threadsActive.\n     * @member {number} threadsActive\n     * @memberof CGCMsgSQLStatsResponse\n     * @instance\n     */\n    CGCMsgSQLStatsResponse.prototype.threadsActive = 0;\n    /**\n     * CGCMsgSQLStatsResponse operationsSubmitted.\n     * @member {number} operationsSubmitted\n     * @memberof CGCMsgSQLStatsResponse\n     * @instance\n     */\n    CGCMsgSQLStatsResponse.prototype.operationsSubmitted = 0;\n    /**\n     * CGCMsgSQLStatsResponse preparedStatementsExecuted.\n     * @member {number} preparedStatementsExecuted\n     * @memberof CGCMsgSQLStatsResponse\n     * @instance\n     */\n    CGCMsgSQLStatsResponse.prototype.preparedStatementsExecuted = 0;\n    /**\n     * CGCMsgSQLStatsResponse nonPreparedStatementsExecuted.\n     * @member {number} nonPreparedStatementsExecuted\n     * @memberof CGCMsgSQLStatsResponse\n     * @instance\n     */\n    CGCMsgSQLStatsResponse.prototype.nonPreparedStatementsExecuted = 0;\n    /**\n     * CGCMsgSQLStatsResponse deadlockRetries.\n     * @member {number} deadlockRetries\n     * @memberof CGCMsgSQLStatsResponse\n     * @instance\n     */\n    CGCMsgSQLStatsResponse.prototype.deadlockRetries = 0;\n    /**\n     * CGCMsgSQLStatsResponse operationsTimedOutInQueue.\n     * @member {number} operationsTimedOutInQueue\n     * @memberof CGCMsgSQLStatsResponse\n     * @instance\n     */\n    CGCMsgSQLStatsResponse.prototype.operationsTimedOutInQueue = 0;\n    /**\n     * CGCMsgSQLStatsResponse errors.\n     * @member {number} errors\n     * @memberof CGCMsgSQLStatsResponse\n     * @instance\n     */\n    CGCMsgSQLStatsResponse.prototype.errors = 0;\n    /**\n     * Decodes a CGCMsgSQLStatsResponse message from the specified reader or buffer.\n     * @function decode\n     * @memberof CGCMsgSQLStatsResponse\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CGCMsgSQLStatsResponse} CGCMsgSQLStatsResponse\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CGCMsgSQLStatsResponse.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgSQLStatsResponse();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.threads = reader.uint32();\n                    break;\n                case 2:\n                    message.threadsConnected = reader.uint32();\n                    break;\n                case 3:\n                    message.threadsActive = reader.uint32();\n                    break;\n                case 4:\n                    message.operationsSubmitted = reader.uint32();\n                    break;\n                case 5:\n                    message.preparedStatementsExecuted = reader.uint32();\n                    break;\n                case 6:\n                    message.nonPreparedStatementsExecuted = reader.uint32();\n                    break;\n                case 7:\n                    message.deadlockRetries = reader.uint32();\n                    break;\n                case 8:\n                    message.operationsTimedOutInQueue = reader.uint32();\n                    break;\n                case 9:\n                    message.errors = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CGCMsgSQLStatsResponse;\n})());\nexports.CMsgAMAddFreeLicense = ($root.CMsgAMAddFreeLicense = (() => {\n    /**\n     * Properties of a CMsgAMAddFreeLicense.\n     * @exports ICMsgAMAddFreeLicense\n     * @interface ICMsgAMAddFreeLicense\n     * @property {number|Long|null} [steamid] CMsgAMAddFreeLicense steamid\n     * @property {number|null} [ipPublic] CMsgAMAddFreeLicense ipPublic\n     * @property {number|null} [packageid] CMsgAMAddFreeLicense packageid\n     * @property {string|null} [storeCountryCode] CMsgAMAddFreeLicense storeCountryCode\n     */\n    /**\n     * Constructs a new CMsgAMAddFreeLicense.\n     * @exports CMsgAMAddFreeLicense\n     * @classdesc Represents a CMsgAMAddFreeLicense.\n     * @implements ICMsgAMAddFreeLicense\n     * @constructor\n     * @param {ICMsgAMAddFreeLicense=} [properties] Properties to set\n     */\n    function CMsgAMAddFreeLicense(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgAMAddFreeLicense steamid.\n     * @member {number|Long} steamid\n     * @memberof CMsgAMAddFreeLicense\n     * @instance\n     */\n    CMsgAMAddFreeLicense.prototype.steamid = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0;\n    /**\n     * CMsgAMAddFreeLicense ipPublic.\n     * @member {number} ipPublic\n     * @memberof CMsgAMAddFreeLicense\n     * @instance\n     */\n    CMsgAMAddFreeLicense.prototype.ipPublic = 0;\n    /**\n     * CMsgAMAddFreeLicense packageid.\n     * @member {number} packageid\n     * @memberof CMsgAMAddFreeLicense\n     * @instance\n     */\n    CMsgAMAddFreeLicense.prototype.packageid = 0;\n    /**\n     * CMsgAMAddFreeLicense storeCountryCode.\n     * @member {string} storeCountryCode\n     * @memberof CMsgAMAddFreeLicense\n     * @instance\n     */\n    CMsgAMAddFreeLicense.prototype.storeCountryCode = \"\";\n    /**\n     * Decodes a CMsgAMAddFreeLicense message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgAMAddFreeLicense\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgAMAddFreeLicense} CMsgAMAddFreeLicense\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgAMAddFreeLicense.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMAddFreeLicense();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.steamid = reader.fixed64();\n                    break;\n                case 2:\n                    message.ipPublic = reader.uint32();\n                    break;\n                case 3:\n                    message.packageid = reader.uint32();\n                    break;\n                case 4:\n                    message.storeCountryCode = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgAMAddFreeLicense;\n})());\nexports.CMsgAMAddFreeLicenseResponse = ($root.CMsgAMAddFreeLicenseResponse = (() => {\n    /**\n     * Properties of a CMsgAMAddFreeLicenseResponse.\n     * @exports ICMsgAMAddFreeLicenseResponse\n     * @interface ICMsgAMAddFreeLicenseResponse\n     * @property {number|null} [eresult] CMsgAMAddFreeLicenseResponse eresult\n     * @property {number|null} [purchaseResultDetail] CMsgAMAddFreeLicenseResponse purchaseResultDetail\n     * @property {number|Long|null} [transid] CMsgAMAddFreeLicenseResponse transid\n     */\n    /**\n     * Constructs a new CMsgAMAddFreeLicenseResponse.\n     * @exports CMsgAMAddFreeLicenseResponse\n     * @classdesc Represents a CMsgAMAddFreeLicenseResponse.\n     * @implements ICMsgAMAddFreeLicenseResponse\n     * @constructor\n     * @param {ICMsgAMAddFreeLicenseResponse=} [properties] Properties to set\n     */\n    function CMsgAMAddFreeLicenseResponse(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgAMAddFreeLicenseResponse eresult.\n     * @member {number} eresult\n     * @memberof CMsgAMAddFreeLicenseResponse\n     * @instance\n     */\n    CMsgAMAddFreeLicenseResponse.prototype.eresult = 2;\n    /**\n     * CMsgAMAddFreeLicenseResponse purchaseResultDetail.\n     * @member {number} purchaseResultDetail\n     * @memberof CMsgAMAddFreeLicenseResponse\n     * @instance\n     */\n    CMsgAMAddFreeLicenseResponse.prototype.purchaseResultDetail = 0;\n    /**\n     * CMsgAMAddFreeLicenseResponse transid.\n     * @member {number|Long} transid\n     * @memberof CMsgAMAddFreeLicenseResponse\n     * @instance\n     */\n    CMsgAMAddFreeLicenseResponse.prototype.transid = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0;\n    /**\n     * Decodes a CMsgAMAddFreeLicenseResponse message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgAMAddFreeLicenseResponse\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgAMAddFreeLicenseResponse} CMsgAMAddFreeLicenseResponse\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgAMAddFreeLicenseResponse.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMAddFreeLicenseResponse();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.eresult = reader.int32();\n                    break;\n                case 2:\n                    message.purchaseResultDetail = reader.int32();\n                    break;\n                case 3:\n                    message.transid = reader.fixed64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgAMAddFreeLicenseResponse;\n})());\nexports.CGCMsgGetIPLocation = ($root.CGCMsgGetIPLocation = (() => {\n    /**\n     * Properties of a CGCMsgGetIPLocation.\n     * @exports ICGCMsgGetIPLocation\n     * @interface ICGCMsgGetIPLocation\n     * @property {Array.<number>|null} [ips] CGCMsgGetIPLocation ips\n     */\n    /**\n     * Constructs a new CGCMsgGetIPLocation.\n     * @exports CGCMsgGetIPLocation\n     * @classdesc Represents a CGCMsgGetIPLocation.\n     * @implements ICGCMsgGetIPLocation\n     * @constructor\n     * @param {ICGCMsgGetIPLocation=} [properties] Properties to set\n     */\n    function CGCMsgGetIPLocation(properties) {\n        this.ips = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CGCMsgGetIPLocation ips.\n     * @member {Array.<number>} ips\n     * @memberof CGCMsgGetIPLocation\n     * @instance\n     */\n    CGCMsgGetIPLocation.prototype.ips = $util.emptyArray;\n    /**\n     * Decodes a CGCMsgGetIPLocation message from the specified reader or buffer.\n     * @function decode\n     * @memberof CGCMsgGetIPLocation\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CGCMsgGetIPLocation} CGCMsgGetIPLocation\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CGCMsgGetIPLocation.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgGetIPLocation();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.ips && message.ips.length))\n                        message.ips = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.ips.push(reader.fixed32());\n                    }\n                    else\n                        message.ips.push(reader.fixed32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CGCMsgGetIPLocation;\n})());\nexports.CIPLocationInfo = ($root.CIPLocationInfo = (() => {\n    /**\n     * Properties of a CIPLocationInfo.\n     * @exports ICIPLocationInfo\n     * @interface ICIPLocationInfo\n     * @property {number|null} [ip] CIPLocationInfo ip\n     * @property {number|null} [latitude] CIPLocationInfo latitude\n     * @property {number|null} [longitude] CIPLocationInfo longitude\n     * @property {string|null} [country] CIPLocationInfo country\n     * @property {string|null} [state] CIPLocationInfo state\n     * @property {string|null} [city] CIPLocationInfo city\n     */\n    /**\n     * Constructs a new CIPLocationInfo.\n     * @exports CIPLocationInfo\n     * @classdesc Represents a CIPLocationInfo.\n     * @implements ICIPLocationInfo\n     * @constructor\n     * @param {ICIPLocationInfo=} [properties] Properties to set\n     */\n    function CIPLocationInfo(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CIPLocationInfo ip.\n     * @member {number} ip\n     * @memberof CIPLocationInfo\n     * @instance\n     */\n    CIPLocationInfo.prototype.ip = 0;\n    /**\n     * CIPLocationInfo latitude.\n     * @member {number} latitude\n     * @memberof CIPLocationInfo\n     * @instance\n     */\n    CIPLocationInfo.prototype.latitude = 0;\n    /**\n     * CIPLocationInfo longitude.\n     * @member {number} longitude\n     * @memberof CIPLocationInfo\n     * @instance\n     */\n    CIPLocationInfo.prototype.longitude = 0;\n    /**\n     * CIPLocationInfo country.\n     * @member {string} country\n     * @memberof CIPLocationInfo\n     * @instance\n     */\n    CIPLocationInfo.prototype.country = \"\";\n    /**\n     * CIPLocationInfo state.\n     * @member {string} state\n     * @memberof CIPLocationInfo\n     * @instance\n     */\n    CIPLocationInfo.prototype.state = \"\";\n    /**\n     * CIPLocationInfo city.\n     * @member {string} city\n     * @memberof CIPLocationInfo\n     * @instance\n     */\n    CIPLocationInfo.prototype.city = \"\";\n    /**\n     * Decodes a CIPLocationInfo message from the specified reader or buffer.\n     * @function decode\n     * @memberof CIPLocationInfo\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CIPLocationInfo} CIPLocationInfo\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CIPLocationInfo.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CIPLocationInfo();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.ip = reader.uint32();\n                    break;\n                case 2:\n                    message.latitude = reader.float();\n                    break;\n                case 3:\n                    message.longitude = reader.float();\n                    break;\n                case 4:\n                    message.country = reader.string();\n                    break;\n                case 5:\n                    message.state = reader.string();\n                    break;\n                case 6:\n                    message.city = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CIPLocationInfo;\n})());\nexports.CGCMsgGetIPLocationResponse = ($root.CGCMsgGetIPLocationResponse = (() => {\n    /**\n     * Properties of a CGCMsgGetIPLocationResponse.\n     * @exports ICGCMsgGetIPLocationResponse\n     * @interface ICGCMsgGetIPLocationResponse\n     * @property {Array.<ICIPLocationInfo>|null} [infos] CGCMsgGetIPLocationResponse infos\n     */\n    /**\n     * Constructs a new CGCMsgGetIPLocationResponse.\n     * @exports CGCMsgGetIPLocationResponse\n     * @classdesc Represents a CGCMsgGetIPLocationResponse.\n     * @implements ICGCMsgGetIPLocationResponse\n     * @constructor\n     * @param {ICGCMsgGetIPLocationResponse=} [properties] Properties to set\n     */\n    function CGCMsgGetIPLocationResponse(properties) {\n        this.infos = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CGCMsgGetIPLocationResponse infos.\n     * @member {Array.<ICIPLocationInfo>} infos\n     * @memberof CGCMsgGetIPLocationResponse\n     * @instance\n     */\n    CGCMsgGetIPLocationResponse.prototype.infos = $util.emptyArray;\n    /**\n     * Decodes a CGCMsgGetIPLocationResponse message from the specified reader or buffer.\n     * @function decode\n     * @memberof CGCMsgGetIPLocationResponse\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CGCMsgGetIPLocationResponse} CGCMsgGetIPLocationResponse\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CGCMsgGetIPLocationResponse.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgGetIPLocationResponse();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.infos && message.infos.length))\n                        message.infos = [];\n                    message.infos.push($root.CIPLocationInfo.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CGCMsgGetIPLocationResponse;\n})());\nexports.CGCMsgSystemStatsSchema = ($root.CGCMsgSystemStatsSchema = (() => {\n    /**\n     * Properties of a CGCMsgSystemStatsSchema.\n     * @exports ICGCMsgSystemStatsSchema\n     * @interface ICGCMsgSystemStatsSchema\n     * @property {number|null} [gcAppId] CGCMsgSystemStatsSchema gcAppId\n     * @property {Uint8Array|null} [schemaKv] CGCMsgSystemStatsSchema schemaKv\n     */\n    /**\n     * Constructs a new CGCMsgSystemStatsSchema.\n     * @exports CGCMsgSystemStatsSchema\n     * @classdesc Represents a CGCMsgSystemStatsSchema.\n     * @implements ICGCMsgSystemStatsSchema\n     * @constructor\n     * @param {ICGCMsgSystemStatsSchema=} [properties] Properties to set\n     */\n    function CGCMsgSystemStatsSchema(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CGCMsgSystemStatsSchema gcAppId.\n     * @member {number} gcAppId\n     * @memberof CGCMsgSystemStatsSchema\n     * @instance\n     */\n    CGCMsgSystemStatsSchema.prototype.gcAppId = 0;\n    /**\n     * CGCMsgSystemStatsSchema schemaKv.\n     * @member {Uint8Array} schemaKv\n     * @memberof CGCMsgSystemStatsSchema\n     * @instance\n     */\n    CGCMsgSystemStatsSchema.prototype.schemaKv = $util.newBuffer([]);\n    /**\n     * Decodes a CGCMsgSystemStatsSchema message from the specified reader or buffer.\n     * @function decode\n     * @memberof CGCMsgSystemStatsSchema\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CGCMsgSystemStatsSchema} CGCMsgSystemStatsSchema\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CGCMsgSystemStatsSchema.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgSystemStatsSchema();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.gcAppId = reader.uint32();\n                    break;\n                case 2:\n                    message.schemaKv = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CGCMsgSystemStatsSchema;\n})());\nexports.CGCMsgGetSystemStats = ($root.CGCMsgGetSystemStats = (() => {\n    /**\n     * Properties of a CGCMsgGetSystemStats.\n     * @exports ICGCMsgGetSystemStats\n     * @interface ICGCMsgGetSystemStats\n     */\n    /**\n     * Constructs a new CGCMsgGetSystemStats.\n     * @exports CGCMsgGetSystemStats\n     * @classdesc Represents a CGCMsgGetSystemStats.\n     * @implements ICGCMsgGetSystemStats\n     * @constructor\n     * @param {ICGCMsgGetSystemStats=} [properties] Properties to set\n     */\n    function CGCMsgGetSystemStats(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * Decodes a CGCMsgGetSystemStats message from the specified reader or buffer.\n     * @function decode\n     * @memberof CGCMsgGetSystemStats\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CGCMsgGetSystemStats} CGCMsgGetSystemStats\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CGCMsgGetSystemStats.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgGetSystemStats();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CGCMsgGetSystemStats;\n})());\nexports.CGCMsgGetSystemStatsResponse = ($root.CGCMsgGetSystemStatsResponse = (() => {\n    /**\n     * Properties of a CGCMsgGetSystemStatsResponse.\n     * @exports ICGCMsgGetSystemStatsResponse\n     * @interface ICGCMsgGetSystemStatsResponse\n     * @property {number|null} [gcAppId] CGCMsgGetSystemStatsResponse gcAppId\n     * @property {Uint8Array|null} [statsKv] CGCMsgGetSystemStatsResponse statsKv\n     * @property {number|null} [activeJobs] CGCMsgGetSystemStatsResponse activeJobs\n     * @property {number|null} [yieldingJobs] CGCMsgGetSystemStatsResponse yieldingJobs\n     * @property {number|null} [userSessions] CGCMsgGetSystemStatsResponse userSessions\n     * @property {number|null} [gameServerSessions] CGCMsgGetSystemStatsResponse gameServerSessions\n     * @property {number|null} [socaches] CGCMsgGetSystemStatsResponse socaches\n     * @property {number|null} [socachesToUnload] CGCMsgGetSystemStatsResponse socachesToUnload\n     * @property {number|null} [socachesLoading] CGCMsgGetSystemStatsResponse socachesLoading\n     * @property {number|null} [writebackQueue] CGCMsgGetSystemStatsResponse writebackQueue\n     * @property {number|null} [steamidLocks] CGCMsgGetSystemStatsResponse steamidLocks\n     * @property {number|null} [logonQueue] CGCMsgGetSystemStatsResponse logonQueue\n     * @property {number|null} [logonJobs] CGCMsgGetSystemStatsResponse logonJobs\n     */\n    /**\n     * Constructs a new CGCMsgGetSystemStatsResponse.\n     * @exports CGCMsgGetSystemStatsResponse\n     * @classdesc Represents a CGCMsgGetSystemStatsResponse.\n     * @implements ICGCMsgGetSystemStatsResponse\n     * @constructor\n     * @param {ICGCMsgGetSystemStatsResponse=} [properties] Properties to set\n     */\n    function CGCMsgGetSystemStatsResponse(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CGCMsgGetSystemStatsResponse gcAppId.\n     * @member {number} gcAppId\n     * @memberof CGCMsgGetSystemStatsResponse\n     * @instance\n     */\n    CGCMsgGetSystemStatsResponse.prototype.gcAppId = 0;\n    /**\n     * CGCMsgGetSystemStatsResponse statsKv.\n     * @member {Uint8Array} statsKv\n     * @memberof CGCMsgGetSystemStatsResponse\n     * @instance\n     */\n    CGCMsgGetSystemStatsResponse.prototype.statsKv = $util.newBuffer([]);\n    /**\n     * CGCMsgGetSystemStatsResponse activeJobs.\n     * @member {number} activeJobs\n     * @memberof CGCMsgGetSystemStatsResponse\n     * @instance\n     */\n    CGCMsgGetSystemStatsResponse.prototype.activeJobs = 0;\n    /**\n     * CGCMsgGetSystemStatsResponse yieldingJobs.\n     * @member {number} yieldingJobs\n     * @memberof CGCMsgGetSystemStatsResponse\n     * @instance\n     */\n    CGCMsgGetSystemStatsResponse.prototype.yieldingJobs = 0;\n    /**\n     * CGCMsgGetSystemStatsResponse userSessions.\n     * @member {number} userSessions\n     * @memberof CGCMsgGetSystemStatsResponse\n     * @instance\n     */\n    CGCMsgGetSystemStatsResponse.prototype.userSessions = 0;\n    /**\n     * CGCMsgGetSystemStatsResponse gameServerSessions.\n     * @member {number} gameServerSessions\n     * @memberof CGCMsgGetSystemStatsResponse\n     * @instance\n     */\n    CGCMsgGetSystemStatsResponse.prototype.gameServerSessions = 0;\n    /**\n     * CGCMsgGetSystemStatsResponse socaches.\n     * @member {number} socaches\n     * @memberof CGCMsgGetSystemStatsResponse\n     * @instance\n     */\n    CGCMsgGetSystemStatsResponse.prototype.socaches = 0;\n    /**\n     * CGCMsgGetSystemStatsResponse socachesToUnload.\n     * @member {number} socachesToUnload\n     * @memberof CGCMsgGetSystemStatsResponse\n     * @instance\n     */\n    CGCMsgGetSystemStatsResponse.prototype.socachesToUnload = 0;\n    /**\n     * CGCMsgGetSystemStatsResponse socachesLoading.\n     * @member {number} socachesLoading\n     * @memberof CGCMsgGetSystemStatsResponse\n     * @instance\n     */\n    CGCMsgGetSystemStatsResponse.prototype.socachesLoading = 0;\n    /**\n     * CGCMsgGetSystemStatsResponse writebackQueue.\n     * @member {number} writebackQueue\n     * @memberof CGCMsgGetSystemStatsResponse\n     * @instance\n     */\n    CGCMsgGetSystemStatsResponse.prototype.writebackQueue = 0;\n    /**\n     * CGCMsgGetSystemStatsResponse steamidLocks.\n     * @member {number} steamidLocks\n     * @memberof CGCMsgGetSystemStatsResponse\n     * @instance\n     */\n    CGCMsgGetSystemStatsResponse.prototype.steamidLocks = 0;\n    /**\n     * CGCMsgGetSystemStatsResponse logonQueue.\n     * @member {number} logonQueue\n     * @memberof CGCMsgGetSystemStatsResponse\n     * @instance\n     */\n    CGCMsgGetSystemStatsResponse.prototype.logonQueue = 0;\n    /**\n     * CGCMsgGetSystemStatsResponse logonJobs.\n     * @member {number} logonJobs\n     * @memberof CGCMsgGetSystemStatsResponse\n     * @instance\n     */\n    CGCMsgGetSystemStatsResponse.prototype.logonJobs = 0;\n    /**\n     * Decodes a CGCMsgGetSystemStatsResponse message from the specified reader or buffer.\n     * @function decode\n     * @memberof CGCMsgGetSystemStatsResponse\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CGCMsgGetSystemStatsResponse} CGCMsgGetSystemStatsResponse\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CGCMsgGetSystemStatsResponse.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCMsgGetSystemStatsResponse();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.gcAppId = reader.uint32();\n                    break;\n                case 2:\n                    message.statsKv = reader.bytes();\n                    break;\n                case 3:\n                    message.activeJobs = reader.uint32();\n                    break;\n                case 4:\n                    message.yieldingJobs = reader.uint32();\n                    break;\n                case 5:\n                    message.userSessions = reader.uint32();\n                    break;\n                case 6:\n                    message.gameServerSessions = reader.uint32();\n                    break;\n                case 7:\n                    message.socaches = reader.uint32();\n                    break;\n                case 8:\n                    message.socachesToUnload = reader.uint32();\n                    break;\n                case 9:\n                    message.socachesLoading = reader.uint32();\n                    break;\n                case 10:\n                    message.writebackQueue = reader.uint32();\n                    break;\n                case 11:\n                    message.steamidLocks = reader.uint32();\n                    break;\n                case 12:\n                    message.logonQueue = reader.uint32();\n                    break;\n                case 13:\n                    message.logonJobs = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CGCMsgGetSystemStatsResponse;\n})());\nexports.CMsgAMSendEmail = ($root.CMsgAMSendEmail = (() => {\n    /**\n     * Properties of a CMsgAMSendEmail.\n     * @exports ICMsgAMSendEmail\n     * @interface ICMsgAMSendEmail\n     * @property {number|Long|null} [steamid] CMsgAMSendEmail steamid\n     * @property {number|null} [emailMsgType] CMsgAMSendEmail emailMsgType\n     * @property {number|null} [emailFormat] CMsgAMSendEmail emailFormat\n     * @property {Array.<CMsgAMSendEmail.IPersonaNameReplacementToken>|null} [personaNameTokens] CMsgAMSendEmail personaNameTokens\n     * @property {number|null} [sourceGc] CMsgAMSendEmail sourceGc\n     * @property {Array.<CMsgAMSendEmail.IReplacementToken>|null} [tokens] CMsgAMSendEmail tokens\n     */\n    /**\n     * Constructs a new CMsgAMSendEmail.\n     * @exports CMsgAMSendEmail\n     * @classdesc Represents a CMsgAMSendEmail.\n     * @implements ICMsgAMSendEmail\n     * @constructor\n     * @param {ICMsgAMSendEmail=} [properties] Properties to set\n     */\n    function CMsgAMSendEmail(properties) {\n        this.personaNameTokens = [];\n        this.tokens = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgAMSendEmail steamid.\n     * @member {number|Long} steamid\n     * @memberof CMsgAMSendEmail\n     * @instance\n     */\n    CMsgAMSendEmail.prototype.steamid = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0;\n    /**\n     * CMsgAMSendEmail emailMsgType.\n     * @member {number} emailMsgType\n     * @memberof CMsgAMSendEmail\n     * @instance\n     */\n    CMsgAMSendEmail.prototype.emailMsgType = 0;\n    /**\n     * CMsgAMSendEmail emailFormat.\n     * @member {number} emailFormat\n     * @memberof CMsgAMSendEmail\n     * @instance\n     */\n    CMsgAMSendEmail.prototype.emailFormat = 0;\n    /**\n     * CMsgAMSendEmail personaNameTokens.\n     * @member {Array.<CMsgAMSendEmail.IPersonaNameReplacementToken>} personaNameTokens\n     * @memberof CMsgAMSendEmail\n     * @instance\n     */\n    CMsgAMSendEmail.prototype.personaNameTokens = $util.emptyArray;\n    /**\n     * CMsgAMSendEmail sourceGc.\n     * @member {number} sourceGc\n     * @memberof CMsgAMSendEmail\n     * @instance\n     */\n    CMsgAMSendEmail.prototype.sourceGc = 0;\n    /**\n     * CMsgAMSendEmail tokens.\n     * @member {Array.<CMsgAMSendEmail.IReplacementToken>} tokens\n     * @memberof CMsgAMSendEmail\n     * @instance\n     */\n    CMsgAMSendEmail.prototype.tokens = $util.emptyArray;\n    /**\n     * Decodes a CMsgAMSendEmail message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgAMSendEmail\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgAMSendEmail} CMsgAMSendEmail\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgAMSendEmail.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMSendEmail();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.steamid = reader.fixed64();\n                    break;\n                case 2:\n                    message.emailMsgType = reader.uint32();\n                    break;\n                case 3:\n                    message.emailFormat = reader.uint32();\n                    break;\n                case 5:\n                    if (!(message.personaNameTokens && message.personaNameTokens.length))\n                        message.personaNameTokens = [];\n                    message.personaNameTokens.push($root.CMsgAMSendEmail.PersonaNameReplacementToken.decode(reader, reader.uint32()));\n                    break;\n                case 6:\n                    message.sourceGc = reader.uint32();\n                    break;\n                case 7:\n                    if (!(message.tokens && message.tokens.length))\n                        message.tokens = [];\n                    message.tokens.push($root.CMsgAMSendEmail.ReplacementToken.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CMsgAMSendEmail.ReplacementToken = (function () {\n        /**\n         * Properties of a ReplacementToken.\n         * @memberof CMsgAMSendEmail\n         * @interface IReplacementToken\n         * @property {string|null} [tokenName] ReplacementToken tokenName\n         * @property {string|null} [tokenValue] ReplacementToken tokenValue\n         */\n        /**\n         * Constructs a new ReplacementToken.\n         * @memberof CMsgAMSendEmail\n         * @classdesc Represents a ReplacementToken.\n         * @implements IReplacementToken\n         * @constructor\n         * @param {CMsgAMSendEmail.IReplacementToken=} [properties] Properties to set\n         */\n        function ReplacementToken(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * ReplacementToken tokenName.\n         * @member {string} tokenName\n         * @memberof CMsgAMSendEmail.ReplacementToken\n         * @instance\n         */\n        ReplacementToken.prototype.tokenName = \"\";\n        /**\n         * ReplacementToken tokenValue.\n         * @member {string} tokenValue\n         * @memberof CMsgAMSendEmail.ReplacementToken\n         * @instance\n         */\n        ReplacementToken.prototype.tokenValue = \"\";\n        /**\n         * Decodes a ReplacementToken message from the specified reader or buffer.\n         * @function decode\n         * @memberof CMsgAMSendEmail.ReplacementToken\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CMsgAMSendEmail.ReplacementToken} ReplacementToken\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ReplacementToken.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMSendEmail.ReplacementToken();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.tokenName = reader.string();\n                        break;\n                    case 2:\n                        message.tokenValue = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return ReplacementToken;\n    })();\n    CMsgAMSendEmail.PersonaNameReplacementToken = (function () {\n        /**\n         * Properties of a PersonaNameReplacementToken.\n         * @memberof CMsgAMSendEmail\n         * @interface IPersonaNameReplacementToken\n         * @property {number|Long|null} [steamid] PersonaNameReplacementToken steamid\n         * @property {string|null} [tokenName] PersonaNameReplacementToken tokenName\n         */\n        /**\n         * Constructs a new PersonaNameReplacementToken.\n         * @memberof CMsgAMSendEmail\n         * @classdesc Represents a PersonaNameReplacementToken.\n         * @implements IPersonaNameReplacementToken\n         * @constructor\n         * @param {CMsgAMSendEmail.IPersonaNameReplacementToken=} [properties] Properties to set\n         */\n        function PersonaNameReplacementToken(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * PersonaNameReplacementToken steamid.\n         * @member {number|Long} steamid\n         * @memberof CMsgAMSendEmail.PersonaNameReplacementToken\n         * @instance\n         */\n        PersonaNameReplacementToken.prototype.steamid = $util.Long\n            ? $util.Long.fromBits(0, 0, false)\n            : 0;\n        /**\n         * PersonaNameReplacementToken tokenName.\n         * @member {string} tokenName\n         * @memberof CMsgAMSendEmail.PersonaNameReplacementToken\n         * @instance\n         */\n        PersonaNameReplacementToken.prototype.tokenName = \"\";\n        /**\n         * Decodes a PersonaNameReplacementToken message from the specified reader or buffer.\n         * @function decode\n         * @memberof CMsgAMSendEmail.PersonaNameReplacementToken\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CMsgAMSendEmail.PersonaNameReplacementToken} PersonaNameReplacementToken\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        PersonaNameReplacementToken.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMSendEmail.PersonaNameReplacementToken();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.steamid = reader.fixed64();\n                        break;\n                    case 2:\n                        message.tokenName = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return PersonaNameReplacementToken;\n    })();\n    return CMsgAMSendEmail;\n})());\nexports.CMsgAMSendEmailResponse = ($root.CMsgAMSendEmailResponse = (() => {\n    /**\n     * Properties of a CMsgAMSendEmailResponse.\n     * @exports ICMsgAMSendEmailResponse\n     * @interface ICMsgAMSendEmailResponse\n     * @property {number|null} [eresult] CMsgAMSendEmailResponse eresult\n     */\n    /**\n     * Constructs a new CMsgAMSendEmailResponse.\n     * @exports CMsgAMSendEmailResponse\n     * @classdesc Represents a CMsgAMSendEmailResponse.\n     * @implements ICMsgAMSendEmailResponse\n     * @constructor\n     * @param {ICMsgAMSendEmailResponse=} [properties] Properties to set\n     */\n    function CMsgAMSendEmailResponse(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgAMSendEmailResponse eresult.\n     * @member {number} eresult\n     * @memberof CMsgAMSendEmailResponse\n     * @instance\n     */\n    CMsgAMSendEmailResponse.prototype.eresult = 2;\n    /**\n     * Decodes a CMsgAMSendEmailResponse message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgAMSendEmailResponse\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgAMSendEmailResponse} CMsgAMSendEmailResponse\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgAMSendEmailResponse.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMSendEmailResponse();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.eresult = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgAMSendEmailResponse;\n})());\nexports.CMsgGCGetEmailTemplate = ($root.CMsgGCGetEmailTemplate = (() => {\n    /**\n     * Properties of a CMsgGCGetEmailTemplate.\n     * @exports ICMsgGCGetEmailTemplate\n     * @interface ICMsgGCGetEmailTemplate\n     * @property {number|null} [appId] CMsgGCGetEmailTemplate appId\n     * @property {number|null} [emailMsgType] CMsgGCGetEmailTemplate emailMsgType\n     * @property {number|null} [emailLang] CMsgGCGetEmailTemplate emailLang\n     * @property {number|null} [emailFormat] CMsgGCGetEmailTemplate emailFormat\n     */\n    /**\n     * Constructs a new CMsgGCGetEmailTemplate.\n     * @exports CMsgGCGetEmailTemplate\n     * @classdesc Represents a CMsgGCGetEmailTemplate.\n     * @implements ICMsgGCGetEmailTemplate\n     * @constructor\n     * @param {ICMsgGCGetEmailTemplate=} [properties] Properties to set\n     */\n    function CMsgGCGetEmailTemplate(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCGetEmailTemplate appId.\n     * @member {number} appId\n     * @memberof CMsgGCGetEmailTemplate\n     * @instance\n     */\n    CMsgGCGetEmailTemplate.prototype.appId = 0;\n    /**\n     * CMsgGCGetEmailTemplate emailMsgType.\n     * @member {number} emailMsgType\n     * @memberof CMsgGCGetEmailTemplate\n     * @instance\n     */\n    CMsgGCGetEmailTemplate.prototype.emailMsgType = 0;\n    /**\n     * CMsgGCGetEmailTemplate emailLang.\n     * @member {number} emailLang\n     * @memberof CMsgGCGetEmailTemplate\n     * @instance\n     */\n    CMsgGCGetEmailTemplate.prototype.emailLang = 0;\n    /**\n     * CMsgGCGetEmailTemplate emailFormat.\n     * @member {number} emailFormat\n     * @memberof CMsgGCGetEmailTemplate\n     * @instance\n     */\n    CMsgGCGetEmailTemplate.prototype.emailFormat = 0;\n    /**\n     * Decodes a CMsgGCGetEmailTemplate message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCGetEmailTemplate\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCGetEmailTemplate} CMsgGCGetEmailTemplate\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCGetEmailTemplate.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetEmailTemplate();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.appId = reader.uint32();\n                    break;\n                case 2:\n                    message.emailMsgType = reader.uint32();\n                    break;\n                case 3:\n                    message.emailLang = reader.int32();\n                    break;\n                case 4:\n                    message.emailFormat = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCGetEmailTemplate;\n})());\nexports.CMsgGCGetEmailTemplateResponse = ($root.CMsgGCGetEmailTemplateResponse = (() => {\n    /**\n     * Properties of a CMsgGCGetEmailTemplateResponse.\n     * @exports ICMsgGCGetEmailTemplateResponse\n     * @interface ICMsgGCGetEmailTemplateResponse\n     * @property {number|null} [eresult] CMsgGCGetEmailTemplateResponse eresult\n     * @property {boolean|null} [templateExists] CMsgGCGetEmailTemplateResponse templateExists\n     * @property {string|null} [template] CMsgGCGetEmailTemplateResponse template\n     */\n    /**\n     * Constructs a new CMsgGCGetEmailTemplateResponse.\n     * @exports CMsgGCGetEmailTemplateResponse\n     * @classdesc Represents a CMsgGCGetEmailTemplateResponse.\n     * @implements ICMsgGCGetEmailTemplateResponse\n     * @constructor\n     * @param {ICMsgGCGetEmailTemplateResponse=} [properties] Properties to set\n     */\n    function CMsgGCGetEmailTemplateResponse(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCGetEmailTemplateResponse eresult.\n     * @member {number} eresult\n     * @memberof CMsgGCGetEmailTemplateResponse\n     * @instance\n     */\n    CMsgGCGetEmailTemplateResponse.prototype.eresult = 2;\n    /**\n     * CMsgGCGetEmailTemplateResponse templateExists.\n     * @member {boolean} templateExists\n     * @memberof CMsgGCGetEmailTemplateResponse\n     * @instance\n     */\n    CMsgGCGetEmailTemplateResponse.prototype.templateExists = false;\n    /**\n     * CMsgGCGetEmailTemplateResponse template.\n     * @member {string} template\n     * @memberof CMsgGCGetEmailTemplateResponse\n     * @instance\n     */\n    CMsgGCGetEmailTemplateResponse.prototype.template = \"\";\n    /**\n     * Decodes a CMsgGCGetEmailTemplateResponse message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCGetEmailTemplateResponse\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCGetEmailTemplateResponse} CMsgGCGetEmailTemplateResponse\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCGetEmailTemplateResponse.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetEmailTemplateResponse();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.eresult = reader.uint32();\n                    break;\n                case 2:\n                    message.templateExists = reader.bool();\n                    break;\n                case 3:\n                    message.template = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCGetEmailTemplateResponse;\n})());\nexports.CMsgAMGrantGuestPasses2 = ($root.CMsgAMGrantGuestPasses2 = (() => {\n    /**\n     * Properties of a CMsgAMGrantGuestPasses2.\n     * @exports ICMsgAMGrantGuestPasses2\n     * @interface ICMsgAMGrantGuestPasses2\n     * @property {number|Long|null} [steamId] CMsgAMGrantGuestPasses2 steamId\n     * @property {number|null} [packageId] CMsgAMGrantGuestPasses2 packageId\n     * @property {number|null} [passesToGrant] CMsgAMGrantGuestPasses2 passesToGrant\n     * @property {number|null} [daysToExpiration] CMsgAMGrantGuestPasses2 daysToExpiration\n     * @property {number|null} [action] CMsgAMGrantGuestPasses2 action\n     */\n    /**\n     * Constructs a new CMsgAMGrantGuestPasses2.\n     * @exports CMsgAMGrantGuestPasses2\n     * @classdesc Represents a CMsgAMGrantGuestPasses2.\n     * @implements ICMsgAMGrantGuestPasses2\n     * @constructor\n     * @param {ICMsgAMGrantGuestPasses2=} [properties] Properties to set\n     */\n    function CMsgAMGrantGuestPasses2(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgAMGrantGuestPasses2 steamId.\n     * @member {number|Long} steamId\n     * @memberof CMsgAMGrantGuestPasses2\n     * @instance\n     */\n    CMsgAMGrantGuestPasses2.prototype.steamId = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0;\n    /**\n     * CMsgAMGrantGuestPasses2 packageId.\n     * @member {number} packageId\n     * @memberof CMsgAMGrantGuestPasses2\n     * @instance\n     */\n    CMsgAMGrantGuestPasses2.prototype.packageId = 0;\n    /**\n     * CMsgAMGrantGuestPasses2 passesToGrant.\n     * @member {number} passesToGrant\n     * @memberof CMsgAMGrantGuestPasses2\n     * @instance\n     */\n    CMsgAMGrantGuestPasses2.prototype.passesToGrant = 0;\n    /**\n     * CMsgAMGrantGuestPasses2 daysToExpiration.\n     * @member {number} daysToExpiration\n     * @memberof CMsgAMGrantGuestPasses2\n     * @instance\n     */\n    CMsgAMGrantGuestPasses2.prototype.daysToExpiration = 0;\n    /**\n     * CMsgAMGrantGuestPasses2 action.\n     * @member {number} action\n     * @memberof CMsgAMGrantGuestPasses2\n     * @instance\n     */\n    CMsgAMGrantGuestPasses2.prototype.action = 0;\n    /**\n     * Decodes a CMsgAMGrantGuestPasses2 message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgAMGrantGuestPasses2\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgAMGrantGuestPasses2} CMsgAMGrantGuestPasses2\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgAMGrantGuestPasses2.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMGrantGuestPasses2();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.steamId = reader.fixed64();\n                    break;\n                case 2:\n                    message.packageId = reader.uint32();\n                    break;\n                case 3:\n                    message.passesToGrant = reader.int32();\n                    break;\n                case 4:\n                    message.daysToExpiration = reader.int32();\n                    break;\n                case 5:\n                    message.action = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgAMGrantGuestPasses2;\n})());\nexports.CMsgAMGrantGuestPasses2Response = ($root.CMsgAMGrantGuestPasses2Response = (() => {\n    /**\n     * Properties of a CMsgAMGrantGuestPasses2Response.\n     * @exports ICMsgAMGrantGuestPasses2Response\n     * @interface ICMsgAMGrantGuestPasses2Response\n     * @property {number|null} [eresult] CMsgAMGrantGuestPasses2Response eresult\n     * @property {number|null} [passesGranted] CMsgAMGrantGuestPasses2Response passesGranted\n     */\n    /**\n     * Constructs a new CMsgAMGrantGuestPasses2Response.\n     * @exports CMsgAMGrantGuestPasses2Response\n     * @classdesc Represents a CMsgAMGrantGuestPasses2Response.\n     * @implements ICMsgAMGrantGuestPasses2Response\n     * @constructor\n     * @param {ICMsgAMGrantGuestPasses2Response=} [properties] Properties to set\n     */\n    function CMsgAMGrantGuestPasses2Response(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgAMGrantGuestPasses2Response eresult.\n     * @member {number} eresult\n     * @memberof CMsgAMGrantGuestPasses2Response\n     * @instance\n     */\n    CMsgAMGrantGuestPasses2Response.prototype.eresult = 2;\n    /**\n     * CMsgAMGrantGuestPasses2Response passesGranted.\n     * @member {number} passesGranted\n     * @memberof CMsgAMGrantGuestPasses2Response\n     * @instance\n     */\n    CMsgAMGrantGuestPasses2Response.prototype.passesGranted = 0;\n    /**\n     * Decodes a CMsgAMGrantGuestPasses2Response message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgAMGrantGuestPasses2Response\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgAMGrantGuestPasses2Response} CMsgAMGrantGuestPasses2Response\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgAMGrantGuestPasses2Response.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgAMGrantGuestPasses2Response();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.eresult = reader.int32();\n                    break;\n                case 2:\n                    message.passesGranted = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgAMGrantGuestPasses2Response;\n})());\nexports.CGCSystemMsg_GetAccountDetails = ($root.CGCSystemMsg_GetAccountDetails = (() => {\n    /**\n     * Properties of a CGCSystemMsg_GetAccountDetails.\n     * @exports ICGCSystemMsg_GetAccountDetails\n     * @interface ICGCSystemMsg_GetAccountDetails\n     * @property {number|Long|null} [steamid] CGCSystemMsg_GetAccountDetails steamid\n     * @property {number|null} [appid] CGCSystemMsg_GetAccountDetails appid\n     */\n    /**\n     * Constructs a new CGCSystemMsg_GetAccountDetails.\n     * @exports CGCSystemMsg_GetAccountDetails\n     * @classdesc Represents a CGCSystemMsg_GetAccountDetails.\n     * @implements ICGCSystemMsg_GetAccountDetails\n     * @constructor\n     * @param {ICGCSystemMsg_GetAccountDetails=} [properties] Properties to set\n     */\n    function CGCSystemMsg_GetAccountDetails(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CGCSystemMsg_GetAccountDetails steamid.\n     * @member {number|Long} steamid\n     * @memberof CGCSystemMsg_GetAccountDetails\n     * @instance\n     */\n    CGCSystemMsg_GetAccountDetails.prototype.steamid = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0;\n    /**\n     * CGCSystemMsg_GetAccountDetails appid.\n     * @member {number} appid\n     * @memberof CGCSystemMsg_GetAccountDetails\n     * @instance\n     */\n    CGCSystemMsg_GetAccountDetails.prototype.appid = 0;\n    /**\n     * Decodes a CGCSystemMsg_GetAccountDetails message from the specified reader or buffer.\n     * @function decode\n     * @memberof CGCSystemMsg_GetAccountDetails\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CGCSystemMsg_GetAccountDetails} CGCSystemMsg_GetAccountDetails\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CGCSystemMsg_GetAccountDetails.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCSystemMsg_GetAccountDetails();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.steamid = reader.fixed64();\n                    break;\n                case 2:\n                    message.appid = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CGCSystemMsg_GetAccountDetails;\n})());\nexports.CGCSystemMsg_GetAccountDetails_Response = ($root.CGCSystemMsg_GetAccountDetails_Response = (() => {\n    /**\n     * Properties of a CGCSystemMsg_GetAccountDetails_Response.\n     * @exports ICGCSystemMsg_GetAccountDetails_Response\n     * @interface ICGCSystemMsg_GetAccountDetails_Response\n     * @property {number|null} [eresultDeprecated] CGCSystemMsg_GetAccountDetails_Response eresultDeprecated\n     * @property {string|null} [accountName] CGCSystemMsg_GetAccountDetails_Response accountName\n     * @property {string|null} [personaName] CGCSystemMsg_GetAccountDetails_Response personaName\n     * @property {boolean|null} [isProfilePublic] CGCSystemMsg_GetAccountDetails_Response isProfilePublic\n     * @property {boolean|null} [isInventoryPublic] CGCSystemMsg_GetAccountDetails_Response isInventoryPublic\n     * @property {boolean|null} [isVacBanned] CGCSystemMsg_GetAccountDetails_Response isVacBanned\n     * @property {boolean|null} [isCyberCafe] CGCSystemMsg_GetAccountDetails_Response isCyberCafe\n     * @property {boolean|null} [isSchoolAccount] CGCSystemMsg_GetAccountDetails_Response isSchoolAccount\n     * @property {boolean|null} [isLimited] CGCSystemMsg_GetAccountDetails_Response isLimited\n     * @property {boolean|null} [isSubscribed] CGCSystemMsg_GetAccountDetails_Response isSubscribed\n     * @property {number|null} [\"package\"] CGCSystemMsg_GetAccountDetails_Response package\n     * @property {boolean|null} [isFreeTrialAccount] CGCSystemMsg_GetAccountDetails_Response isFreeTrialAccount\n     * @property {number|null} [freeTrialExpiration] CGCSystemMsg_GetAccountDetails_Response freeTrialExpiration\n     * @property {boolean|null} [isLowViolence] CGCSystemMsg_GetAccountDetails_Response isLowViolence\n     * @property {boolean|null} [isAccountLockedDown] CGCSystemMsg_GetAccountDetails_Response isAccountLockedDown\n     * @property {boolean|null} [isCommunityBanned] CGCSystemMsg_GetAccountDetails_Response isCommunityBanned\n     * @property {boolean|null} [isTradeBanned] CGCSystemMsg_GetAccountDetails_Response isTradeBanned\n     * @property {number|null} [tradeBanExpiration] CGCSystemMsg_GetAccountDetails_Response tradeBanExpiration\n     * @property {number|null} [accountid] CGCSystemMsg_GetAccountDetails_Response accountid\n     * @property {number|null} [suspensionEndTime] CGCSystemMsg_GetAccountDetails_Response suspensionEndTime\n     * @property {string|null} [currency] CGCSystemMsg_GetAccountDetails_Response currency\n     * @property {number|null} [steamLevel] CGCSystemMsg_GetAccountDetails_Response steamLevel\n     */\n    /**\n     * Constructs a new CGCSystemMsg_GetAccountDetails_Response.\n     * @exports CGCSystemMsg_GetAccountDetails_Response\n     * @classdesc Represents a CGCSystemMsg_GetAccountDetails_Response.\n     * @implements ICGCSystemMsg_GetAccountDetails_Response\n     * @constructor\n     * @param {ICGCSystemMsg_GetAccountDetails_Response=} [properties] Properties to set\n     */\n    function CGCSystemMsg_GetAccountDetails_Response(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CGCSystemMsg_GetAccountDetails_Response eresultDeprecated.\n     * @member {number} eresultDeprecated\n     * @memberof CGCSystemMsg_GetAccountDetails_Response\n     * @instance\n     */\n    CGCSystemMsg_GetAccountDetails_Response.prototype.eresultDeprecated = 2;\n    /**\n     * CGCSystemMsg_GetAccountDetails_Response accountName.\n     * @member {string} accountName\n     * @memberof CGCSystemMsg_GetAccountDetails_Response\n     * @instance\n     */\n    CGCSystemMsg_GetAccountDetails_Response.prototype.accountName = \"\";\n    /**\n     * CGCSystemMsg_GetAccountDetails_Response personaName.\n     * @member {string} personaName\n     * @memberof CGCSystemMsg_GetAccountDetails_Response\n     * @instance\n     */\n    CGCSystemMsg_GetAccountDetails_Response.prototype.personaName = \"\";\n    /**\n     * CGCSystemMsg_GetAccountDetails_Response isProfilePublic.\n     * @member {boolean} isProfilePublic\n     * @memberof CGCSystemMsg_GetAccountDetails_Response\n     * @instance\n     */\n    CGCSystemMsg_GetAccountDetails_Response.prototype.isProfilePublic = false;\n    /**\n     * CGCSystemMsg_GetAccountDetails_Response isInventoryPublic.\n     * @member {boolean} isInventoryPublic\n     * @memberof CGCSystemMsg_GetAccountDetails_Response\n     * @instance\n     */\n    CGCSystemMsg_GetAccountDetails_Response.prototype.isInventoryPublic = false;\n    /**\n     * CGCSystemMsg_GetAccountDetails_Response isVacBanned.\n     * @member {boolean} isVacBanned\n     * @memberof CGCSystemMsg_GetAccountDetails_Response\n     * @instance\n     */\n    CGCSystemMsg_GetAccountDetails_Response.prototype.isVacBanned = false;\n    /**\n     * CGCSystemMsg_GetAccountDetails_Response isCyberCafe.\n     * @member {boolean} isCyberCafe\n     * @memberof CGCSystemMsg_GetAccountDetails_Response\n     * @instance\n     */\n    CGCSystemMsg_GetAccountDetails_Response.prototype.isCyberCafe = false;\n    /**\n     * CGCSystemMsg_GetAccountDetails_Response isSchoolAccount.\n     * @member {boolean} isSchoolAccount\n     * @memberof CGCSystemMsg_GetAccountDetails_Response\n     * @instance\n     */\n    CGCSystemMsg_GetAccountDetails_Response.prototype.isSchoolAccount = false;\n    /**\n     * CGCSystemMsg_GetAccountDetails_Response isLimited.\n     * @member {boolean} isLimited\n     * @memberof CGCSystemMsg_GetAccountDetails_Response\n     * @instance\n     */\n    CGCSystemMsg_GetAccountDetails_Response.prototype.isLimited = false;\n    /**\n     * CGCSystemMsg_GetAccountDetails_Response isSubscribed.\n     * @member {boolean} isSubscribed\n     * @memberof CGCSystemMsg_GetAccountDetails_Response\n     * @instance\n     */\n    CGCSystemMsg_GetAccountDetails_Response.prototype.isSubscribed = false;\n    /**\n     * CGCSystemMsg_GetAccountDetails_Response package.\n     * @member {number} package\n     * @memberof CGCSystemMsg_GetAccountDetails_Response\n     * @instance\n     */\n    CGCSystemMsg_GetAccountDetails_Response.prototype[\"package\"] = 0;\n    /**\n     * CGCSystemMsg_GetAccountDetails_Response isFreeTrialAccount.\n     * @member {boolean} isFreeTrialAccount\n     * @memberof CGCSystemMsg_GetAccountDetails_Response\n     * @instance\n     */\n    CGCSystemMsg_GetAccountDetails_Response.prototype.isFreeTrialAccount = false;\n    /**\n     * CGCSystemMsg_GetAccountDetails_Response freeTrialExpiration.\n     * @member {number} freeTrialExpiration\n     * @memberof CGCSystemMsg_GetAccountDetails_Response\n     * @instance\n     */\n    CGCSystemMsg_GetAccountDetails_Response.prototype.freeTrialExpiration = 0;\n    /**\n     * CGCSystemMsg_GetAccountDetails_Response isLowViolence.\n     * @member {boolean} isLowViolence\n     * @memberof CGCSystemMsg_GetAccountDetails_Response\n     * @instance\n     */\n    CGCSystemMsg_GetAccountDetails_Response.prototype.isLowViolence = false;\n    /**\n     * CGCSystemMsg_GetAccountDetails_Response isAccountLockedDown.\n     * @member {boolean} isAccountLockedDown\n     * @memberof CGCSystemMsg_GetAccountDetails_Response\n     * @instance\n     */\n    CGCSystemMsg_GetAccountDetails_Response.prototype.isAccountLockedDown = false;\n    /**\n     * CGCSystemMsg_GetAccountDetails_Response isCommunityBanned.\n     * @member {boolean} isCommunityBanned\n     * @memberof CGCSystemMsg_GetAccountDetails_Response\n     * @instance\n     */\n    CGCSystemMsg_GetAccountDetails_Response.prototype.isCommunityBanned = false;\n    /**\n     * CGCSystemMsg_GetAccountDetails_Response isTradeBanned.\n     * @member {boolean} isTradeBanned\n     * @memberof CGCSystemMsg_GetAccountDetails_Response\n     * @instance\n     */\n    CGCSystemMsg_GetAccountDetails_Response.prototype.isTradeBanned = false;\n    /**\n     * CGCSystemMsg_GetAccountDetails_Response tradeBanExpiration.\n     * @member {number} tradeBanExpiration\n     * @memberof CGCSystemMsg_GetAccountDetails_Response\n     * @instance\n     */\n    CGCSystemMsg_GetAccountDetails_Response.prototype.tradeBanExpiration = 0;\n    /**\n     * CGCSystemMsg_GetAccountDetails_Response accountid.\n     * @member {number} accountid\n     * @memberof CGCSystemMsg_GetAccountDetails_Response\n     * @instance\n     */\n    CGCSystemMsg_GetAccountDetails_Response.prototype.accountid = 0;\n    /**\n     * CGCSystemMsg_GetAccountDetails_Response suspensionEndTime.\n     * @member {number} suspensionEndTime\n     * @memberof CGCSystemMsg_GetAccountDetails_Response\n     * @instance\n     */\n    CGCSystemMsg_GetAccountDetails_Response.prototype.suspensionEndTime = 0;\n    /**\n     * CGCSystemMsg_GetAccountDetails_Response currency.\n     * @member {string} currency\n     * @memberof CGCSystemMsg_GetAccountDetails_Response\n     * @instance\n     */\n    CGCSystemMsg_GetAccountDetails_Response.prototype.currency = \"\";\n    /**\n     * CGCSystemMsg_GetAccountDetails_Response steamLevel.\n     * @member {number} steamLevel\n     * @memberof CGCSystemMsg_GetAccountDetails_Response\n     * @instance\n     */\n    CGCSystemMsg_GetAccountDetails_Response.prototype.steamLevel = 0;\n    /**\n     * Decodes a CGCSystemMsg_GetAccountDetails_Response message from the specified reader or buffer.\n     * @function decode\n     * @memberof CGCSystemMsg_GetAccountDetails_Response\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CGCSystemMsg_GetAccountDetails_Response} CGCSystemMsg_GetAccountDetails_Response\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CGCSystemMsg_GetAccountDetails_Response.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCSystemMsg_GetAccountDetails_Response();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.eresultDeprecated = reader.uint32();\n                    break;\n                case 2:\n                    message.accountName = reader.string();\n                    break;\n                case 3:\n                    message.personaName = reader.string();\n                    break;\n                case 4:\n                    message.isProfilePublic = reader.bool();\n                    break;\n                case 5:\n                    message.isInventoryPublic = reader.bool();\n                    break;\n                case 7:\n                    message.isVacBanned = reader.bool();\n                    break;\n                case 8:\n                    message.isCyberCafe = reader.bool();\n                    break;\n                case 9:\n                    message.isSchoolAccount = reader.bool();\n                    break;\n                case 10:\n                    message.isLimited = reader.bool();\n                    break;\n                case 11:\n                    message.isSubscribed = reader.bool();\n                    break;\n                case 12:\n                    message[\"package\"] = reader.uint32();\n                    break;\n                case 13:\n                    message.isFreeTrialAccount = reader.bool();\n                    break;\n                case 14:\n                    message.freeTrialExpiration = reader.uint32();\n                    break;\n                case 15:\n                    message.isLowViolence = reader.bool();\n                    break;\n                case 16:\n                    message.isAccountLockedDown = reader.bool();\n                    break;\n                case 17:\n                    message.isCommunityBanned = reader.bool();\n                    break;\n                case 18:\n                    message.isTradeBanned = reader.bool();\n                    break;\n                case 19:\n                    message.tradeBanExpiration = reader.uint32();\n                    break;\n                case 20:\n                    message.accountid = reader.uint32();\n                    break;\n                case 21:\n                    message.suspensionEndTime = reader.uint32();\n                    break;\n                case 22:\n                    message.currency = reader.string();\n                    break;\n                case 23:\n                    message.steamLevel = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CGCSystemMsg_GetAccountDetails_Response;\n})());\nexports.CMsgGCGetPersonaNames = ($root.CMsgGCGetPersonaNames = (() => {\n    /**\n     * Properties of a CMsgGCGetPersonaNames.\n     * @exports ICMsgGCGetPersonaNames\n     * @interface ICMsgGCGetPersonaNames\n     * @property {Array.<number|Long>|null} [steamids] CMsgGCGetPersonaNames steamids\n     */\n    /**\n     * Constructs a new CMsgGCGetPersonaNames.\n     * @exports CMsgGCGetPersonaNames\n     * @classdesc Represents a CMsgGCGetPersonaNames.\n     * @implements ICMsgGCGetPersonaNames\n     * @constructor\n     * @param {ICMsgGCGetPersonaNames=} [properties] Properties to set\n     */\n    function CMsgGCGetPersonaNames(properties) {\n        this.steamids = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCGetPersonaNames steamids.\n     * @member {Array.<number|Long>} steamids\n     * @memberof CMsgGCGetPersonaNames\n     * @instance\n     */\n    CMsgGCGetPersonaNames.prototype.steamids = $util.emptyArray;\n    /**\n     * Decodes a CMsgGCGetPersonaNames message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCGetPersonaNames\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCGetPersonaNames} CMsgGCGetPersonaNames\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCGetPersonaNames.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetPersonaNames();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.steamids && message.steamids.length))\n                        message.steamids = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.steamids.push(reader.fixed64());\n                    }\n                    else\n                        message.steamids.push(reader.fixed64());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCGetPersonaNames;\n})());\nexports.CMsgGCGetPersonaNames_Response = ($root.CMsgGCGetPersonaNames_Response = (() => {\n    /**\n     * Properties of a CMsgGCGetPersonaNames_Response.\n     * @exports ICMsgGCGetPersonaNames_Response\n     * @interface ICMsgGCGetPersonaNames_Response\n     * @property {Array.<CMsgGCGetPersonaNames_Response.IPersonaName>|null} [succeededLookups] CMsgGCGetPersonaNames_Response succeededLookups\n     * @property {Array.<number|Long>|null} [failedLookupSteamids] CMsgGCGetPersonaNames_Response failedLookupSteamids\n     */\n    /**\n     * Constructs a new CMsgGCGetPersonaNames_Response.\n     * @exports CMsgGCGetPersonaNames_Response\n     * @classdesc Represents a CMsgGCGetPersonaNames_Response.\n     * @implements ICMsgGCGetPersonaNames_Response\n     * @constructor\n     * @param {ICMsgGCGetPersonaNames_Response=} [properties] Properties to set\n     */\n    function CMsgGCGetPersonaNames_Response(properties) {\n        this.succeededLookups = [];\n        this.failedLookupSteamids = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCGetPersonaNames_Response succeededLookups.\n     * @member {Array.<CMsgGCGetPersonaNames_Response.IPersonaName>} succeededLookups\n     * @memberof CMsgGCGetPersonaNames_Response\n     * @instance\n     */\n    CMsgGCGetPersonaNames_Response.prototype.succeededLookups = $util.emptyArray;\n    /**\n     * CMsgGCGetPersonaNames_Response failedLookupSteamids.\n     * @member {Array.<number|Long>} failedLookupSteamids\n     * @memberof CMsgGCGetPersonaNames_Response\n     * @instance\n     */\n    CMsgGCGetPersonaNames_Response.prototype.failedLookupSteamids =\n        $util.emptyArray;\n    /**\n     * Decodes a CMsgGCGetPersonaNames_Response message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCGetPersonaNames_Response\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCGetPersonaNames_Response} CMsgGCGetPersonaNames_Response\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCGetPersonaNames_Response.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetPersonaNames_Response();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.succeededLookups && message.succeededLookups.length))\n                        message.succeededLookups = [];\n                    message.succeededLookups.push($root.CMsgGCGetPersonaNames_Response.PersonaName.decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    if (!(message.failedLookupSteamids &&\n                        message.failedLookupSteamids.length))\n                        message.failedLookupSteamids = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.failedLookupSteamids.push(reader.fixed64());\n                    }\n                    else\n                        message.failedLookupSteamids.push(reader.fixed64());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CMsgGCGetPersonaNames_Response.PersonaName = (function () {\n        /**\n         * Properties of a PersonaName.\n         * @memberof CMsgGCGetPersonaNames_Response\n         * @interface IPersonaName\n         * @property {number|Long|null} [steamid] PersonaName steamid\n         * @property {string|null} [personaName] PersonaName personaName\n         */\n        /**\n         * Constructs a new PersonaName.\n         * @memberof CMsgGCGetPersonaNames_Response\n         * @classdesc Represents a PersonaName.\n         * @implements IPersonaName\n         * @constructor\n         * @param {CMsgGCGetPersonaNames_Response.IPersonaName=} [properties] Properties to set\n         */\n        function PersonaName(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * PersonaName steamid.\n         * @member {number|Long} steamid\n         * @memberof CMsgGCGetPersonaNames_Response.PersonaName\n         * @instance\n         */\n        PersonaName.prototype.steamid = $util.Long\n            ? $util.Long.fromBits(0, 0, false)\n            : 0;\n        /**\n         * PersonaName personaName.\n         * @member {string} personaName\n         * @memberof CMsgGCGetPersonaNames_Response.PersonaName\n         * @instance\n         */\n        PersonaName.prototype.personaName = \"\";\n        /**\n         * Decodes a PersonaName message from the specified reader or buffer.\n         * @function decode\n         * @memberof CMsgGCGetPersonaNames_Response.PersonaName\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CMsgGCGetPersonaNames_Response.PersonaName} PersonaName\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        PersonaName.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetPersonaNames_Response.PersonaName();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.steamid = reader.fixed64();\n                        break;\n                    case 2:\n                        message.personaName = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return PersonaName;\n    })();\n    return CMsgGCGetPersonaNames_Response;\n})());\nexports.CMsgGCCheckFriendship = ($root.CMsgGCCheckFriendship = (() => {\n    /**\n     * Properties of a CMsgGCCheckFriendship.\n     * @exports ICMsgGCCheckFriendship\n     * @interface ICMsgGCCheckFriendship\n     * @property {number|Long|null} [steamidLeft] CMsgGCCheckFriendship steamidLeft\n     * @property {number|Long|null} [steamidRight] CMsgGCCheckFriendship steamidRight\n     */\n    /**\n     * Constructs a new CMsgGCCheckFriendship.\n     * @exports CMsgGCCheckFriendship\n     * @classdesc Represents a CMsgGCCheckFriendship.\n     * @implements ICMsgGCCheckFriendship\n     * @constructor\n     * @param {ICMsgGCCheckFriendship=} [properties] Properties to set\n     */\n    function CMsgGCCheckFriendship(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCheckFriendship steamidLeft.\n     * @member {number|Long} steamidLeft\n     * @memberof CMsgGCCheckFriendship\n     * @instance\n     */\n    CMsgGCCheckFriendship.prototype.steamidLeft = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0;\n    /**\n     * CMsgGCCheckFriendship steamidRight.\n     * @member {number|Long} steamidRight\n     * @memberof CMsgGCCheckFriendship\n     * @instance\n     */\n    CMsgGCCheckFriendship.prototype.steamidRight = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0;\n    /**\n     * Decodes a CMsgGCCheckFriendship message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCheckFriendship\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCheckFriendship} CMsgGCCheckFriendship\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCheckFriendship.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCheckFriendship();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.steamidLeft = reader.fixed64();\n                    break;\n                case 2:\n                    message.steamidRight = reader.fixed64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCheckFriendship;\n})());\nexports.CMsgGCCheckFriendship_Response = ($root.CMsgGCCheckFriendship_Response = (() => {\n    /**\n     * Properties of a CMsgGCCheckFriendship_Response.\n     * @exports ICMsgGCCheckFriendship_Response\n     * @interface ICMsgGCCheckFriendship_Response\n     * @property {boolean|null} [success] CMsgGCCheckFriendship_Response success\n     * @property {boolean|null} [foundFriendship] CMsgGCCheckFriendship_Response foundFriendship\n     */\n    /**\n     * Constructs a new CMsgGCCheckFriendship_Response.\n     * @exports CMsgGCCheckFriendship_Response\n     * @classdesc Represents a CMsgGCCheckFriendship_Response.\n     * @implements ICMsgGCCheckFriendship_Response\n     * @constructor\n     * @param {ICMsgGCCheckFriendship_Response=} [properties] Properties to set\n     */\n    function CMsgGCCheckFriendship_Response(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCCheckFriendship_Response success.\n     * @member {boolean} success\n     * @memberof CMsgGCCheckFriendship_Response\n     * @instance\n     */\n    CMsgGCCheckFriendship_Response.prototype.success = false;\n    /**\n     * CMsgGCCheckFriendship_Response foundFriendship.\n     * @member {boolean} foundFriendship\n     * @memberof CMsgGCCheckFriendship_Response\n     * @instance\n     */\n    CMsgGCCheckFriendship_Response.prototype.foundFriendship = false;\n    /**\n     * Decodes a CMsgGCCheckFriendship_Response message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCCheckFriendship_Response\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCCheckFriendship_Response} CMsgGCCheckFriendship_Response\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCCheckFriendship_Response.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCCheckFriendship_Response();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.success = reader.bool();\n                    break;\n                case 2:\n                    message.foundFriendship = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCCheckFriendship_Response;\n})());\nexports.CMsgGCMsgMasterSetDirectory = ($root.CMsgGCMsgMasterSetDirectory = (() => {\n    /**\n     * Properties of a CMsgGCMsgMasterSetDirectory.\n     * @exports ICMsgGCMsgMasterSetDirectory\n     * @interface ICMsgGCMsgMasterSetDirectory\n     * @property {number|null} [masterDirIndex] CMsgGCMsgMasterSetDirectory masterDirIndex\n     * @property {Array.<CMsgGCMsgMasterSetDirectory.ISubGC>|null} [dir] CMsgGCMsgMasterSetDirectory dir\n     */\n    /**\n     * Constructs a new CMsgGCMsgMasterSetDirectory.\n     * @exports CMsgGCMsgMasterSetDirectory\n     * @classdesc Represents a CMsgGCMsgMasterSetDirectory.\n     * @implements ICMsgGCMsgMasterSetDirectory\n     * @constructor\n     * @param {ICMsgGCMsgMasterSetDirectory=} [properties] Properties to set\n     */\n    function CMsgGCMsgMasterSetDirectory(properties) {\n        this.dir = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCMsgMasterSetDirectory masterDirIndex.\n     * @member {number} masterDirIndex\n     * @memberof CMsgGCMsgMasterSetDirectory\n     * @instance\n     */\n    CMsgGCMsgMasterSetDirectory.prototype.masterDirIndex = 0;\n    /**\n     * CMsgGCMsgMasterSetDirectory dir.\n     * @member {Array.<CMsgGCMsgMasterSetDirectory.ISubGC>} dir\n     * @memberof CMsgGCMsgMasterSetDirectory\n     * @instance\n     */\n    CMsgGCMsgMasterSetDirectory.prototype.dir = $util.emptyArray;\n    /**\n     * Decodes a CMsgGCMsgMasterSetDirectory message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCMsgMasterSetDirectory\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCMsgMasterSetDirectory} CMsgGCMsgMasterSetDirectory\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCMsgMasterSetDirectory.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetDirectory();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.masterDirIndex = reader.uint32();\n                    break;\n                case 2:\n                    if (!(message.dir && message.dir.length))\n                        message.dir = [];\n                    message.dir.push($root.CMsgGCMsgMasterSetDirectory.SubGC.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CMsgGCMsgMasterSetDirectory.SubGC = (function () {\n        /**\n         * Properties of a SubGC.\n         * @memberof CMsgGCMsgMasterSetDirectory\n         * @interface ISubGC\n         * @property {number|null} [dirIndex] SubGC dirIndex\n         * @property {string|null} [name] SubGC name\n         * @property {string|null} [box] SubGC box\n         * @property {string|null} [commandLine] SubGC commandLine\n         * @property {string|null} [gcBinary] SubGC gcBinary\n         */\n        /**\n         * Constructs a new SubGC.\n         * @memberof CMsgGCMsgMasterSetDirectory\n         * @classdesc Represents a SubGC.\n         * @implements ISubGC\n         * @constructor\n         * @param {CMsgGCMsgMasterSetDirectory.ISubGC=} [properties] Properties to set\n         */\n        function SubGC(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * SubGC dirIndex.\n         * @member {number} dirIndex\n         * @memberof CMsgGCMsgMasterSetDirectory.SubGC\n         * @instance\n         */\n        SubGC.prototype.dirIndex = 0;\n        /**\n         * SubGC name.\n         * @member {string} name\n         * @memberof CMsgGCMsgMasterSetDirectory.SubGC\n         * @instance\n         */\n        SubGC.prototype.name = \"\";\n        /**\n         * SubGC box.\n         * @member {string} box\n         * @memberof CMsgGCMsgMasterSetDirectory.SubGC\n         * @instance\n         */\n        SubGC.prototype.box = \"\";\n        /**\n         * SubGC commandLine.\n         * @member {string} commandLine\n         * @memberof CMsgGCMsgMasterSetDirectory.SubGC\n         * @instance\n         */\n        SubGC.prototype.commandLine = \"\";\n        /**\n         * SubGC gcBinary.\n         * @member {string} gcBinary\n         * @memberof CMsgGCMsgMasterSetDirectory.SubGC\n         * @instance\n         */\n        SubGC.prototype.gcBinary = \"\";\n        /**\n         * Decodes a SubGC message from the specified reader or buffer.\n         * @function decode\n         * @memberof CMsgGCMsgMasterSetDirectory.SubGC\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CMsgGCMsgMasterSetDirectory.SubGC} SubGC\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        SubGC.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetDirectory.SubGC();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.dirIndex = reader.uint32();\n                        break;\n                    case 2:\n                        message.name = reader.string();\n                        break;\n                    case 3:\n                        message.box = reader.string();\n                        break;\n                    case 4:\n                        message.commandLine = reader.string();\n                        break;\n                    case 5:\n                        message.gcBinary = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return SubGC;\n    })();\n    return CMsgGCMsgMasterSetDirectory;\n})());\nexports.CMsgGCMsgMasterSetDirectory_Response = ($root.CMsgGCMsgMasterSetDirectory_Response = (() => {\n    /**\n     * Properties of a CMsgGCMsgMasterSetDirectory_Response.\n     * @exports ICMsgGCMsgMasterSetDirectory_Response\n     * @interface ICMsgGCMsgMasterSetDirectory_Response\n     * @property {number|null} [eresult] CMsgGCMsgMasterSetDirectory_Response eresult\n     */\n    /**\n     * Constructs a new CMsgGCMsgMasterSetDirectory_Response.\n     * @exports CMsgGCMsgMasterSetDirectory_Response\n     * @classdesc Represents a CMsgGCMsgMasterSetDirectory_Response.\n     * @implements ICMsgGCMsgMasterSetDirectory_Response\n     * @constructor\n     * @param {ICMsgGCMsgMasterSetDirectory_Response=} [properties] Properties to set\n     */\n    function CMsgGCMsgMasterSetDirectory_Response(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCMsgMasterSetDirectory_Response eresult.\n     * @member {number} eresult\n     * @memberof CMsgGCMsgMasterSetDirectory_Response\n     * @instance\n     */\n    CMsgGCMsgMasterSetDirectory_Response.prototype.eresult = 2;\n    /**\n     * Decodes a CMsgGCMsgMasterSetDirectory_Response message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCMsgMasterSetDirectory_Response\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCMsgMasterSetDirectory_Response} CMsgGCMsgMasterSetDirectory_Response\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCMsgMasterSetDirectory_Response.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetDirectory_Response();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.eresult = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCMsgMasterSetDirectory_Response;\n})());\nexports.CMsgGCMsgWebAPIJobRequestForwardResponse = ($root.CMsgGCMsgWebAPIJobRequestForwardResponse = (() => {\n    /**\n     * Properties of a CMsgGCMsgWebAPIJobRequestForwardResponse.\n     * @exports ICMsgGCMsgWebAPIJobRequestForwardResponse\n     * @interface ICMsgGCMsgWebAPIJobRequestForwardResponse\n     * @property {number|null} [dirIndex] CMsgGCMsgWebAPIJobRequestForwardResponse dirIndex\n     */\n    /**\n     * Constructs a new CMsgGCMsgWebAPIJobRequestForwardResponse.\n     * @exports CMsgGCMsgWebAPIJobRequestForwardResponse\n     * @classdesc Represents a CMsgGCMsgWebAPIJobRequestForwardResponse.\n     * @implements ICMsgGCMsgWebAPIJobRequestForwardResponse\n     * @constructor\n     * @param {ICMsgGCMsgWebAPIJobRequestForwardResponse=} [properties] Properties to set\n     */\n    function CMsgGCMsgWebAPIJobRequestForwardResponse(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCMsgWebAPIJobRequestForwardResponse dirIndex.\n     * @member {number} dirIndex\n     * @memberof CMsgGCMsgWebAPIJobRequestForwardResponse\n     * @instance\n     */\n    CMsgGCMsgWebAPIJobRequestForwardResponse.prototype.dirIndex = 0;\n    /**\n     * Decodes a CMsgGCMsgWebAPIJobRequestForwardResponse message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCMsgWebAPIJobRequestForwardResponse\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCMsgWebAPIJobRequestForwardResponse} CMsgGCMsgWebAPIJobRequestForwardResponse\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCMsgWebAPIJobRequestForwardResponse.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgWebAPIJobRequestForwardResponse();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.dirIndex = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCMsgWebAPIJobRequestForwardResponse;\n})());\nexports.CGCSystemMsg_GetPurchaseTrust_Request = ($root.CGCSystemMsg_GetPurchaseTrust_Request = (() => {\n    /**\n     * Properties of a CGCSystemMsg_GetPurchaseTrust_Request.\n     * @exports ICGCSystemMsg_GetPurchaseTrust_Request\n     * @interface ICGCSystemMsg_GetPurchaseTrust_Request\n     * @property {number|Long|null} [steamid] CGCSystemMsg_GetPurchaseTrust_Request steamid\n     */\n    /**\n     * Constructs a new CGCSystemMsg_GetPurchaseTrust_Request.\n     * @exports CGCSystemMsg_GetPurchaseTrust_Request\n     * @classdesc Represents a CGCSystemMsg_GetPurchaseTrust_Request.\n     * @implements ICGCSystemMsg_GetPurchaseTrust_Request\n     * @constructor\n     * @param {ICGCSystemMsg_GetPurchaseTrust_Request=} [properties] Properties to set\n     */\n    function CGCSystemMsg_GetPurchaseTrust_Request(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CGCSystemMsg_GetPurchaseTrust_Request steamid.\n     * @member {number|Long} steamid\n     * @memberof CGCSystemMsg_GetPurchaseTrust_Request\n     * @instance\n     */\n    CGCSystemMsg_GetPurchaseTrust_Request.prototype.steamid = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0;\n    /**\n     * Decodes a CGCSystemMsg_GetPurchaseTrust_Request message from the specified reader or buffer.\n     * @function decode\n     * @memberof CGCSystemMsg_GetPurchaseTrust_Request\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CGCSystemMsg_GetPurchaseTrust_Request} CGCSystemMsg_GetPurchaseTrust_Request\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CGCSystemMsg_GetPurchaseTrust_Request.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCSystemMsg_GetPurchaseTrust_Request();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.steamid = reader.fixed64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CGCSystemMsg_GetPurchaseTrust_Request;\n})());\nexports.CGCSystemMsg_GetPurchaseTrust_Response = ($root.CGCSystemMsg_GetPurchaseTrust_Response = (() => {\n    /**\n     * Properties of a CGCSystemMsg_GetPurchaseTrust_Response.\n     * @exports ICGCSystemMsg_GetPurchaseTrust_Response\n     * @interface ICGCSystemMsg_GetPurchaseTrust_Response\n     * @property {boolean|null} [hasPriorPurchaseHistory] CGCSystemMsg_GetPurchaseTrust_Response hasPriorPurchaseHistory\n     * @property {boolean|null} [hasNoRecentPasswordResets] CGCSystemMsg_GetPurchaseTrust_Response hasNoRecentPasswordResets\n     * @property {boolean|null} [isWalletCashTrusted] CGCSystemMsg_GetPurchaseTrust_Response isWalletCashTrusted\n     * @property {number|null} [timeAllTrusted] CGCSystemMsg_GetPurchaseTrust_Response timeAllTrusted\n     */\n    /**\n     * Constructs a new CGCSystemMsg_GetPurchaseTrust_Response.\n     * @exports CGCSystemMsg_GetPurchaseTrust_Response\n     * @classdesc Represents a CGCSystemMsg_GetPurchaseTrust_Response.\n     * @implements ICGCSystemMsg_GetPurchaseTrust_Response\n     * @constructor\n     * @param {ICGCSystemMsg_GetPurchaseTrust_Response=} [properties] Properties to set\n     */\n    function CGCSystemMsg_GetPurchaseTrust_Response(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CGCSystemMsg_GetPurchaseTrust_Response hasPriorPurchaseHistory.\n     * @member {boolean} hasPriorPurchaseHistory\n     * @memberof CGCSystemMsg_GetPurchaseTrust_Response\n     * @instance\n     */\n    CGCSystemMsg_GetPurchaseTrust_Response.prototype.hasPriorPurchaseHistory = false;\n    /**\n     * CGCSystemMsg_GetPurchaseTrust_Response hasNoRecentPasswordResets.\n     * @member {boolean} hasNoRecentPasswordResets\n     * @memberof CGCSystemMsg_GetPurchaseTrust_Response\n     * @instance\n     */\n    CGCSystemMsg_GetPurchaseTrust_Response.prototype.hasNoRecentPasswordResets = false;\n    /**\n     * CGCSystemMsg_GetPurchaseTrust_Response isWalletCashTrusted.\n     * @member {boolean} isWalletCashTrusted\n     * @memberof CGCSystemMsg_GetPurchaseTrust_Response\n     * @instance\n     */\n    CGCSystemMsg_GetPurchaseTrust_Response.prototype.isWalletCashTrusted = false;\n    /**\n     * CGCSystemMsg_GetPurchaseTrust_Response timeAllTrusted.\n     * @member {number} timeAllTrusted\n     * @memberof CGCSystemMsg_GetPurchaseTrust_Response\n     * @instance\n     */\n    CGCSystemMsg_GetPurchaseTrust_Response.prototype.timeAllTrusted = 0;\n    /**\n     * Decodes a CGCSystemMsg_GetPurchaseTrust_Response message from the specified reader or buffer.\n     * @function decode\n     * @memberof CGCSystemMsg_GetPurchaseTrust_Response\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CGCSystemMsg_GetPurchaseTrust_Response} CGCSystemMsg_GetPurchaseTrust_Response\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CGCSystemMsg_GetPurchaseTrust_Response.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CGCSystemMsg_GetPurchaseTrust_Response();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.hasPriorPurchaseHistory = reader.bool();\n                    break;\n                case 2:\n                    message.hasNoRecentPasswordResets = reader.bool();\n                    break;\n                case 3:\n                    message.isWalletCashTrusted = reader.bool();\n                    break;\n                case 4:\n                    message.timeAllTrusted = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CGCSystemMsg_GetPurchaseTrust_Response;\n})());\nexports.CMsgGCHAccountVacStatusChange = ($root.CMsgGCHAccountVacStatusChange = (() => {\n    /**\n     * Properties of a CMsgGCHAccountVacStatusChange.\n     * @exports ICMsgGCHAccountVacStatusChange\n     * @interface ICMsgGCHAccountVacStatusChange\n     * @property {number|Long|null} [steamId] CMsgGCHAccountVacStatusChange steamId\n     * @property {number|null} [appId] CMsgGCHAccountVacStatusChange appId\n     * @property {number|null} [rtimeVacbanStarts] CMsgGCHAccountVacStatusChange rtimeVacbanStarts\n     * @property {boolean|null} [isBannedNow] CMsgGCHAccountVacStatusChange isBannedNow\n     * @property {boolean|null} [isBannedFuture] CMsgGCHAccountVacStatusChange isBannedFuture\n     */\n    /**\n     * Constructs a new CMsgGCHAccountVacStatusChange.\n     * @exports CMsgGCHAccountVacStatusChange\n     * @classdesc Represents a CMsgGCHAccountVacStatusChange.\n     * @implements ICMsgGCHAccountVacStatusChange\n     * @constructor\n     * @param {ICMsgGCHAccountVacStatusChange=} [properties] Properties to set\n     */\n    function CMsgGCHAccountVacStatusChange(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCHAccountVacStatusChange steamId.\n     * @member {number|Long} steamId\n     * @memberof CMsgGCHAccountVacStatusChange\n     * @instance\n     */\n    CMsgGCHAccountVacStatusChange.prototype.steamId = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0;\n    /**\n     * CMsgGCHAccountVacStatusChange appId.\n     * @member {number} appId\n     * @memberof CMsgGCHAccountVacStatusChange\n     * @instance\n     */\n    CMsgGCHAccountVacStatusChange.prototype.appId = 0;\n    /**\n     * CMsgGCHAccountVacStatusChange rtimeVacbanStarts.\n     * @member {number} rtimeVacbanStarts\n     * @memberof CMsgGCHAccountVacStatusChange\n     * @instance\n     */\n    CMsgGCHAccountVacStatusChange.prototype.rtimeVacbanStarts = 0;\n    /**\n     * CMsgGCHAccountVacStatusChange isBannedNow.\n     * @member {boolean} isBannedNow\n     * @memberof CMsgGCHAccountVacStatusChange\n     * @instance\n     */\n    CMsgGCHAccountVacStatusChange.prototype.isBannedNow = false;\n    /**\n     * CMsgGCHAccountVacStatusChange isBannedFuture.\n     * @member {boolean} isBannedFuture\n     * @memberof CMsgGCHAccountVacStatusChange\n     * @instance\n     */\n    CMsgGCHAccountVacStatusChange.prototype.isBannedFuture = false;\n    /**\n     * Decodes a CMsgGCHAccountVacStatusChange message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCHAccountVacStatusChange\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCHAccountVacStatusChange} CMsgGCHAccountVacStatusChange\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCHAccountVacStatusChange.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCHAccountVacStatusChange();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.steamId = reader.fixed64();\n                    break;\n                case 2:\n                    message.appId = reader.uint32();\n                    break;\n                case 3:\n                    message.rtimeVacbanStarts = reader.uint32();\n                    break;\n                case 4:\n                    message.isBannedNow = reader.bool();\n                    break;\n                case 5:\n                    message.isBannedFuture = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCHAccountVacStatusChange;\n})());\nexports.CMsgGCGetPartnerAccountLink = ($root.CMsgGCGetPartnerAccountLink = (() => {\n    /**\n     * Properties of a CMsgGCGetPartnerAccountLink.\n     * @exports ICMsgGCGetPartnerAccountLink\n     * @interface ICMsgGCGetPartnerAccountLink\n     * @property {number|Long|null} [steamid] CMsgGCGetPartnerAccountLink steamid\n     */\n    /**\n     * Constructs a new CMsgGCGetPartnerAccountLink.\n     * @exports CMsgGCGetPartnerAccountLink\n     * @classdesc Represents a CMsgGCGetPartnerAccountLink.\n     * @implements ICMsgGCGetPartnerAccountLink\n     * @constructor\n     * @param {ICMsgGCGetPartnerAccountLink=} [properties] Properties to set\n     */\n    function CMsgGCGetPartnerAccountLink(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCGetPartnerAccountLink steamid.\n     * @member {number|Long} steamid\n     * @memberof CMsgGCGetPartnerAccountLink\n     * @instance\n     */\n    CMsgGCGetPartnerAccountLink.prototype.steamid = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0;\n    /**\n     * Decodes a CMsgGCGetPartnerAccountLink message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCGetPartnerAccountLink\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCGetPartnerAccountLink} CMsgGCGetPartnerAccountLink\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCGetPartnerAccountLink.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetPartnerAccountLink();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.steamid = reader.fixed64();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCGetPartnerAccountLink;\n})());\nexports.CMsgGCGetPartnerAccountLink_Response = ($root.CMsgGCGetPartnerAccountLink_Response = (() => {\n    /**\n     * Properties of a CMsgGCGetPartnerAccountLink_Response.\n     * @exports ICMsgGCGetPartnerAccountLink_Response\n     * @interface ICMsgGCGetPartnerAccountLink_Response\n     * @property {number|null} [pwid] CMsgGCGetPartnerAccountLink_Response pwid\n     * @property {number|null} [nexonid] CMsgGCGetPartnerAccountLink_Response nexonid\n     */\n    /**\n     * Constructs a new CMsgGCGetPartnerAccountLink_Response.\n     * @exports CMsgGCGetPartnerAccountLink_Response\n     * @classdesc Represents a CMsgGCGetPartnerAccountLink_Response.\n     * @implements ICMsgGCGetPartnerAccountLink_Response\n     * @constructor\n     * @param {ICMsgGCGetPartnerAccountLink_Response=} [properties] Properties to set\n     */\n    function CMsgGCGetPartnerAccountLink_Response(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCGetPartnerAccountLink_Response pwid.\n     * @member {number} pwid\n     * @memberof CMsgGCGetPartnerAccountLink_Response\n     * @instance\n     */\n    CMsgGCGetPartnerAccountLink_Response.prototype.pwid = 0;\n    /**\n     * CMsgGCGetPartnerAccountLink_Response nexonid.\n     * @member {number} nexonid\n     * @memberof CMsgGCGetPartnerAccountLink_Response\n     * @instance\n     */\n    CMsgGCGetPartnerAccountLink_Response.prototype.nexonid = 0;\n    /**\n     * Decodes a CMsgGCGetPartnerAccountLink_Response message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCGetPartnerAccountLink_Response\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCGetPartnerAccountLink_Response} CMsgGCGetPartnerAccountLink_Response\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCGetPartnerAccountLink_Response.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCGetPartnerAccountLink_Response();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.pwid = reader.uint32();\n                    break;\n                case 2:\n                    message.nexonid = reader.uint32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCGetPartnerAccountLink_Response;\n})());\nexports.CMsgGCRoutingInfo = ($root.CMsgGCRoutingInfo = (() => {\n    /**\n     * Properties of a CMsgGCRoutingInfo.\n     * @exports ICMsgGCRoutingInfo\n     * @interface ICMsgGCRoutingInfo\n     * @property {Array.<number>|null} [dirIndex] CMsgGCRoutingInfo dirIndex\n     * @property {CMsgGCRoutingInfo.RoutingMethod|null} [method] CMsgGCRoutingInfo method\n     * @property {CMsgGCRoutingInfo.RoutingMethod|null} [fallback] CMsgGCRoutingInfo fallback\n     * @property {number|null} [protobufField] CMsgGCRoutingInfo protobufField\n     * @property {string|null} [webapiParam] CMsgGCRoutingInfo webapiParam\n     */\n    /**\n     * Constructs a new CMsgGCRoutingInfo.\n     * @exports CMsgGCRoutingInfo\n     * @classdesc Represents a CMsgGCRoutingInfo.\n     * @implements ICMsgGCRoutingInfo\n     * @constructor\n     * @param {ICMsgGCRoutingInfo=} [properties] Properties to set\n     */\n    function CMsgGCRoutingInfo(properties) {\n        this.dirIndex = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCRoutingInfo dirIndex.\n     * @member {Array.<number>} dirIndex\n     * @memberof CMsgGCRoutingInfo\n     * @instance\n     */\n    CMsgGCRoutingInfo.prototype.dirIndex = $util.emptyArray;\n    /**\n     * CMsgGCRoutingInfo method.\n     * @member {CMsgGCRoutingInfo.RoutingMethod} method\n     * @memberof CMsgGCRoutingInfo\n     * @instance\n     */\n    CMsgGCRoutingInfo.prototype.method = 0;\n    /**\n     * CMsgGCRoutingInfo fallback.\n     * @member {CMsgGCRoutingInfo.RoutingMethod} fallback\n     * @memberof CMsgGCRoutingInfo\n     * @instance\n     */\n    CMsgGCRoutingInfo.prototype.fallback = 1;\n    /**\n     * CMsgGCRoutingInfo protobufField.\n     * @member {number} protobufField\n     * @memberof CMsgGCRoutingInfo\n     * @instance\n     */\n    CMsgGCRoutingInfo.prototype.protobufField = 0;\n    /**\n     * CMsgGCRoutingInfo webapiParam.\n     * @member {string} webapiParam\n     * @memberof CMsgGCRoutingInfo\n     * @instance\n     */\n    CMsgGCRoutingInfo.prototype.webapiParam = \"\";\n    /**\n     * Decodes a CMsgGCRoutingInfo message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCRoutingInfo\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCRoutingInfo} CMsgGCRoutingInfo\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCRoutingInfo.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCRoutingInfo();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.dirIndex && message.dirIndex.length))\n                        message.dirIndex = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.dirIndex.push(reader.uint32());\n                    }\n                    else\n                        message.dirIndex.push(reader.uint32());\n                    break;\n                case 2:\n                    message.method = reader.int32();\n                    break;\n                case 3:\n                    message.fallback = reader.int32();\n                    break;\n                case 4:\n                    message.protobufField = reader.uint32();\n                    break;\n                case 5:\n                    message.webapiParam = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    /**\n     * RoutingMethod enum.\n     * @name CMsgGCRoutingInfo.RoutingMethod\n     * @enum {string}\n     * @property {number} RANDOM=0 RANDOM value\n     * @property {number} DISCARD=1 DISCARD value\n     * @property {number} CLIENT_STEAMID=2 CLIENT_STEAMID value\n     * @property {number} PROTOBUF_FIELD_UINT64=3 PROTOBUF_FIELD_UINT64 value\n     * @property {number} WEBAPI_PARAM_UINT64=4 WEBAPI_PARAM_UINT64 value\n     */\n    CMsgGCRoutingInfo.RoutingMethod = (function () {\n        const valuesById = {}, values = Object.create(valuesById);\n        values[(valuesById[0] = \"RANDOM\")] = 0;\n        values[(valuesById[1] = \"DISCARD\")] = 1;\n        values[(valuesById[2] = \"CLIENT_STEAMID\")] = 2;\n        values[(valuesById[3] = \"PROTOBUF_FIELD_UINT64\")] = 3;\n        values[(valuesById[4] = \"WEBAPI_PARAM_UINT64\")] = 4;\n        return values;\n    })();\n    return CMsgGCRoutingInfo;\n})());\nexports.CMsgGCMsgMasterSetWebAPIRouting = ($root.CMsgGCMsgMasterSetWebAPIRouting = (() => {\n    /**\n     * Properties of a CMsgGCMsgMasterSetWebAPIRouting.\n     * @exports ICMsgGCMsgMasterSetWebAPIRouting\n     * @interface ICMsgGCMsgMasterSetWebAPIRouting\n     * @property {Array.<CMsgGCMsgMasterSetWebAPIRouting.IEntry>|null} [entries] CMsgGCMsgMasterSetWebAPIRouting entries\n     */\n    /**\n     * Constructs a new CMsgGCMsgMasterSetWebAPIRouting.\n     * @exports CMsgGCMsgMasterSetWebAPIRouting\n     * @classdesc Represents a CMsgGCMsgMasterSetWebAPIRouting.\n     * @implements ICMsgGCMsgMasterSetWebAPIRouting\n     * @constructor\n     * @param {ICMsgGCMsgMasterSetWebAPIRouting=} [properties] Properties to set\n     */\n    function CMsgGCMsgMasterSetWebAPIRouting(properties) {\n        this.entries = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCMsgMasterSetWebAPIRouting entries.\n     * @member {Array.<CMsgGCMsgMasterSetWebAPIRouting.IEntry>} entries\n     * @memberof CMsgGCMsgMasterSetWebAPIRouting\n     * @instance\n     */\n    CMsgGCMsgMasterSetWebAPIRouting.prototype.entries = $util.emptyArray;\n    /**\n     * Decodes a CMsgGCMsgMasterSetWebAPIRouting message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCMsgMasterSetWebAPIRouting\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCMsgMasterSetWebAPIRouting} CMsgGCMsgMasterSetWebAPIRouting\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCMsgMasterSetWebAPIRouting.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetWebAPIRouting();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.entries && message.entries.length))\n                        message.entries = [];\n                    message.entries.push($root.CMsgGCMsgMasterSetWebAPIRouting.Entry.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CMsgGCMsgMasterSetWebAPIRouting.Entry = (function () {\n        /**\n         * Properties of an Entry.\n         * @memberof CMsgGCMsgMasterSetWebAPIRouting\n         * @interface IEntry\n         * @property {string|null} [interfaceName] Entry interfaceName\n         * @property {string|null} [methodName] Entry methodName\n         * @property {ICMsgGCRoutingInfo|null} [routing] Entry routing\n         */\n        /**\n         * Constructs a new Entry.\n         * @memberof CMsgGCMsgMasterSetWebAPIRouting\n         * @classdesc Represents an Entry.\n         * @implements IEntry\n         * @constructor\n         * @param {CMsgGCMsgMasterSetWebAPIRouting.IEntry=} [properties] Properties to set\n         */\n        function Entry(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * Entry interfaceName.\n         * @member {string} interfaceName\n         * @memberof CMsgGCMsgMasterSetWebAPIRouting.Entry\n         * @instance\n         */\n        Entry.prototype.interfaceName = \"\";\n        /**\n         * Entry methodName.\n         * @member {string} methodName\n         * @memberof CMsgGCMsgMasterSetWebAPIRouting.Entry\n         * @instance\n         */\n        Entry.prototype.methodName = \"\";\n        /**\n         * Entry routing.\n         * @member {ICMsgGCRoutingInfo|null|undefined} routing\n         * @memberof CMsgGCMsgMasterSetWebAPIRouting.Entry\n         * @instance\n         */\n        Entry.prototype.routing = null;\n        /**\n         * Decodes an Entry message from the specified reader or buffer.\n         * @function decode\n         * @memberof CMsgGCMsgMasterSetWebAPIRouting.Entry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CMsgGCMsgMasterSetWebAPIRouting.Entry} Entry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Entry.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetWebAPIRouting.Entry();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.interfaceName = reader.string();\n                        break;\n                    case 2:\n                        message.methodName = reader.string();\n                        break;\n                    case 3:\n                        message.routing = $root.CMsgGCRoutingInfo.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return Entry;\n    })();\n    return CMsgGCMsgMasterSetWebAPIRouting;\n})());\nexports.CMsgGCMsgMasterSetClientMsgRouting = ($root.CMsgGCMsgMasterSetClientMsgRouting = (() => {\n    /**\n     * Properties of a CMsgGCMsgMasterSetClientMsgRouting.\n     * @exports ICMsgGCMsgMasterSetClientMsgRouting\n     * @interface ICMsgGCMsgMasterSetClientMsgRouting\n     * @property {Array.<CMsgGCMsgMasterSetClientMsgRouting.IEntry>|null} [entries] CMsgGCMsgMasterSetClientMsgRouting entries\n     */\n    /**\n     * Constructs a new CMsgGCMsgMasterSetClientMsgRouting.\n     * @exports CMsgGCMsgMasterSetClientMsgRouting\n     * @classdesc Represents a CMsgGCMsgMasterSetClientMsgRouting.\n     * @implements ICMsgGCMsgMasterSetClientMsgRouting\n     * @constructor\n     * @param {ICMsgGCMsgMasterSetClientMsgRouting=} [properties] Properties to set\n     */\n    function CMsgGCMsgMasterSetClientMsgRouting(properties) {\n        this.entries = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCMsgMasterSetClientMsgRouting entries.\n     * @member {Array.<CMsgGCMsgMasterSetClientMsgRouting.IEntry>} entries\n     * @memberof CMsgGCMsgMasterSetClientMsgRouting\n     * @instance\n     */\n    CMsgGCMsgMasterSetClientMsgRouting.prototype.entries = $util.emptyArray;\n    /**\n     * Decodes a CMsgGCMsgMasterSetClientMsgRouting message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCMsgMasterSetClientMsgRouting\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCMsgMasterSetClientMsgRouting} CMsgGCMsgMasterSetClientMsgRouting\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCMsgMasterSetClientMsgRouting.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetClientMsgRouting();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.entries && message.entries.length))\n                        message.entries = [];\n                    message.entries.push($root.CMsgGCMsgMasterSetClientMsgRouting.Entry.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CMsgGCMsgMasterSetClientMsgRouting.Entry = (function () {\n        /**\n         * Properties of an Entry.\n         * @memberof CMsgGCMsgMasterSetClientMsgRouting\n         * @interface IEntry\n         * @property {number|null} [msgType] Entry msgType\n         * @property {ICMsgGCRoutingInfo|null} [routing] Entry routing\n         */\n        /**\n         * Constructs a new Entry.\n         * @memberof CMsgGCMsgMasterSetClientMsgRouting\n         * @classdesc Represents an Entry.\n         * @implements IEntry\n         * @constructor\n         * @param {CMsgGCMsgMasterSetClientMsgRouting.IEntry=} [properties] Properties to set\n         */\n        function Entry(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * Entry msgType.\n         * @member {number} msgType\n         * @memberof CMsgGCMsgMasterSetClientMsgRouting.Entry\n         * @instance\n         */\n        Entry.prototype.msgType = 0;\n        /**\n         * Entry routing.\n         * @member {ICMsgGCRoutingInfo|null|undefined} routing\n         * @memberof CMsgGCMsgMasterSetClientMsgRouting.Entry\n         * @instance\n         */\n        Entry.prototype.routing = null;\n        /**\n         * Decodes an Entry message from the specified reader or buffer.\n         * @function decode\n         * @memberof CMsgGCMsgMasterSetClientMsgRouting.Entry\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CMsgGCMsgMasterSetClientMsgRouting.Entry} Entry\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        Entry.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetClientMsgRouting.Entry();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.msgType = reader.uint32();\n                        break;\n                    case 2:\n                        message.routing = $root.CMsgGCRoutingInfo.decode(reader, reader.uint32());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return Entry;\n    })();\n    return CMsgGCMsgMasterSetClientMsgRouting;\n})());\nexports.CMsgGCMsgMasterSetWebAPIRouting_Response = ($root.CMsgGCMsgMasterSetWebAPIRouting_Response = (() => {\n    /**\n     * Properties of a CMsgGCMsgMasterSetWebAPIRouting_Response.\n     * @exports ICMsgGCMsgMasterSetWebAPIRouting_Response\n     * @interface ICMsgGCMsgMasterSetWebAPIRouting_Response\n     * @property {number|null} [eresult] CMsgGCMsgMasterSetWebAPIRouting_Response eresult\n     */\n    /**\n     * Constructs a new CMsgGCMsgMasterSetWebAPIRouting_Response.\n     * @exports CMsgGCMsgMasterSetWebAPIRouting_Response\n     * @classdesc Represents a CMsgGCMsgMasterSetWebAPIRouting_Response.\n     * @implements ICMsgGCMsgMasterSetWebAPIRouting_Response\n     * @constructor\n     * @param {ICMsgGCMsgMasterSetWebAPIRouting_Response=} [properties] Properties to set\n     */\n    function CMsgGCMsgMasterSetWebAPIRouting_Response(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCMsgMasterSetWebAPIRouting_Response eresult.\n     * @member {number} eresult\n     * @memberof CMsgGCMsgMasterSetWebAPIRouting_Response\n     * @instance\n     */\n    CMsgGCMsgMasterSetWebAPIRouting_Response.prototype.eresult = 2;\n    /**\n     * Decodes a CMsgGCMsgMasterSetWebAPIRouting_Response message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCMsgMasterSetWebAPIRouting_Response\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCMsgMasterSetWebAPIRouting_Response} CMsgGCMsgMasterSetWebAPIRouting_Response\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCMsgMasterSetWebAPIRouting_Response.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetWebAPIRouting_Response();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.eresult = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCMsgMasterSetWebAPIRouting_Response;\n})());\nexports.CMsgGCMsgMasterSetClientMsgRouting_Response = ($root.CMsgGCMsgMasterSetClientMsgRouting_Response = (() => {\n    /**\n     * Properties of a CMsgGCMsgMasterSetClientMsgRouting_Response.\n     * @exports ICMsgGCMsgMasterSetClientMsgRouting_Response\n     * @interface ICMsgGCMsgMasterSetClientMsgRouting_Response\n     * @property {number|null} [eresult] CMsgGCMsgMasterSetClientMsgRouting_Response eresult\n     */\n    /**\n     * Constructs a new CMsgGCMsgMasterSetClientMsgRouting_Response.\n     * @exports CMsgGCMsgMasterSetClientMsgRouting_Response\n     * @classdesc Represents a CMsgGCMsgMasterSetClientMsgRouting_Response.\n     * @implements ICMsgGCMsgMasterSetClientMsgRouting_Response\n     * @constructor\n     * @param {ICMsgGCMsgMasterSetClientMsgRouting_Response=} [properties] Properties to set\n     */\n    function CMsgGCMsgMasterSetClientMsgRouting_Response(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCMsgMasterSetClientMsgRouting_Response eresult.\n     * @member {number} eresult\n     * @memberof CMsgGCMsgMasterSetClientMsgRouting_Response\n     * @instance\n     */\n    CMsgGCMsgMasterSetClientMsgRouting_Response.prototype.eresult = 2;\n    /**\n     * Decodes a CMsgGCMsgMasterSetClientMsgRouting_Response message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCMsgMasterSetClientMsgRouting_Response\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCMsgMasterSetClientMsgRouting_Response} CMsgGCMsgMasterSetClientMsgRouting_Response\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCMsgMasterSetClientMsgRouting_Response.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgMasterSetClientMsgRouting_Response();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.eresult = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    return CMsgGCMsgMasterSetClientMsgRouting_Response;\n})());\nexports.CMsgGCMsgSetOptions = ($root.CMsgGCMsgSetOptions = (() => {\n    /**\n     * Properties of a CMsgGCMsgSetOptions.\n     * @exports ICMsgGCMsgSetOptions\n     * @interface ICMsgGCMsgSetOptions\n     * @property {Array.<CMsgGCMsgSetOptions.Option>|null} [options] CMsgGCMsgSetOptions options\n     * @property {Array.<CMsgGCMsgSetOptions.IMessageRange>|null} [clientMsgRanges] CMsgGCMsgSetOptions clientMsgRanges\n     */\n    /**\n     * Constructs a new CMsgGCMsgSetOptions.\n     * @exports CMsgGCMsgSetOptions\n     * @classdesc Represents a CMsgGCMsgSetOptions.\n     * @implements ICMsgGCMsgSetOptions\n     * @constructor\n     * @param {ICMsgGCMsgSetOptions=} [properties] Properties to set\n     */\n    function CMsgGCMsgSetOptions(properties) {\n        this.options = [];\n        this.clientMsgRanges = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCMsgSetOptions options.\n     * @member {Array.<CMsgGCMsgSetOptions.Option>} options\n     * @memberof CMsgGCMsgSetOptions\n     * @instance\n     */\n    CMsgGCMsgSetOptions.prototype.options = $util.emptyArray;\n    /**\n     * CMsgGCMsgSetOptions clientMsgRanges.\n     * @member {Array.<CMsgGCMsgSetOptions.IMessageRange>} clientMsgRanges\n     * @memberof CMsgGCMsgSetOptions\n     * @instance\n     */\n    CMsgGCMsgSetOptions.prototype.clientMsgRanges = $util.emptyArray;\n    /**\n     * Decodes a CMsgGCMsgSetOptions message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCMsgSetOptions\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCMsgSetOptions} CMsgGCMsgSetOptions\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCMsgSetOptions.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgSetOptions();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if (!(message.options && message.options.length))\n                        message.options = [];\n                    if ((tag & 7) === 2) {\n                        let end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2)\n                            message.options.push(reader.int32());\n                    }\n                    else\n                        message.options.push(reader.int32());\n                    break;\n                case 2:\n                    if (!(message.clientMsgRanges && message.clientMsgRanges.length))\n                        message.clientMsgRanges = [];\n                    message.clientMsgRanges.push($root.CMsgGCMsgSetOptions.MessageRange.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CMsgGCMsgSetOptions.MessageRange = (function () {\n        /**\n         * Properties of a MessageRange.\n         * @memberof CMsgGCMsgSetOptions\n         * @interface IMessageRange\n         * @property {number} low MessageRange low\n         * @property {number} high MessageRange high\n         */\n        /**\n         * Constructs a new MessageRange.\n         * @memberof CMsgGCMsgSetOptions\n         * @classdesc Represents a MessageRange.\n         * @implements IMessageRange\n         * @constructor\n         * @param {CMsgGCMsgSetOptions.IMessageRange=} [properties] Properties to set\n         */\n        function MessageRange(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * MessageRange low.\n         * @member {number} low\n         * @memberof CMsgGCMsgSetOptions.MessageRange\n         * @instance\n         */\n        MessageRange.prototype.low = 0;\n        /**\n         * MessageRange high.\n         * @member {number} high\n         * @memberof CMsgGCMsgSetOptions.MessageRange\n         * @instance\n         */\n        MessageRange.prototype.high = 0;\n        /**\n         * Decodes a MessageRange message from the specified reader or buffer.\n         * @function decode\n         * @memberof CMsgGCMsgSetOptions.MessageRange\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CMsgGCMsgSetOptions.MessageRange} MessageRange\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        MessageRange.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCMsgSetOptions.MessageRange();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.low = reader.uint32();\n                        break;\n                    case 2:\n                        message.high = reader.uint32();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            if (!message.hasOwnProperty(\"low\"))\n                throw $util.ProtocolError(\"missing required 'low'\", {\n                    instance: message\n                });\n            if (!message.hasOwnProperty(\"high\"))\n                throw $util.ProtocolError(\"missing required 'high'\", {\n                    instance: message\n                });\n            return message;\n        };\n        return MessageRange;\n    })();\n    /**\n     * Option enum.\n     * @name CMsgGCMsgSetOptions.Option\n     * @enum {string}\n     * @property {number} NOTIFY_USER_SESSIONS=0 NOTIFY_USER_SESSIONS value\n     * @property {number} NOTIFY_SERVER_SESSIONS=1 NOTIFY_SERVER_SESSIONS value\n     * @property {number} NOTIFY_ACHIEVEMENTS=2 NOTIFY_ACHIEVEMENTS value\n     * @property {number} NOTIFY_VAC_ACTION=3 NOTIFY_VAC_ACTION value\n     */\n    CMsgGCMsgSetOptions.Option = (function () {\n        const valuesById = {}, values = Object.create(valuesById);\n        values[(valuesById[0] = \"NOTIFY_USER_SESSIONS\")] = 0;\n        values[(valuesById[1] = \"NOTIFY_SERVER_SESSIONS\")] = 1;\n        values[(valuesById[2] = \"NOTIFY_ACHIEVEMENTS\")] = 2;\n        values[(valuesById[3] = \"NOTIFY_VAC_ACTION\")] = 3;\n        return values;\n    })();\n    return CMsgGCMsgSetOptions;\n})());\nexports.CMsgGCHUpdateSession = ($root.CMsgGCHUpdateSession = (() => {\n    /**\n     * Properties of a CMsgGCHUpdateSession.\n     * @exports ICMsgGCHUpdateSession\n     * @interface ICMsgGCHUpdateSession\n     * @property {number|Long|null} [steamId] CMsgGCHUpdateSession steamId\n     * @property {number|null} [appId] CMsgGCHUpdateSession appId\n     * @property {boolean|null} [online] CMsgGCHUpdateSession online\n     * @property {number|Long|null} [serverSteamId] CMsgGCHUpdateSession serverSteamId\n     * @property {number|null} [serverAddr] CMsgGCHUpdateSession serverAddr\n     * @property {number|null} [serverPort] CMsgGCHUpdateSession serverPort\n     * @property {number|null} [osType] CMsgGCHUpdateSession osType\n     * @property {number|null} [clientAddr] CMsgGCHUpdateSession clientAddr\n     * @property {Array.<CMsgGCHUpdateSession.IExtraField>|null} [extraFields] CMsgGCHUpdateSession extraFields\n     */\n    /**\n     * Constructs a new CMsgGCHUpdateSession.\n     * @exports CMsgGCHUpdateSession\n     * @classdesc Represents a CMsgGCHUpdateSession.\n     * @implements ICMsgGCHUpdateSession\n     * @constructor\n     * @param {ICMsgGCHUpdateSession=} [properties] Properties to set\n     */\n    function CMsgGCHUpdateSession(properties) {\n        this.extraFields = [];\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgGCHUpdateSession steamId.\n     * @member {number|Long} steamId\n     * @memberof CMsgGCHUpdateSession\n     * @instance\n     */\n    CMsgGCHUpdateSession.prototype.steamId = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0;\n    /**\n     * CMsgGCHUpdateSession appId.\n     * @member {number} appId\n     * @memberof CMsgGCHUpdateSession\n     * @instance\n     */\n    CMsgGCHUpdateSession.prototype.appId = 0;\n    /**\n     * CMsgGCHUpdateSession online.\n     * @member {boolean} online\n     * @memberof CMsgGCHUpdateSession\n     * @instance\n     */\n    CMsgGCHUpdateSession.prototype.online = false;\n    /**\n     * CMsgGCHUpdateSession serverSteamId.\n     * @member {number|Long} serverSteamId\n     * @memberof CMsgGCHUpdateSession\n     * @instance\n     */\n    CMsgGCHUpdateSession.prototype.serverSteamId = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0;\n    /**\n     * CMsgGCHUpdateSession serverAddr.\n     * @member {number} serverAddr\n     * @memberof CMsgGCHUpdateSession\n     * @instance\n     */\n    CMsgGCHUpdateSession.prototype.serverAddr = 0;\n    /**\n     * CMsgGCHUpdateSession serverPort.\n     * @member {number} serverPort\n     * @memberof CMsgGCHUpdateSession\n     * @instance\n     */\n    CMsgGCHUpdateSession.prototype.serverPort = 0;\n    /**\n     * CMsgGCHUpdateSession osType.\n     * @member {number} osType\n     * @memberof CMsgGCHUpdateSession\n     * @instance\n     */\n    CMsgGCHUpdateSession.prototype.osType = 0;\n    /**\n     * CMsgGCHUpdateSession clientAddr.\n     * @member {number} clientAddr\n     * @memberof CMsgGCHUpdateSession\n     * @instance\n     */\n    CMsgGCHUpdateSession.prototype.clientAddr = 0;\n    /**\n     * CMsgGCHUpdateSession extraFields.\n     * @member {Array.<CMsgGCHUpdateSession.IExtraField>} extraFields\n     * @memberof CMsgGCHUpdateSession\n     * @instance\n     */\n    CMsgGCHUpdateSession.prototype.extraFields = $util.emptyArray;\n    /**\n     * Decodes a CMsgGCHUpdateSession message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgGCHUpdateSession\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgGCHUpdateSession} CMsgGCHUpdateSession\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgGCHUpdateSession.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCHUpdateSession();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.steamId = reader.fixed64();\n                    break;\n                case 2:\n                    message.appId = reader.uint32();\n                    break;\n                case 3:\n                    message.online = reader.bool();\n                    break;\n                case 4:\n                    message.serverSteamId = reader.fixed64();\n                    break;\n                case 5:\n                    message.serverAddr = reader.uint32();\n                    break;\n                case 6:\n                    message.serverPort = reader.uint32();\n                    break;\n                case 7:\n                    message.osType = reader.uint32();\n                    break;\n                case 8:\n                    message.clientAddr = reader.uint32();\n                    break;\n                case 9:\n                    if (!(message.extraFields && message.extraFields.length))\n                        message.extraFields = [];\n                    message.extraFields.push($root.CMsgGCHUpdateSession.ExtraField.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CMsgGCHUpdateSession.ExtraField = (function () {\n        /**\n         * Properties of an ExtraField.\n         * @memberof CMsgGCHUpdateSession\n         * @interface IExtraField\n         * @property {string|null} [name] ExtraField name\n         * @property {string|null} [value] ExtraField value\n         */\n        /**\n         * Constructs a new ExtraField.\n         * @memberof CMsgGCHUpdateSession\n         * @classdesc Represents an ExtraField.\n         * @implements IExtraField\n         * @constructor\n         * @param {CMsgGCHUpdateSession.IExtraField=} [properties] Properties to set\n         */\n        function ExtraField(properties) {\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * ExtraField name.\n         * @member {string} name\n         * @memberof CMsgGCHUpdateSession.ExtraField\n         * @instance\n         */\n        ExtraField.prototype.name = \"\";\n        /**\n         * ExtraField value.\n         * @member {string} value\n         * @memberof CMsgGCHUpdateSession.ExtraField\n         * @instance\n         */\n        ExtraField.prototype.value = \"\";\n        /**\n         * Decodes an ExtraField message from the specified reader or buffer.\n         * @function decode\n         * @memberof CMsgGCHUpdateSession.ExtraField\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CMsgGCHUpdateSession.ExtraField} ExtraField\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        ExtraField.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgGCHUpdateSession.ExtraField();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.name = reader.string();\n                        break;\n                    case 2:\n                        message.value = reader.string();\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return ExtraField;\n    })();\n    return CMsgGCHUpdateSession;\n})());\nexports.CMsgNotificationOfSuspiciousActivity = ($root.CMsgNotificationOfSuspiciousActivity = (() => {\n    /**\n     * Properties of a CMsgNotificationOfSuspiciousActivity.\n     * @exports ICMsgNotificationOfSuspiciousActivity\n     * @interface ICMsgNotificationOfSuspiciousActivity\n     * @property {number|Long|null} [steamid] CMsgNotificationOfSuspiciousActivity steamid\n     * @property {number|null} [appid] CMsgNotificationOfSuspiciousActivity appid\n     * @property {CMsgNotificationOfSuspiciousActivity.IMultipleGameInstances|null} [multipleInstances] CMsgNotificationOfSuspiciousActivity multipleInstances\n     */\n    /**\n     * Constructs a new CMsgNotificationOfSuspiciousActivity.\n     * @exports CMsgNotificationOfSuspiciousActivity\n     * @classdesc Represents a CMsgNotificationOfSuspiciousActivity.\n     * @implements ICMsgNotificationOfSuspiciousActivity\n     * @constructor\n     * @param {ICMsgNotificationOfSuspiciousActivity=} [properties] Properties to set\n     */\n    function CMsgNotificationOfSuspiciousActivity(properties) {\n        if (properties)\n            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                if (properties[keys[i]] != null)\n                    this[keys[i]] = properties[keys[i]];\n    }\n    /**\n     * CMsgNotificationOfSuspiciousActivity steamid.\n     * @member {number|Long} steamid\n     * @memberof CMsgNotificationOfSuspiciousActivity\n     * @instance\n     */\n    CMsgNotificationOfSuspiciousActivity.prototype.steamid = $util.Long\n        ? $util.Long.fromBits(0, 0, false)\n        : 0;\n    /**\n     * CMsgNotificationOfSuspiciousActivity appid.\n     * @member {number} appid\n     * @memberof CMsgNotificationOfSuspiciousActivity\n     * @instance\n     */\n    CMsgNotificationOfSuspiciousActivity.prototype.appid = 0;\n    /**\n     * CMsgNotificationOfSuspiciousActivity multipleInstances.\n     * @member {CMsgNotificationOfSuspiciousActivity.IMultipleGameInstances|null|undefined} multipleInstances\n     * @memberof CMsgNotificationOfSuspiciousActivity\n     * @instance\n     */\n    CMsgNotificationOfSuspiciousActivity.prototype.multipleInstances = null;\n    /**\n     * Decodes a CMsgNotificationOfSuspiciousActivity message from the specified reader or buffer.\n     * @function decode\n     * @memberof CMsgNotificationOfSuspiciousActivity\n     * @static\n     * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n     * @param {number} [length] Message length if known beforehand\n     * @returns {CMsgNotificationOfSuspiciousActivity} CMsgNotificationOfSuspiciousActivity\n     * @throws {Error} If the payload is not a reader or valid buffer\n     * @throws {$protobuf.util.ProtocolError} If required fields are missing\n     */\n    CMsgNotificationOfSuspiciousActivity.decode = function decode(reader, length) {\n        if (!(reader instanceof $Reader))\n            reader = $Reader.create(reader);\n        let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgNotificationOfSuspiciousActivity();\n        while (reader.pos < end) {\n            let tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.steamid = reader.fixed64();\n                    break;\n                case 2:\n                    message.appid = reader.uint32();\n                    break;\n                case 3:\n                    message.multipleInstances = $root.CMsgNotificationOfSuspiciousActivity.MultipleGameInstances.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    };\n    CMsgNotificationOfSuspiciousActivity.MultipleGameInstances = (function () {\n        /**\n         * Properties of a MultipleGameInstances.\n         * @memberof CMsgNotificationOfSuspiciousActivity\n         * @interface IMultipleGameInstances\n         * @property {number|null} [appInstanceCount] MultipleGameInstances appInstanceCount\n         * @property {Array.<number|Long>|null} [otherSteamids] MultipleGameInstances otherSteamids\n         */\n        /**\n         * Constructs a new MultipleGameInstances.\n         * @memberof CMsgNotificationOfSuspiciousActivity\n         * @classdesc Represents a MultipleGameInstances.\n         * @implements IMultipleGameInstances\n         * @constructor\n         * @param {CMsgNotificationOfSuspiciousActivity.IMultipleGameInstances=} [properties] Properties to set\n         */\n        function MultipleGameInstances(properties) {\n            this.otherSteamids = [];\n            if (properties)\n                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)\n                    if (properties[keys[i]] != null)\n                        this[keys[i]] = properties[keys[i]];\n        }\n        /**\n         * MultipleGameInstances appInstanceCount.\n         * @member {number} appInstanceCount\n         * @memberof CMsgNotificationOfSuspiciousActivity.MultipleGameInstances\n         * @instance\n         */\n        MultipleGameInstances.prototype.appInstanceCount = 0;\n        /**\n         * MultipleGameInstances otherSteamids.\n         * @member {Array.<number|Long>} otherSteamids\n         * @memberof CMsgNotificationOfSuspiciousActivity.MultipleGameInstances\n         * @instance\n         */\n        MultipleGameInstances.prototype.otherSteamids = $util.emptyArray;\n        /**\n         * Decodes a MultipleGameInstances message from the specified reader or buffer.\n         * @function decode\n         * @memberof CMsgNotificationOfSuspiciousActivity.MultipleGameInstances\n         * @static\n         * @param {$protobuf.Reader|Uint8Array} reader Reader or buffer to decode from\n         * @param {number} [length] Message length if known beforehand\n         * @returns {CMsgNotificationOfSuspiciousActivity.MultipleGameInstances} MultipleGameInstances\n         * @throws {Error} If the payload is not a reader or valid buffer\n         * @throws {$protobuf.util.ProtocolError} If required fields are missing\n         */\n        MultipleGameInstances.decode = function decode(reader, length) {\n            if (!(reader instanceof $Reader))\n                reader = $Reader.create(reader);\n            let end = length === undefined ? reader.len : reader.pos + length, message = new $root.CMsgNotificationOfSuspiciousActivity.MultipleGameInstances();\n            while (reader.pos < end) {\n                let tag = reader.uint32();\n                switch (tag >>> 3) {\n                    case 1:\n                        message.appInstanceCount = reader.uint32();\n                        break;\n                    case 2:\n                        if (!(message.otherSteamids && message.otherSteamids.length))\n                            message.otherSteamids = [];\n                        if ((tag & 7) === 2) {\n                            let end2 = reader.uint32() + reader.pos;\n                            while (reader.pos < end2)\n                                message.otherSteamids.push(reader.fixed64());\n                        }\n                        else\n                            message.otherSteamids.push(reader.fixed64());\n                        break;\n                    default:\n                        reader.skipType(tag & 7);\n                        break;\n                }\n            }\n            return message;\n        };\n        return MultipleGameInstances;\n    })();\n    return CMsgNotificationOfSuspiciousActivity;\n})());\n//# sourceMappingURL=cstrike15_usermessages.js.map"]},"metadata":{},"sourceType":"script"}